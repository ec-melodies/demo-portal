"format global";
/* */ 
"format global";
(function (global) {
  var babelHelpers = global.babelHelpers = {};

  babelHelpers.inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  babelHelpers.defaults = function (obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);

      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }

    return obj;
  };

  babelHelpers.createClass = (function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();

  babelHelpers.createDecoratedClass = (function () {
    function defineProperties(target, descriptors, initializers) {
      for (var i = 0; i < descriptors.length; i++) {
        var descriptor = descriptors[i];
        var decorators = descriptor.decorators;
        var key = descriptor.key;
        delete descriptor.key;
        delete descriptor.decorators;
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor || descriptor.initializer) descriptor.writable = true;

        if (decorators) {
          for (var f = 0; f < decorators.length; f++) {
            var decorator = decorators[f];

            if (typeof decorator === "function") {
              descriptor = decorator(target, key, descriptor) || descriptor;
            } else {
              throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator);
            }
          }

          if (descriptor.initializer !== undefined) {
            initializers[key] = descriptor;
            continue;
          }
        }

        Object.defineProperty(target, key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps, protoInitializers, staticInitializers) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps, protoInitializers);
      if (staticProps) defineProperties(Constructor, staticProps, staticInitializers);
      return Constructor;
    };
  })();

  babelHelpers.createDecoratedObject = function (descriptors) {
    var target = {};

    for (var i = 0; i < descriptors.length; i++) {
      var descriptor = descriptors[i];
      var decorators = descriptor.decorators;
      var key = descriptor.key;
      delete descriptor.key;
      delete descriptor.decorators;
      descriptor.enumerable = true;
      descriptor.configurable = true;
      if ("value" in descriptor || descriptor.initializer) descriptor.writable = true;

      if (decorators) {
        for (var f = 0; f < decorators.length; f++) {
          var decorator = decorators[f];

          if (typeof decorator === "function") {
            descriptor = decorator(target, key, descriptor) || descriptor;
          } else {
            throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator);
          }
        }
      }

      if (descriptor.initializer) {
        descriptor.value = descriptor.initializer.call(target);
      }

      Object.defineProperty(target, key, descriptor);
    }

    return target;
  };

  babelHelpers.defineDecoratedPropertyDescriptor = function (target, key, descriptors) {
    var _descriptor = descriptors[key];
    if (!_descriptor) return;
    var descriptor = {};

    for (var _key in _descriptor) descriptor[_key] = _descriptor[_key];

    descriptor.value = descriptor.initializer ? descriptor.initializer.call(target) : undefined;
    Object.defineProperty(target, key, descriptor);
  };

  babelHelpers.taggedTemplateLiteral = function (strings, raw) {
    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  };

  babelHelpers.taggedTemplateLiteralLoose = function (strings, raw) {
    strings.raw = raw;
    return strings;
  };

  babelHelpers.toArray = function (arr) {
    return Array.isArray(arr) ? arr : Array.from(arr);
  };

  babelHelpers.toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  babelHelpers.slicedToArray = (function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  })();

  babelHelpers.slicedToArrayLoose = function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      var _arr = [];

      for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
        _arr.push(_step.value);

        if (i && _arr.length === i) break;
      }

      return _arr;
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };

  babelHelpers.objectWithoutProperties = function (obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  };

  babelHelpers.hasOwn = Object.prototype.hasOwnProperty;
  babelHelpers.slice = Array.prototype.slice;
  babelHelpers.bind = Function.prototype.bind;

  babelHelpers.defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  babelHelpers.asyncToGenerator = function (fn) {
    return function () {
      var gen = fn.apply(this, arguments);
      return new Promise(function (resolve, reject) {
        var callNext = step.bind(null, "next");
        var callThrow = step.bind(null, "throw");

        function step(key, arg) {
          try {
            var info = gen[key](arg);
            var value = info.value;
          } catch (error) {
            reject(error);
            return;
          }

          if (info.done) {
            resolve(value);
          } else {
            Promise.resolve(value).then(callNext, callThrow);
          }
        }

        callNext();
      });
    };
  };

  babelHelpers.interopExportWildcard = function (obj, defaults) {
    var newObj = defaults({}, obj);
    delete newObj["default"];
    return newObj;
  };

  babelHelpers.interopRequireWildcard = function (obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj["default"] = obj;
      return newObj;
    }
  };

  babelHelpers.interopRequireDefault = function (obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  };

  babelHelpers._typeof = function (obj) {
    return obj && obj.constructor === Symbol ? "symbol" : typeof obj;
  };

  babelHelpers._extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  babelHelpers.get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  babelHelpers.set = function set(object, property, value, receiver) {
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent !== null) {
        set(parent, property, value, receiver);
      }
    } else if ("value" in desc && desc.writable) {
      desc.value = value;
    } else {
      var setter = desc.set;

      if (setter !== undefined) {
        setter.call(receiver, value);
      }
    }

    return value;
  };

  babelHelpers.newArrowCheck = function (innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  };

  babelHelpers.classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  babelHelpers.objectDestructuringEmpty = function (obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  };

  babelHelpers.temporalUndefined = {};

  babelHelpers.temporalAssertDefined = function (val, name, undef) {
    if (val === undef) {
      throw new ReferenceError(name + " is not defined - temporal dead zone");
    }

    return true;
  };

  babelHelpers.selfGlobal = typeof global === "undefined" ? self : global;
  babelHelpers.typeofReactElement = typeof Symbol === "function" && Symbol["for"] && Symbol["for"]("react.element") || 60103;

  babelHelpers.defaultProps = function (defaultProps, props) {
    if (defaultProps) {
      for (var propName in defaultProps) {
        if (typeof props[propName] === "undefined") {
          props[propName] = defaultProps[propName];
        }
      }
    }

    return props;
  };

  babelHelpers._instanceof = function (left, right) {
    if (right != null && right[Symbol.hasInstance]) {
      return right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  };

  babelHelpers.interopRequire = function (obj) {
    return obj && obj.__esModule ? obj["default"] : obj;
  };
})(typeof global === "undefined" ? self : global);

(function(global) {

  var defined = {};

  // indexOf polyfill for IE8
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++)
      if (this[i] === item)
        return i;
    return -1;
  }

  var getOwnPropertyDescriptor = true;
  try {
    Object.getOwnPropertyDescriptor({ a: 0 }, 'a');
  }
  catch(e) {
    getOwnPropertyDescriptor = false;
  }

  var defineProperty;
  (function () {
    try {
      if (!!Object.defineProperty({}, 'a', {}))
        defineProperty = Object.defineProperty;
    }
    catch (e) {
      defineProperty = function(obj, prop, opt) {
        try {
          obj[prop] = opt.value || opt.get.call(obj);
        }
        catch(e) {}
      }
    }
  })();

  function register(name, deps, declare) {
    if (arguments.length === 4)
      return registerDynamic.apply(this, arguments);
    doRegister(name, {
      declarative: true,
      deps: deps,
      declare: declare
    });
  }

  function registerDynamic(name, deps, executingRequire, execute) {
    doRegister(name, {
      declarative: false,
      deps: deps,
      executingRequire: executingRequire,
      execute: execute
    });
  }

  function doRegister(name, entry) {
    entry.name = name;

    // we never overwrite an existing define
    if (!(name in defined))
      defined[name] = entry;

    // we have to normalize dependencies
    // (assume dependencies are normalized for now)
    // entry.normalizedDeps = entry.deps.map(normalize);
    entry.normalizedDeps = entry.deps;
  }


  function buildGroups(entry, groups) {
    groups[entry.groupIndex] = groups[entry.groupIndex] || [];

    if (indexOf.call(groups[entry.groupIndex], entry) != -1)
      return;

    groups[entry.groupIndex].push(entry);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];

      // not in the registry means already linked / ES6
      if (!depEntry || depEntry.evaluated)
        continue;

      // now we know the entry is in our unlinked linkage group
      var depGroupIndex = entry.groupIndex + (depEntry.declarative != entry.declarative);

      // the group index of an entry is always the maximum
      if (depEntry.groupIndex === undefined || depEntry.groupIndex < depGroupIndex) {

        // if already in a group, remove from the old group
        if (depEntry.groupIndex !== undefined) {
          groups[depEntry.groupIndex].splice(indexOf.call(groups[depEntry.groupIndex], depEntry), 1);

          // if the old group is empty, then we have a mixed depndency cycle
          if (groups[depEntry.groupIndex].length == 0)
            throw new TypeError("Mixed dependency cycle detected");
        }

        depEntry.groupIndex = depGroupIndex;
      }

      buildGroups(depEntry, groups);
    }
  }

  function link(name) {
    var startEntry = defined[name];

    startEntry.groupIndex = 0;

    var groups = [];

    buildGroups(startEntry, groups);

    var curGroupDeclarative = !!startEntry.declarative == groups.length % 2;
    for (var i = groups.length - 1; i >= 0; i--) {
      var group = groups[i];
      for (var j = 0; j < group.length; j++) {
        var entry = group[j];

        // link each group
        if (curGroupDeclarative)
          linkDeclarativeModule(entry);
        else
          linkDynamicModule(entry);
      }
      curGroupDeclarative = !curGroupDeclarative; 
    }
  }

  // module binding records
  var moduleRecords = {};
  function getOrCreateModuleRecord(name) {
    return moduleRecords[name] || (moduleRecords[name] = {
      name: name,
      dependencies: [],
      exports: {}, // start from an empty module and extend
      importers: []
    })
  }

  function linkDeclarativeModule(entry) {
    // only link if already not already started linking (stops at circular)
    if (entry.module)
      return;

    var module = entry.module = getOrCreateModuleRecord(entry.name);
    var exports = entry.module.exports;

    var declaration = entry.declare.call(global, function(name, value) {
      module.locked = true;

      if (typeof name == 'object') {
        for (var p in name)
          exports[p] = name[p];
      }
      else {
        exports[name] = value;
      }

      for (var i = 0, l = module.importers.length; i < l; i++) {
        var importerModule = module.importers[i];
        if (!importerModule.locked) {
          for (var j = 0; j < importerModule.dependencies.length; ++j) {
            if (importerModule.dependencies[j] === module) {
              importerModule.setters[j](exports);
            }
          }
        }
      }

      module.locked = false;
      return value;
    });

    module.setters = declaration.setters;
    module.execute = declaration.execute;

    // now link all the module dependencies
    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];
      var depModule = moduleRecords[depName];

      // work out how to set depExports based on scenarios...
      var depExports;

      if (depModule) {
        depExports = depModule.exports;
      }
      else if (depEntry && !depEntry.declarative) {
        depExports = depEntry.esModule;
      }
      // in the module registry
      else if (!depEntry) {
        depExports = load(depName);
      }
      // we have an entry -> link
      else {
        linkDeclarativeModule(depEntry);
        depModule = depEntry.module;
        depExports = depModule.exports;
      }

      // only declarative modules have dynamic bindings
      if (depModule && depModule.importers) {
        depModule.importers.push(module);
        module.dependencies.push(depModule);
      }
      else
        module.dependencies.push(null);

      // run the setter for this dependency
      if (module.setters[i])
        module.setters[i](depExports);
    }
  }

  // An analog to loader.get covering execution of all three layers (real declarative, simulated declarative, simulated dynamic)
  function getModule(name) {
    var exports;
    var entry = defined[name];

    if (!entry) {
      exports = load(name);
      if (!exports)
        throw new Error("Unable to load dependency " + name + ".");
    }

    else {
      if (entry.declarative)
        ensureEvaluated(name, []);

      else if (!entry.evaluated)
        linkDynamicModule(entry);

      exports = entry.module.exports;
    }

    if ((!entry || entry.declarative) && exports && exports.__useDefault)
      return exports['default'];

    return exports;
  }

  function linkDynamicModule(entry) {
    if (entry.module)
      return;

    var exports = {};

    var module = entry.module = { exports: exports, id: entry.name };

    // AMD requires execute the tree first
    if (!entry.executingRequire) {
      for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
        var depName = entry.normalizedDeps[i];
        var depEntry = defined[depName];
        if (depEntry)
          linkDynamicModule(depEntry);
      }
    }

    // now execute
    entry.evaluated = true;
    var output = entry.execute.call(global, function(name) {
      for (var i = 0, l = entry.deps.length; i < l; i++) {
        if (entry.deps[i] != name)
          continue;
        return getModule(entry.normalizedDeps[i]);
      }
      throw new TypeError('Module ' + name + ' not declared as a dependency.');
    }, exports, module);

    if (output)
      module.exports = output;

    // create the esModule object, which allows ES6 named imports of dynamics
    exports = module.exports;
 
    if (exports && exports.__esModule) {
      entry.esModule = exports;
    }
    else {
      entry.esModule = {};
      
      // don't trigger getters/setters in environments that support them
      if ((typeof exports == 'object' || typeof exports == 'function') && exports !== global) {
        if (getOwnPropertyDescriptor) {
          var d;
          for (var p in exports)
            if (d = Object.getOwnPropertyDescriptor(exports, p))
              defineProperty(entry.esModule, p, d);
        }
        else {
          var hasOwnProperty = exports && exports.hasOwnProperty;
          for (var p in exports) {
            if (!hasOwnProperty || exports.hasOwnProperty(p))
              entry.esModule[p] = exports[p];
          }
         }
       }
      entry.esModule['default'] = exports;
      defineProperty(entry.esModule, '__useDefault', {
        value: true
      });
    }
  }

  /*
   * Given a module, and the list of modules for this current branch,
   *  ensure that each of the dependencies of this module is evaluated
   *  (unless one is a circular dependency already in the list of seen
   *  modules, in which case we execute it)
   *
   * Then we evaluate the module itself depth-first left to right 
   * execution to match ES6 modules
   */
  function ensureEvaluated(moduleName, seen) {
    var entry = defined[moduleName];

    // if already seen, that means it's an already-evaluated non circular dependency
    if (!entry || entry.evaluated || !entry.declarative)
      return;

    // this only applies to declarative modules which late-execute

    seen.push(moduleName);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      if (indexOf.call(seen, depName) == -1) {
        if (!defined[depName])
          load(depName);
        else
          ensureEvaluated(depName, seen);
      }
    }

    if (entry.evaluated)
      return;

    entry.evaluated = true;
    entry.module.execute.call(global);
  }

  // magical execution function
  var modules = {};
  function load(name) {
    if (modules[name])
      return modules[name];

    // node core modules
    if (name.substr(0, 6) == '@node/')
      return require(name.substr(6));

    var entry = defined[name];

    // first we check if this module has already been defined in the registry
    if (!entry)
      throw "Module " + name + " not present.";

    // recursively ensure that the module and all its 
    // dependencies are linked (with dependency group handling)
    link(name);

    // now handle dependency execution in correct order
    ensureEvaluated(name, []);

    // remove from the registry
    defined[name] = undefined;

    // exported modules get __esModule defined for interop
    if (entry.declarative)
      defineProperty(entry.module.exports, '__esModule', { value: true });

    // return the defined module object
    return modules[name] = entry.declarative ? entry.module.exports : entry.esModule;
  };

  return function(mains, depNames, declare) {
    return function(formatDetect) {
      formatDetect(function(deps) {
        var System = {
          _nodeRequire: typeof require != 'undefined' && require.resolve && typeof process != 'undefined' && require,
          register: register,
          registerDynamic: registerDynamic,
          get: load, 
          set: function(name, module) {
            modules[name] = module; 
          },
          newModule: function(module) {
            return module;
          }
        };
        System.set('@empty', {});

        // register external dependencies
        for (var i = 0; i < depNames.length; i++) (function(depName, dep) {
          if (dep && dep.__esModule)
            System.register(depName, [], function(_export) {
              return {
                setters: [],
                execute: function() {
                  for (var p in dep)
                    if (p != '__esModule' && !(typeof p == 'object' && p + '' == 'Module'))
                      _export(p, dep[p]);
                }
              };
            });
          else
            System.registerDynamic(depName, [], false, function() {
              return dep;
            });
        })(depNames[i], arguments[i]);

        // register modules in this bundle
        declare(System);

        // load mains
        var firstLoad = load(mains[0]);
        if (mains.length > 1)
          for (var i = 1; i < mains.length; i++)
            load(mains[i]);

        if (firstLoad.__useDefault)
          return firstLoad['default'];
        else
          return firstLoad;
      });
    };
  };

})(typeof self != 'undefined' ? self : global)
/* (['mainModule'], ['external-dep'], function($__System) {
  System.register(...);
})
(function(factory) {
  if (typeof define && define.amd)
    define(['external-dep'], factory);
  // etc UMD / module pattern
})*/

(['1'], [], function($__System) {

(function(__global) {
  var loader = $__System;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++)
      if (this[i] === item)
        return i;
    return -1;
  }

  function readMemberExpression(p, value) {
    var pParts = p.split('.');
    while (pParts.length)
      value = value[pParts.shift()];
    return value;
  }

  // bare minimum ignores for IE8
  var ignoredGlobalProps = ['_g', 'sessionStorage', 'localStorage', 'clipboardData', 'frames', 'external', 'mozAnimationStartTime', 'webkitStorageInfo', 'webkitIndexedDB'];

  var globalSnapshot;

  function forEachGlobal(callback) {
    if (Object.keys)
      Object.keys(__global).forEach(callback);
    else
      for (var g in __global) {
        if (!hasOwnProperty.call(__global, g))
          continue;
        callback(g);
      }
  }

  function forEachGlobalValue(callback) {
    forEachGlobal(function(globalName) {
      if (indexOf.call(ignoredGlobalProps, globalName) != -1)
        return;
      try {
        var value = __global[globalName];
      }
      catch (e) {
        ignoredGlobalProps.push(globalName);
      }
      callback(globalName, value);
    });
  }

  loader.set('@@global-helpers', loader.newModule({
    prepareGlobal: function(moduleName, exportName, globals) {
      // disable module detection
      var curDefine = __global.define;
       
      __global.define = undefined;
      __global.exports = undefined;
      if (__global.module && __global.module.exports)
        __global.module = undefined;

      // set globals
      var oldGlobals;
      if (globals) {
        oldGlobals = {};
        for (var g in globals) {
          oldGlobals[g] = globals[g];
          __global[g] = globals[g];
        }
      }

      // store a complete copy of the global object in order to detect changes
      if (!exportName) {
        globalSnapshot = {};

        forEachGlobalValue(function(name, value) {
          globalSnapshot[name] = value;
        });
      }

      // return function to retrieve global
      return function() {
        var globalValue;

        if (exportName) {
          globalValue = readMemberExpression(exportName, __global);
        }
        else {
          var singleGlobal;
          var multipleExports;
          var exports = {};

          forEachGlobalValue(function(name, value) {
            if (globalSnapshot[name] === value)
              return;
            if (typeof value == 'undefined')
              return;
            exports[name] = value;

            if (typeof singleGlobal != 'undefined') {
              if (!multipleExports && singleGlobal !== value)
                multipleExports = true;
            }
            else {
              singleGlobal = value;
            }
          });
          globalValue = multipleExports ? exports : singleGlobal;
        }

        // revert globals
        if (oldGlobals) {
          for (var g in oldGlobals)
            __global[g] = oldGlobals[g];
        }
        __global.define = curDefine;

        return globalValue;
      };
    }
  }));

})(typeof self != 'undefined' ? self : global);

(function(__global) {
  var loader = $__System;
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++)
      if (this[i] === item)
        return i;
    return -1;
  }

  var commentRegEx = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg;
  var cjsRequirePre = "(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])";
  var cjsRequirePost = "\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)";
  var fnBracketRegEx = /\(([^\)]*)\)/;
  var wsRegEx = /^\s+|\s+$/g;
  
  var requireRegExs = {};

  function getCJSDeps(source, requireIndex) {

    // remove comments
    source = source.replace(commentRegEx, '');

    // determine the require alias
    var params = source.match(fnBracketRegEx);
    var requireAlias = (params[1].split(',')[requireIndex] || 'require').replace(wsRegEx, '');

    // find or generate the regex for this requireAlias
    var requireRegEx = requireRegExs[requireAlias] || (requireRegExs[requireAlias] = new RegExp(cjsRequirePre + requireAlias + cjsRequirePost, 'g'));

    requireRegEx.lastIndex = 0;

    var deps = [];

    var match;
    while (match = requireRegEx.exec(source))
      deps.push(match[2] || match[3]);

    return deps;
  }

  /*
    AMD-compatible require
    To copy RequireJS, set window.require = window.requirejs = loader.amdRequire
  */
  function require(names, callback, errback, referer) {
    // in amd, first arg can be a config object... we just ignore
    if (typeof names == 'object' && !(names instanceof Array))
      return require.apply(null, Array.prototype.splice.call(arguments, 1, arguments.length - 1));

    // amd require
    if (typeof names == 'string' && typeof callback == 'function')
      names = [names];
    if (names instanceof Array) {
      var dynamicRequires = [];
      for (var i = 0; i < names.length; i++)
        dynamicRequires.push(loader['import'](names[i], referer));
      Promise.all(dynamicRequires).then(function(modules) {
        if (callback)
          callback.apply(null, modules);
      }, errback);
    }

    // commonjs require
    else if (typeof names == 'string') {
      var module = loader.get(names);
      return module.__useDefault ? module['default'] : module;
    }

    else
      throw new TypeError('Invalid require');
  }

  function define(name, deps, factory) {
    if (typeof name != 'string') {
      factory = deps;
      deps = name;
      name = null;
    }
    if (!(deps instanceof Array)) {
      factory = deps;
      deps = ['require', 'exports', 'module'].splice(0, factory.length);
    }

    if (typeof factory != 'function')
      factory = (function(factory) {
        return function() { return factory; }
      })(factory);

    // in IE8, a trailing comma becomes a trailing undefined entry
    if (deps[deps.length - 1] === undefined)
      deps.pop();

    // remove system dependencies
    var requireIndex, exportsIndex, moduleIndex;
    
    if ((requireIndex = indexOf.call(deps, 'require')) != -1) {
      
      deps.splice(requireIndex, 1);

      // only trace cjs requires for non-named
      // named defines assume the trace has already been done
      if (!name)
        deps = deps.concat(getCJSDeps(factory.toString(), requireIndex));
    }

    if ((exportsIndex = indexOf.call(deps, 'exports')) != -1)
      deps.splice(exportsIndex, 1);
    
    if ((moduleIndex = indexOf.call(deps, 'module')) != -1)
      deps.splice(moduleIndex, 1);

    var define = {
      name: name,
      deps: deps,
      execute: function(req, exports, module) {

        var depValues = [];
        for (var i = 0; i < deps.length; i++)
          depValues.push(req(deps[i]));

        module.uri = module.id;

        module.config = function() {};

        // add back in system dependencies
        if (moduleIndex != -1)
          depValues.splice(moduleIndex, 0, module);
        
        if (exportsIndex != -1)
          depValues.splice(exportsIndex, 0, exports);
        
        if (requireIndex != -1) 
          depValues.splice(requireIndex, 0, function(names, callback, errback) {
            if (typeof names == 'string' && typeof callback != 'function')
              return req(names);
            return require.call(loader, names, callback, errback, module.id);
          });

        var output = factory.apply(exportsIndex == -1 ? __global : exports, depValues);

        if (typeof output == 'undefined' && module)
          output = module.exports;

        if (typeof output != 'undefined')
          return output;
      }
    };

    // anonymous define
    if (!name) {
      // already defined anonymously -> throw
      if (lastModule.anonDefine)
        throw new TypeError('Multiple defines for anonymous module');
      lastModule.anonDefine = define;
    }
    // named define
    else {
      // if we don't have any other defines,
      // then let this be an anonymous define
      // this is just to support single modules of the form:
      // define('jquery')
      // still loading anonymously
      // because it is done widely enough to be useful
      if (!lastModule.anonDefine && !lastModule.isBundle) {
        lastModule.anonDefine = define;
      }
      // otherwise its a bundle only
      else {
        // if there is an anonDefine already (we thought it could have had a single named define)
        // then we define it now
        // this is to avoid defining named defines when they are actually anonymous
        if (lastModule.anonDefine && lastModule.anonDefine.name)
          loader.registerDynamic(lastModule.anonDefine.name, lastModule.anonDefine.deps, false, lastModule.anonDefine.execute);

        lastModule.anonDefine = null;
      }

      // note this is now a bundle
      lastModule.isBundle = true;

      // define the module through the register registry
      loader.registerDynamic(name, define.deps, false, define.execute);
    }
  }
  define.amd = {};

  // adds define as a global (potentially just temporarily)
  function createDefine(loader) {
    lastModule.anonDefine = null;
    lastModule.isBundle = false;

    // ensure no NodeJS environment detection
    var oldModule = __global.module;
    var oldExports = __global.exports;
    var oldDefine = __global.define;

    __global.module = undefined;
    __global.exports = undefined;
    __global.define = define;

    return function() {
      __global.define = oldDefine;
      __global.module = oldModule;
      __global.exports = oldExports;
    };
  }

  var lastModule = {
    isBundle: false,
    anonDefine: null
  };

  loader.set('@@amd-helpers', loader.newModule({
    createDefine: createDefine,
    require: require,
    define: define,
    lastModule: lastModule
  }));
  loader.amdDefine = define;
  loader.amdRequire = require;
})(typeof self != 'undefined' ? self : global);

"bundle";
$__System.register("2", [], function() { return { setters: [], execute: function() {} } });

$__System.register("3", [], function() { return { setters: [], execute: function() {} } });

$__System.register('4', ['5'], function (_export) {

  // https://github.com/davicustodio/Leaflet.StyledLayerControl/blob/7a3268d446d755f59bcd845cf873444d01ce1774/src/styledLayerControl.js
  // + some patches to make it 'use strict' compatible

  'use strict';

  var L;
  return {
    setters: [function (_) {
      L = _['default'];
    }],
    execute: function () {
      L.Control.StyledLayerControl = L.Control.Layers.extend({
        options: {
          collapsed: true,
          position: 'topright',
          autoZIndex: true
        },

        initialize: function initialize(baseLayers, groupedOverlays, options) {
          var i, j;
          L.Util.setOptions(this, options);

          this._layers = {};
          this._lastZIndex = 0;
          this._handlingClick = false;
          this._groupList = [];
          this._domGroups = [];

          for (i in baseLayers) {
            for (var j in baseLayers[i].layers) {
              this._addLayer(baseLayers[i].layers[j], j, baseLayers[i], false);
            }
          }

          for (i in groupedOverlays) {
            for (var j in groupedOverlays[i].layers) {
              this._addLayer(groupedOverlays[i].layers[j], j, groupedOverlays[i], true);
            }
          }
        },

        onAdd: function onAdd(map) {
          this._initLayout();
          this._update();

          map.on('layeradd', this._onLayerChange, this).on('layerremove', this._onLayerChange, this);

          return this._container;
        },

        onRemove: function onRemove(map) {
          map.off('layeradd', this._onLayerChange).off('layerremove', this._onLayerChange);
        },

        addBaseLayer: function addBaseLayer(layer, name, group) {
          this._addLayer(layer, name, group, false);
          this._update();
          return this;
        },

        addOverlay: function addOverlay(layer, name, group) {
          this._addLayer(layer, name, group, true);
          this._update();
          return this;
        },

        removeLayer: function removeLayer(layer) {
          var id = L.Util.stamp(layer);
          delete this._layers[id];
          this._update();
          return this;
        },

        removeGroup: function removeGroup(group_Name) {
          for (var group in this._groupList) {
            if (this._groupList[group].groupName == group_Name) {
              for (var layer in this._layers) {
                if (this._layers[layer].group && this._layers[layer].group.name == group_Name) {
                  delete this._layers[layer];
                }
              }
              delete this._groupList[group];
              this._update();
              break;
            }
          }
        },

        _initLayout: function _initLayout() {
          var className = 'leaflet-control-layers',
              container = this._container = L.DomUtil.create('div', className);

          //Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released
          container.setAttribute('aria-haspopup', true);

          if (!L.Browser.touch) {
            L.DomEvent.disableClickPropagation(container);
            L.DomEvent.on(container, 'wheel', L.DomEvent.stopPropagation);
          } else {
            L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
          }

          var section = document.createElement('section');
          section.className = 'ac-container ' + className + '-list';

          var form = this._form = L.DomUtil.create('form');

          section.appendChild(form);

          if (this.options.collapsed) {
            if (!L.Browser.android) {
              L.DomEvent.on(container, 'mouseover', this._expand, this).on(container, 'mouseout', this._collapse, this);
            }
            var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
            link.href = '#';
            link.title = 'Layers';

            if (L.Browser.touch) {
              L.DomEvent.on(link, 'click', L.DomEvent.stop).on(link, 'click', this._expand, this);
            } else {
              L.DomEvent.on(link, 'focus', this._expand, this);
            }

            this._map.on('click', this._collapse, this);
            // TODO keyboard accessibility
          } else {
              this._expand();
            }

          this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
          this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

          container.appendChild(section);

          this._containers = container.getElementsByClassName('ac-container');

          // process options of ac-container css class - to options.container_width and options.container_maxHeight
          for (var c = 0; c < this._containers.length; c++) {
            if (this.options.container_width) {
              this._containers[c].style.width = this.options.container_width;
            }

            // set the max-height of control to y value of map object
            this._default_maxHeight = this.options.container_maxHeight ? this.options.container_maxHeight : this._map._size.y - 70;
            this._containers[c].style.maxHeight = this._default_maxHeight + "px";
          }

          window.onresize = this._on_resize_window.bind(this);
        },

        _on_resize_window: function _on_resize_window() {
          // listen to resize of screen to reajust de maxHeight of container
          for (var c = 0; c < this._containers.length; c++) {
            // input the new value to height
            this._containers[c].style.maxHeight = window.innerHeight - 90 < this._removePxToInt(this._default_maxHeight) ? window.innerHeight - 90 + "px" : this._removePxToInt(this._default_maxHeight) + "px";
          }
        },

        // remove the px from a css value and convert to a int
        _removePxToInt: function _removePxToInt(value) {
          return parseInt(value.replace("px", ""));
        },

        _addLayer: function _addLayer(layer, name, group, overlay) {
          var id = L.Util.stamp(layer);

          this._layers[id] = {
            layer: layer,
            name: name,
            overlay: overlay
          };

          if (group) {
            var groupId = this._groupList.indexOf(group);

            // if not find the group search for the name
            if (groupId === -1) {
              for (var g in this._groupList) {
                if (this._groupList[g].groupName == group.groupName) {
                  groupId = g;
                  break;
                }
              }
            }

            if (groupId === -1) {
              groupId = this._groupList.push(group) - 1;
            }

            this._layers[id].group = {
              name: group.groupName,
              id: groupId,
              expanded: group.expanded
            };
          }

          if (this.options.autoZIndex && layer.setZIndex) {
            this._lastZIndex++;
            layer.setZIndex(this._lastZIndex);
          }
        },

        _update: function _update() {
          if (!this._container) {
            return;
          }

          this._baseLayersList.innerHTML = '';
          this._overlaysList.innerHTML = '';
          this._domGroups.length = 0;

          var baseLayersPresent = false,
              overlaysPresent = false,
              i,
              obj;

          for (i in this._layers) {
            obj = this._layers[i];
            this._addItem(obj);
            overlaysPresent = overlaysPresent || obj.overlay;
            baseLayersPresent = baseLayersPresent || !obj.overlay;
          }
        },

        _onLayerChange: function _onLayerChange(e) {
          var obj = this._layers[L.Util.stamp(e.layer)];

          if (!obj) {
            return;
          }

          if (!this._handlingClick) {
            this._update();
          }

          var type = obj.overlay ? e.type === 'layeradd' ? 'overlayadd' : 'overlayremove' : e.type === 'layeradd' ? 'baselayerchange' : null;

          if (type) {
            this._map.fire(type, obj);
          }
        },

        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
        _createRadioElement: function _createRadioElement(name, checked) {

          var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"';
          if (checked) {
            radioHtml += ' checked="checked"';
          }
          radioHtml += '/>';

          var radioFragment = document.createElement('div');
          radioFragment.innerHTML = radioHtml;

          return radioFragment.firstChild;
        },

        _addItem: function _addItem(obj) {
          var label = document.createElement('div'),
              input,
              checked = this._map.hasLayer(obj.layer),
              container;

          if (obj.overlay) {
            input = document.createElement('input');
            input.type = 'checkbox';
            input.className = 'leaflet-control-layers-selector';
            input.defaultChecked = checked;

            label.className = "menu-item-checkbox";
          } else {
            input = this._createRadioElement('leaflet-base-layers', checked);

            label.className = "menu-item-radio";
          }

          input.layerId = L.Util.stamp(obj.layer);

          L.DomEvent.on(input, 'click', this._onInputClick, this);

          var name = document.createElement('span');
          name.innerHTML = ' ' + obj.name;

          label.appendChild(input);
          label.appendChild(name);

          // configure the delete button for layers with attribute removable = true
          if (obj.layer.StyledLayerControl && obj.layer.StyledLayerControl.removable) {
            var bt_delete = document.createElement("input");
            bt_delete.type = "button";
            bt_delete.className = "bt_delete";
            L.DomEvent.on(bt_delete, 'click', this._onDeleteClick, this);
            label.appendChild(bt_delete);
          }

          if (obj.overlay) {
            container = this._overlaysList;
          } else {
            container = this._baseLayersList;
          }

          var groupContainer = this._domGroups[obj.group.id];

          if (!groupContainer) {

            groupContainer = document.createElement('div');
            groupContainer.id = 'leaflet-control-accordion-layers-' + obj.group.id;

            // verify if group is expanded
            var s_expanded = obj.group.expanded ? ' checked = "true" ' : '';

            // verify if type is exclusive
            var s_type_exclusive = this.options.exclusive ? ' type="radio" ' : ' type="checkbox" ';

            var inputElement = '<input id="ac' + obj.group.id + '" name="accordion-1" class="menu" ' + s_expanded + s_type_exclusive + '/>';
            var inputLabel = '<label for="ac' + obj.group.id + '">' + obj.group.name + '</label>';

            var article = document.createElement('article');
            article.className = 'ac-large';
            article.appendChild(label);

            // process options of ac-large css class - to options.group_maxHeight property
            if (this.options.group_maxHeight) {
              article.style.maxHeight = this.options.group_maxHeight;
            }

            groupContainer.innerHTML = inputElement + inputLabel;
            groupContainer.appendChild(article);
            container.appendChild(groupContainer);

            this._domGroups[obj.group.id] = groupContainer;
          } else {
            groupContainer.lastElementChild.appendChild(label);
          }

          return label;
        },

        _onInputClick: function _onInputClick() {
          var i,
              input,
              obj,
              inputs = this._form.getElementsByTagName('input'),
              inputsLen = inputs.length;

          this._handlingClick = true;

          for (i = 0; i < inputsLen; i++) {
            input = inputs[i];
            obj = this._layers[input.layerId];

            if (!obj) {
              continue;
            }

            if (input.checked && !this._map.hasLayer(obj.layer)) {
              this._map.addLayer(obj.layer);
            } else if (!input.checked && this._map.hasLayer(obj.layer)) {
              this._map.removeLayer(obj.layer);
            }
          }

          this._handlingClick = false;
        },

        _onDeleteClick: function _onDeleteClick(obj) {
          var node = obj.target.parentElement.childNodes[0];
          var n_obj = this._layers[node.layerId];

          // verify if obj is a basemap and checked to not remove
          if (!n_obj.overlay && node.checked) {
            return false;
          }

          if (this._map.hasLayer(n_obj.layer)) {
            this._map.removeLayer(n_obj.layer);
          }
          this.removeLayer(n_obj.layer);
          obj.target.parentNode.remove();

          return false;
        },

        _expand: function _expand() {
          L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
        },

        _collapse: function _collapse() {
          this._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');
        }
      });

      L.Control.styledLayerControl = function (baseLayers, overlays, options) {
        return new L.Control.StyledLayerControl(baseLayers, overlays, options);
      };
    }
  };
});

$__System.register("6", [], function() { return { setters: [], execute: function() {} } });

$__System.register('7', ['8', '9', 'c', 'a', 'b'], function (_export) {
  'use strict';

  var $, $$, HTML, i18n, Modal, Eventable, EXTERNAL_LINK, paneHtml, bodyHtml, TEMPLATES, css, WorkspacePane;
  return {
    setters: [function (_) {
      $ = _.$;
      $$ = _.$$;
      HTML = _.HTML;
    }, function (_2) {
      i18n = _2.i18n;
    }, function (_c) {
      Modal = _c['default'];
    }, function (_a) {
      Eventable = _a['default'];
    }, function (_b) {
      EXTERNAL_LINK = _b.EXTERNAL_LINK;
    }],
    execute: function () {
      paneHtml = function paneHtml() {
        return '\n<h1 class="sidebar-header">Workspace<div class="sidebar-close"><i class="glyphicon glyphicon-menu-left"></i></div></h1>\n\n<p style="margin-top: 20px">\n  <button type="button" class="btn btn-primary create-dataset-button">Load Data</button>\n</p>\n\n<div class="workspace-dataset-list">\n  <p class="user-hint">Click on "Add to Workspace" in the search tab to add datasets.</p>\n</div>\n';
      };

      bodyHtml = '\n<div class="modal fade" id="formatSelectModal" tabindex="-1" role="dialog" aria-labelledby="formatSelectModalLabel">\n  <div class="modal-dialog" role="document">\n    <div class="modal-content">\n      <div class="modal-header">\n        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>\n        <h4 class="modal-title" id="formatSelectModalLabel">Select a format</h4>\n      </div>\n      <div class="modal-body">      \n        <span class="format-list"></span>\n        <div class="alert alert-info" role="alert">\n          The data you add here is not uploaded to a server. It stays within your browser and is gone when you reload the page.\n        </div>\n      </div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class="modal fade" id="dataCreateLoadModal" tabindex="-1" role="dialog" aria-labelledby="dataCreateLoadModalLabel">\n<div class="modal-dialog" role="document">\n  <div class="modal-content">\n    <div class="modal-header">\n      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>\n      <h4 class="modal-title" id="dataCreateLoadModalLabel">Input your data</h4>\n    </div>\n    <div class="modal-body">      \n      <div class="form-group">\n        <label for="formDatasetTitle">Give your new dataset a name:</label>\n        <input class="form-control dataset-title" type="text" id="formDatasetTitle" placeholder="My new dataset">\n      </div>\n    \n      <span class="data-input-methods"></span>\n    </div>\n    <div class="modal-footer">\n      <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>\n    </div>\n  </div>\n</div>\n</div>\n';

      $('body').add(HTML(bodyHtml));

      TEMPLATES = {
        // Important: No whitespace at beginning as this introduces text nodes and we just get the first node!
        'workspace-dataset': '<div class="panel workspace-dataset">\n    <div class="panel-heading dataset-title-heading">\n      <h4>\n        <span class="dataset-title"></span>\n        <small><a href="#" class="dataset-title-edit"><i class="glyphicon glyphicon-pencil"></i></a></small>\n        <button type="button" class="close" aria-label="Close"><span aria-hidden="true">&times;</span></button>\n      </h4>\n    </div>\n    <div class="panel-heading dataset-title-edit-form" style="display:none">\n      <form>\n        <div class="form-group">\n          <input type="text" class="form-control">\n        </div>\n        <button type="submit" class="btn btn-default">Rename</button>\n        <button type="button" name="cancel" class="btn btn-default">Cancel</button>\n      </form>\n    </div>\n    <div class="panel-body" style="text-align: center">\n      <div class="throbber-loader loader">Loading...</div>\n    </div>\n  \n    <ul class="list-group workspace-dataset-distribution-list"></ul>\n  </div>',

        'workspace-dataset-distribution': '<li class="list-group-item workspace-dataset-distribution">\n    <p>Title: <em class="distribution-title"></em></p>\n    <p>Type: <span class="distribution-format"></span></p>\n    <p>Content: <span class="distribution-content"></span></p>\n    <div class="distribution-actions"></div>\n  </li>',

        'workspace-dataset-distribution-action': '<span class="workspace-dataset-distribution-action">\n    <button type="button" class="btn btn-primary"><span class="action-icon"></span> <span class="action-label"></span></button>\n  </span>',

        'workspace-dataset-distribution-action-external-link': '<span class="workspace-dataset-distribution-action">\n    <a target="_new" class="btn btn-primary"><span class="action-icon"></span> <span class="action-label"></span></a>\n  </span>',

        'workspace-dataset-distribution-error': '<li class="list-group-item list-group-item-danger workspace-dataset-distribution error-item">\n    <p>Type: <span class="distribution-format"></span></p>\n    <p>Error: <em class="error-message"></em></p>\n    <span class="error-details-section">\n      <p>Details:</p>\n      <small><pre class="error-details"></pre></small>\n    </span>\n  </li>',

        'format-button-item': '<span><button type="button" class="btn btn-primary format-button" data-dismiss="modal"></button></span> ',

        'url-input-panel': '<div class="panel panel-primary">\n    <div class="panel-heading">\n      <h4>By URL</h4>\n    </div>\n    <div class="panel-body">\n      <div class="input-group">\n        <input type="text" class="form-control data-url" placeholder="http://..." />\n        <span class="input-group-btn">\n          <button class="btn btn-primary load-url-button" type="button" data-dismiss="modal">Load</button>\n        </span>\n      </div>\n    </div>\n  </div>',

        'file-input-panel': '<div class="panel panel-primary">\n    <div class="panel-heading">\n      <h4>By Local File</h4>\n    </div>\n    <div class="panel-body">\n      <div class="input-group">\n        <input type="file" class="form-control data-file" />\n        <span class="input-group-btn">\n          <button class="btn btn-primary load-file-button" type="button" data-dismiss="modal">Load</button>\n        </span>\n      </div>\n    </div>\n  </div>',

        'text-input-panel': '<div class="panel panel-primary">\n    <div class="panel-heading">\n      <h4>By Direct Input</h4>\n    </div>\n    <div class="panel-body">\n      <textarea class="form-control data-textarea" rows="10"></textarea>\n      <button class="btn btn-primary load-text-button" type="button" data-dismiss="modal">Load</button>\n      <div class="alert alert-danger json-parse-error" style="display:none" role="alert"></div>\n    </div>\n  </div>'
      };
      css = '\n<style>\n.virtual-dataset > .panel-heading {\n  background: repeating-linear-gradient( -45deg, #d9edf7, #d9edf7 10px, #CCE8F4 10px, #CCE8F4 20px );\n}\n.workspace-dataset-list, .load-input-button, .json-parse-error {\n  margin-top: 20px;\n}\n.format-button {\n  margin-bottom: 15px;\n}\n.virtual-dataset {\n  overflow: hidden;\n  max-height: 0;\n  transition: max-height 20s;\n}\n.blind-in {\n  max-height: 10000px;\n}\n@keyframes flash-icon {\n  0%   {color: black}\n  50%  {color: red}\n  100% {color: black}\n}\n.highlight-anim {\n  animation-name: flash-icon;\n  animation-duration: 0.8s;\n  animation-iteration-count: 4;\n  animation-timing-function: ease-in-out;\n}\n/* http://www.css-spinners.com/spinner/throbber */\n@keyframes throbber-loader {\n  0%  { background: #dde2e7 }\n  10% { background: #6b9dc8 }\n  40% { background: #dde2e7 }\n}\n/* :not(:required) hides these rules from IE9 and below */\n.throbber-loader:not(:required) {\n  animation: throbber-loader 2000ms 300ms infinite ease-out;\n  background: #dde2e7;\n  display: inline-block;\n  position: relative;\n  text-indent: -9999px;\n  width: 0.9em;\n  height: 1.5em;\n  margin: 0 1.6em;\n}\n.throbber-loader:not(:required):before, .throbber-loader:not(:required):after {\n  background: #dde2e7;\n  content: \' 0B\';\n  display: inline-block;\n  width: 0.9em;\n  height: 1.5em;\n  position: absolute;\n  top: 0;\n}\n.throbber-loader:not(:required):before {\n  animation: throbber-loader 2000ms 150ms infinite ease-out;\n  left: -1.6em;\n}\n.throbber-loader:not(:required):after {\n  animation: throbber-loader 2000ms 450ms infinite ease-out;\n  right: -1.6em;\n}\n</style>\n';

      $('head').add(HTML(css));

      WorkspacePane = (function (_Eventable) {
        babelHelpers.inherits(WorkspacePane, _Eventable);

        function WorkspacePane(sidebar, paneId) {
          babelHelpers.classCallCheck(this, WorkspacePane);

          babelHelpers.get(Object.getPrototypeOf(WorkspacePane.prototype), 'constructor', this).call(this);
          this.sidebar = sidebar;
          this.id = paneId;

          $('#' + paneId).fill(HTML(paneHtml()));

          this.workspace = sidebar.workspace;
          this.app = sidebar.app;

          this._registerUIListeners();
          this._registerModelListeners();
        }

        babelHelpers.createClass(WorkspacePane, [{
          key: '_registerUIListeners',
          value: function _registerUIListeners() {
            var _this = this;

            $('.create-dataset-button', '#' + this.id).on('click', function () {
              return _this._createDatasetWorkflow();
            });
          }
        }, {
          key: '_createDatasetWorkflow',
          value: function _createDatasetWorkflow() {
            var _this2 = this;

            // Step 1: show first modal and let user select the format
            // Step 2: show second modal and display URL field, text area (if media type json or xml), and local file field
            // Step 3: create virtual dataset

            var formatModal = function formatModal() {
              var modalEl = $('#formatSelectModal');

              // iterate over all formats and skip the ones without a proper mimetype (not in the form */*)
              // (these are not real file formats and exist only internally for derived object-only data (e.g. "CoverageData"))

              $('.format-list', modalEl).fill();
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                var _loop = function () {
                  var format = _step.value;

                  if (format.mediaTypes.some(function (mt) {
                    return mt.indexOf('/') !== -1;
                  })) {
                    var el = $(HTML(TEMPLATES['format-button-item']));
                    $('.format-button', el).fill(format.label).on('|click', function () {
                      setTimeout(function () {
                        return dataModal(format);
                      }, 100);
                    });

                    $('.format-list', modalEl).add(el);
                  }
                };

                for (var _iterator = _this2.app.formats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  _loop();
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator['return']) {
                    _iterator['return']();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }

              new Modal(modalEl[0]).open();
            };

            var dataModal = function dataModal(format) {
              var modalEl = $('#dataCreateLoadModal');

              var methods = $('.data-input-methods', modalEl);
              methods.fill();
              methods.add(HTML(TEMPLATES['url-input-panel']));
              methods.add(HTML(TEMPLATES['file-input-panel']));

              var createVirtualDataset = function createVirtualDataset(url) {
                var datasetTitle = $('.dataset-title', modalEl).get('value') || '(No title)';
                var virtualDataset = {
                  title: { en: datasetTitle },
                  virtual: true,
                  distributions: [{
                    title: { en: 'Data' },
                    mediaType: format.mediaTypes[0],
                    url: url
                  }]
                };
                return virtualDataset;
              };
              var addVirtualDataset = function addVirtualDataset(virtualDataset) {
                _this2.workspace.addDataset(virtualDataset);
                _this2.workspace.requestFocus(virtualDataset);
              };

              $('.load-url-button', modalEl).on('|click', function () {
                var url = $('.data-url', modalEl).get('value');
                addVirtualDataset(createVirtualDataset(url));
              });

              var addBlobDataset = function addBlobDataset(content) {
                var blob = new Blob([content], { type: format.mediaTypes[0] });
                var url = URL.createObjectURL(blob);
                var virtualDataset = createVirtualDataset(url);

                var fn = function fn(_ref) {
                  var dataset = _ref.dataset;

                  if (dataset === virtualDataset) {
                    URL.revokeObjectURL(url);
                    delete dataset.distributions[0].url;
                    _this2.workspace.off('distributionsLoad', fn);
                  }
                };
                _this2.workspace.on('distributionsLoad', fn);

                addVirtualDataset(virtualDataset);
              };

              $('.load-file-button', modalEl).on('|click', function () {
                var file = $('.data-file', modalEl)[0].files[0];
                addBlobDataset(file);
              });

              // check if the format has a text media type, if yes: show text area
              if (format.mediaTypes.some(function (mt) {
                return mt.indexOf('json') !== -1 || mt.indexOf('xml') !== -1;
              })) {
                methods.add(HTML(TEMPLATES['text-input-panel']));

                $('.load-text-button', modalEl).on('|click', function (event) {
                  var text = $('.data-textarea', modalEl).get('value');
                  if (format.mediaTypes.some(function (mt) {
                    return mt.indexOf('json') !== -1;
                  })) {
                    try {
                      JSON.parse(text);
                    } catch (e) {
                      $('.json-parse-error', modalEl).show().fill(e.message);
                      event.stopPropagation(); // prevent closing of modal
                      return;
                    }
                  }
                  addBlobDataset(text);
                });
              }

              new Modal(modalEl[0]).open();
            };

            formatModal();
          }
        }, {
          key: '_registerModelListeners',
          value: function _registerModelListeners() {
            var _this3 = this;

            this.workspace.on('add', function (_ref2) {
              var dataset = _ref2.dataset;
              var parent = _ref2.parent;

              var tab = $('a.sidebar-tab', '#' + _this3.sidebar.id).filter(function (t) {
                return $(t).get('@href') === '#' + _this3.id;
              });
              tab.set('-highlight-anim');
              setTimeout(function () {
                // doesn't work without small delay
                tab.set('+highlight-anim');
              }, 100);

              _this3._addDataset(dataset, parent);

              $('.user-hint', '#' + _this3.id).remove();
            });

            this.workspace.on('remove', function (_ref3) {
              var dataset = _ref3.dataset;

              $(dataset.domEl).remove();
            });

            this.workspace.on('distributionsLoading', function (_ref4) {
              var dataset = _ref4.dataset;

              $('.panel-body', dataset.domEl).show();
            });

            this.workspace.on('distributionsLoad', function (_ref5) {
              var dataset = _ref5.dataset;

              $('.panel-body', dataset.domEl).hide();
            });

            this.workspace.on('distributionLoad', function (_ref6) {
              var dataset = _ref6.dataset;
              var distribution = _ref6.distribution;

              _this3._addDistribution(dataset, distribution);
            });

            this.workspace.on('distributionLoadError', function (_ref7) {
              var dataset = _ref7.dataset;
              var distribution = _ref7.distribution;
              var error = _ref7.error;

              _this3._addDistributionLoadError(dataset, distribution, error);
            });

            this.workspace.on('requestFocus', function (_ref8) {
              var dataset = _ref8.dataset;

              // not added to dom yet, defer
              var opts = { behavior: 'smooth' };
              if (!dataset.domEl) {
                var fn = function fn(data) {
                  if (data.dataset === dataset) {
                    dataset.domEl.scrollIntoView(opts);
                    _this3.off('add', fn);
                  }
                };
                _this3.on('add', fn);
              } else {
                dataset.domEl.scrollIntoView(opts);
              }
            });

            this.workspace.on('titleChange', function (_ref9) {
              var dataset = _ref9.dataset;

              $('.dataset-title', dataset.domEl).fill(i18n(dataset.title));
            });
          }
        }, {
          key: '_addDataset',
          value: function _addDataset(dataset, parent) {
            var _this4 = this;

            var el = HTML(TEMPLATES['workspace-dataset'])[0]; // the outer div
            var list = $('.workspace-dataset-list', '#' + this.id);

            if (parent && this.workspace.datasets.indexOf(parent) !== -1) {
              $(parent.domEl).addAfter(el);
            } else {
              list.add(el);
            }
            dataset.domEl = el;

            if (dataset.virtual) {
              $(el).set('+panel-info +virtual-dataset');
              setTimeout(function () {
                return $(el).set('+blind-in');
              }, 100);
            } else {
              $(el).set('+panel-default');
            }
            $('.dataset-title', el).fill(i18n(dataset.title));

            $('.close', el).on('click', function () {
              _this4.workspace.removeDataset(dataset);
            });

            var titleInput = $$('input', $('.dataset-title-edit-form', el));
            $('.dataset-title-edit', el).on('click', function () {
              $('.dataset-title-heading', el).hide();
              $('.dataset-title-edit-form', el).show();
              titleInput.value = i18n(dataset.title);
            });
            $('form', $('.dataset-title-edit-form', el)).on('submit', function () {
              _this4.workspace.setDatasetTitle(dataset, titleInput.value);

              $('.dataset-title-heading', el).show();
              $('.dataset-title-edit-form', el).hide();
            });
            $('button', $('.dataset-title-edit-form', el)).filter(function (b) {
              return b.name === 'cancel';
            }).on('click', function () {
              $('.dataset-title-heading', el).show();
              $('.dataset-title-edit-form', el).hide();
            });

            this.fire('add', { dataset: dataset });
          }
        }, {
          key: '_addDistribution',
          value: function _addDistribution(dataset, distribution) {
            var el = HTML(TEMPLATES['workspace-dataset-distribution']);
            $('.workspace-dataset-distribution-list', dataset.domEl).add(el);
            distribution.domEl = el;
            var meta = distribution.metadata;

            $('.distribution-title', el).fill(i18n(distribution.title));
            $('.distribution-format', el).fill(meta.format);
            $('.distribution-content', el).fill(meta.content);

            if (distribution.actions) {
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                var _loop2 = function () {
                  var action = _step2.value;

                  var actionEl = undefined;
                  if (action.type === EXTERNAL_LINK) {
                    actionEl = HTML(TEMPLATES['workspace-dataset-distribution-action-external-link']);
                    $('a', actionEl).set('@href', action.run());
                  } else {
                    actionEl = HTML(TEMPLATES['workspace-dataset-distribution-action']);
                    $('button', actionEl).on('click', function () {
                      return action.run();
                    });
                  }
                  var setLabelAndIcon = function setLabelAndIcon() {
                    $('.action-label', actionEl).fill(action.label);
                    if (action.icon) {
                      $('.action-icon', actionEl).fill(HTML(action.icon));
                    }
                  };
                  setLabelAndIcon();
                  action.on('labelChange', function () {
                    return setLabelAndIcon();
                  });

                  $('.distribution-actions', el).add(actionEl);
                };

                for (var _iterator2 = distribution.actions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  _loop2();
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                    _iterator2['return']();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            }
          }
        }, {
          key: '_addDistributionLoadError',
          value: function _addDistributionLoadError(dataset, distribution, error) {
            var el = HTML(TEMPLATES['workspace-dataset-distribution-error']);
            $('.workspace-dataset-distribution-list', dataset.domEl).add(el);
            distribution.domEl = el;

            $('.distribution-format', el).fill(distribution.formatImpl.label);
            $('.error-message', el).fill(error.message);
            if (Object.keys(error).length > 0) {
              $('.error-details', el).fill(JSON.stringify(error, null, 1));
            } else {
              $('.error-details-section', el).remove();
            }
          }
        }]);
        return WorkspacePane;
      })(Eventable);

      _export('default', WorkspacePane);
    }
  };
});

$__System.registerDynamic("d", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(factory) {
    if (typeof module !== "undefined" && typeof exports == "object") {
      if (typeof window != "undefined") {
        module.exports = factory();
      } else {
        module.exports = factory;
      }
    } else {
      window.Tab = factory();
    }
  })(function() {
    var Tab = function(element, options) {
      options = options || {};
      this.isIE = (new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})").exec(navigator.userAgent) != null) ? parseFloat(RegExp.$1) : false;
      this.tab = typeof element === 'object' ? element : document.querySelector(element);
      this.tabs = this.tab.parentNode.parentNode;
      this.dropdown = this.tabs.querySelector('.dropdown');
      if (/dropdown-menu/.test(this.tabs.className)) {
        this.dropdown = this.tabs.parentNode;
        this.tabs = this.tabs.parentNode.parentNode;
      }
      this.options = options;
      this.duration = 150;
      this.options.duration = (this.isIE && this.isIE < 10) ? 0 : (options.duration || this.duration);
      this.init();
    };
    Tab.prototype = {
      init: function() {
        this.actions();
        this.tab.addEventListener('click', this.action, false);
      },
      actions: function() {
        var self = this;
        this.action = function(e) {
          e = e || window.e;
          e.preventDefault();
          var next = e.target;
          var nextContent = document.getElementById(next.getAttribute('href').replace('#', ''));
          var isDropDown = new RegExp('(?:^|\\s)' + 'dropdown-menu' + '(?!\\S)');
          var activeTab = self.getActiveTab();
          var activeContent = self.getActiveContent();
          if (!/active/.test(next.parentNode.className)) {
            self.removeClass(activeTab, 'active');
            self.addClass(next.parentNode, 'active');
            if (self.dropdown) {
              if (!(isDropDown.test(self.tab.parentNode.parentNode.className))) {
                if (/active/.test(self.dropdown.className))
                  self.removeClass(self.dropdown, 'active');
              } else {
                if (!/active/.test(self.dropdown.className))
                  self.addClass(self.dropdown, 'active');
              }
            }
            self.removeClass(activeContent, 'in');
            setTimeout(function() {
              self.removeClass(activeContent, 'active');
              self.addClass(nextContent, 'active');
            }, self.options.duration);
            setTimeout(function() {
              self.addClass(nextContent, 'in');
            }, self.options.duration * 2);
          }
        }, this.addClass = function(el, c) {
          if (el.classList) {
            el.classList.add(c);
          } else {
            el.className += ' ' + c;
          }
        }, this.removeClass = function(el, c) {
          if (el.classList) {
            el.classList.remove(c);
          } else {
            el.className = el.className.replace(c, '').replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
          }
        }, this.getActiveTab = function() {
          var activeTabs = this.tabs.querySelectorAll('.active');
          if (activeTabs.length === 1 && !/dropdown/.test(activeTabs[0].className)) {
            return activeTabs[0];
          } else if (activeTabs.length > 1) {
            return activeTabs[activeTabs.length - 1];
          }
        }, this.getActiveContent = function() {
          var a = this.getActiveTab().getElementsByTagName('A')[0].getAttribute('href').replace('#', '');
          return a && document.getElementById(a);
        };
      }
    };
    var Tabs = document.querySelectorAll("[data-toggle='tab'], [data-toggle='pill']"),
        tbl = Tabs.length,
        i = 0;
    for (i; i < tbl; i++) {
      var tab = Tabs[i],
          options = {};
      options.duration = tab.getAttribute('data-duration') && tab.getAttribute('data-duration') || false;
      new Tab(tab, options);
    }
    return Tab;
  });
  global.define = __define;
  return module.exports;
});

$__System.register('e', ['5', '8', '9', 'c', 'd', 'b', 'f'], function (_export) {
  'use strict';

  var L, $, HTML, i18n, sortByKey, Modal, Tab, PROCESS, loadDCATCatalog, TEMPLATES, html, paneHtml, SearchPane, MediaTypeLabels;

  /** Short label for media types that CKAN doesn't know (otherwise we can use .format) */
  function getDistFormatLabel(dist) {
    var label = dist.format;
    if (!label && dist.mediaType in MediaTypeLabels) {
      label = MediaTypeLabels[dist.mediaType];
    }
    if (!label) {
      label = dist.mediaType || 'unknown';
    }
    return label;
  }

  // maps media types we don't support in analysis/display to short format labels
  return {
    setters: [function (_2) {
      L = _2['default'];
    }, function (_) {
      $ = _.$;
      HTML = _.HTML;
    }, function (_3) {
      i18n = _3.i18n;
      sortByKey = _3.sortByKey;
    }, function (_c) {
      Modal = _c['default'];
    }, function (_d) {
      Tab = _d['default'];
    }, function (_b) {
      PROCESS = _b.PROCESS;
    }, function (_f) {
      loadDCATCatalog = _f.loadDCATCatalog;
    }],
    execute: function () {
      TEMPLATES = {
        'dataset-list-item': '\n  <li class="list-group-item">\n    <h4 class="list-group-item-heading dataset-title"></h4>\n    <p class="dataset-publisher"></p>\n    <p class="dataset-distribution-labels"></p>\n    <p class="dataset-description"></p>\n    <p class="dataset-temporal"><i class="glyphicon glyphicon-time"></i> <span class="dataset-temporal-text"></span></p>\n    <p class="dataset-spatial-geometry"><i class="glyphicon glyphicon-globe"></i> <span class="dataset-spatial-geometry-text"></span></p>\n    <div class="dataset-spatial-minimap"></div>\n    <button type="button" class="btn btn-success dataset-analyse-button" style="display:none">\n      <span class="glyphicon glyphicon-flash" aria-hidden="true"></span> Add to Workspace\n    </button>\n  </li>\n  ',
        'dataset-error': '\n  <li class="list-group-item list-group-item-danger error-item">\n    <h4 class="list-group-item-heading dataset-title">Problem while loading catalogue</h4>\n    <p>Error: <em class="error-message"></em></p>\n    <p>Details:</p>\n    <small><pre class="error-details"></pre></small>\n  </li>\n  '
      };
      html = '\n<div class="modal fade" id="dcatSourceModal" tabindex="-1" role="dialog" aria-labelledby="dcatSourceModalLabel">\n  <div class="modal-dialog modal-lg" role="document">\n    <div class="modal-content">\n      <div class="modal-header">\n        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>\n        <h4 class="modal-title" id="dcatSourceModalLabel">DCAT Source View</h4>\n      </div>\n      <div class="modal-body">\n        <!-- Nav tabs -->\n        <ul class="nav nav-tabs" role="tablist">\n          <li role="presentation" class="active"><a href="#dcat-original" role="tab" data-toggle="tab">Original</a></li>\n          <li role="presentation"><a href="#dcat-framed" role="tab" data-toggle="tab">Framed</a></li>\n          <li role="presentation"><a href="#dcat-frame" role="tab" data-toggle="tab">Frame</a></li>\n        </ul>\n  \n        <!-- Tab panes -->\n        <div class="tab-content">\n          <div role="tabpanel" class="tab-pane active" id="dcat-original">\n            <pre><code class="dcat-original"></code></pre>\n          </div>\n          <div role="tabpanel" class="tab-pane" id="dcat-framed">\n            <pre><code class="dcat-framed"></code></pre>\n          </div>\n          <div role="tabpanel" class="tab-pane" id="dcat-frame">\n            <pre><code class="dcat-frame"></code></pre>\n          </div>\n        </div>\n      </div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>\n      </div>\n    </div>\n  </div>\n</div>\n\n<style>\n.catalog-url-panel {\n  margin-top: 20px;\n}\n.dataset-spatial-minimap {\n  margin-bottom: 10px;\n}\n</style>\n';

      $('body').add(HTML(html));

      paneHtml = function paneHtml() {
        return '\n<h1 class="sidebar-header">Search<div class="sidebar-close"><i class="glyphicon glyphicon-menu-left"></i></div></h1>\n\n<div class="panel panel-default catalog-url-panel">\n  <div class="panel-heading">\n    <h3 class="panel-title">\n      <a href="http://json-ld.org/" title="JSON-LD Data"><img width="32" src="http://json-ld.org/images/json-ld-data-32.png" alt="JSON-LD-logo-32"></a>\n      <span style="vertical-align:middle">\n        <a href="http://www.w3.org/TR/vocab-dcat/">DCAT</a> Catalogue\n      </span>\n      <button type="button" class="btn btn-primary pull-right jsonld-view-button"><i class="glyphicon glyphicon-eye-open"></i> JSON-LD</button>\n    </h3>\n  </div>\n  <div class="panel-body catalog-url-info">\n    <a href="#" class="catalog-url-edit"><i class="glyphicon glyphicon-pencil"></i></a>\n    <a class="catalog-url"></a>\n  </div>\n  <div class="panel-body catalog-url-form" style="display:none">\n    <form>\n      <div class="form-group">\n        <input type="text" class="form-control" placeholder="http://">\n      </div>\n      <button type="submit" class="btn btn-default">Load</button>\n      <button type="button" name="cancel" class="btn btn-default">Cancel</button>\n    </form>\n  </div>\n</div>\n\n<ul class="list-group dataset-list"></ul>\n';
      };

      SearchPane = (function () {
        function SearchPane(sidebar, paneId) {
          babelHelpers.classCallCheck(this, SearchPane);

          this.sidebar = sidebar;
          this.id = paneId;
          this.map = this.sidebar.map;
          this.layerControl = this.sidebar.layerControl;

          $('#' + paneId).fill(HTML(paneHtml()));

          this.catalogue = sidebar.catalogue;
          this.workspace = sidebar.workspace;

          this._registerUIListeners();
          this._registerModelListeners();
        }

        babelHelpers.createClass(SearchPane, [{
          key: '_registerUIListeners',
          value: function _registerUIListeners() {
            var _this = this;

            var el = $('#' + this.id);
            var input = $('input', $('.catalog-url-form', el));
            $('.catalog-url-edit', el).on('click', function () {
              $('.catalog-url-info', el).hide();
              $('.catalog-url-form', el).show();
              input.set('value', _this.url);
            });
            $('form', $('.catalog-url-form', el)).on('submit', function () {
              _this.catalogue.loadFromDCAT(input.get('value')).then(function () {
                $('.catalog-url-info', el).show();
                $('.catalog-url-form', el).hide();
              });
            });
            $('button', $('.catalog-url-form', el)).filter(function (b) {
              return b.name === 'cancel';
            }).on('click', function () {
              $('.catalog-url-info', el).show();
              $('.catalog-url-form', el).hide();
            });
            $('.jsonld-view-button', el).on('click', function () {
              _this._showDCATInfoModal();
            });

            // work-around as bootstrap.native only scans for tabs once, but we add the modal HTML later
            var tabs = document.querySelectorAll("#dcatSourceModal [data-toggle='tab']");
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = tabs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var tab = _step.value;

                new Tab(tab);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
        }, {
          key: '_showDCATInfoModal',
          value: function _showDCATInfoModal() {
            var modalEl = $('#dcatSourceModal');
            new Modal(modalEl[0]).open();

            var asJSON = function asJSON(obj) {
              return JSON.stringify(obj, null, 2);
            };
            loadDCATCatalog(this.catalogue.url).then(function (_ref) {
              var raw = _ref.raw;
              var compacted = _ref.compacted;
              var frame = _ref.frame;

              $('.dcat-original', modalEl).fill(asJSON(raw));
              $('.dcat-framed', modalEl).fill(asJSON(compacted));
              $('.dcat-frame', modalEl).fill(asJSON(frame));
            });
          }
        }, {
          key: '_registerModelListeners',
          value: function _registerModelListeners() {
            var _this2 = this;

            this.catalogue.on('load', function (_ref2) {
              var url = _ref2.url;

              _this2._clearList();
              _this2._addDatasets(_this2.catalogue.datasets);
              _this2._setCatalogueUrl(url);
            });
            this.catalogue.on('loadError', function (_ref3) {
              var url = _ref3.url;
              var error = _ref3.error;

              _this2._clearList();
              _this2._setCatalogueUrl(url);
              var el = HTML(TEMPLATES['dataset-error']);
              $('.error-message', el).fill(error.message);
              var json = JSON.stringify(error, null, 1);
              $('.error-details', el).fill(json);
              $('.dataset-list', '#' + _this2.id).fill(el);
              console.log(error);
            });
          }
        }, {
          key: '_clearList',
          value: function _clearList() {
            $('.dataset-list', '#' + this.id).fill();
          }
        }, {
          key: '_setCatalogueUrl',
          value: function _setCatalogueUrl(url) {
            this.url = url;
            $('.catalog-url', '#' + this.id).set('@href', url).fill(url);
          }
        }, {
          key: '_addDatasets',
          value: function _addDatasets(datasets) {
            var sortKey = arguments.length <= 1 || arguments[1] === undefined ? 'title' : arguments[1];

            datasets = sortByKey(datasets, function (d) {
              return i18n(d[sortKey]);
            });
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = datasets[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var dataset = _step2.value;

                this._addDataset(dataset);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                  _iterator2['return']();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
        }, {
          key: '_addDataset',
          value: function _addDataset(dataset) {
            var _this3 = this;

            var el = HTML(TEMPLATES['dataset-list-item']);
            $('.dataset-list', '#' + this.id).add(el);

            var title = i18n(dataset.title);
            var description = i18n(dataset.description);

            // TODO switch to .landingPage once https://github.com/ckan/ckanext-dcat/issues/50 is fixed
            //let landingPage = dataset.landingPage
            var landingPage = dataset['dcat:landingPage'] || dataset['landingPage'];
            if (landingPage) {
              $('.dataset-title', el).fill(HTML('<a href="' + landingPage + '" target="_new" class="external dataset-title">' + title + '</a>'));
            } else {
              $('.dataset-title', el).fill(title);
            }

            $('.dataset-description', el).fill(description);

            if (dataset.publisher) {
              // TODO switch to .homepage once https://github.com/ckan/ckanext-dcat/issues/50 is fixed
              //let homepage = dataset.publisher.homepage
              var homepage = dataset.publisher['foaf:homepage'];
              if (homepage) {
                $('.dataset-publisher', el).fill(HTML('<a class="external" href="' + homepage + '"><em>' + dataset.publisher.name + '</em></a>'));
              } else {
                $('.dataset-publisher', el).fill(HTML('<em>' + dataset.publisher.name + '</em>'));
              }
            } else {
              $('.dataset-publisher', el).hide();
            }

            if (dataset.temporal) {
              var temporal = dataset.temporal.startDate.substr(0, 10) + ' to ' + dataset.temporal.endDate.substr(0, 10);
              $('.dataset-temporal-text', el).fill(temporal);
            } else {
              $('.dataset-temporal', el).hide();
            }

            var isGlobal = undefined;
            var geom = dataset.spatial && dataset.spatial.geometry ? JSON.parse(dataset.spatial.geometry) : null;
            // check if global bounding box and don't display map in that case
            if (geom) {
              var geomLayer = L.geoJson(geom);
              isGlobal = geomLayer.getBounds().equals([[-90, -180], [90, 180]]);
            }

            if (geom && !isGlobal) {
              (function () {
                $('.dataset-spatial-geometry', el).hide();

                var map = L.map($('.dataset-spatial-minimap', el)[0], {
                  touchZoom: false,
                  scrollWheelZoom: false,
                  doubleClickZoom: false,
                  boxZoom: false,
                  zoomControl: false,
                  attributionControl: false
                }).on('load', function () {
                  L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
                });

                setTimeout(function () {
                  var geomLayer = L.geoJson(geom, {
                    style: function style() {
                      return { color: "#ff7800", weight: 1, clickable: false };
                    }
                  });
                  map.fitBounds(geomLayer.getBounds(), { reset: true });
                  geomLayer.addTo(map);
                }, 1000);
              })();
            } else {
              $('.dataset-spatial-minimap', el).hide();
              if (isGlobal) {
                $('.dataset-spatial-geometry-text', el).fill('global');
              } else {
                $('.dataset-spatial-geometry', el).hide();
              }
            }

            if (dataset.distributions) {
              var formats = dataset.distributions.map(function (d) {
                return {
                  label: getDistFormatLabel(d),
                  mediaType: d.mediaType
                };
              });
              formats.sort(function (a, b) {
                return a.label.toLowerCase().localeCompare(b.label.toLowerCase());
              });

              var seen = new Set();
              var hasProcessableDistributions = false;
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (var _iterator3 = formats[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var format = _step3.value;

                  if (seen.has(format.label)) continue;
                  seen.add(format.label);
                  var formatImpl = this._findFormatImpl(format.mediaType);
                  if (formatImpl) {
                    hasProcessableDistributions = true;
                  }
                  var label = formatImpl ? formatImpl.shortLabel : format.label;

                  var color = formatImpl ? 'success' : 'default';
                  var glyph = formatImpl && formatImpl.actionClasses.some(function (cl) {
                    return cl.type === PROCESS;
                  }) ? '<span class="glyphicon glyphicon-flash"></span> ' : '';
                  var _html = undefined;
                  if (formatImpl) {
                    _html = HTML('<span class="label label-success">' + glyph + label + '</span> ');
                  } else {
                    _html = HTML('<span class="label label-' + color + '">' + label + '</span> ');
                  }
                  $('.dataset-distribution-labels', el).add(_html);
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                    _iterator3['return']();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }

              if (hasProcessableDistributions) {
                $('.dataset-analyse-button', el).show();
                $('.dataset-analyse-button', el).on('click', function () {
                  _this3.workspace.addDataset(dataset);
                });
              }
            }
          }
        }, {
          key: '_findFormatImpl',
          value: function _findFormatImpl(mediaType) {
            // TODO formats should be directly injected
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = this.sidebar.app.formats[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var format = _step4.value;

                if (format.supports(mediaType)) {
                  return format;
                }
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                  _iterator4['return']();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }
          }
        }]);
        return SearchPane;
      })();

      _export('default', SearchPane);

      MediaTypeLabels = {
        'application/x-netcdf': 'netCDF'
      };
    }
  };
});

$__System.register("10", [], function() { return { setters: [], execute: function() {} } });

$__System.registerDynamic("11", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    L.Control.Sidebar = L.Control.extend({
      includes: L.Mixin.Events,
      options: {position: 'left'},
      initialize: function(id, options) {
        var i,
            child;
        L.setOptions(this, options);
        this._sidebar = L.DomUtil.get(id);
        L.DomUtil.addClass(this._sidebar, 'sidebar-' + this.options.position);
        if (L.Browser.touch)
          L.DomUtil.addClass(this._sidebar, 'leaflet-touch');
        for (i = this._sidebar.children.length - 1; i >= 0; i--) {
          child = this._sidebar.children[i];
          if (child.tagName == 'DIV' && L.DomUtil.hasClass(child, 'sidebar-content'))
            this._container = child;
        }
        this._tabitems = this._sidebar.querySelectorAll('ul.sidebar-tabs > li, .sidebar-tabs > ul > li');
        for (i = this._tabitems.length - 1; i >= 0; i--) {
          this._tabitems[i]._sidebar = this;
        }
        this._panes = [];
        this._closeButtons = [];
        for (i = this._container.children.length - 1; i >= 0; i--) {
          child = this._container.children[i];
          if (child.tagName == 'DIV' && L.DomUtil.hasClass(child, 'sidebar-pane')) {
            this._panes.push(child);
            var closeButtons = child.querySelectorAll('.sidebar-close');
            for (var j = 0,
                len = closeButtons.length; j < len; j++)
              this._closeButtons.push(closeButtons[j]);
          }
        }
      },
      addTo: function(map) {
        var i,
            child;
        this._map = map;
        for (i = this._tabitems.length - 1; i >= 0; i--) {
          child = this._tabitems[i];
          L.DomEvent.on(child.querySelector('a'), 'click', L.DomEvent.preventDefault).on(child.querySelector('a'), 'click', this._onClick, child);
        }
        for (i = this._closeButtons.length - 1; i >= 0; i--) {
          child = this._closeButtons[i];
          L.DomEvent.on(child, 'click', this._onCloseClick, this);
        }
        return this;
      },
      removeFrom: function(map) {
        var i,
            child;
        this._map = null;
        for (i = this._tabitems.length - 1; i >= 0; i--) {
          child = this._tabitems[i];
          L.DomEvent.off(child.querySelector('a'), 'click', this._onClick);
        }
        for (i = this._closeButtons.length - 1; i >= 0; i--) {
          child = this._closeButtons[i];
          L.DomEvent.off(child, 'click', this._onCloseClick, this);
        }
        return this;
      },
      open: function(id) {
        var i,
            child;
        for (i = this._panes.length - 1; i >= 0; i--) {
          child = this._panes[i];
          if (child.id == id)
            L.DomUtil.addClass(child, 'active');
          else if (L.DomUtil.hasClass(child, 'active'))
            L.DomUtil.removeClass(child, 'active');
        }
        for (i = this._tabitems.length - 1; i >= 0; i--) {
          child = this._tabitems[i];
          if (child.querySelector('a').hash == '#' + id)
            L.DomUtil.addClass(child, 'active');
          else if (L.DomUtil.hasClass(child, 'active'))
            L.DomUtil.removeClass(child, 'active');
        }
        this.fire('content', {id: id});
        if (L.DomUtil.hasClass(this._sidebar, 'collapsed')) {
          this.fire('opening');
          L.DomUtil.removeClass(this._sidebar, 'collapsed');
        }
        return this;
      },
      close: function() {
        for (var i = this._tabitems.length - 1; i >= 0; i--) {
          var child = this._tabitems[i];
          if (L.DomUtil.hasClass(child, 'active'))
            L.DomUtil.removeClass(child, 'active');
        }
        if (!L.DomUtil.hasClass(this._sidebar, 'collapsed')) {
          this.fire('closing');
          L.DomUtil.addClass(this._sidebar, 'collapsed');
        }
        return this;
      },
      _onClick: function() {
        if (L.DomUtil.hasClass(this, 'active'))
          this._sidebar.close();
        else if (!L.DomUtil.hasClass(this, 'disabled'))
          this._sidebar.open(this.querySelector('a').hash.slice(1));
      },
      _onCloseClick: function() {
        this.close();
      }
    });
    L.control.sidebar = function(id, options) {
      return new L.Control.Sidebar(id, options);
    };
  })();
  return _retrieveGlobal();
});

$__System.register('12', ['5', '7', '8', '10', '11', '13', 'e'], function (_export) {
  'use strict';

  var L, WorkspacePane, $, HTML, SearchPane, sidebarHtml, Sidebar;
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_6) {
      WorkspacePane = _6['default'];
    }, function (_5) {
      $ = _5.$;
      HTML = _5.HTML;
    }, function (_3) {}, function (_2) {}, function (_4) {}, function (_e) {
      SearchPane = _e['default'];
    }],
    execute: function () {
      sidebarHtml = function sidebarHtml(sidebarId, searchPaneId, workspacePaneId) {
        return '\n<div id="' + sidebarId + '" class="sidebar collapsed">\n  <!-- Nav tabs -->\n  <div class="sidebar-tabs">\n      <ul role="tablist">\n          <li><a href="#' + searchPaneId + '" role="tab" class="sidebar-tab"><i class="glyphicon glyphicon-search"></i></a></li>\n          <li><a href="#' + workspacePaneId + '" role="tab" class="sidebar-tab"><i class="glyphicon glyphicon-flash"></i></a></li>\n      </ul>\n  </div>\n  \n  <!-- Tab panes -->\n  <div class="sidebar-content">\n      <div class="sidebar-pane" id="' + searchPaneId + '"></div>\n      <div class="sidebar-pane" id="' + workspacePaneId + '"></div>\n  </div>\n</div>\n<style>\n.error-item {\n  word-wrap: break-word;\n}\n';
      };

      Sidebar = (function () {
        function Sidebar(map) {
          var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

          var app = _ref.app;
          var _ref$sidebarId = _ref.sidebarId;
          var sidebarId = _ref$sidebarId === undefined ? 'sidebar' : _ref$sidebarId;
          var _ref$searchPaneId = _ref.searchPaneId;
          var searchPaneId = _ref$searchPaneId === undefined ? 'search' : _ref$searchPaneId;
          var _ref$workspacePaneId = _ref.workspacePaneId;
          var workspacePaneId = _ref$workspacePaneId === undefined ? 'workspace' : _ref$workspacePaneId;
          var _ref$layerControl = _ref.layerControl;
          var layerControl = _ref$layerControl === undefined ? null : _ref$layerControl;
          babelHelpers.classCallCheck(this, Sidebar);

          this.map = map;
          this.app = app;
          this.catalogue = app.catalogue;
          this.workspace = app.workspace;
          this.id = sidebarId;
          this.layerControl = layerControl;
          // has to come before the map div, otherwise it overlays zoom controls
          $('body').addFront(HTML(sidebarHtml(sidebarId, searchPaneId, workspacePaneId)));

          $('#' + map.getContainer().id).set('+sidebar-map');

          this.panes = {
            Search: new SearchPane(this, searchPaneId),
            Workspace: new WorkspacePane(this, workspacePaneId)
          };

          this.control = L.control.sidebar(sidebarId).addTo(map);
        }

        babelHelpers.createClass(Sidebar, [{
          key: 'open',
          value: function open(pane) {
            this.control.open(pane.id);
          }
        }]);
        return Sidebar;
      })();

      _export('default', Sidebar);
    }
  };
});

$__System.register('14', ['b'], function (_export) {
  'use strict';

  var Action, EXTERNAL_LINK, GoToSource;
  return {
    setters: [function (_b) {
      Action = _b['default'];
      EXTERNAL_LINK = _b.EXTERNAL_LINK;
    }],
    execute: function () {
      GoToSource = (function (_Action) {
        babelHelpers.inherits(GoToSource, _Action);

        function GoToSource(data, context) {
          babelHelpers.classCallCheck(this, GoToSource);

          babelHelpers.get(Object.getPrototypeOf(GoToSource.prototype), 'constructor', this).call(this, context);

          this.icon = '<span class="glyphicon glyphicon-link"></span>';
          this.label = 'Source';
        }

        babelHelpers.createClass(GoToSource, [{
          key: 'run',
          value: function run() {
            return this.context.distribution.url;
          }
        }, {
          key: 'isSupported',
          get: function get() {
            return this.context.distribution.url;
          }
        }]);
        return GoToSource;
      })(Action);

      _export('default', GoToSource);

      GoToSource.type = EXTERNAL_LINK;
    }
  };
});

$__System.register('15', ['5', '8'], function (_export) {
  'use strict';

  var L, $, HTML, DEFAULT_TEMPLATE_ID, DEFAULT_TEMPLATE, ImageLegend;
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_2) {
      $ = _2.$;
      HTML = _2.HTML;
    }],
    execute: function () {
      DEFAULT_TEMPLATE_ID = 'template-image-legend';
      DEFAULT_TEMPLATE = '\n<template id="' + DEFAULT_TEMPLATE_ID + '">\n  <div class="info legend image-legend">\n    <div class="legend-title">\n      <strong class="legend-title-text"></strong>\n      <a href="#"><span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span></a>\n    </div>\n    <img alt="Legend" />\n  </div>\n</template>\n<style>\n.legend {\n  color: #555;\n}\n.legend-title {\n  margin-bottom:3px;\n}\n</style>\n';

      ImageLegend = (function (_L$Control) {
        babelHelpers.inherits(ImageLegend, _L$Control);

        function ImageLegend(url, options) {
          babelHelpers.classCallCheck(this, ImageLegend);

          babelHelpers.get(Object.getPrototypeOf(ImageLegend.prototype), 'constructor', this).call(this, options.position ? { position: options.position } : {});
          this.url = url;
          this.title = options.title;
          this.layer = options.layer;
          this.id = options.id || DEFAULT_TEMPLATE_ID;

          if (!options.id && document.getElementById(DEFAULT_TEMPLATE_ID) === null) {
            $('body').add(HTML(DEFAULT_TEMPLATE));
          }
        }

        babelHelpers.createClass(ImageLegend, [{
          key: 'onRemove',
          value: function onRemove(map) {
            if (this.layer) {
              map.off('layerremove', this._remove);
            }
          }
        }, {
          key: 'onAdd',
          value: function onAdd(map) {
            var _this = this;

            if (this.layer) {
              this._remove = function (e) {
                if (e.layer !== _this.layer) return;
                _this.removeFrom(map);
              };
              map.on('layerremove', this._remove);
            }

            var el = document.importNode($('#' + this.id)[0].content, true).children[0];
            $('img', el).set('@src', this.url);
            if (this.title) {
              $('.legend-title-text', el).fill(this.title);
            } else {
              $('.legend-title', el).hide();
            }

            $('a', el).on('click', function () {
              var img = $('img', el);
              if (img.get('$$show')) {
                img.hide();
                $('.glyphicon', el).set('+glyphicon-menu-down -glyphicon-menu-up');
              } else {
                img.show();
                $('.glyphicon', el).set('-glyphicon-menu-down +glyphicon-menu-up');
              }
            });

            return el;
          }
        }]);
        return ImageLegend;
      })(L.Control);

      _export('default', ImageLegend);
    }
  };
});

$__System.register('16', ['5', '9', '15', 'b'], function (_export) {
  'use strict';

  var L, i18n, ImageLegend, Action, VIEW, WMSView;

  function getLegendUrl(wmsEndpoint, layer) {
    return wmsEndpoint + '?service=wms&version=1.1.1&request=GetLegendGraphic&format=image/png&transparent=true&layer=' + layer;
  }
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_2) {
      i18n = _2.i18n;
    }, function (_3) {
      ImageLegend = _3['default'];
    }, function (_b) {
      Action = _b['default'];
      VIEW = _b.VIEW;
    }],
    execute: function () {
      WMSView = (function (_Action) {
        babelHelpers.inherits(WMSView, _Action);

        function WMSView(data, context) {
          babelHelpers.classCallCheck(this, WMSView);

          babelHelpers.get(Object.getPrototypeOf(WMSView.prototype), 'constructor', this).call(this, context);
          this.data = data;

          this._setHidden();

          this.layers = [];
        }

        babelHelpers.createClass(WMSView, [{
          key: '_setVisible',
          value: function _setVisible() {
            this.visible = true;
            this.label = 'Hide';
            this.icon = '<span class="glyphicon glyphicon-eye-close"></span>';
            this.fire('labelChange');
          }
        }, {
          key: '_setHidden',
          value: function _setHidden() {
            this.visible = false;
            this.label = 'View';
            this.icon = '<span class="glyphicon glyphicon-eye-open"></span>';
            this.fire('labelChange');
          }
        }, {
          key: 'run',
          value: function run() {
            var _this = this;

            if (this.visible) {
              this.remove();
              this._setHidden();
              return;
            }

            this._setVisible();

            var map = this.context.map;

            var wmsLayers = this.data.layers;
            // FIXME this is not necessarily the endpoint url
            //      -> read the endpoint url directly from the GetCapabilities document
            var url = this.data.url;

            var datasetTitle = i18n(this.context.dataset.title);

            var firstDisplayed = false;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              var _loop = function () {
                var wmsLayer = _step.value;

                var layer = L.tileLayer.wms(url, {
                  layers: wmsLayer.name,
                  format: 'image/png',
                  transparent: true
                }).on('loading', function () {
                  return _this.fire('loading');
                }).on('load', function () {
                  return _this.fire('load');
                });

                // In leaflet 1.0 every layer will have add/remove events, this is a workaround
                map.on('layeradd', function (e) {
                  if (e.layer !== layer) return;
                  var legendUrl = getLegendUrl(url, wmsLayer.name);
                  new ImageLegend(legendUrl, { layer: e.layer, title: wmsLayer.title }).addTo(map);
                });
                if (!firstDisplayed) {
                  firstDisplayed = true;
                  layer.addTo(map);
                }
                map.layerControl.addOverlay(layer, '<span class="label label-success">WMS</span> ' + wmsLayer.title, { groupName: datasetTitle, expanded: true });
                _this.layers.push(layer);
              };

              for (var _iterator = wmsLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                _loop();
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
        }, {
          key: 'remove',
          value: function remove() {
            var map = this.context.map;

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var layer = _step2.value;

                if (map.hasLayer(layer)) {
                  map.removeLayer(layer);
                }
                map.layerControl.removeLayer(layer);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                  _iterator2['return']();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }

            this.layers = [];
          }
        }, {
          key: 'isSupported',
          get: function get() {
            return true;
          }
        }]);
        return WMSView;
      })(Action);

      _export('default', WMSView);

      WMSView.type = VIEW;
    }
  };
});

$__System.register('17', ['5', '9', 'b'], function (_export) {
  'use strict';

  var L, i18n, Action, VIEW, GeoJSONView;
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_2) {
      i18n = _2.i18n;
    }, function (_b) {
      Action = _b['default'];
      VIEW = _b.VIEW;
    }],
    execute: function () {
      GeoJSONView = (function (_Action) {
        babelHelpers.inherits(GeoJSONView, _Action);

        function GeoJSONView(data, context) {
          babelHelpers.classCallCheck(this, GeoJSONView);

          babelHelpers.get(Object.getPrototypeOf(GeoJSONView.prototype), 'constructor', this).call(this, context);
          this.data = data;

          this._setHidden();

          this.layers = [];
        }

        babelHelpers.createClass(GeoJSONView, [{
          key: '_setVisible',
          value: function _setVisible() {
            this.visible = true;
            this.label = 'Hide';
            this.icon = '<span class="glyphicon glyphicon-eye-close"></span>';
            this.fire('labelChange');
          }
        }, {
          key: '_setHidden',
          value: function _setHidden() {
            this.visible = false;
            this.label = 'View';
            this.icon = '<span class="glyphicon glyphicon-eye-open"></span>';
            this.fire('labelChange');
          }
        }, {
          key: 'run',
          value: function run() {
            if (this.visible) {
              this.remove();
              this._setHidden();
              return;
            }

            this._setVisible();

            var map = this.context.map;

            var color = '#CC2222';
            var defaultStyle = {
              color: color,
              weight: 2,
              opacity: 0.6,
              fillOpacity: 0,
              fillColor: color
            };

            var highlightStyle = {
              color: color,
              weight: 3,
              opacity: 0.6,
              fillOpacity: 0.65,
              fillColor: color
            };

            var mouseoverFn = function mouseoverFn(e) {
              e.target.setStyle(highlightStyle);
            };

            var mouseoutFn = function mouseoutFn(e) {
              e.target.setStyle(defaultStyle);
            };

            var layer = L.geoJson(this.data, {
              pointToLayer: function pointToLayer(feature, latlng) {
                return L.circleMarker(latlng);
              },
              onEachFeature: function onEachFeature(feature, layer) {
                layer.setStyle(defaultStyle);
                layer.on('mouseover', mouseoverFn);
                layer.on('mouseout', mouseoutFn);
                layer.bindPopup('<pre><code class="code-nowrap">' + JSON.stringify(feature.properties, null, 4) + '</code></pre>', { maxWidth: 400, maxHeight: 300 });
              }
            }).addTo(map);

            var datasetTitle = i18n(this.context.dataset.title);
            var distTitle = i18n(this.context.distribution.title);

            var layerName = '<span class="label label-success">GeoJSON</span> ' + distTitle;
            map.layerControl.addOverlay(layer, layerName, { groupName: datasetTitle, expanded: true });
            this.layers.push(layer);
          }
        }, {
          key: 'remove',
          value: function remove() {
            var map = this.context.map;

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = this.layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var layer = _step.value;

                if (map.hasLayer(layer)) {
                  map.removeLayer(layer);
                }
                map.layerControl.removeLayer(layer);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            this.layers = [];
          }
        }, {
          key: 'isSupported',
          get: function get() {
            return true;
          }
        }]);
        return GeoJSONView;
      })(Action);

      _export('default', GeoJSONView);

      GeoJSONView.type = VIEW;
    }
  };
});

$__System.register('18', ['5', '8'], function (_export) {
  'use strict';

  var L, $, HTML, TEMPLATE, ButtonControl;
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_2) {
      $ = _2.$;
      HTML = _2.HTML;
    }],
    execute: function () {
      TEMPLATE = '<div class="info" style="clear:none">\n  <button></button>\n</div>';

      ButtonControl = (function (_L$Control) {
        babelHelpers.inherits(ButtonControl, _L$Control);

        function ButtonControl(options) {
          babelHelpers.classCallCheck(this, ButtonControl);

          babelHelpers.get(Object.getPrototypeOf(ButtonControl.prototype), 'constructor', this).call(this, options.position ? { position: options.position } : { position: 'topleft' });
          this._title = options.title;
        }

        babelHelpers.createClass(ButtonControl, [{
          key: 'onAdd',
          value: function onAdd(map) {
            var _this = this;

            var el = HTML(TEMPLATE)[0];
            L.DomEvent.disableClickPropagation(el);

            $('button', el).fill(this._title).on('click', function () {
              return _this.fire('click');
            });

            return el;
          }
        }]);
        return ButtonControl;
      })(L.Control);

      ButtonControl.include(L.Mixin.Events);

      //work-around for Babel bug, otherwise ButtonControl cannot be referenced here

      _export('default', ButtonControl);
    }
  };
});

$__System.register('19', ['8', '9', '18', '20', '1b', '1c', '1d', '1e', '1f', 'c', '1a', 'b'], function (_export) {
  'use strict';

  var $, $$, HTML, i18n, COVJSON_PREFIX, ButtonControl, unitUtils, indexOfNearest, indicesOfNearest, referencingUtil, COVJSON_GRID, COVJSON_POINT, COVJSON_VERTICALPROFILE, TimeAxis, Dropdown, Modal, CoverageData, Action, VIEW, PROCESS, PointCollection, ProfileCollection, TYPE, html, TEMPLATES, CoverageModelObservationCompare;

  /**
   * Prepares coverage data for comparison, i.e. assigns the semantic type (model or observations)
   * and also extracts grids from 1-element collections.
   * If the coverage data is not suitable for intercomparison, then undefined is returned.
   */
  function getCovData(data) {
    // either a Grid (=model) or a collection of Point or VerticalProfile coverages (=observations)
    // also, there must be non-categorical parameters
    var res = undefined;
    if (data.coverages) {
      if (data.domainType === COVJSON_POINT || data.domainType === COVJSON_VERTICALPROFILE) {
        res = { type: TYPE.OBSERVATIONS, data: data };
      }
      // check if Grid in a 1-element collection
      if (data.coverages.length === 1 && data.coverages[0].domainType === COVJSON_GRID) {
        res = { type: TYPE.MODEL, data: data.coverages[0] };
      }
    } else if (data.domainType === COVJSON_GRID) {
      res = { type: TYPE.MODEL, data: data };
    }
    if (res && getNonCategoricalParams(res.data).length === 0) {
      res = undefined;
    }
    return res;
  }

  function getNonCategoricalParams(cov) {
    var params = [].concat(babelHelpers.toConsumableArray(cov.parameters.values()));
    return params.filter(function (param) {
      return !param.observedProperty.categories;
    });
  }

  // TODO move to reusable module
  function subsetGridToPointsSimple(gridCov, points) {
    return Promise.all(points.map(function (_ref5) {
      var _ref52 = babelHelpers.slicedToArray(_ref5, 2);

      var x = _ref52[0];
      var y = _ref52[1];

      // we want exactly the grid cell in which the point is locatedlink:
      return gridCov.subsetByValue({ x: { start: x, stop: x }, y: { start: y, stop: y } }, { eagerload: true });
    }));
  }

  /**
   * Returns a subsetted XY grid which fits the given x and y extent.
   */
  function subsetHorizontalGrid(xVals, yVals, xExtent, yExtent) {
    var _xExtent = babelHelpers.slicedToArray(xExtent, 2);

    var xMin = _xExtent[0];
    var xMax = _xExtent[1];

    var _yExtent = babelHelpers.slicedToArray(yExtent, 2);

    var yMin = _yExtent[0];
    var yMax = _yExtent[1];

    // snap xMin, xMax etc to grid
    xMin = xVals[indexOfNearest(xVals, xMin)];
    xMax = xVals[indexOfNearest(xVals, xMax)];
    yMin = yVals[indexOfNearest(yVals, yMin)];
    yMax = yVals[indexOfNearest(yVals, yMax)];

    // determine resolution of grid (assumes a regular grid)
    // TODO support non-regular grids (rectilinear)
    var dx = Math.abs(xVals[0] - xVals[1]);
    var dy = Math.abs(yVals[0] - yVals[1]);

    var nx = Math.round((xMax - xMin) / dx + 1);
    var ny = Math.round((yMax - yMin) / dy + 1);
    var arr = new Uint8Array(nx * ny);

    // convenience functions
    var idx = function idx(ix, iy) {
      return nx * iy + ix;
    };
    var xv2i = function xv2i(x) {
      return Math.round((x - xMin) / dx);
    };
    var yv2i = function yv2i(y) {
      return Math.round((y - yMin) / dy);
    };
    var vidx = function vidx(x, y) {
      return idx(xv2i(x), yv2i(y));
    };

    return {
      nx: nx, ny: ny,
      dx: dx, dy: dy,
      get: function get(ix, iy) {
        return arr[idx(ix, iy)];
      },
      set: function set(ix, iy, v) {
        return arr[idx(ix, iy)] = v;
      },
      vset: function vset(x, y, v) {
        return arr[vidx(x, y)] = v;
      },
      ix2v: function ix2v(ix) {
        return xMin + ix * dx;
      },
      iy2v: function iy2v(iy) {
        return yMin + iy * dy;
      }
    };
  }

  /*
  // debug function
  function print2D (matrix) {
    for (let iy=0; iy < matrix.ny; iy++) {
      let line = ''
      for (let ix=0; ix < matrix.nx; ix++) {
        line += matrix.get(ix,iy) + ' '
      }
      console.log(line)
    }
  }
  
  // debug function
  function print2DCoords (matrix) {
    console.log('x:')
    let line = ''
    for (let ix=0; ix < matrix.nx; ix++) {
      line += matrix.ix2v(ix) + ' '
    }
    console.log(line)
    console.log('y:')
    for (let iy=0; iy < matrix.ny; iy++) {
      console.log(matrix.iy2v(iy))
    }
  }
  */

  // TODO move to reusable module
  function subsetGridToPointsConnected(gridCov, points) {
    // try to find rectangles in order to limit the number of grid subset queries

    if (points.length === 0) {
      return Promise.resolve([]);
    }

    var X = 'x';
    var Y = 'y';

    // TODO handle points outside grid domain

    var xs = points.map(function (_ref6) {
      var _ref62 = babelHelpers.slicedToArray(_ref6, 1);

      var x = _ref62[0];
      return x;
    });
    var ys = points.map(function (_ref7) {
      var _ref72 = babelHelpers.slicedToArray(_ref7, 2);

      var y = _ref72[1];
      return y;
    });
    var xExtent = [Math.min.apply(Math, babelHelpers.toConsumableArray(xs)), Math.max.apply(Math, babelHelpers.toConsumableArray(xs))];
    var yExtent = [Math.min.apply(Math, babelHelpers.toConsumableArray(ys)), Math.max.apply(Math, babelHelpers.toConsumableArray(ys))];

    return gridCov.loadDomain().then(function (domain) {
      var hits = subsetHorizontalGrid(domain.axes.get(X).values, domain.axes.get(Y).values, xExtent, yExtent);

      // all points are placed into a 2D hit matrix
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = points[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _step3$value = babelHelpers.slicedToArray(_step3.value, 2);

          var x = _step3$value[0];
          var y = _step3$value[1];

          hits.vset(x, y, 1);
        }

        // find hit rectangles, as big as possible
        // an approximative algorithm is used, picking the first rectangles it finds
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3['return']) {
            _iterator3['return']();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var rectangles = findRectangles(hits);

      // some debug stats
      var sizes = rectangles.map(function (_ref8) {
        var _ref82 = babelHelpers.slicedToArray(_ref8, 4);

        var ix1 = _ref82[0];
        var iy1 = _ref82[1];
        var ix2 = _ref82[2];
        var iy2 = _ref82[3];
        return (ix2 - ix1 + 1) * (iy2 - iy1 + 1);
      });
      var connected = sizes.filter(function (s) {
        return s > 1;
      }).length;
      console.log('grid subset queries total: ' + rectangles.length + ', connected: ' + connected);

      // convert to axis values
      var rectanglesCenter = rectangles.map(function (_ref9) {
        var _ref92 = babelHelpers.slicedToArray(_ref9, 4);

        var ix1 = _ref92[0];
        var iy1 = _ref92[1];
        var ix2 = _ref92[2];
        var iy2 = _ref92[3];
        return [hits.ix2v(ix1), hits.iy2v(iy1), hits.ix2v(ix2), hits.iy2v(iy2)];
      });

      var dx = hits.dx;
      var dy = hits.dy;

      var rectanglesBounds = rectanglesCenter.map(function (_ref10) {
        var _ref102 = babelHelpers.slicedToArray(_ref10, 4);

        var x1 = _ref102[0];
        var y1 = _ref102[1];
        var x2 = _ref102[2];
        var y2 = _ref102[3];
        return [x1 - dx / 2, y1 - dy / 2, x2 + dx / 2, y2 + dy / 2];
      });

      // map to subsets
      // the center coordinates are used to avoid fetching neighboring cells
      var rectSubsetPromises = rectanglesCenter.map(function (_ref11) {
        var _ref112 = babelHelpers.slicedToArray(_ref11, 4);

        var x1 = _ref112[0];
        var y1 = _ref112[1];
        var x2 = _ref112[2];
        var y2 = _ref112[3];
        return gridCov.subsetByValue({ x: { start: x1, stop: x2 }, y: { start: y1, stop: y2 } }, { eagerload: true });
      });

      return Promise.all(rectSubsetPromises).then(function (rectSubsets) {
        var pointSubsetPromises = [];
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = points[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _step4$value = babelHelpers.slicedToArray(_step4.value, 2);

            var x = _step4$value[0];
            var y = _step4$value[1];

            var rectSubset = undefined;
            for (var i = 0; i < rectangles.length; i++) {
              var _rectanglesBounds$i = babelHelpers.slicedToArray(rectanglesBounds[i], 4);

              var x1 = _rectanglesBounds$i[0];
              var y1 = _rectanglesBounds$i[1];
              var x2 = _rectanglesBounds$i[2];
              var y2 = _rectanglesBounds$i[3];

              if (x1 <= x && x <= x2 && y1 <= y && y <= y2) {
                rectSubset = rectSubsets[i];
                break;
              }
            }
            if (!rectSubset) {
              throw new Error('bug');
            }
            // the following subsetting will not do a network request since all data has been eagerly loaded already
            pointSubsetPromises.push(rectSubset.subsetByValue({ x: { start: x, stop: x }, y: { start: y, stop: y } }));
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4['return']) {
              _iterator4['return']();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        return Promise.all(pointSubsetPromises);
      });
    });
  }

  /**
   * Returns as-big-as-possible rectangles of 1's in a 2D matrix.
   * 
   * Note: The matrix gets modified in-place during processing.
   * 
   * TODO move to reusable module
   * 
   * @param {object} matrix An object with get(ix,iy), set(ix,iy,v) functions and nx, ny properties
   * @returns {array<[x1,y1,x2,y2]>} rectangles with top-left and bottom-right index coordinates
   */
  function findRectangles(matrix) {
    /* matrix:
     * 1 1 1 0 1
     * 1 1 0 1 1
     * 0 0 1 1 1
     */

    var nx = matrix.nx;
    var ny = matrix.ny;

    // find hit rectangles, as big as possible
    // an approximative algorithm is used, picking the first rectangles it finds

    // pre-compute vertical lengths of consecutive 1s
    for (var iy = ny - 2; iy >= 0; iy--) {
      for (var ix = 0; ix < nx; ix++) {
        var val = matrix.get(ix, iy);
        if (val > 0) {
          matrix.set(ix, iy, val + matrix.get(ix, iy + 1));
        }
      }
    }

    /* matrix:
     * 2 2 1 0 3
     * 1 1 0 2 2
     * 0 0 1 1 1
     */

    // now iterate through each row and if v > 0 then expand to the right until value <  v
    // and mark found rectangles as 0 in matrix matrix
    var rectangles = [];

    for (var iy = 0; iy < ny; iy++) {
      for (var ix = 0; ix < nx; ix++) {
        // any hit here?
        var v = matrix.get(ix, iy);
        if (v === 0) {
          continue;
        }
        // expand rectangle to the right keeping initial height
        var ix2 = ix + 1;
        while (ix2 < nx && matrix.get(ix2, iy) >= v) {
          ix2++;
        }
        ix2 -= 1;
        var iy2 = iy + v - 1;
        // add the found rectangle
        rectangles.push([ix, iy, ix2, iy2]);
        // clear rectangle area (skip over first row as we don't look at it again)
        for (var iy3 = iy + 1; iy3 <= iy2; iy3++) {
          for (var ix3 = ix; ix3 <= ix2; ix3++) {
            matrix.set(ix3, iy3, 0);
          }
        }
        // skip over rectangle
        ix = ix2;
      }
    }

    return rectangles;
  }

  /**
   * Load and return all coverages of all pages of the collection.
   * 
   * TODO move to reusable module
   * 
   * @param {CoverageCollection} collection The first page of the collection.
   * @param {object} [options] Options to use when loading pages.
   * @returns {Promise<Array>} Promise succeeding with an array of coverage objects.
   */
  function loadAllCoverages(collection, options) {
    var hasNext = collection.paging && collection.paging.next;
    var nextPage = hasNext ? collection.paging.next.load(options) : Promise.resolve();
    var covs = collection.coverages;
    return nextPage.then(function (nextPageColl) {
      if (nextPageColl) {
        return loadAllCoverages(nextPageColl, options).then(function (nextCovs) {
          return covs.concat(nextCovs);
        });
      } else {
        return covs;
      }
    });
  }

  /**
   * Returns a derived collection where coverages are organized into tile pages.
   * Each page corresponds to a tile.
   * A tile will contain all coverages which intersect that tile, meaning that
   * coverages may appear in multiple tiles if they have an extent greater than
   * a point. 
   *  
   * TODO move to reusable module
   * 
   * @param {CoverageCollection} coll A coverage collection with coverages having x/y components.
   * @param {array<[xmin,ymin,xmax,ymax]>} tileExtents A non-empty array of tile extents in domain coordinates.
   * @param {object} [queryOptions] Options to use when filtering or paging through the collection (e.g. ``{eagerload: true}``).
   * @return {Promise<CoverageCollection>} A Promise succeeding with the tiled coverage collection.
   */
  function getTiledCollection(coll, tileExtents, queryOptions) {
    function getCollectionTile(i) {
      var _tileExtents$i = babelHelpers.slicedToArray(tileExtents[i], 4);

      var xmin = _tileExtents$i[0];
      var ymin = _tileExtents$i[1];
      var xmax = _tileExtents$i[2];
      var ymax = _tileExtents$i[3];

      var filter = {
        x: { start: xmin, stop: xmax },
        y: { start: ymin, stop: ymax }
      };
      return coll.query().filter(filter).execute(queryOptions).then(function (filteredColl) {
        return loadAllCoverages(filteredColl, queryOptions);
      }).then(function (covs) {
        var tiledColl = {
          id: coll.id,
          domainType: coll.domainType,
          parameters: coll.parameters,
          coverages: covs
          // we don't implement .query() for now since we don't need it
        };
        if (i < tileExtents.length - 1) {
          tiledColl.paging = {
            next: {
              load: function load(options) {
                return getCollectionTile(i + 1);
              }
            }
          };
        }
        return tiledColl;
      });
    }
    return getCollectionTile(0);
  }

  /**
   * Return tile extents for use in getTiledCollection().
   * 
   * @param {array} xExtent
   * @param {array} yExtent
   * @param {number} nx number of tiles along x axis
   * @param {number} ny number of tiles along y axis
   * @returns {Array<[xmin,ymin,xmax,ymax]>} of size nx*ny
   */
  function getTileExtents(xExtent, yExtent, nx, ny) {
    /** Lazy version of numpy's linspace function. */
    function linspace(start, stop, num) {
      var step = (stop - start) / (num - 1);
      return function (i) {
        return start + i * step;
      };
    }
    var xs = linspace(xExtent[0], xExtent[1], nx);
    var ys = linspace(yExtent[0], yExtent[1], ny);
    var extents = [];
    for (var i = 0; i < nx - 1; i++) {
      for (var j = 0; j < ny - 1; j++) {
        var xmin = xs(i);
        var xmax = xs(i + 1);
        var ymin = ys(j);
        var ymax = ys(j + 1);

        extents.push([xmin, ymin, xmax, ymax]);
      }
    }
    return extents;
  }

  function deriveIntercomparisonStatistics(modelGridCoverage, insituCoverageCollection, modelParamKey, insituParamKey) {

    // Basic requirements:
    // - the measurement units of both input parameters must be equal
    // - the model and insitu axes must have the same meaning and CRS
    // If any of that is not the case, then the input has to be transformed before-hand.

    // The following combinations for the Z axes are possible:
    // - the model has a fixed Z axis and the insitu coverages have a fixed or varying Z axis
    // - the model has a varying Z axis and the insitu coverages have a fixed or varying Z axis
    // - the model has a fixed Z axis and the insitu coverages have no Z axis
    // - the model has no Z axis and the insitu coverages have a fixed or no Z axis

    // The model grid must have:
    // - X and Y axes

    // Both inputs can have other fixed axes (like T), but those will be discarded in the result.

    // If one input has a fixed, the other a varying Z axis, then there are multiple choices
    // for matching up Z values. In that case the closest Z value is chosen and the result
    // is the absolute difference between both measurement values.

    // If both inputs have varying Z axes, then the insitu Z steps are used as base for extracting
    // a virtual vertical profile from the model grid (picking the closest slices from the grid).
    // In that case, the resulting statistics is the standard deviation (RMSE).

    // If neither of the inputs has a Z axis, then the resulting statistics is the absolute difference
    // between both measurement values, equal to the case when one input has a fixed Z axis.

    // The above is done for every insitu coverage in the collection.
    // The result is again a collection, but of Point coverages.
    // For each Point coverage, the input model grid and the input insitu coverage are referenced
    // by their IDs. This is to help with connecting data and specifically combined visualization
    // (info popups, plots etc.).

    // Formula used in all cases (n = number of z steps or 1 if no z axis):
    // RMSE = sqrt ( ( sum_{i=1}^n (x_i - y_i)^2 ) / n)
    // (simplifies to absolute difference if n=1)

    // Currently, we hard-code the statistics axis to 'z' but it can be any varying axis along which to calculate the RMSE.
    // For example, z could be fixed and the time axis 't' is varying instead.
    // This would however require that in-situ coverages have a time axis, which is typically not the case,
    // instead each new observation is a separate coverage (the reason is that the z values are often not the same).
    var Z = 'z';

    var X = 'x';
    var Y = 'y';

    // TODO check that model and insitu coverages have the same CRSs

    var model = modelGridCoverage;
    var modelParam = model.parameters.get(modelParamKey);

    function getAxisExtent(axis) {
      var withBounds = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

      if (!axis) {
        return [undefined, undefined];
      }
      var vals = axis.values;
      var min = Math.min(vals[0], vals[vals.length - 1]);
      var max = Math.max(vals[0], vals[vals.length - 1]);
      // TODO handle explicit bounds
      if (withBounds && vals.length > 1) {
        var halfCell = Math.abs(vals[0] - vals[1]) / 2;
        min -= halfCell;
        max += halfCell;
      }
      return [min, max];
    }

    return model.loadDomain().then(function (modelDomain) {
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = modelDomain.axes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _step5$value = babelHelpers.slicedToArray(_step5.value, 2);

          var key = _step5$value[0];
          var axis = _step5$value[1];

          if ([X, Y, Z].indexOf(key) === -1 && axis.values.length > 1) {
            throw new Error('Only x,y,' + Z + ' can be varying axes in the model grid, not: ' + key);
          }
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5['return']) {
            _iterator5['return']();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      var modelHasZ = modelDomain.axes.has(Z);
      var modelZ = modelHasZ ? modelDomain.axes.get(Z).values : null;
      var modelHasVaryingZ = modelZ && modelZ.length > 1;

      var _getAxisExtent = getAxisExtent(modelDomain.axes.get(Z));

      var _getAxisExtent2 = babelHelpers.slicedToArray(_getAxisExtent, 2);

      var modelZMin = _getAxisExtent2[0];
      var modelZMax = _getAxisExtent2[1];

      function deriveCovJSONs(insituCollection) {
        var hasNextPage = insituCollection.paging && insituCollection.paging.next;
        var nextPage = hasNextPage ? insituCollection.paging.next.load({ eagerload: true }) : undefined;

        var insituCovs = insituCollection.coverages;

        var promises = [Promise.all(insituCovs.map(function (cov) {
          return cov.loadDomain();
        })), Promise.all(insituCovs.map(function (cov) {
          return cov.loadRange(insituParamKey);
        }))];

        return Promise.all(promises).then(function (_ref12) {
          var _ref122 = babelHelpers.slicedToArray(_ref12, 2);

          var insituDomains = _ref122[0];
          var insituRanges = _ref122[1];

          var insitus = insituCovs.map(function (cov, i) {
            return {
              cov: cov,
              domain: insituDomains[i],
              range: insituRanges[i]
            };
          });

          var points = insitus.map(function (insitu) {
            return { x: insitu.domain.axes.get(X).values[0], y: insitu.domain.axes.get(Y).values[0] };
          });
          if (points.length > 0) {
            (function () {
              var fromProj = referencingUtil.getProjection(insituDomains[0]);
              var toProj = referencingUtil.getProjection(modelDomain);
              points = points.map(function (point) {
                return referencingUtil.reproject(point, fromProj, toProj);
              }).map(function (_ref13) {
                var x = _ref13.x;
                var y = _ref13.y;
                return [x, y];
              });
            })();
          }
          var modelSubsetsPromise = subsetGridToPointsConnected(model, points);

          return modelSubsetsPromise.then(function (modelSubsets) {
            var promises = [];
            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = undefined;

            try {
              var _loop2 = function () {
                var _step6$value = babelHelpers.slicedToArray(_step6.value, 2);

                var insitu = _step6$value[0];
                var modelSubset = _step6$value[1];
                _iteratorNormalCompletion7 = true;
                _didIteratorError7 = false;
                _iteratorError7 = undefined;

                try {
                  for (_iterator7 = insitu.domain.axes[Symbol.iterator](); !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                    var _step7$value = babelHelpers.slicedToArray(_step7.value, 2);

                    var key = _step7$value[0];
                    var axis = _step7$value[1];

                    if (key !== Z && axis.values.length > 1) {
                      throw new Error('Only ' + Z + ' can be a varying axis in in-situ coverages, not: ' + key);
                    }
                  }
                } catch (err) {
                  _didIteratorError7 = true;
                  _iteratorError7 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion7 && _iterator7['return']) {
                      _iterator7['return']();
                    }
                  } finally {
                    if (_didIteratorError7) {
                      throw _iteratorError7;
                    }
                  }
                }

                var insituX = insitu.domain.axes.get(X).values[0];
                var insituY = insitu.domain.axes.get(Y).values[0];
                var insituHasZ = insitu.domain.axes.has(Z);
                var insituZ = insituHasZ ? insitu.domain.axes.get(Z).values : null;
                var insituHasVaryingZ = insituZ && insituZ.length > 1;

                if (insituHasVaryingZ && !modelHasZ) {
                  throw new Error('Model grid must have a ' + Z + ' axis if insitu data has a varying ' + Z + ' axis');
                }
                if (!insituHasZ && modelHasVaryingZ) {
                  throw new Error('Model grid must not have a varying ' + Z + ' axis if insitu data has no ' + Z + ' axis');
                }

                var promise = modelSubset.loadRange(modelParamKey).then(function (modelSubsetRange) {
                  // collect the values to compare against each other
                  var modelVals = [];
                  var insituVals = [];
                  if (!modelHasVaryingZ) {
                    var modelVal = modelSubsetRange.get({});

                    var insituVal = undefined;
                    if (!insituHasVaryingZ) {
                      insituVal = insitu.range.get({});
                    } else {
                      // varying insitu z, get closest value to grid z
                      var zIdxClosest = indexOfNearest(insituZ, modelZ[0]);
                      insituVal = insitu.range.get(babelHelpers.defineProperty({}, Z, zIdxClosest));
                    }
                    if (modelVal !== null && insituVal !== null) {
                      modelVals = [modelVal];
                      insituVals = [insituVal];
                    }
                  } else {
                    // varying model z

                    // linear interpolation
                    var interp = function interp(z, z0, v0, z1, v1) {
                      return v0 + (v1 - v0) * (z - z0) / (z1 - z0);
                    };

                    for (var i = 0; i < insituZ.length; i++) {
                      var z = insituZ[i];
                      if (z < modelZMin || z > modelZMax) {
                        // we don't extrapolate
                        continue;
                      }
                      var insituVal = insitu.range.get(babelHelpers.defineProperty({}, Z, i));
                      if (insituVal === null) {
                        continue;
                      }

                      // interpolate between nearest model points on z axis

                      var _indicesOfNearest = indicesOfNearest(modelZ, z);

                      var _indicesOfNearest2 = babelHelpers.slicedToArray(_indicesOfNearest, 2);

                      var zIdxClosest1 = _indicesOfNearest2[0];
                      var zIdxClosest2 = _indicesOfNearest2[1];
                      var zClosest1 = modelZ[zIdxClosest1];
                      var zClosest2 = modelZ[zIdxClosest2];

                      var val1 = modelSubsetRange.get(babelHelpers.defineProperty({}, Z, zIdxClosest1));
                      var val2 = modelSubsetRange.get(babelHelpers.defineProperty({}, Z, zIdxClosest2));
                      if (val1 === null || val2 === null) {
                        // We could be more clever here and search for other points.
                        // However, model grids will likely not have partially missing values at one x/y point anyway.
                        continue;
                      }

                      var val = undefined;
                      if (zIdxClosest1 === zIdxClosest2) {
                        val = val1;
                      } else {
                        val = interp(z, zClosest1, val1, zClosest2, val2);
                      }
                      modelVals.push(val);
                      insituVals.push(insituVal);
                    }
                  }

                  if (modelVals.length === 0) {
                    return;
                  }

                  // calculate RMSE = sqrt ( ( sum_{i=1}^n (x_i - y_i)^2 ) / n)
                  var n = modelVals.length;
                  var sum = zip(modelVals, insituVals).map(function (_ref14) {
                    var _ref142 = babelHelpers.slicedToArray(_ref14, 2);

                    var v1 = _ref142[0];
                    var v2 = _ref142[1];
                    return Math.pow(v1 - v2, 2);
                  }).reduce(function (l, r) {
                    return l + r;
                  });
                  var rmse = Math.sqrt(sum / n);

                  // assemble the result into a CovJSON Point coverage           
                  var covjson = {
                    "type": "Coverage",
                    "profile": "PointCoverage",
                    "wasGeneratedBy": {
                      "type": "ModelObservationComparisonActivity",
                      "qualifiedUsage": {
                        "model": {
                          "entity": modelGridCoverage.id,
                          "hadRole": "modelToCompareAgainst",
                          "parameterKey": modelParamKey
                        },
                        "observation": {
                          "entity": insitu.cov.id,
                          "hadRole": "observationToCompareAgainst",
                          "parameterKey": insituParamKey
                        }
                      }
                    },
                    "domain": {
                      "type": "Domain",
                      "profile": "Point",
                      "axes": {
                        "x": { "values": [insituX] },
                        "y": { "values": [insituY] }
                      }
                    },
                    "ranges": {
                      "rmse": {
                        "type": "Range",
                        "values": [rmse],
                        "dataType": "float"
                      }
                    }
                  };

                  return covjson;
                });

                promises.push(promise);
              };

              for (var _iterator6 = insitus.map(function (v, i) {
                return [v, modelSubsets[i]];
              })[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                var _iteratorNormalCompletion7;

                var _didIteratorError7;

                var _iteratorError7;

                var _iterator7, _step7;

                _loop2();
              }
            } catch (err) {
              _didIteratorError6 = true;
              _iteratorError6 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion6 && _iterator6['return']) {
                  _iterator6['return']();
                }
              } finally {
                if (_didIteratorError6) {
                  throw _iteratorError6;
                }
              }
            }

            return Promise.all([Promise.all(promises), nextPage]).then(function (_ref15) {
              var _ref152 = babelHelpers.slicedToArray(_ref15, 2);

              var covjsons = _ref152[0];
              var nextPageColl = _ref152[1];

              if (nextPageColl) {
                return deriveCovJSONs(nextPageColl).then(function (nextCovjsons) {
                  return covjsons.concat(nextCovjsons);
                });
              } else {
                return covjsons;
              }
            });
          });
        });
      }

      // get a tiled collection to help the model subsetting rectangle-based algorithm
      var modelXExtent = getAxisExtent(modelDomain.axes.get(X), true);
      var modelYExtent = getAxisExtent(modelDomain.axes.get(Y), true);
      // TODO make this depend on something
      var nx = 6;
      var ny = nx;
      var tileExtents = getTileExtents(modelXExtent, modelYExtent, nx, ny);
      var tiledInsituCoverageCollection = undefined;
      return getTiledCollection(insituCoverageCollection, tileExtents, { eagerload: true }).then(deriveCovJSONs).then(function (covjsons) {
        // put statistical point coverages into a CovJSON collection

        covjsons = covjsons.filter(function (o) {
          return o;
        }); // filter empty results

        var coll = {
          "@context": {
            "prov": "http://www.w3.org/ns/prov#",
            "wasGeneratedBy": "prov:wasGeneratedBy",
            "qualifiedUsage": { "@id": "prov:qualifiedUsage", "@container": "@index" },
            "entity": { "@id": "prov:entity", "@type": "@id" },
            "hadRole": { "@id": "prov:hadRole", "@type": "@vocab" },
            "covstats": "http://covstats#",
            "ModelObservationComparisonActivity": "covstats:ModelObservationComparisonActivity",
            "modelToCompareAgainst": "covstats:modelToCompareAgainst",
            "observationsToCompareAgainst": "covstats:observationsToCompareAgainst",
            "observationToCompareAgainst": "covstats:observationToCompareAgainst",
            "parameterKey": "covstats:parameterKey"
          },
          "type": "CoverageCollection",
          "profile": "PointCoverageCollection",
          "wasGeneratedBy": {
            "type": "ModelObservationComparisonActivity",
            "qualifiedUsage": {
              "model": {
                "entity": modelGridCoverage.id,
                "hadRole": "modelToCompareAgainst",
                "parameterKey": modelParamKey
              },
              "observations": {
                "entity": insituCoverageCollection.id,
                "hadRole": "observationsToCompareAgainst",
                "parameterKey": insituParamKey
              }
            }
          },
          "parameters": {
            "rmse": {
              "type": "Parameter",
              "unit": modelParam.unit,
              "observedProperty": {
                "label": {
                  "en": "RMSE of " + i18n(modelParam.observedProperty.label)
                },
                // TODO is stddev ok here? uncertml doesn't know RMSE
                "statisticalMeasure": "http://www.uncertml.org/statistics/standard-deviation"
              },
              "preferredPalette": {
                "interpolation": "linear",
                "colors": ["green", "orange", "red"]
              }
            }
          },
          "referencing": [{
            // FIXME the order could be different, or even be a x-y-z CRS
            "components": ["x", "y"],
            "system": referencingUtil.getReferenceObject(modelDomain, X).system
          }],
          "coverages": covjsons
        };
        return coll;
      });
    });
  }

  function zip(a, b) {
    return a.map(function (e, i) {
      return [a[i], b[i]];
    });
  }
  return {
    setters: [function (_3) {
      $ = _3.$;
      $$ = _3.$$;
      HTML = _3.HTML;
    }, function (_4) {
      i18n = _4.i18n;
      COVJSON_PREFIX = _4.COVJSON_PREFIX;
    }, function (_) {
      ButtonControl = _['default'];
    }, function (_2) {
      unitUtils = _2;
    }, function (_b) {
      indexOfNearest = _b.indexOfNearest;
      indicesOfNearest = _b.indicesOfNearest;
    }, function (_c) {
      referencingUtil = _c;
    }, function (_d) {
      COVJSON_GRID = _d.COVJSON_GRID;
      COVJSON_POINT = _d.COVJSON_POINT;
      COVJSON_VERTICALPROFILE = _d.COVJSON_VERTICALPROFILE;
    }, function (_e) {
      TimeAxis = _e['default'];
    }, function (_f) {
      Dropdown = _f['default'];
    }, function (_c2) {
      Modal = _c2['default'];
    }, function (_a) {
      CoverageData = _a['default'];
    }, function (_b2) {
      Action = _b2['default'];
      VIEW = _b2.VIEW;
      PROCESS = _b2.PROCESS;
    }],
    execute: function () {
      PointCollection = COVJSON_PREFIX + 'PointCoverageCollection';
      ProfileCollection = COVJSON_PREFIX + 'VerticalProfileCoverageCollection';
      TYPE = {
        MODEL: 1,
        OBSERVATIONS: 2
      };
      html = '\n<div class="modal fade" id="comparisonDatasetSelectModal" tabindex="-1" role="dialog" aria-labelledby="comparisonDatasetSelectModalLabel">\n  <div class="modal-dialog" role="document">\n    <div class="modal-content">\n      <div class="modal-header">\n        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>\n        <h4 class="modal-title" id="comparisonDatasetSelectModalLabel">Select a dataset to compare against</h4>\n      </div>\n      <div class="modal-body">\n        \n        <div class="panel panel-primary">\n          <div class="panel-heading">\n            <h4>Model-Observation comparison</h4>\n          </div>\n          <div class="panel-body">\n            <p class="help-text-model">\n              The gridded input dataset that you selected is assumed to be the model dataset that is compared\n              against an observation collection dataset (point or vertical profile observations).\n              Please select the observation dataset below.\n            </p>\n            <p class="help-text-observations">\n              The collection-type input dataset that you selected is assumed to be the observation set that is\n              compared against a model grid dataset.\n              Please select the model dataset below.\n            </p>\n            <div class="alert alert-info comparison-distribution-list-empty" role="alert"><strong>None found.</strong></div>\n          </div>\n          \n          <ul class="list-group comparison-distribution-list"></ul>\n        </div>\n       \n      </div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class="modal fade" id="comparisonParametersSelectModal" tabindex="-1" role="dialog" aria-labelledby="comparisonParametersSelectModalLabel">\n  <div class="modal-dialog" role="document">\n    <div class="modal-content">\n      <div class="modal-header">\n        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>\n        <h4 class="modal-title" id="comparisonParametersSelectModalLabel">Select parameters</h4>\n      </div>\n      <div class="modal-body">\n        \n        <div class="panel panel-primary">\n          <div class="panel-body">\n            <p>\n              Select the parameters you wish to compare.\n              Note that currently no unit conversion is done.\n            </p>\n              \n            <div class="form-horizontal">\n              <div class="form-group">\n                <label for="modelComparisonParameter" class="col-sm-3 control-label">Model</label>\n                <div class="col-sm-9">\n                  <select id="modelComparisonParameter" class="form-control model-parameter-select"></select>\n                </div>\n              </div>\n              \n              <div class="form-group">\n                <label for="observationComparisonParameter" class="col-sm-3 control-label">Observations</label>\n                <div class="col-sm-9">\n                  <select id="observationComparisonParameter" class="form-control observation-parameter-select"></select>\n                </div>\n              </div>\n            </div>\n                          \n            <div class="parameter-select-button-container"></div>\n          </div>\n        </div>\n      </div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>\n      </div>\n    </div>\n  </div>\n</div>\n';

      $('body').add(HTML(html));

      TEMPLATES = {
        'comparison-distribution-item': '\n  <li class="list-group-item">\n    <h4 class="list-group-item-heading dataset-title"></h4>\n    <p>Distribution: <span class="distribution-title"></span></p>\n    <button type="button" class="btn btn-primary select-button" data-dismiss="modal">\n      Select\n    </button>\n  </li>\n  ',
        'params-select-button': '<button type="button" class="btn btn-primary params-select-button" data-dismiss="modal">Select</button>'
      };

      /**
       * Compare a model grid against an observation collection.
       */

      CoverageModelObservationCompare = (function (_Action) {
        babelHelpers.inherits(CoverageModelObservationCompare, _Action);

        function CoverageModelObservationCompare(data, context) {
          babelHelpers.classCallCheck(this, CoverageModelObservationCompare);

          babelHelpers.get(Object.getPrototypeOf(CoverageModelObservationCompare.prototype), 'constructor', this).call(this, context);

          this.data = data;

          this.label = 'Intercompare';
          this.icon = '<span class="glyphicon glyphicon-stats"></span>';
        }

        babelHelpers.createClass(CoverageModelObservationCompare, [{
          key: 'run',
          value: function run() {
            // Step 1: determine if this dataset is the model grid or the observation collection
            // Step 2: display modal for selecting the dataset to compare against
            //         (filter appropriately by coverage type / collection)
            // Step 3: display modal for selecting the parameters to compare against (if more than one)
            // Step 4: interactive map display
            //         - if there is a model time dimension, display that as an axis selector
            //           and have an observation time dimension extent selector (e.g. +- 1h)
            //         - the intercomparison data is calculated for the current model time step and observation time extent
            //           (don't subset by bounding box for now, do globally, we'll see how it goes)
            //         - the result is a virtual dataset which is added to the workspace and displayed
            //         - when clicking on a comparison point, a popup is shown with plots etc.
            //         - when changing times the virtual dataset is replaced by a new one

            this._displayDistributionSelectModal();
          }
        }, {
          key: '_displayDistributionSelectModal',
          value: function _displayDistributionSelectModal() {
            var _this = this;

            var _getCovData = getCovData(this.data);

            var data = _getCovData.data;
            var type = _getCovData.type;

            var modalEl = $('#comparisonDatasetSelectModal');

            var dists = undefined;
            if (type === TYPE.MODEL) {
              $('.help-text-model', modalEl).show();
              $('.help-text-observations', modalEl).hide();

              dists = this.context.workspace.filterDistributions(function (dist) {
                if (dist.formatImpl instanceof CoverageData) {
                  var covdata = getCovData(dist.data);
                  return covdata && covdata.type === TYPE.OBSERVATIONS;
                }
              });
            } else {
              $('.help-text-model', modalEl).hide();
              $('.help-text-observations', modalEl).show();

              dists = this.context.workspace.filterDistributions(function (dist) {
                if (dist.formatImpl instanceof CoverageData) {
                  var covdata = getCovData(dist.data);
                  return covdata && covdata.type === TYPE.MODEL;
                }
              });
            }

            $('.comparison-distribution-list', modalEl).fill();
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              var _loop = function () {
                var _step$value = _step.value;
                var distribution = _step$value.distribution;
                var dataset = _step$value.dataset;

                var el = $(HTML(TEMPLATES['comparison-distribution-item']));

                $('.dataset-title', el).fill(i18n(dataset.title));
                $('.distribution-title', el).fill(i18n(distribution.title));

                $('.select-button', el).on('|click', function () {
                  if (type === TYPE.MODEL) {
                    _this._displayParameterSelectModal(data, distribution.data);
                  } else {
                    // extract grid from 1-element collection if necessary
                    var modelCov = getCovData(distribution.data).data;
                    _this._displayParameterSelectModal(modelCov, data);
                  }
                });

                $('.comparison-distribution-list', modalEl).add(el);
              };

              for (var _iterator = dists[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                _loop();
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            $$('.comparison-distribution-list-empty', modalEl).style.display = dists.length > 0 ? 'none' : 'block';

            new Modal(modalEl[0]).open();
          }
        }, {
          key: '_displayParameterSelectModal',
          value: function _displayParameterSelectModal(modelCov, observationsColl) {
            var _this2 = this;

            var modelParams = getNonCategoricalParams(modelCov);
            var observationsParams = getNonCategoricalParams(observationsColl);

            var modalEl = $('#comparisonParametersSelectModal');

            var fillSelect = function fillSelect(el, params) {
              el.fill();
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = params[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var param = _step2.value;

                  var unit = unitUtils.toAscii(param.unit) || 'unknown unit';
                  var label = i18n(param.observedProperty.label) + ' (' + unit + ')';
                  el.add(HTML('<option value="' + param.key + '">' + label + '</option>'));
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                    _iterator2['return']();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            };

            fillSelect($('.model-parameter-select', modalEl), modelParams);
            fillSelect($('.observation-parameter-select', modalEl), observationsParams);

            // we add this anew each time to get rid of old event listeners
            $('.parameter-select-button-container', modalEl).fill(HTML(TEMPLATES['params-select-button']));

            $('.params-select-button', modalEl).on('|click', function () {
              var modelParamKey = $$('.model-parameter-select', modalEl).value;
              var observationsParamKey = $$('.observation-parameter-select', modalEl).value;
              _this2._displayIntercomparisonUI(modelCov, observationsColl, modelParamKey, observationsParamKey);
            });

            new Modal(modalEl[0]).open();
          }
        }, {
          key: '_displayIntercomparisonUI',
          value: function _displayIntercomparisonUI(modelCov, observationsColl, modelParamKey, observationsParamKey) {
            var _this3 = this;

            var map = this.context.map;

            this._intercomparisonActive = true;

            var doIntercomparison = function doIntercomparison(modelTime, obsTimeDelta) {
              _this3.fire('loading');
              var promises = undefined;
              if (modelTime) {
                // subset model + filter observations
                var obsStart = new Date(modelTime.getTime() - obsTimeDelta * 1000);
                var obsStop = new Date(modelTime.getTime() + obsTimeDelta * 1000);
                promises = [modelCov.subsetByValue({ t: modelTime.toISOString() }), observationsColl.query().filter({ t: { start: obsStart.toISOString(), stop: obsStop.toISOString() } }).execute({ eagerload: true })];
              } else {
                promises = [modelCov, observationsColl];
              }
              Promise.all(promises).then(function (_ref) {
                var _ref2 = babelHelpers.slicedToArray(_ref, 2);

                var modelCovSubset = _ref2[0];
                var obsCollFiltered = _ref2[1];

                deriveIntercomparisonStatistics(modelCovSubset, obsCollFiltered, modelParamKey, observationsParamKey).then(function (covjsonobj) {
                  _this3.fire('load');
                  var workspace = _this3.context.workspace;

                  // discard old intercomparison dataset
                  if (_this3._intercomparisonResultDataset) {
                    workspace.removeDataset(_this3._intercomparisonResultDataset);
                  }

                  // create new dataset and display         
                  var covjson = JSON.stringify(covjsonobj, null, 2);

                  // NOTE: we don't call URL.revokeObjectURL() currently when removing the dataset again
                  var blobUrl = URL.createObjectURL(new Blob([covjson], { type: 'application/prs.coverage+json' }));

                  var prefixTitle = 'Intercomparison';
                  if (modelTime) {
                    var modelTimeISO = modelTime.toISOString();
                    var obsTimeDeltaStr = '± ' + Math.round(obsTimeDelta / 60) + ' min';
                    prefixTitle += ' [Model: ' + modelTimeISO + ', Observations: ' + obsTimeDeltaStr + ']';
                  }

                  var virtualDataset = {
                    title: { en: prefixTitle },
                    virtual: true,
                    distributions: [{
                      title: { en: prefixTitle },
                      mediaType: 'application/prs.coverage+json',
                      url: blobUrl
                    }]
                  };
                  _this3._intercomparisonResultDataset = virtualDataset;

                  // display after loading
                  var done = function done(_ref3) {
                    var dataset = _ref3.dataset;

                    if (dataset === virtualDataset) {
                      dataset.distributions[0].actions.find(function (a) {
                        return a.type === VIEW;
                      }).run();
                      workspace.off('distributionsLoad', done);
                    }
                  };
                  workspace.on('distributionsLoad', done);
                  workspace.addDataset(virtualDataset, _this3.context.dataset);
                });
              });
            };

            // UI
            modelCov.loadDomain().then(function (modelDomain) {
              if (modelDomain.axes.has('t')) {
                (function () {
                  // display time controls

                  // Model: simple time axis control
                  var modelTimeSlices = modelDomain.axes.get('t').values.map(function (t) {
                    return new Date(t);
                  });
                  var modelFakeLayer = { timeSlices: modelTimeSlices, time: modelTimeSlices[0] };
                  _this3._modelTimeControl = new TimeAxis(modelFakeLayer, { title: 'Model time' }).on('change', function (_ref4) {
                    var time = _ref4.time;

                    var obsTimeDelta = parseInt(_this3._obsTimeDeltaControl.value);
                    doIntercomparison(time, obsTimeDelta);
                  }).addTo(map);

                  // Observations: time delta control
                  var choices = [{ value: 60, label: '± 1 min' }, { value: 60 * 10, label: '± 10 min' }, { value: 60 * 30, label: '± 30 min' }, { value: 60 * 60, label: '± 1 hour' }, { value: 60 * 60 * 24, label: '± 1 day' }, { value: 60 * 60 * 24 * 30, label: '± 30 days' }];
                  _this3._obsTimeDeltaControl = new Dropdown(choices, { title: 'Observation time delta' }).on('change', function (event) {
                    var obsTimeDelta = parseInt(event.value);
                    var modelTime = modelFakeLayer.time;
                    doIntercomparison(modelTime, obsTimeDelta);
                  }).addTo(map);

                  // to start, apply first model time slice and first delta choice
                  doIntercomparison(modelFakeLayer.time, choices[0].value);

                  var doneButton = new ButtonControl({ title: 'Exit Intercomparison' }).addTo(map);
                  doneButton.on('click', function () {
                    map.removeControl(_this3._modelTimeControl);
                    map.removeControl(_this3._obsTimeDeltaControl);
                    map.removeControl(doneButton);
                    var viewAction = _this3._intercomparisonResultDataset.distributions[0].actions.find(function (a) {
                      return a.type === VIEW;
                    });
                    if (viewAction.visible) {
                      // hide it
                      viewAction.run();
                    }
                    _this3._intercomparisonActive = false;
                  });
                })();
              } else {
                doIntercomparison();
              }
            });
          }
        }, {
          key: 'isSupported',
          get: function get() {
            return getCovData(this.data);
          }
        }]);
        return CoverageModelObservationCompare;
      })(Action);

      _export('default', CoverageModelObservationCompare);

      CoverageModelObservationCompare.type = PROCESS;
    }
  };
});

$__System.register('21', ['5', '8', '9', '22', '23', 'c', '1d', 'b'], function (_export) {
  'use strict';

  var L, $, $$, HTML, i18n, GeoJSON, transformUtil, Modal, COVJSON_GRID, Action, PROCESS, html, TEMPLATES, CoverageSubsetByPolygon;

  function getPolygonFeatures(geojson) {
    var features = []; // array of GeoJSON feature objects with (Multi)Polygon geometries
    switch (geojson.type) {
      case 'Polygon':
      case 'MultiPolygon':
        features.push({
          type: 'Feature',
          geometry: geojson
        });
        break;
      case 'Feature':
        switch (geojson.geometry.type) {
          case 'Polygon':
          case 'MultiPolygon':
            features.push(geojson);
            break;
        }
        break;
      case 'FeatureCollection':
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = geojson.features[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var feature = _step2.value;

            switch (feature.geometry.type) {
              case 'Polygon':
              case 'MultiPolygon':
                features.push(feature);
                break;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

    }
    return features;
  }

  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_2) {
      $ = _2.$;
      $$ = _2.$$;
      HTML = _2.HTML;
    }, function (_4) {
      i18n = _4.i18n;
    }, function (_5) {
      GeoJSON = _5['default'];
    }, function (_3) {
      transformUtil = _3;
    }, function (_c) {
      Modal = _c['default'];
    }, function (_d) {
      COVJSON_GRID = _d.COVJSON_GRID;
    }, function (_b) {
      Action = _b['default'];
      PROCESS = _b.PROCESS;
    }],
    execute: function () {
      html = '\n<div class="modal fade" id="geojsonSelectModal" tabindex="-1" role="dialog" aria-labelledby="geojsonSelectModalLabel">\n  <div class="modal-dialog" role="document">\n    <div class="modal-content">\n      <div class="modal-header">\n        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>\n        <h4 class="modal-title" id="geojsonSelectModalLabel">Select a GeoJSON resource</h4>\n      </div>\n      <div class="modal-body">\n        <div class="panel panel-primary remap-remapping-distributions">\n          <div class="panel-heading">\n            <h4>Select the GeoJSON resource containing the subsetting polygon</h4>\n          </div>\n          <div class="panel-body">\n            <p>\n              Only those GeoJSON resources are shown which contain at least one (multi)polygon.\n              After selecting a GeoJSON resource, all polygons will be displayed on the map\n              and you can pick the one that should be used for subsetting.\n            </p>\n            <div class="alert alert-info geojson-distribution-list-empty" role="alert"><strong>None found.</strong></div>\n          </div>\n          <ul class="list-group geojson-distribution-list"></ul>\n        </div>\n               \n      </div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>\n      </div>\n    </div>\n  </div>\n</div>\n';

      $('body').add(HTML(html));

      TEMPLATES = {
        'geojson-distribution-item': '\n  <li class="list-group-item">\n    <h4 class="list-group-item-heading dataset-title"></h4>\n    <p>Distribution: <span class="distribution-title"></span></p>\n    <p>Polygons: <span class="polygon-count"></span></p>\n    \n    <button type="button" class="btn btn-primary select-button" data-dismiss="modal">\n      Select\n    </button>\n  </li>\n  '
      };

      CoverageSubsetByPolygon = (function (_Action) {
        babelHelpers.inherits(CoverageSubsetByPolygon, _Action);

        function CoverageSubsetByPolygon(data, context) {
          babelHelpers.classCallCheck(this, CoverageSubsetByPolygon);

          babelHelpers.get(Object.getPrototypeOf(CoverageSubsetByPolygon.prototype), 'constructor', this).call(this, context);

          if (this._isSingleCoverage(data)) {
            this.cov = this._getSingleCoverage(data);
          } else {
            this.cov = data;
          }

          this.label = 'Polygon Subset';
          this.icon = '<span class="glyphicon glyphicon-scissors"></span>';
        }

        // TODO code duplication with CoverageRemapCategories.js
        babelHelpers.createClass(CoverageSubsetByPolygon, [{
          key: '_isSingleCoverage',
          value: function _isSingleCoverage(cov) {
            try {
              this._getSingleCoverage(cov);
              return true;
            } catch (e) {
              return false;
            }
          }
        }, {
          key: '_getSingleCoverage',
          value: function _getSingleCoverage(cov) {
            if (!cov.coverages) {
              return cov;
            } else if (cov.coverages.length === 1) {
              return cov.coverages[0];
            } else {
              throw new Error('not a single coverage');
            }
          }
        }, {
          key: 'run',
          value: function run() {
            var _this = this;

            // Step 1: display modal for selecting a GeoJSON distribution
            // Step 2: let user select one of the contained polygon features
            //         (or skip if only a single feature)

            var modalEl = $('#geojsonSelectModal');
            var geojsonDists = this._findGeoJSONDistributions();

            $('.geojson-distribution-list', modalEl).fill();
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              var _loop = function () {
                var _step$value = _step.value;
                var distribution = _step$value.distribution;
                var dataset = _step$value.dataset;

                var el = $(HTML(TEMPLATES['geojson-distribution-item']));

                $('.dataset-title', el).fill(i18n(dataset.title));
                $('.distribution-title', el).fill(i18n(distribution.title));

                var polygonCount = getPolygonFeatures(distribution.data).length;
                $('.polygon-count', el).fill(polygonCount);

                $('.select-button', el).on('|click', function () {
                  _this._displayPolygons(distribution);
                });

                $('.geojson-distribution-list', modalEl).add(el);
              };

              for (var _iterator = geojsonDists[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                _loop();
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            $$('.geojson-distribution-list-empty', modalEl).style.display = geojsonDists.length > 0 ? 'none' : 'block';

            new Modal(modalEl[0]).open();
          }
        }, {
          key: '_displayPolygons',
          value: function _displayPolygons(distribution) {
            var _this2 = this;

            var features = {
              type: 'FeatureCollection',
              features: getPolygonFeatures(distribution.data)
            };
            var map = this.context.map;

            // copied from GeoJSONView
            var color = '#CC2222';
            var defaultStyle = {
              color: color,
              weight: 2,
              opacity: 0.6,
              fillOpacity: 0,
              fillColor: color
            };

            var highlightStyle = {
              color: color,
              weight: 3,
              opacity: 0.6,
              fillOpacity: 0.65,
              fillColor: color
            };

            var mouseoverFn = function mouseoverFn(e) {
              e.target.setStyle(highlightStyle);
            };

            var mouseoutFn = function mouseoutFn(e) {
              e.target.setStyle(defaultStyle);
            };

            var featuresLayer = L.geoJson(features, {
              onEachFeature: function onEachFeature(feature, layer) {
                layer.setStyle(defaultStyle);
                layer.on('mouseover', mouseoverFn);
                layer.on('mouseout', mouseoutFn);
                layer.on('click', function () {
                  _this2._applySubsetAndCreateVirtualDataset(feature);
                  map.removeLayer(featuresLayer);
                });
              }
            }).addTo(map);
            map.fitBounds(featuresLayer.getBounds());
          }
        }, {
          key: '_applySubsetAndCreateVirtualDataset',
          value: function _applySubsetAndCreateVirtualDataset(feature) {
            var _this3 = this;

            var appendTitle = ' [subsetted by polygon]';

            this.fire('loading');
            var bbox = L.geoJson(feature).getBounds();
            transformUtil.subsetByBbox(this.cov, [bbox.getWest(), bbox.getSouth(), bbox.getEast(), bbox.getNorth()]).then(function (bboxSubsetCov) {
              transformUtil.maskByPolygon(bboxSubsetCov, feature.geometry).then(function (polySubsetCov) {
                var virtualDataset = {
                  title: { en: i18n(_this3.context.dataset.title) + appendTitle },
                  virtual: true,
                  distributions: [{
                    title: { en: i18n(_this3.context.distribution.title) + appendTitle },
                    mediaType: 'coveragedata',
                    data: polySubsetCov
                  }]
                };
                var workspace = _this3.context.workspace;

                workspace.addDataset(virtualDataset, _this3.context.dataset);
                workspace.requestFocus(virtualDataset);

                _this3.fire('load');
              });
            });
          }
        }, {
          key: '_findGeoJSONDistributions',
          value: function _findGeoJSONDistributions() {
            return this.context.workspace.filterDistributions(function (dist) {
              if (!(dist.formatImpl instanceof GeoJSON)) return false;
              return getPolygonFeatures(dist.data).length > 0;
            });
          }
        }, {
          key: 'isSupported',
          get: function get() {
            // data is single grid coverage
            if (this._isSingleCoverage(this.cov) && this.cov.domainType === COVJSON_GRID) {
              return true;
            }
            return false;
          }
        }]);
        return CoverageSubsetByPolygon;
      })(Action);

      _export('default', CoverageSubsetByPolygon);

      CoverageSubsetByPolygon.type = PROCESS;
    }
  };
});

$__System.register('24', ['8', '9', '25', 'c', '1c', '1d', 'b'], function (_export) {
  /*
   * For a given categorical coverage parameter, calculate and show
   * percentages of each category for a given time step or combined
   * as a time series plot.
   */

  'use strict';

  var $, $$, HTML, i18n, rangeUtil, Modal, referencingUtil, COVJSON_GRID, Action, PROCESS, html, TEMPLATES, CoverageCategoriesStatistics;
  return {
    setters: [function (_) {
      $ = _.$;
      $$ = _.$$;
      HTML = _.HTML;
    }, function (_2) {
      i18n = _2.i18n;
    }, function (_3) {
      rangeUtil = _3;
    }, function (_c) {
      Modal = _c['default'];
    }, function (_c2) {
      referencingUtil = _c2;
    }, function (_d) {
      COVJSON_GRID = _d.COVJSON_GRID;
    }, function (_b) {
      Action = _b['default'];
      PROCESS = _b.PROCESS;
    }],
    execute: function () {
      html = '\n<div class="modal fade" id="statisticsOptionsModal" tabindex="-1" role="dialog" aria-labelledby="statisticsOptionsModalLabel">\n  <div class="modal-dialog" role="document">\n    <div class="modal-content">\n      <div class="modal-header">\n        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>\n        <h4 class="modal-title" id="statisticsOptionsModalLabel">Select reference periods</h4>\n      </div>\n      <div class="modal-body">\n        \n        <div class="panel panel-primary">\n          <div class="panel-body">\n            <p>\n              Select the reference periods for which the summary statistics shall be calculated.\n              The more periods you select, the longer the processing time will be.\n            </p>\n              \n            <select multiple class="form-control ref-periods-select">\n            </select>\n            \n            <div class="calculate-button-container"></div>\n          </div>\n          \n       \n        </div>\n       \n      </div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class="modal fade" id="statisticsProgressModal" tabindex="-1" role="dialog" aria-labelledby="statisticsProgressModalLabel">\n  <div class="modal-dialog" role="document">\n    <div class="modal-content">\n      <div class="modal-header">\n        <h4 class="modal-title" id="statisticsProgressModalLabel">Progress</h4>\n      </div>\n      <div class="modal-body">\n        \n        <div class="panel panel-primary">\n          <div class="panel-body">\n            <p>\n              Please wait until the operation is finished.\n            </p>\n            <progress max="1" value="0"></progress>\n          </div>\n        </div>\n       \n      </div>\n    </div>\n  </div>\n</div>\n\n<style>\n.calculate-button-container {\n  margin-top: 20px;\n}\n#statisticsProgressModal progress {\n  width: 100%;\n}\n</style>\n';

      $('body').add(HTML(html));

      TEMPLATES = {
        'calculate-button': '<button type="button" class="btn btn-primary calculate-button" data-dismiss="modal">Calculate</button>'
      };

      CoverageCategoriesStatistics = (function (_Action) {
        babelHelpers.inherits(CoverageCategoriesStatistics, _Action);

        function CoverageCategoriesStatistics(data, context) {
          babelHelpers.classCallCheck(this, CoverageCategoriesStatistics);

          babelHelpers.get(Object.getPrototypeOf(CoverageCategoriesStatistics.prototype), 'constructor', this).call(this, context);

          if (this._isSingleCoverage(data)) {
            this.cov = this._getSingleCoverage(data);
          } else {
            this.cov = data;
          }

          this.label = 'Statistics';
          this.icon = '<span class="glyphicon glyphicon-stats"></span>';
        }

        // TODO code duplication with CoverageRemapCategories.js
        babelHelpers.createClass(CoverageCategoriesStatistics, [{
          key: '_getCategoricalParams',
          value: function _getCategoricalParams() {
            var params = [].concat(babelHelpers.toConsumableArray(this.cov.parameters.values()));
            return params.filter(function (param) {
              return param.observedProperty.categories;
            });
          }
        }, {
          key: '_isSingleCoverage',
          value: function _isSingleCoverage(cov) {
            try {
              this._getSingleCoverage(cov);
              return true;
            } catch (e) {
              return false;
            }
          }
        }, {
          key: '_getSingleCoverage',
          value: function _getSingleCoverage(cov) {
            if (!cov.coverages) {
              return cov;
            } else if (cov.coverages.length === 1) {
              return cov.coverages[0];
            } else {
              throw new Error('not a single coverage');
            }
          }
        }, {
          key: 'run',
          value: function run() {
            var _this = this;

            // we only derive a new coverage dataset here
            // viewing happens in another class

            // Step 1: Modal to select statistics options
            //         -> Either a single time step, or all time steps
            // Step 2: Create statistics coverage (without geo axes!)

            // FIXME need param select modal!!   
            var param = this._getCategoricalParams()[0];

            this.cov.loadDomain().then(function (domain) {
              if (!domain.axes.has('t')) {
                _this._createStats(_this.cov, param, domain);
              } else if (domain.axes.get('t').values.length === 1) {
                _this._createStats(_this.cov, param, domain, [0]);
              } else {
                _this._refPeriodsModal(_this.cov, param, domain);
              }
            });
          }
        }, {
          key: '_refPeriodsModal',
          value: function _refPeriodsModal(cov, param, domain) {
            var _this2 = this;

            var modalEl = $('#statisticsOptionsModal');

            // we add this anew each time to get rid of old event listeners
            $('.calculate-button-container', modalEl).fill(HTML(TEMPLATES['calculate-button']));

            $('.ref-periods-select', modalEl).fill();

            var t = domain.axes.get('t');

            for (var i = 0; i < t.values.length; i++) {
              var refPeriod = undefined;
              if (t.bounds) {
                refPeriod = t.bounds[i][0] + ' - ' + t.bounds[i][1];
              } else {
                refPeriod = t.values[i];
              }
              $('.ref-periods-select', modalEl).add(HTML('<option value="' + i + '">' + refPeriod + '</option>'));
            }

            $('.calculate-button', modalEl).on('|click', function () {
              var timeIndices = [];

              var options = $$('.ref-periods-select', modalEl).options;
              for (var i = 0; i < options.length; i++) {
                if (options[i].selected) {
                  timeIndices.push(parseInt(options[i].value));
                }
              }

              if (timeIndices.length === 0) {
                alert('Please select at least one reference period');
                return false;
              }

              _this2._createStats(cov, param, domain, timeIndices);
            });

            new Modal(modalEl[0]).open();
          }
        }, {
          key: '_createStats',
          value: function _createStats(cov, param, domain, timeIndices) {
            var _this3 = this;

            // show progress modal and calculate statistics
            // when done, display a close button with a guidance text what to do next

            var modalEl = $('#statisticsProgressModal');
            $$('progress', modalEl).value = 0;
            var modal = new Modal(modalEl[0]);
            modal.open();

            if (!timeIndices) {
              timeIndices = [null];
            }

            var total = timeIndices.length;
            var done = 0;

            var raiseProgress = function raiseProgress() {
              done++;
              $$('progress', modalEl).value = done / total;
            };

            var getRatios = function getRatios(range) {
              var rawCounts = new Map();
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = param.categoryEncoding.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var vals = _step.value;
                  var _iteratorNormalCompletion3 = true;
                  var _didIteratorError3 = false;
                  var _iteratorError3 = undefined;

                  try {
                    for (var _iterator3 = vals[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                      var val = _step3.value;

                      rawCounts.set(val, 0);
                    }
                  } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                        _iterator3['return']();
                      }
                    } finally {
                      if (_didIteratorError3) {
                        throw _iteratorError3;
                      }
                    }
                  }
                }

                // TODO using a Map is possibly too slow
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator['return']) {
                    _iterator['return']();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }

              rangeUtil.iterate(range, function (val) {
                if (val !== null) {
                  rawCounts.set(val, rawCounts.get(val) + 1);
                }
              });

              // convert to [category, count] array
              var categoryCounts = [];
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = param.observedProperty.categories[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var category = _step2.value;

                  if (!param.categoryEncoding.has(category.id)) {
                    categoryCounts.push([category, 0]);
                  } else {
                    var count = param.categoryEncoding.get(category.id).map(function (val) {
                      return rawCounts.get(val);
                    }).reduce(function (c1, c2) {
                      return c1 + c2;
                    });
                    categoryCounts.push([category, count]);
                  }
                }

                // convert to ratios
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                    _iterator2['return']();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }

              var totalCount = categoryCounts.map(function (c) {
                return c[1];
              }).reduce(function (c1, c2) {
                return c1 + c2;
              });
              var ratios = categoryCounts.map(function (_ref) {
                var _ref2 = babelHelpers.slicedToArray(_ref, 2);

                var category = _ref2[0];
                var count = _ref2[1];
                return [category, count / totalCount];
              });

              return ratios;
            };

            var processTimeSlices = function processTimeSlices(stats, currentIndex) {
              return cov.subsetByIndex({ t: timeIndices[currentIndex] }).then(function (subset) {
                return subset.loadDomain().then(function (subsetDomain) {
                  return subset.loadRange(param.key).then(function (range) {
                    raiseProgress();

                    var ratios = getRatios(range);
                    stats.push({
                      t: subsetDomain.axes.get('t'),
                      ratios: ratios
                    });

                    if (currentIndex + 1 < total) {
                      return processTimeSlices(stats, currentIndex + 1);
                    } else {
                      return stats;
                    }
                  });
                });
              });
            };

            var asCoverageJSON = function asCoverageJSON(stats) {
              var t = {
                "values": stats.map(function (s) {
                  return s.t.values[0];
                })
              };
              if (stats[0].t.bounds) {
                t["bounds"] = stats.map(function (s) {
                  return s.t.bounds[0];
                });
              }

              var params = {};
              var ranges = {};

              var paramKey = function paramKey(category) {
                return i18n(category.label).replace(/ /g, '_');
              };

              var _iteratorNormalCompletion4 = true;
              var _didIteratorError4 = false;
              var _iteratorError4 = undefined;

              try {
                for (var _iterator4 = param.observedProperty.categories[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  var category = _step4.value;

                  var key = paramKey(category);
                  params[key] = {
                    "type": "Parameter",
                    "observedProperty": {
                      "label": {
                        "en": i18n(category.label) + " Ratio"
                      },
                      "statisticalMeasure": "http://www.uncertml.org/statistics/discrete-probability",
                      "statisticalCategories": [category]
                    }
                  };
                  ranges[key] = {
                    "type": "Range",
                    "dataType": "float",
                    "values": []
                  };
                }
              } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                    _iterator4['return']();
                  }
                } finally {
                  if (_didIteratorError4) {
                    throw _iteratorError4;
                  }
                }
              }

              var _iteratorNormalCompletion5 = true;
              var _didIteratorError5 = false;
              var _iteratorError5 = undefined;

              try {
                for (var _iterator5 = stats[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                  var ratios = _step5.value.ratios;
                  var _iteratorNormalCompletion6 = true;
                  var _didIteratorError6 = false;
                  var _iteratorError6 = undefined;

                  try {
                    for (var _iterator6 = ratios[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                      var _step6$value = babelHelpers.slicedToArray(_step6.value, 2);

                      var category = _step6$value[0];
                      var ratio = _step6$value[1];

                      ranges[paramKey(category)].values.push(ratio);
                    }
                  } catch (err) {
                    _didIteratorError6 = true;
                    _iteratorError6 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion6 && _iterator6['return']) {
                        _iterator6['return']();
                      }
                    } finally {
                      if (_didIteratorError6) {
                        throw _iteratorError6;
                      }
                    }
                  }
                }
              } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion5 && _iterator5['return']) {
                    _iterator5['return']();
                  }
                } finally {
                  if (_didIteratorError5) {
                    throw _iteratorError5;
                  }
                }
              }

              return {
                "type": "Coverage",
                "domain": {
                  "type": "Domain",
                  "axes": {
                    "t": t
                  },
                  "referencing": [referencingUtil.getReferenceObject(domain, 't')]
                },
                "parameters": params,
                "ranges": ranges
              };
            };

            processTimeSlices([], 0).then(function (stats) {
              var covjson = JSON.stringify(asCoverageJSON(stats), null, 2);

              // NOTE: we don't call URL.revokeObjectURL() currently when removing the dataset again
              var blobUrl = URL.createObjectURL(new Blob([covjson], { type: 'application/prs.coverage+json' }));

              // add as dataset
              var prefixTitle = 'Statistics of ';
              var virtualDataset = {
                title: { en: prefixTitle + i18n(_this3.context.dataset.title) },
                virtual: true,
                distributions: [{
                  title: { en: prefixTitle + i18n(_this3.context.dataset.title) },
                  mediaType: 'application/prs.coverage+json',
                  url: blobUrl
                }]
              };
              var workspace = _this3.context.workspace;
              workspace.addDataset(virtualDataset, _this3.context.dataset);
              workspace.requestFocus(virtualDataset);

              modal.close();
            });
          }
        }, {
          key: 'isSupported',
          get: function get() {
            // TODO check if there are other multi-valued axes except x,y,t -> if yes, unsupported

            // data is single grid coverage with one or more categorical parameters
            if (this._isSingleCoverage(this.cov) && this.cov.domainType === COVJSON_GRID) {
              if (this._getCategoricalParams().length > 0) {
                return true;
              }
            }
            return false;
          }
        }]);
        return CoverageCategoriesStatistics;
      })(Action);

      _export('default', CoverageCategoriesStatistics);

      CoverageCategoriesStatistics.type = PROCESS;
    }
  };
});

$__System.registerDynamic("26", ["27", "28", "29"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, "__esModule", {value: true});
  var _slicedToArray = function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  exports.reproject = reproject;
  var _util = req('27');
  var _constants = req('28');
  var _referencing = req('29');
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0,
          arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  function reproject(cov, refDomain) {
    return cov.loadDomain().then(function(sourceDomain) {
      var sourceRef = (0, _referencing.getHorizontalCRSReferenceObject)(sourceDomain);
      if (sourceRef.components.some(sourceDomain.axes.has)) {
        throw new Error('Grid reprojection not supported yet');
      }
      var _sourceRef$components = _slicedToArray(sourceRef.components, 2);
      var xComp = _sourceRef$components[0];
      var yComp = _sourceRef$components[1];
      var axes = [].concat(_toConsumableArray(sourceDomain.axes.values()));
      var axis = axes.find(function(axis) {
        return sourceRef.components.every(function(comp) {
          return axis.components.indexOf(comp) !== -1;
        });
      });
      var xCompIdx = axis.components.indexOf(xComp);
      var yCompIdx = axis.components.indexOf(yComp);
      var sourceProjection = (0, _referencing.getProjection)(sourceDomain);
      var targetProjection = (0, _referencing.getProjection)(refDomain);
      var values = void 0;
      if (axis.dataType === _constants.COVJSON_DATATYPE_TUPLE) {
        values = axis.values.map(function(tuple) {
          return tuple.slice();
        });
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;
        try {
          for (var _iterator = values[Symbol.iterator](),
              _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var tuple = _step.value;
            var sourceX = tuple[xCompIdx];
            var sourceY = tuple[yCompIdx];
            var latlon = sourceProjection.unproject({
              x: sourceX,
              y: sourceY
            });
            var _targetProjection$pro = targetProjection.project(latlon);
            var x = _targetProjection$pro.x;
            var y = _targetProjection$pro.y;
            tuple[xCompIdx] = x;
            tuple[yCompIdx] = y;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else {
        throw new Error('Unsupported data type: ' + axis.dataType);
      }
      var newAxes = new Map(sourceDomain.axes);
      var newAxis = (0, _util.shallowcopy)(axis);
      delete newAxis.bounds;
      newAxis.values = values;
      newAxes.set(axis.key, newAxis);
      var targetRef = (0, _referencing.getHorizontalCRSReferenceObject)(refDomain);
      var newReferencing = sourceDomain.referencing.map(function(ref) {
        if (ref === sourceRef) {
          return {
            components: sourceRef.components,
            system: targetRef.system
          };
        } else {
          return ref;
        }
      });
      var newDomain = {
        type: _constants.DOMAIN,
        domainType: sourceDomain.domainType,
        axes: newAxes,
        referencing: newReferencing
      };
      var newCoverage = {
        type: _constants.COVERAGE,
        domainType: cov.domainType,
        parameters: cov.parameters,
        loadDomain: function loadDomain() {
          return Promise.resolve(newDomain);
        },
        loadRange: function loadRange(paramKey) {
          return cov.loadRange(paramKey);
        },
        loadRanges: function loadRanges(paramKeys) {
          return cov.loadRanges(paramKeys);
        },
        subsetByIndex: function subsetByIndex(constraints) {
          return cov.subsetByIndex(constraints).then(function(sub) {
            return reproject(sub, refDomain);
          });
        },
        subsetByValue: function subsetByValue(constraints) {
          return cov.subsetByValue(constraints).then(function(sub) {
            return reproject(sub, refDomain);
          });
        }
      };
      return newCoverage;
    });
  }
  global.define = __define;
  return module.exports;
});

$__System.register('23', ['26', '2a', '2b'], function (_export) {
  /* */
  'use strict';

  return {
    setters: [function (_) {
      var _exportObj = {};
      _exportObj['reproject'] = _.reproject;

      _export(_exportObj);
    }, function (_a) {
      var _exportObj2 = {};
      _exportObj2['withParameters'] = _a.withParameters;
      _exportObj2['withCategories'] = _a.withCategories;
      _exportObj2['mapRange'] = _a.mapRange;
      _exportObj2['maskByPolygon'] = _a.maskByPolygon;

      _export(_exportObj2);
    }, function (_b) {
      var _exportObj3 = {};
      _exportObj3['subsetByBbox'] = _b.subsetByBbox;

      _export(_exportObj3);
    }],
    execute: function () {}
  };
});

$__System.register("2c", [], function() { return { setters: [], execute: function() {} } });

$__System.registerDynamic("2d", ["2e"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    (function() {
      var root = this;
      if (typeof Math.sgn == "undefined") {
        Math.sgn = function(x) {
          return x == 0 ? 0 : x > 0 ? 1 : -1;
        };
      }
      var Vectors = {
        subtract: function(v1, v2) {
          return {
            x: v1.x - v2.x,
            y: v1.y - v2.y
          };
        },
        dotProduct: function(v1, v2) {
          return (v1.x * v2.x) + (v1.y * v2.y);
        },
        square: function(v) {
          return Math.sqrt((v.x * v.x) + (v.y * v.y));
        },
        scale: function(v, s) {
          return {
            x: v.x * s,
            y: v.y * s
          };
        }
      },
          maxRecursion = 64,
          flatnessTolerance = Math.pow(2.0, -maxRecursion - 1);
      var _distanceFromCurve = function(point, curve) {
        var candidates = [],
            w = _convertToBezier(point, curve),
            degree = curve.length - 1,
            higherDegree = (2 * degree) - 1,
            numSolutions = _findRoots(w, higherDegree, candidates, 0),
            v = Vectors.subtract(point, curve[0]),
            dist = Vectors.square(v),
            t = 0.0;
        for (var i = 0; i < numSolutions; i++) {
          v = Vectors.subtract(point, _bezier(curve, degree, candidates[i], null, null));
          var newDist = Vectors.square(v);
          if (newDist < dist) {
            dist = newDist;
            t = candidates[i];
          }
        }
        v = Vectors.subtract(point, curve[degree]);
        newDist = Vectors.square(v);
        if (newDist < dist) {
          dist = newDist;
          t = 1.0;
        }
        return {
          location: t,
          distance: dist
        };
      };
      var _nearestPointOnCurve = function(point, curve) {
        var td = _distanceFromCurve(point, curve);
        return {
          point: _bezier(curve, curve.length - 1, td.location, null, null),
          location: td.location
        };
      };
      var _convertToBezier = function(point, curve) {
        var degree = curve.length - 1,
            higherDegree = (2 * degree) - 1,
            c = [],
            d = [],
            cdTable = [],
            w = [],
            z = [[1.0, 0.6, 0.3, 0.1], [0.4, 0.6, 0.6, 0.4], [0.1, 0.3, 0.6, 1.0]];
        for (var i = 0; i <= degree; i++)
          c[i] = Vectors.subtract(curve[i], point);
        for (var i = 0; i <= degree - 1; i++) {
          d[i] = Vectors.subtract(curve[i + 1], curve[i]);
          d[i] = Vectors.scale(d[i], 3.0);
        }
        for (var row = 0; row <= degree - 1; row++) {
          for (var column = 0; column <= degree; column++) {
            if (!cdTable[row])
              cdTable[row] = [];
            cdTable[row][column] = Vectors.dotProduct(d[row], c[column]);
          }
        }
        for (i = 0; i <= higherDegree; i++) {
          if (!w[i])
            w[i] = [];
          w[i].y = 0.0;
          w[i].x = parseFloat(i) / higherDegree;
        }
        var n = degree,
            m = degree - 1;
        for (var k = 0; k <= n + m; k++) {
          var lb = Math.max(0, k - m),
              ub = Math.min(k, n);
          for (i = lb; i <= ub; i++) {
            j = k - i;
            w[i + j].y += cdTable[j][i] * z[j][i];
          }
        }
        return w;
      };
      var _findRoots = function(w, degree, t, depth) {
        var left = [],
            right = [],
            left_count,
            right_count,
            left_t = [],
            right_t = [];
        switch (_getCrossingCount(w, degree)) {
          case 0:
            {
              return 0;
            }
          case 1:
            {
              if (depth >= maxRecursion) {
                t[0] = (w[0].x + w[degree].x) / 2.0;
                return 1;
              }
              if (_isFlatEnough(w, degree)) {
                t[0] = _computeXIntercept(w, degree);
                return 1;
              }
              break;
            }
        }
        _bezier(w, degree, 0.5, left, right);
        left_count = _findRoots(left, degree, left_t, depth + 1);
        right_count = _findRoots(right, degree, right_t, depth + 1);
        for (var i = 0; i < left_count; i++)
          t[i] = left_t[i];
        for (var i = 0; i < right_count; i++)
          t[i + left_count] = right_t[i];
        return (left_count + right_count);
      };
      var _getCrossingCount = function(curve, degree) {
        var n_crossings = 0,
            sign,
            old_sign;
        sign = old_sign = Math.sgn(curve[0].y);
        for (var i = 1; i <= degree; i++) {
          sign = Math.sgn(curve[i].y);
          if (sign != old_sign)
            n_crossings++;
          old_sign = sign;
        }
        return n_crossings;
      };
      var _isFlatEnough = function(curve, degree) {
        var error,
            intercept_1,
            intercept_2,
            left_intercept,
            right_intercept,
            a,
            b,
            c,
            det,
            dInv,
            a1,
            b1,
            c1,
            a2,
            b2,
            c2;
        a = curve[0].y - curve[degree].y;
        b = curve[degree].x - curve[0].x;
        c = curve[0].x * curve[degree].y - curve[degree].x * curve[0].y;
        var max_distance_above = max_distance_below = 0.0;
        for (var i = 1; i < degree; i++) {
          var value = a * curve[i].x + b * curve[i].y + c;
          if (value > max_distance_above)
            max_distance_above = value;
          else if (value < max_distance_below)
            max_distance_below = value;
        }
        a1 = 0.0;
        b1 = 1.0;
        c1 = 0.0;
        a2 = a;
        b2 = b;
        c2 = c - max_distance_above;
        det = a1 * b2 - a2 * b1;
        dInv = 1.0 / det;
        intercept_1 = (b1 * c2 - b2 * c1) * dInv;
        a2 = a;
        b2 = b;
        c2 = c - max_distance_below;
        det = a1 * b2 - a2 * b1;
        dInv = 1.0 / det;
        intercept_2 = (b1 * c2 - b2 * c1) * dInv;
        left_intercept = Math.min(intercept_1, intercept_2);
        right_intercept = Math.max(intercept_1, intercept_2);
        error = right_intercept - left_intercept;
        return (error < flatnessTolerance) ? 1 : 0;
      };
      var _computeXIntercept = function(curve, degree) {
        var XLK = 1.0,
            YLK = 0.0,
            XNM = curve[degree].x - curve[0].x,
            YNM = curve[degree].y - curve[0].y,
            XMK = curve[0].x - 0.0,
            YMK = curve[0].y - 0.0,
            det = XNM * YLK - YNM * XLK,
            detInv = 1.0 / det,
            S = (XNM * YMK - YNM * XMK) * detInv;
        return 0.0 + XLK * S;
      };
      var _bezier = function(curve, degree, t, left, right) {
        var temp = [[]];
        for (var j = 0; j <= degree; j++)
          temp[0][j] = curve[j];
        for (var i = 1; i <= degree; i++) {
          for (var j = 0; j <= degree - i; j++) {
            if (!temp[i])
              temp[i] = [];
            if (!temp[i][j])
              temp[i][j] = {};
            temp[i][j].x = (1.0 - t) * temp[i - 1][j].x + t * temp[i - 1][j + 1].x;
            temp[i][j].y = (1.0 - t) * temp[i - 1][j].y + t * temp[i - 1][j + 1].y;
          }
        }
        if (left != null)
          for (j = 0; j <= degree; j++)
            left[j] = temp[j][0];
        if (right != null)
          for (j = 0; j <= degree; j++)
            right[j] = temp[degree - j][j];
        return (temp[degree][0]);
      };
      var _curveFunctionCache = {};
      var _getCurveFunctions = function(order) {
        var fns = _curveFunctionCache[order];
        if (!fns) {
          fns = [];
          var f_term = function() {
            return function(t) {
              return Math.pow(t, order);
            };
          },
              l_term = function() {
                return function(t) {
                  return Math.pow((1 - t), order);
                };
              },
              c_term = function(c) {
                return function(t) {
                  return c;
                };
              },
              t_term = function() {
                return function(t) {
                  return t;
                };
              },
              one_minus_t_term = function() {
                return function(t) {
                  return 1 - t;
                };
              },
              _termFunc = function(terms) {
                return function(t) {
                  var p = 1;
                  for (var i = 0; i < terms.length; i++)
                    p = p * terms[i](t);
                  return p;
                };
              };
          fns.push(new f_term());
          for (var i = 1; i < order; i++) {
            var terms = [new c_term(order)];
            for (var j = 0; j < (order - i); j++)
              terms.push(new t_term());
            for (var j = 0; j < i; j++)
              terms.push(new one_minus_t_term());
            fns.push(new _termFunc(terms));
          }
          fns.push(new l_term());
          _curveFunctionCache[order] = fns;
        }
        return fns;
      };
      var _pointOnPath = function(curve, location) {
        var cc = _getCurveFunctions(curve.length - 1),
            _x = 0,
            _y = 0;
        for (var i = 0; i < curve.length; i++) {
          _x = _x + (curve[i].x * cc[i](location));
          _y = _y + (curve[i].y * cc[i](location));
        }
        return {
          x: _x,
          y: _y
        };
      };
      var _dist = function(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
      };
      var _isPoint = function(curve) {
        return curve[0].x == curve[1].x && curve[0].y == curve[1].y;
      };
      var _pointAlongPath = function(curve, location, distance) {
        if (_isPoint(curve)) {
          return {
            point: curve[0],
            location: location
          };
        }
        var prev = _pointOnPath(curve, location),
            tally = 0,
            curLoc = location,
            direction = distance > 0 ? 1 : -1,
            cur = null;
        while (tally < Math.abs(distance)) {
          curLoc += (0.005 * direction);
          cur = _pointOnPath(curve, curLoc);
          tally += _dist(cur, prev);
          prev = cur;
        }
        return {
          point: cur,
          location: curLoc
        };
      };
      var _length = function(curve) {
        if (_isPoint(curve))
          return 0;
        var prev = _pointOnPath(curve, 0),
            tally = 0,
            curLoc = 0,
            direction = 1,
            cur = null;
        while (curLoc < 1) {
          curLoc += (0.005 * direction);
          cur = _pointOnPath(curve, curLoc);
          tally += _dist(cur, prev);
          prev = cur;
        }
        return tally;
      };
      var _pointAlongPathFrom = function(curve, location, distance) {
        return _pointAlongPath(curve, location, distance).point;
      };
      var _locationAlongPathFrom = function(curve, location, distance) {
        return _pointAlongPath(curve, location, distance).location;
      };
      var _gradientAtPoint = function(curve, location) {
        var p1 = _pointOnPath(curve, location),
            p2 = _pointOnPath(curve.slice(0, curve.length - 1), location),
            dy = p2.y - p1.y,
            dx = p2.x - p1.x;
        return dy == 0 ? Infinity : Math.atan(dy / dx);
      };
      var _gradientAtPointAlongPathFrom = function(curve, location, distance) {
        var p = _pointAlongPath(curve, location, distance);
        if (p.location > 1)
          p.location = 1;
        if (p.location < 0)
          p.location = 0;
        return _gradientAtPoint(curve, p.location);
      };
      var _perpendicularToPathAt = function(curve, location, length, distance) {
        distance = distance == null ? 0 : distance;
        var p = _pointAlongPath(curve, location, distance),
            m = _gradientAtPoint(curve, p.location),
            _theta2 = Math.atan(-1 / m),
            y = length / 2 * Math.sin(_theta2),
            x = length / 2 * Math.cos(_theta2);
        return [{
          x: p.point.x + x,
          y: p.point.y + y
        }, {
          x: p.point.x - x,
          y: p.point.y - y
        }];
      };
      this.jsBezier = {
        distanceFromCurve: _distanceFromCurve,
        gradientAtPoint: _gradientAtPoint,
        gradientAtPointAlongCurveFrom: _gradientAtPointAlongPathFrom,
        nearestPointOnCurve: _nearestPointOnCurve,
        pointOnCurve: _pointOnPath,
        pointAlongCurveFrom: _pointAlongPathFrom,
        perpendicularToCurveAt: _perpendicularToPathAt,
        locationAlongCurveFrom: _locationAlongPathFrom,
        getLength: _length
      };
    }).call(this);
    ;
    (function() {
      "use strict";
      var Biltong = this.Biltong = {};
      var _isa = function(a) {
        return Object.prototype.toString.call(a) === "[object Array]";
      },
          _pointHelper = function(p1, p2, fn) {
            p1 = _isa(p1) ? p1 : [p1.x, p1.y];
            p2 = _isa(p2) ? p2 : [p2.x, p2.y];
            return fn(p1, p2);
          },
          _gradient = Biltong.gradient = function(p1, p2) {
            return _pointHelper(p1, p2, function(_p1, _p2) {
              if (_p2[0] == _p1[0])
                return _p2[1] > _p1[1] ? Infinity : -Infinity;
              else if (_p2[1] == _p1[1])
                return _p2[0] > _p1[0] ? 0 : -0;
              else
                return (_p2[1] - _p1[1]) / (_p2[0] - _p1[0]);
            });
          },
          _normal = Biltong.normal = function(p1, p2) {
            return -1 / _gradient(p1, p2);
          },
          _lineLength = Biltong.lineLength = function(p1, p2) {
            return _pointHelper(p1, p2, function(_p1, _p2) {
              return Math.sqrt(Math.pow(_p2[1] - _p1[1], 2) + Math.pow(_p2[0] - _p1[0], 2));
            });
          },
          _quadrant = Biltong.quadrant = function(p1, p2) {
            return _pointHelper(p1, p2, function(_p1, _p2) {
              if (_p2[0] > _p1[0]) {
                return (_p2[1] > _p1[1]) ? 2 : 1;
              } else if (_p2[0] == _p1[0]) {
                return _p2[1] > _p1[1] ? 2 : 1;
              } else {
                return (_p2[1] > _p1[1]) ? 3 : 4;
              }
            });
          },
          _theta = Biltong.theta = function(p1, p2) {
            return _pointHelper(p1, p2, function(_p1, _p2) {
              var m = _gradient(_p1, _p2),
                  t = Math.atan(m),
                  s = _quadrant(_p1, _p2);
              if ((s == 4 || s == 3))
                t += Math.PI;
              if (t < 0)
                t += (2 * Math.PI);
              return t;
            });
          },
          _intersects = Biltong.intersects = function(r1, r2) {
            var x1 = r1.x,
                x2 = r1.x + r1.w,
                y1 = r1.y,
                y2 = r1.y + r1.h,
                a1 = r2.x,
                a2 = r2.x + r2.w,
                b1 = r2.y,
                b2 = r2.y + r2.h;
            return ((x1 <= a1 && a1 <= x2) && (y1 <= b1 && b1 <= y2)) || ((x1 <= a2 && a2 <= x2) && (y1 <= b1 && b1 <= y2)) || ((x1 <= a1 && a1 <= x2) && (y1 <= b2 && b2 <= y2)) || ((x1 <= a2 && a1 <= x2) && (y1 <= b2 && b2 <= y2)) || ((a1 <= x1 && x1 <= a2) && (b1 <= y1 && y1 <= b2)) || ((a1 <= x2 && x2 <= a2) && (b1 <= y1 && y1 <= b2)) || ((a1 <= x1 && x1 <= a2) && (b1 <= y2 && y2 <= b2)) || ((a1 <= x2 && x1 <= a2) && (b1 <= y2 && y2 <= b2));
          },
          _encloses = Biltong.encloses = function(r1, r2, allowSharedEdges) {
            var x1 = r1.x,
                x2 = r1.x + r1.w,
                y1 = r1.y,
                y2 = r1.y + r1.h,
                a1 = r2.x,
                a2 = r2.x + r2.w,
                b1 = r2.y,
                b2 = r2.y + r2.h,
                c = function(v1, v2, v3, v4) {
                  return allowSharedEdges ? v1 <= v2 && v3 >= v4 : v1 < v2 && v3 > v4;
                };
            return c(x1, a1, x2, a2) && c(y1, b1, y2, b2);
          },
          _segmentMultipliers = [null, [1, -1], [1, 1], [-1, 1], [-1, -1]],
          _inverseSegmentMultipliers = [null, [-1, -1], [-1, 1], [1, 1], [1, -1]],
          _pointOnLine = Biltong.pointOnLine = function(fromPoint, toPoint, distance) {
            var m = _gradient(fromPoint, toPoint),
                s = _quadrant(fromPoint, toPoint),
                segmentMultiplier = distance > 0 ? _segmentMultipliers[s] : _inverseSegmentMultipliers[s],
                theta = Math.atan(m),
                y = Math.abs(distance * Math.sin(theta)) * segmentMultiplier[1],
                x = Math.abs(distance * Math.cos(theta)) * segmentMultiplier[0];
            return {
              x: fromPoint.x + x,
              y: fromPoint.y + y
            };
          },
          _perpendicularLineTo = Biltong.perpendicularLineTo = function(fromPoint, toPoint, length) {
            var m = _gradient(fromPoint, toPoint),
                theta2 = Math.atan(-1 / m),
                y = length / 2 * Math.sin(theta2),
                x = length / 2 * Math.cos(theta2);
            return [{
              x: toPoint.x + x,
              y: toPoint.y + y
            }, {
              x: toPoint.x - x,
              y: toPoint.y - y
            }];
          };
    }).call(this);
    ;
    (function() {
      "use strict";
      var root = this,
          Sniff = {android: navigator.userAgent.toLowerCase().indexOf("android") > -1},
          matchesSelector = function(el, selector, ctx) {
            ctx = ctx || el.parentNode;
            var possibles = ctx.querySelectorAll(selector);
            for (var i = 0; i < possibles.length; i++) {
              if (possibles[i] === el) {
                return true;
              }
            }
            return false;
          },
          _gel = function(el) {
            return (typeof el == "string" || el.constructor === String) ? document.getElementById(el) : el;
          },
          _t = function(e) {
            return e.srcElement || e.target;
          },
          _d = function(l, fn) {
            for (var i = 0,
                j = l.length; i < j; i++) {
              if (l[i] == fn)
                break;
            }
            if (i < l.length)
              l.splice(i, 1);
          },
          guid = 1,
          _store = function(obj, event, fn) {
            var g = guid++;
            obj.__ta = obj.__ta || {};
            obj.__ta[event] = obj.__ta[event] || {};
            obj.__ta[event][g] = fn;
            fn.__tauid = g;
            return g;
          },
          _unstore = function(obj, event, fn) {
            obj.__ta && obj.__ta[event] && delete obj.__ta[event][fn.__tauid];
            if (fn.__taExtra) {
              for (var i = 0; i < fn.__taExtra.length; i++) {
                _unbind(obj, fn.__taExtra[i][0], fn.__taExtra[i][1]);
              }
              fn.__taExtra.length = 0;
            }
            fn.__taUnstore && fn.__taUnstore();
          },
          _curryChildFilter = function(children, obj, fn, evt) {
            if (children == null)
              return fn;
            else {
              var c = children.split(","),
                  _fn = function(e) {
                    _fn.__tauid = fn.__tauid;
                    var t = _t(e);
                    for (var i = 0; i < c.length; i++) {
                      if (matchesSelector(t, c[i], obj)) {
                        fn.apply(t, arguments);
                      }
                    }
                  };
              registerExtraFunction(fn, evt, _fn);
              return _fn;
            }
          },
          registerExtraFunction = function(fn, evt, newFn) {
            fn.__taExtra = fn.__taExtra || [];
            fn.__taExtra.push([evt, newFn]);
          },
          DefaultHandler = function(obj, evt, fn, children) {
            if (isTouchDevice && touchMap[evt]) {
              var tfn = _curryChildFilter(children, obj, fn, touchMap[evt]);
              _bind(obj, touchMap[evt], tfn, fn);
            }
            if (evt === "focus" && obj.getAttribute("tabindex") == null) {
              obj.setAttribute("tabindex", "1");
            }
            _bind(obj, evt, _curryChildFilter(children, obj, fn, evt), fn);
          },
          SmartClickHandler = function(obj, evt, fn, children) {
            if (obj.__taSmartClicks == null) {
              var down = function(e) {
                obj.__tad = _pageLocation(e);
              },
                  up = function(e) {
                    obj.__tau = _pageLocation(e);
                  },
                  click = function(e) {
                    if (obj.__tad && obj.__tau && obj.__tad[0] === obj.__tau[0] && obj.__tad[1] === obj.__tau[1]) {
                      for (var i = 0; i < obj.__taSmartClicks.length; i++)
                        obj.__taSmartClicks[i].apply(_t(e), [e]);
                    }
                  };
              DefaultHandler(obj, "mousedown", down, children);
              DefaultHandler(obj, "mouseup", up, children);
              DefaultHandler(obj, "click", click, children);
              obj.__taSmartClicks = [];
            }
            obj.__taSmartClicks.push(fn);
            fn.__taUnstore = function() {
              _d(obj.__taSmartClicks, fn);
            };
          },
          _tapProfiles = {
            "tap": {
              touches: 1,
              taps: 1
            },
            "dbltap": {
              touches: 1,
              taps: 2
            },
            "contextmenu": {
              touches: 2,
              taps: 1
            }
          },
          TapHandler = function(clickThreshold, dblClickThreshold) {
            return function(obj, evt, fn, children) {
              if (evt == "contextmenu" && isMouseDevice)
                DefaultHandler(obj, evt, fn, children);
              else {
                if (obj.__taTapHandler == null) {
                  var tt = obj.__taTapHandler = {
                    tap: [],
                    dbltap: [],
                    contextmenu: [],
                    down: false,
                    taps: 0,
                    downSelectors: []
                  };
                  var down = function(e) {
                    var target = e.srcElement || e.target;
                    for (var i = 0; i < tt.downSelectors.length; i++) {
                      if (tt.downSelectors[i] == null || matchesSelector(target, tt.downSelectors[i], obj)) {
                        tt.down = true;
                        setTimeout(clearSingle, clickThreshold);
                        setTimeout(clearDouble, dblClickThreshold);
                        break;
                      }
                    }
                  },
                      up = function(e) {
                        if (tt.down) {
                          var target = e.srcElement || e.target;
                          tt.taps++;
                          var tc = _touchCount(e);
                          for (var eventId in _tapProfiles) {
                            if (_tapProfiles.hasOwnProperty(eventId)) {
                              var p = _tapProfiles[eventId];
                              if (p.touches === tc && (p.taps === 1 || p.taps === tt.taps)) {
                                for (var i = 0; i < tt[eventId].length; i++) {
                                  if (tt[eventId][i][1] == null || matchesSelector(target, tt[eventId][i][1], obj))
                                    tt[eventId][i][0].apply(_t(e), [e]);
                                }
                              }
                            }
                          }
                        }
                      },
                      clearSingle = function() {
                        tt.down = false;
                      },
                      clearDouble = function() {
                        tt.taps = 0;
                      };
                  DefaultHandler(obj, "mousedown", down);
                  DefaultHandler(obj, "mouseup", up);
                }
                obj.__taTapHandler.downSelectors.push(children);
                obj.__taTapHandler[evt].push([fn, children]);
                fn.__taUnstore = function() {
                  _d(obj.__taTapHandler[evt], fn);
                };
              }
            };
          },
          meeHelper = function(type, evt, obj, target) {
            for (var i in obj.__tamee[type]) {
              if (obj.__tamee[type].hasOwnProperty(i)) {
                obj.__tamee[type][i].apply(target, [evt]);
              }
            }
          },
          MouseEnterExitHandler = function() {
            var activeElements = [];
            return function(obj, evt, fn, children) {
              if (!obj.__tamee) {
                obj.__tamee = {
                  over: false,
                  mouseenter: [],
                  mouseexit: []
                };
                var over = function(e) {
                  var t = _t(e);
                  if ((children == null && (t == obj && !obj.__tamee.over)) || (matchesSelector(t, children, obj) && (t.__tamee == null || !t.__tamee.over))) {
                    meeHelper("mouseenter", e, obj, t);
                    t.__tamee = t.__tamee || {};
                    t.__tamee.over = true;
                    activeElements.push(t);
                  }
                },
                    out = function(e) {
                      var t = _t(e);
                      for (var i = 0; i < activeElements.length; i++) {
                        if (t == activeElements[i] && !matchesSelector((e.relatedTarget || e.toElement), "*", t)) {
                          t.__tamee.over = false;
                          activeElements.splice(i, 1);
                          meeHelper("mouseexit", e, obj, t);
                        }
                      }
                    };
                _bind(obj, "mouseover", _curryChildFilter(children, obj, over, "mouseover"), over);
                _bind(obj, "mouseout", _curryChildFilter(children, obj, out, "mouseout"), out);
              }
              fn.__taUnstore = function() {
                delete obj.__tamee[evt][fn.__tauid];
              };
              _store(obj, evt, fn);
              obj.__tamee[evt][fn.__tauid] = fn;
            };
          },
          isTouchDevice = "ontouchstart" in document.documentElement,
          isMouseDevice = "onmousedown" in document.documentElement,
          touchMap = {
            "mousedown": "touchstart",
            "mouseup": "touchend",
            "mousemove": "touchmove"
          },
          touchstart = "touchstart",
          touchend = "touchend",
          touchmove = "touchmove",
          iev = (function() {
            var rv = -1;
            if (navigator.appName == 'Microsoft Internet Explorer') {
              var ua = navigator.userAgent,
                  re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
              if (re.exec(ua) != null)
                rv = parseFloat(RegExp.$1);
            }
            return rv;
          })(),
          isIELT9 = iev > -1 && iev < 9,
          _genLoc = function(e, prefix) {
            if (e == null)
              return [0, 0];
            var ts = _touches(e),
                t = _getTouch(ts, 0);
            return [t[prefix + "X"], t[prefix + "Y"]];
          },
          _pageLocation = function(e) {
            if (e == null)
              return [0, 0];
            if (isIELT9) {
              return [e.clientX + document.documentElement.scrollLeft, e.clientY + document.documentElement.scrollTop];
            } else {
              return _genLoc(e, "page");
            }
          },
          _screenLocation = function(e) {
            return _genLoc(e, "screen");
          },
          _clientLocation = function(e) {
            return _genLoc(e, "client");
          },
          _getTouch = function(touches, idx) {
            return touches.item ? touches.item(idx) : touches[idx];
          },
          _touches = function(e) {
            return e.touches && e.touches.length > 0 ? e.touches : e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches : e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches : [e];
          },
          _touchCount = function(e) {
            return _touches(e).length;
          },
          _bind = function(obj, type, fn, originalFn) {
            _store(obj, type, fn);
            originalFn.__tauid = fn.__tauid;
            if (obj.addEventListener)
              obj.addEventListener(type, fn, false);
            else if (obj.attachEvent) {
              var key = type + fn.__tauid;
              obj["e" + key] = fn;
              obj[key] = function() {
                obj["e" + key] && obj["e" + key](window.event);
              };
              obj.attachEvent("on" + type, obj[key]);
            }
          },
          _unbind = function(obj, type, fn) {
            if (fn == null)
              return;
            _each(obj, function() {
              var _el = _gel(this);
              _unstore(_el, type, fn);
              if (fn.__tauid != null) {
                if (_el.removeEventListener) {
                  _el.removeEventListener(type, fn, false);
                  if (isTouchDevice && touchMap[type])
                    _el.removeEventListener(touchMap[type], fn, false);
                } else if (this.detachEvent) {
                  var key = type + fn.__tauid;
                  _el[key] && _el.detachEvent("on" + type, _el[key]);
                  _el[key] = null;
                  _el["e" + key] = null;
                }
              }
              if (fn.__taTouchProxy) {
                _unbind(obj, fn.__taTouchProxy[1], fn.__taTouchProxy[0]);
              }
            });
          },
          _each = function(obj, fn) {
            if (obj == null)
              return;
            obj = (typeof Window !== "undefined" && (typeof obj.top !== "unknown" && obj == obj.top)) ? [obj] : (typeof obj !== "string") && (obj.tagName == null && obj.length != null) ? obj : typeof obj === "string" ? document.querySelectorAll(obj) : [obj];
            for (var i = 0; i < obj.length; i++)
              fn.apply(obj[i]);
          };
      root.Mottle = function(params) {
        params = params || {};
        var clickThreshold = params.clickThreshold || 150,
            dblClickThreshold = params.dblClickThreshold || 350,
            mouseEnterExitHandler = new MouseEnterExitHandler(),
            tapHandler = new TapHandler(clickThreshold, dblClickThreshold),
            _smartClicks = params.smartClicks,
            _doBind = function(obj, evt, fn, children) {
              if (fn == null)
                return;
              _each(obj, function() {
                var _el = _gel(this);
                if (_smartClicks && evt === "click")
                  SmartClickHandler(_el, evt, fn, children);
                else if (evt === "tap" || evt === "dbltap" || evt === "contextmenu") {
                  tapHandler(_el, evt, fn, children);
                } else if (evt === "mouseenter" || evt == "mouseexit")
                  mouseEnterExitHandler(_el, evt, fn, children);
                else
                  DefaultHandler(_el, evt, fn, children);
              });
            };
        this.remove = function(el) {
          _each(el, function() {
            var _el = _gel(this);
            if (_el.__ta) {
              for (var evt in _el.__ta) {
                if (_el.__ta.hasOwnProperty(evt)) {
                  for (var h in _el.__ta[evt]) {
                    if (_el.__ta[evt].hasOwnProperty(h))
                      _unbind(_el, evt, _el.__ta[evt][h]);
                  }
                }
              }
            }
            _el.parentNode && _el.parentNode.removeChild(_el);
          });
          return this;
        };
        this.on = function(el, event, children, fn) {
          var _el = arguments[0],
              _c = arguments.length == 4 ? arguments[2] : null,
              _e = arguments[1],
              _f = arguments[arguments.length - 1];
          _doBind(_el, _e, _f, _c);
          return this;
        };
        this.off = function(el, event, fn) {
          _unbind(el, event, fn);
          return this;
        };
        this.trigger = function(el, event, originalEvent, payload) {
          var originalIsMouse = isMouseDevice && (typeof MouseEvent === "undefined" || originalEvent == null || originalEvent.constructor === MouseEvent);
          var eventToBind = (isTouchDevice && !isMouseDevice && touchMap[event]) ? touchMap[event] : event,
              bindingAMouseEvent = !(isTouchDevice && !isMouseDevice && touchMap[event]);
          var pl = _pageLocation(originalEvent),
              sl = _screenLocation(originalEvent),
              cl = _clientLocation(originalEvent);
          _each(el, function() {
            var _el = _gel(this),
                evt;
            originalEvent = originalEvent || {
              screenX: sl[0],
              screenY: sl[1],
              clientX: cl[0],
              clientY: cl[1]
            };
            var _decorate = function(_evt) {
              if (payload)
                _evt.payload = payload;
            };
            var eventGenerators = {
              "TouchEvent": function(evt) {
                var touch = document.createTouch(window, _el, 0, pl[0], pl[1], sl[0], sl[1], cl[0], cl[1], 0, 0, 0, 0);
                var touches = document.createTouchList(touch);
                var targetTouches = document.createTouchList(touch);
                var changedTouches = document.createTouchList(touch);
                evt.initTouchEvent(eventToBind, true, true, window, null, sl[0], sl[1], cl[0], cl[1], false, false, false, false, touches, targetTouches, changedTouches, 1, 0);
              },
              "MouseEvents": function(evt) {
                evt.initMouseEvent(eventToBind, true, true, window, 0, sl[0], sl[1], cl[0], cl[1], false, false, false, false, 1, _el);
                if (Sniff.android) {
                  var t = document.createTouch(window, _el, 0, pl[0], pl[1], sl[0], sl[1], cl[0], cl[1], 0, 0, 0, 0);
                  evt.touches = evt.targetTouches = evt.changedTouches = document.createTouchList(t);
                }
              }
            };
            if (document.createEvent) {
              var ite = !bindingAMouseEvent && !originalIsMouse && (isTouchDevice && touchMap[event] && !Sniff.android),
                  evtName = ite ? "TouchEvent" : "MouseEvents";
              evt = document.createEvent(evtName);
              eventGenerators[evtName](evt);
              _decorate(evt);
              _el.dispatchEvent(evt);
            } else if (document.createEventObject) {
              evt = document.createEventObject();
              evt.eventType = evt.eventName = eventToBind;
              evt.screenX = sl[0];
              evt.screenY = sl[1];
              evt.clientX = cl[0];
              evt.clientY = cl[1];
              _decorate(evt);
              _el.fireEvent('on' + eventToBind, evt);
            }
          });
          return this;
        };
      };
      root.Mottle.consume = function(e, doNotPreventDefault) {
        if (e.stopPropagation)
          e.stopPropagation();
        else
          e.returnValue = false;
        if (!doNotPreventDefault && e.preventDefault)
          e.preventDefault();
      };
      root.Mottle.pageLocation = _pageLocation;
      root.Mottle.setForceTouchEvents = function(value) {
        isTouchDevice = value;
      };
      root.Mottle.setForceMouseEvents = function(value) {
        isMouseDevice = value;
      };
    }).call(this);
    ;
    (function() {
      "use strict";
      var _suggest = function(list, item, head) {
        if (list.indexOf(item) === -1) {
          head ? list.unshift(item) : list.push(item);
          return true;
        }
        return false;
      };
      var _vanquish = function(list, item) {
        var idx = list.indexOf(item);
        if (idx != -1)
          list.splice(idx, 1);
      };
      var _difference = function(l1, l2) {
        var d = [];
        for (var i = 0; i < l1.length; i++) {
          if (l2.indexOf(l1[i]) == -1)
            d.push(l1[i]);
        }
        return d;
      };
      var _isString = function(f) {
        return f == null ? false : (typeof f === "string" || f.constructor == String);
      };
      var getOffsetRect = function(elem) {
        var box = elem.getBoundingClientRect(),
            body = document.body,
            docElem = document.documentElement,
            scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
            scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
            clientTop = docElem.clientTop || body.clientTop || 0,
            clientLeft = docElem.clientLeft || body.clientLeft || 0,
            top = box.top + scrollTop - clientTop,
            left = box.left + scrollLeft - clientLeft;
        return {
          top: Math.round(top),
          left: Math.round(left)
        };
      };
      var matchesSelector = function(el, selector, ctx) {
        ctx = ctx || el.parentNode;
        var possibles = ctx.querySelectorAll(selector);
        for (var i = 0; i < possibles.length; i++) {
          if (possibles[i] === el)
            return true;
        }
        return false;
      };
      var iev = (function() {
        var rv = -1;
        if (navigator.appName == 'Microsoft Internet Explorer') {
          var ua = navigator.userAgent,
              re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
          if (re.exec(ua) != null)
            rv = parseFloat(RegExp.$1);
        }
        return rv;
      })(),
          DEFAULT_GRID_X = 50,
          DEFAULT_GRID_Y = 50,
          isIELT9 = iev > -1 && iev < 9,
          isIE9 = iev == 9,
          _pl = function(e) {
            if (isIELT9) {
              return [e.clientX + document.documentElement.scrollLeft, e.clientY + document.documentElement.scrollTop];
            } else {
              var ts = _touches(e),
                  t = _getTouch(ts, 0);
              return isIE9 ? [t.pageX || t.clientX, t.pageY || t.clientY] : [t.pageX, t.pageY];
            }
          },
          _getTouch = function(touches, idx) {
            return touches.item ? touches.item(idx) : touches[idx];
          },
          _touches = function(e) {
            return e.touches && e.touches.length > 0 ? e.touches : e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches : e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches : [e];
          },
          _classes = {
            draggable: "katavorio-draggable",
            droppable: "katavorio-droppable",
            drag: "katavorio-drag",
            selected: "katavorio-drag-selected",
            active: "katavorio-drag-active",
            hover: "katavorio-drag-hover",
            noSelect: "katavorio-drag-no-select"
          },
          _defaultScope = "katavorio-drag-scope",
          _events = ["stop", "start", "drag", "drop", "over", "out", "beforeStart"],
          _devNull = function() {},
          _true = function() {
            return true;
          },
          _foreach = function(l, fn, from) {
            for (var i = 0; i < l.length; i++) {
              if (l[i] != from)
                fn(l[i]);
            }
          },
          _setDroppablesActive = function(dd, val, andHover, drag) {
            _foreach(dd, function(e) {
              e.setActive(val);
              if (val)
                e.updatePosition();
              if (andHover)
                e.setHover(drag, val);
            });
          },
          _each = function(obj, fn) {
            if (obj == null)
              return;
            obj = !_isString(obj) && (obj.tagName == null && obj.length != null) ? obj : [obj];
            for (var i = 0; i < obj.length; i++)
              fn.apply(obj[i], [obj[i]]);
          },
          _consume = function(e) {
            if (e.stopPropagation) {
              e.stopPropagation();
              e.preventDefault();
            } else {
              e.returnValue = false;
            }
          },
          _defaultInputFilterSelector = "input,textarea,select,button,option",
          _inputFilter = function(e, el, _katavorio) {
            var t = e.srcElement || e.target;
            return !matchesSelector(t, _katavorio.getInputFilterSelector(), el);
          };
      var Super = function(el, params, css, scope) {
        this.params = params || {};
        this.el = el;
        this.params.addClass(this.el, this._class);
        this.uuid = _uuid();
        var enabled = true;
        this.setEnabled = function(e) {
          enabled = e;
        };
        this.isEnabled = function() {
          return enabled;
        };
        this.toggleEnabled = function() {
          enabled = !enabled;
        };
        this.setScope = function(scopes) {
          this.scopes = scopes ? scopes.split(/\s+/) : [scope];
        };
        this.addScope = function(scopes) {
          var m = {};
          _each(this.scopes, function(s) {
            m[s] = true;
          });
          _each(scopes ? scopes.split(/\s+/) : [], function(s) {
            m[s] = true;
          });
          this.scopes = [];
          for (var i in m)
            this.scopes.push(i);
        };
        this.removeScope = function(scopes) {
          var m = {};
          _each(this.scopes, function(s) {
            m[s] = true;
          });
          _each(scopes ? scopes.split(/\s+/) : [], function(s) {
            delete m[s];
          });
          this.scopes = [];
          for (var i in m)
            this.scopes.push(i);
        };
        this.toggleScope = function(scopes) {
          var m = {};
          _each(this.scopes, function(s) {
            m[s] = true;
          });
          _each(scopes ? scopes.split(/\s+/) : [], function(s) {
            if (m[s])
              delete m[s];
            else
              m[s] = true;
          });
          this.scopes = [];
          for (var i in m)
            this.scopes.push(i);
        };
        this.setScope(params.scope);
        this.k = params.katavorio;
        return params.katavorio;
      };
      var Drag = function(el, params, css, scope) {
        this._class = css.draggable;
        var k = Super.apply(this, arguments);
        this.rightButtonCanDrag = this.params.rightButtonCanDrag;
        var downAt = [0, 0],
            posAtDown = null,
            moving = false,
            consumeStartEvent = this.params.consumeStartEvent !== false,
            dragEl = this.el,
            clone = this.params.clone,
            scroll = this.params.scroll,
            _multipleDrop = params.multipleDrop !== false;
        var snapThreshold = params.snapThreshold || 5,
            _snap = function(pos, x, y, thresholdX, thresholdY) {
              thresholdX = thresholdX || snapThreshold;
              thresholdY = thresholdY || snapThreshold;
              var _dx = Math.floor(pos[0] / x),
                  _dxl = x * _dx,
                  _dxt = _dxl + x,
                  _x = Math.abs(pos[0] - _dxl) <= thresholdX ? _dxl : Math.abs(_dxt - pos[0]) <= thresholdX ? _dxt : pos[0];
              var _dy = Math.floor(pos[1] / y),
                  _dyl = y * _dy,
                  _dyt = _dyl + y,
                  _y = Math.abs(pos[1] - _dyl) <= thresholdY ? _dyl : Math.abs(_dyt - pos[1]) <= thresholdY ? _dyt : pos[1];
              return [_x, _y];
            };
        this.posses = [];
        this.posseRoles = {};
        this.toGrid = function(pos) {
          if (this.params.grid == null) {
            return pos;
          } else {
            return _snap(pos, this.params.grid[0], this.params.grid[1]);
          }
        };
        this.snap = function(x, y) {
          if (dragEl == null)
            return;
          x = x || (this.params.grid ? this.params.grid[0] : DEFAULT_GRID_X);
          y = y || (this.params.grid ? this.params.grid[1] : DEFAULT_GRID_Y);
          var p = this.params.getPosition(dragEl);
          this.params.setPosition(dragEl, _snap(p, x, y, x, y));
        };
        this.constrain = typeof this.params.constrain === "function" ? this.params.constrain : (this.params.constrain || this.params.containment) ? function(pos) {
          return [Math.max(0, Math.min(constrainRect.w - this.size[0], pos[0])), Math.max(0, Math.min(constrainRect.h - this.size[1], pos[1]))];
        } : function(pos) {
          return pos;
        };
        var _assignId = function(obj) {
          if (typeof obj == "function") {
            obj._katavorioId = _uuid();
            return obj._katavorioId;
          } else {
            return obj;
          }
        },
            _filters = {},
            _testFilter = function(e) {
              for (var key in _filters) {
                var f = _filters[key];
                var rv = f[0](e);
                if (f[1])
                  rv = !rv;
                if (!rv)
                  return false;
              }
              return true;
            },
            _setFilter = this.setFilter = function(f, _exclude) {
              if (f) {
                var key = _assignId(f);
                _filters[key] = [function(e) {
                  var t = e.srcElement || e.target,
                      m;
                  if (_isString(f)) {
                    m = matchesSelector(t, f, el);
                  } else if (typeof f === "function") {
                    m = f(e, el);
                  }
                  return m;
                }, _exclude !== false];
              }
            },
            _addFilter = this.addFilter = _setFilter,
            _removeFilter = this.removeFilter = function(f) {
              var key = typeof f == "function" ? f._katavorioId : f;
              delete _filters[key];
            };
        this.clearAllFilters = function() {
          _filters = {};
        };
        this.canDrag = this.params.canDrag || _true;
        var constrainRect,
            matchingDroppables = [],
            intersectingDroppables = [];
        this.downListener = function(e) {
          var isNotRightClick = this.rightButtonCanDrag || (e.which !== 3 && e.button !== 2);
          if (isNotRightClick && this.isEnabled() && this.canDrag()) {
            var _f = _testFilter(e) && _inputFilter(e, this.el, this.k);
            if (_f) {
              if (!clone)
                dragEl = this.el;
              else {
                dragEl = this.el.cloneNode(true);
                dragEl.setAttribute("id", null);
                dragEl.style.position = "absolute";
                var b = getOffsetRect(this.el);
                dragEl.style.left = b.left + "px";
                dragEl.style.top = b.top + "px";
                document.body.appendChild(dragEl);
              }
              consumeStartEvent && _consume(e);
              downAt = _pl(e);
              this.params.bind(document, "mousemove", this.moveListener);
              this.params.bind(document, "mouseup", this.upListener);
              k.markSelection(this);
              k.markPosses(this);
              this.params.addClass(document.body, css.noSelect);
              _dispatch("beforeStart", {
                el: this.el,
                pos: posAtDown,
                e: e,
                drag: this
              });
            } else if (this.params.consumeFilteredEvents) {
              _consume(e);
            }
          }
        }.bind(this);
        this.moveListener = function(e) {
          if (downAt) {
            if (!moving) {
              var _continue = _dispatch("start", {
                el: this.el,
                pos: posAtDown,
                e: e,
                drag: this
              });
              if (_continue !== false) {
                if (!downAt)
                  return;
                this.mark(true);
                moving = true;
              }
            }
            if (downAt) {
              intersectingDroppables.length = 0;
              var pos = _pl(e),
                  dx = pos[0] - downAt[0],
                  dy = pos[1] - downAt[1],
                  z = this.params.ignoreZoom ? 1 : k.getZoom();
              dx /= z;
              dy /= z;
              this.moveBy(dx, dy, e);
              k.updateSelection(dx, dy, this);
              k.updatePosses(dx, dy, this);
            }
          }
        }.bind(this);
        this.upListener = function(e) {
          if (downAt) {
            downAt = null;
            this.params.unbind(document, "mousemove", this.moveListener);
            this.params.unbind(document, "mouseup", this.upListener);
            this.params.removeClass(document.body, css.noSelect);
            this.unmark(e);
            k.unmarkSelection(this, e);
            k.unmarkPosses(this, e);
            this.stop(e);
            k.notifySelectionDragStop(this, e);
            k.notifyPosseDragStop(this, e);
            moving = false;
            if (clone) {
              dragEl && dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
              dragEl = null;
            }
          }
        }.bind(this);
        this.getFilters = function() {
          return _filters;
        };
        this.abort = function() {
          if (downAt != null)
            this.upListener();
        };
        this.getDragElement = function() {
          return dragEl || this.el;
        };
        var listeners = {
          "start": [],
          "drag": [],
          "stop": [],
          "over": [],
          "out": [],
          "beforeStart": []
        };
        if (params.events.start)
          listeners.start.push(params.events.start);
        if (params.events.beforeStart)
          listeners.beforeStart.push(params.events.beforeStart);
        if (params.events.stop)
          listeners.stop.push(params.events.stop);
        if (params.events.drag)
          listeners.drag.push(params.events.drag);
        this.on = function(evt, fn) {
          if (listeners[evt])
            listeners[evt].push(fn);
        };
        var _dispatch = function(evt, value) {
          if (listeners[evt]) {
            for (var i = 0; i < listeners[evt].length; i++) {
              try {
                listeners[evt][i](value);
              } catch (e) {}
            }
          }
        };
        this.notifyStart = function(e) {
          _dispatch("start", {
            el: this.el,
            pos: this.params.getPosition(dragEl),
            e: e,
            drag: this
          });
        };
        this.stop = function(e, force) {
          if (force || moving) {
            var positions = [],
                sel = k.getSelection(),
                dPos = this.params.getPosition(dragEl);
            if (sel.length > 1) {
              for (var i = 0; i < sel.length; i++) {
                var p = this.params.getPosition(sel[i].el);
                positions.push([sel[i].el, {
                  left: p[0],
                  top: p[1]
                }, sel[i]]);
              }
            } else {
              positions.push([dragEl, {
                left: dPos[0],
                top: dPos[1]
              }, this]);
            }
            _dispatch("stop", {
              el: dragEl,
              pos: dPos,
              e: e,
              drag: this,
              selection: positions
            });
          }
        };
        this.mark = function(andNotify) {
          posAtDown = this.params.getPosition(dragEl);
          this.size = this.params.getSize(dragEl);
          matchingDroppables = k.getMatchingDroppables(this);
          _setDroppablesActive(matchingDroppables, true, false, this);
          this.params.addClass(dragEl, this.params.dragClass || css.drag);
          if (this.params.constrain || this.params.containment) {
            var cs = this.params.getSize(dragEl.parentNode);
            constrainRect = {
              w: cs[0],
              h: cs[1]
            };
          }
          if (andNotify) {
            k.notifySelectionDragStart(this);
          }
        };
        this.unmark = function(e, doNotCheckDroppables) {
          _setDroppablesActive(matchingDroppables, false, true, this);
          this.params.removeClass(dragEl, this.params.dragClass || css.drag);
          matchingDroppables.length = 0;
          if (!doNotCheckDroppables) {
            for (var i = 0; i < intersectingDroppables.length; i++) {
              var retVal = intersectingDroppables[i].drop(this, e);
              if (retVal === true)
                break;
            }
          }
        };
        this.moveBy = function(dx, dy, e) {
          intersectingDroppables.length = 0;
          var cPos = this.constrain(this.toGrid(([posAtDown[0] + dx, posAtDown[1] + dy])), dragEl),
              rect = {
                x: cPos[0],
                y: cPos[1],
                w: this.size[0],
                h: this.size[1]
              },
              focusDropElement = null;
          this.params.setPosition(dragEl, cPos);
          for (var i = 0; i < matchingDroppables.length; i++) {
            var r2 = {
              x: matchingDroppables[i].position[0],
              y: matchingDroppables[i].position[1],
              w: matchingDroppables[i].size[0],
              h: matchingDroppables[i].size[1]
            };
            if (this.params.intersects(rect, r2) && (_multipleDrop || focusDropElement == null || focusDropElement == matchingDroppables[i].el) && matchingDroppables[i].canDrop(this)) {
              if (!focusDropElement)
                focusDropElement = matchingDroppables[i].el;
              intersectingDroppables.push(matchingDroppables[i]);
              matchingDroppables[i].setHover(this, true, e);
            } else if (matchingDroppables[i].isHover()) {
              matchingDroppables[i].setHover(this, false, e);
            }
          }
          _dispatch("drag", {
            el: this.el,
            pos: cPos,
            e: e,
            drag: this
          });
        };
        this.destroy = function() {
          this.params.unbind(this.el, "mousedown", this.downListener);
          this.params.unbind(document, "mousemove", this.moveListener);
          this.params.unbind(document, "mouseup", this.upListener);
          this.downListener = null;
          this.upListener = null;
          this.moveListener = null;
        };
        this.params.bind(this.el, "mousedown", this.downListener);
        if (this.params.handle)
          _setFilter(this.params.handle, false);
        else
          _setFilter(this.params.filter, this.params.filterExclude);
      };
      var Drop = function(el, params, css, scope) {
        this._class = css.droppable;
        this.params = params || {};
        this._activeClass = this.params.activeClass || css.active;
        this._hoverClass = this.params.hoverClass || css.hover;
        Super.apply(this, arguments);
        var hover = false;
        this.allowLoopback = this.params.allowLoopback !== false;
        this.setActive = function(val) {
          this.params[val ? "addClass" : "removeClass"](this.el, this._activeClass);
        };
        this.updatePosition = function() {
          this.position = this.params.getPosition(this.el);
          this.size = this.params.getSize(this.el);
        };
        this.canDrop = this.params.canDrop || function(drag) {
          return true;
        };
        this.isHover = function() {
          return hover;
        };
        this.setHover = function(drag, val, e) {
          if (val || this.el._katavorioDragHover == null || this.el._katavorioDragHover == drag.el._katavorio) {
            this.params[val ? "addClass" : "removeClass"](this.el, this._hoverClass);
            this.el._katavorioDragHover = val ? drag.el._katavorio : null;
            if (hover !== val)
              this.params.events[val ? "over" : "out"]({
                el: this.el,
                e: e,
                drag: drag,
                drop: this
              });
            hover = val;
          }
        };
        this.drop = function(drag, event) {
          return this.params.events["drop"]({
            drag: drag,
            e: event,
            drop: this
          });
        };
        this.destroy = function() {
          this._class = null;
          this._activeClass = null;
          this._hoverClass = null;
          hover = null;
        };
      };
      var _uuid = function() {
        return ('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          var r = Math.random() * 16 | 0,
              v = c == 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        }));
      };
      var _gel = function(el) {
        if (el == null)
          return null;
        el = (typeof el === "string" || el.constructor == String) ? document.getElementById(el) : el;
        if (el == null)
          return null;
        el._katavorio = el._katavorio || _uuid();
        return el;
      };
      this.Katavorio = function(katavorioParams) {
        var _selection = [],
            _selectionMap = {};
        this._dragsByScope = {};
        this._dropsByScope = {};
        var _zoom = 1,
            _reg = function(obj, map) {
              _each(obj, function(_obj) {
                for (var i = 0; i < _obj.scopes.length; i++) {
                  map[_obj.scopes[i]] = map[_obj.scopes[i]] || [];
                  map[_obj.scopes[i]].push(_obj);
                }
              });
            },
            _unreg = function(obj, map) {
              var c = 0;
              _each(obj, function(_obj) {
                for (var i = 0; i < _obj.scopes.length; i++) {
                  if (map[_obj.scopes[i]]) {
                    var idx = katavorioParams.indexOf(map[_obj.scopes[i]], _obj);
                    if (idx != -1) {
                      map[_obj.scopes[i]].splice(idx, 1);
                      c++;
                    }
                  }
                }
              });
              return c > 0;
            },
            _getMatchingDroppables = this.getMatchingDroppables = function(drag) {
              var dd = [],
                  _m = {};
              for (var i = 0; i < drag.scopes.length; i++) {
                var _dd = this._dropsByScope[drag.scopes[i]];
                if (_dd) {
                  for (var j = 0; j < _dd.length; j++) {
                    if (_dd[j].canDrop(drag) && !_m[_dd[j].uuid] && (_dd[j].allowLoopback || _dd[j].el !== drag.el)) {
                      _m[_dd[j].uuid] = true;
                      dd.push(_dd[j]);
                    }
                  }
                }
              }
              return dd;
            },
            _prepareParams = function(p) {
              p = p || {};
              var _p = {events: {}},
                  i;
              for (i in katavorioParams)
                _p[i] = katavorioParams[i];
              for (i in p)
                _p[i] = p[i];
              for (i = 0; i < _events.length; i++) {
                _p.events[_events[i]] = p[_events[i]] || _devNull;
              }
              _p.katavorio = this;
              return _p;
            }.bind(this),
            _mistletoe = function(existingDrag, params) {
              for (var i = 0; i < _events.length; i++) {
                if (params[_events[i]]) {
                  existingDrag.on(_events[i], params[_events[i]]);
                }
              }
            }.bind(this),
            _css = {},
            overrideCss = katavorioParams.css || {},
            _scope = katavorioParams.scope || _defaultScope;
        for (var i in _classes)
          _css[i] = _classes[i];
        for (var i in overrideCss)
          _css[i] = overrideCss[i];
        var inputFilterSelector = katavorioParams.inputFilterSelector || _defaultInputFilterSelector;
        this.getInputFilterSelector = function() {
          return inputFilterSelector;
        };
        this.setInputFilterSelector = function(selector) {
          inputFilterSelector = selector;
          return this;
        };
        this.draggable = function(el, params) {
          var o = [];
          _each(el, function(_el) {
            _el = _gel(_el);
            if (_el != null) {
              if (_el._katavorioDrag == null) {
                var p = _prepareParams(params);
                _el._katavorioDrag = new Drag(_el, p, _css, _scope);
                _reg(_el._katavorioDrag, this._dragsByScope);
                o.push(_el._katavorioDrag);
                katavorioParams.addClass(_el, _css.draggable);
              } else {
                _mistletoe(_el._katavorioDrag, params);
              }
            }
          }.bind(this));
          return o;
        };
        this.droppable = function(el, params) {
          var o = [];
          _each(el, function(_el) {
            _el = _gel(_el);
            if (_el != null) {
              var drop = new Drop(_el, _prepareParams(params), _css, _scope);
              _el._katavorioDrop = _el._katavorioDrop || [];
              _el._katavorioDrop.push(drop);
              _reg(drop, this._dropsByScope);
              o.push(drop);
              katavorioParams.addClass(_el, _css.droppable);
            }
          }.bind(this));
          return o;
        };
        this.select = function(el) {
          _each(el, function() {
            var _el = _gel(this);
            if (_el && _el._katavorioDrag) {
              if (!_selectionMap[_el._katavorio]) {
                _selection.push(_el._katavorioDrag);
                _selectionMap[_el._katavorio] = [_el, _selection.length - 1];
                katavorioParams.addClass(_el, _css.selected);
              }
            }
          });
          return this;
        };
        this.deselect = function(el) {
          _each(el, function() {
            var _el = _gel(this);
            if (_el && _el._katavorio) {
              var e = _selectionMap[_el._katavorio];
              if (e) {
                var _s = [];
                for (var i = 0; i < _selection.length; i++)
                  if (_selection[i].el !== _el)
                    _s.push(_selection[i]);
                _selection = _s;
                delete _selectionMap[_el._katavorio];
                katavorioParams.removeClass(_el, _css.selected);
              }
            }
          });
          return this;
        };
        this.deselectAll = function() {
          for (var i in _selectionMap) {
            var d = _selectionMap[i];
            katavorioParams.removeClass(d[0], _css.selected);
          }
          _selection.length = 0;
          _selectionMap = {};
        };
        this.markSelection = function(drag) {
          _foreach(_selection, function(e) {
            e.mark();
          }, drag);
        };
        this.markPosses = function(drag) {
          if (drag.posses) {
            _each(drag.posses, function(p) {
              if (drag.posseRoles[p] && _posses[p]) {
                _foreach(_posses[p].members, function(d) {
                  d.mark();
                }, drag);
              }
            });
          }
        };
        this.unmarkSelection = function(drag, event) {
          _foreach(_selection, function(e) {
            e.unmark(event);
          }, drag);
        };
        this.unmarkPosses = function(drag, event) {
          if (drag.posses) {
            _each(drag.posses, function(p) {
              if (drag.posseRoles[p] && _posses[p]) {
                _foreach(_posses[p].members, function(d) {
                  d.unmark(event, true);
                }, drag);
              }
            });
          }
        };
        this.getSelection = function() {
          return _selection.slice(0);
        };
        this.updateSelection = function(dx, dy, drag) {
          _foreach(_selection, function(e) {
            e.moveBy(dx, dy);
          }, drag);
        };
        var _posseAction = function(fn, drag) {
          if (drag.posses) {
            _each(drag.posses, function(p) {
              if (drag.posseRoles[p] && _posses[p]) {
                _foreach(_posses[p].members, function(e) {
                  fn(e);
                }, drag);
              }
            });
          }
        };
        this.updatePosses = function(dx, dy, drag) {
          _posseAction(function(e) {
            e.moveBy(dx, dy);
          }, drag);
        };
        this.notifyPosseDragStop = function(drag, evt) {
          _posseAction(function(e) {
            e.stop(evt, true);
          }, drag);
        };
        this.notifySelectionDragStop = function(drag, evt) {
          _foreach(_selection, function(e) {
            e.stop(evt, true);
          }, drag);
        };
        this.notifySelectionDragStart = function(drag, evt) {
          _foreach(_selection, function(e) {
            e.notifyStart(evt);
          }, drag);
        };
        this.setZoom = function(z) {
          _zoom = z;
        };
        this.getZoom = function() {
          return _zoom;
        };
        var _scopeManip = function(kObj, scopes, map, fn) {
          _each(kObj, function(_kObj) {
            _unreg(_kObj, map);
            _kObj[fn](scopes);
            _reg(_kObj, map);
          });
        };
        _each(["set", "add", "remove", "toggle"], function(v) {
          this[v + "Scope"] = function(el, scopes) {
            _scopeManip(el._katavorioDrag, scopes, this._dragsByScope, v + "Scope");
            _scopeManip(el._katavorioDrop, scopes, this._dropsByScope, v + "Scope");
          }.bind(this);
          this[v + "DragScope"] = function(el, scopes) {
            _scopeManip(el.constructor === Drag ? el : el._katavorioDrag, scopes, this._dragsByScope, v + "Scope");
          }.bind(this);
          this[v + "DropScope"] = function(el, scopes) {
            _scopeManip(el.constructor === Drop ? el : el._katavorioDrop, scopes, this._dropsByScope, v + "Scope");
          }.bind(this);
        }.bind(this));
        this.snapToGrid = function(x, y) {
          for (var s in this._dragsByScope) {
            _foreach(this._dragsByScope[s], function(d) {
              d.snap(x, y);
            });
          }
        };
        this.getDragsForScope = function(s) {
          return this._dragsByScope[s];
        };
        this.getDropsForScope = function(s) {
          return this._dropsByScope[s];
        };
        var _destroy = function(el, type, map) {
          el = _gel(el);
          if (el[type]) {
            if (_unreg(el[type], map)) {
              _each(el[type], function(kObj) {
                kObj.destroy();
              });
            }
            el[type] = null;
          }
        };
        this.elementRemoved = function(el) {
          this.destroyDraggable(el);
          this.destroyDroppable(el);
        };
        this.destroyDraggable = function(el) {
          _destroy(el, "_katavorioDrag", this._dragsByScope);
        };
        this.destroyDroppable = function(el) {
          _destroy(el, "_katavorioDrop", this._dropsByScope);
        };
        this.reset = function() {
          this._dragsByScope = {};
          this._dropsByScope = {};
          _selection = [];
          _selectionMap = {};
          _posses = {};
        };
        var _posses = {};
        var _processOneSpec = function(el, _spec, dontAddExisting) {
          var posseId = _isString(_spec) ? _spec : _spec.id;
          var active = _isString(_spec) ? true : _spec.active !== false;
          var posse = _posses[posseId] || (function() {
            var g = {
              name: posseId,
              members: []
            };
            _posses[posseId] = g;
            return g;
          })();
          _each(el, function(_el) {
            if (_el._katavorioDrag) {
              if (dontAddExisting && _el._katavorioDrag.posseRoles[posse.name] != null)
                return;
              _suggest(posse.members, _el._katavorioDrag);
              _suggest(_el._katavorioDrag.posses, posse.name);
              _el._katavorioDrag.posseRoles[posse.name] = active;
            }
          });
          return posse;
        };
        this.addToPosse = function(el, spec) {
          var posses = [];
          for (var i = 1; i < arguments.length; i++) {
            posses.push(_processOneSpec(el, arguments[i]));
          }
          return posses.length == 1 ? posses[0] : posses;
        };
        this.setPosse = function(el, spec) {
          var posses = [];
          for (var i = 1; i < arguments.length; i++) {
            posses.push(_processOneSpec(el, arguments[i], true).name);
          }
          _each(el, function(_el) {
            if (_el._katavorioDrag) {
              var diff = _difference(_el._katavorioDrag.posses, posses);
              var p = [];
              Array.prototype.push.apply(p, _el._katavorioDrag.posses);
              for (var i = 0; i < diff.length; i++) {
                this.removeFromPosse(_el, diff[i]);
              }
            }
          }.bind(this));
          return posses.length == 1 ? posses[0] : posses;
        };
        this.removeFromPosse = function(el, posseId) {
          if (arguments.length < 2)
            throw new TypeError("No posse id provided for remove operation");
          for (var i = 1; i < arguments.length; i++) {
            posseId = arguments[i];
            _each(el, function(_el) {
              if (_el._katavorioDrag && _el._katavorioDrag.posses) {
                var d = _el._katavorioDrag;
                _each(posseId, function(p) {
                  _vanquish(_posses[p].members, d);
                  _vanquish(d.posses, p);
                  delete d.posseRoles[p];
                });
              }
            });
          }
        };
        this.removeFromAllPosses = function(el) {
          _each(el, function(_el) {
            if (_el._katavorioDrag && _el._katavorioDrag.posses) {
              var d = _el._katavorioDrag;
              _each(d.posses, function(p) {
                _vanquish(_posses[p].members, d);
              });
              d.posses.length = 0;
              d.posseRoles = {};
            }
          });
        };
        this.setPosseState = function(el, posseId, state) {
          var posse = _posses[posseId];
          if (posse) {
            _each(el, function(_el) {
              if (_el._katavorioDrag && _el._katavorioDrag.posses) {
                _el._katavorioDrag.posseRoles[posse.name] = state;
              }
            });
          }
        };
      };
    }).call(this);
    ;
    (function() {
      var _isa = function(a) {
        return Object.prototype.toString.call(a) === "[object Array]";
      },
          _isnum = function(n) {
            return Object.prototype.toString.call(n) === "[object Number]";
          },
          _iss = function(s) {
            return typeof s === "string";
          },
          _isb = function(s) {
            return typeof s === "boolean";
          },
          _isnull = function(s) {
            return s == null;
          },
          _iso = function(o) {
            return o == null ? false : Object.prototype.toString.call(o) === "[object Object]";
          },
          _isd = function(o) {
            return Object.prototype.toString.call(o) === "[object Date]";
          },
          _isf = function(o) {
            return Object.prototype.toString.call(o) === "[object Function]";
          },
          _isNamedFunction = function(o) {
            return _isf(o) && o.name != null && o.name.length > 0;
          },
          _ise = function(o) {
            for (var i in o) {
              if (o.hasOwnProperty(i))
                return false;
            }
            return true;
          };
      var root = this;
      var exports = root.jsPlumbUtil = {
        isArray: _isa,
        isString: _iss,
        isBoolean: _isb,
        isNull: _isnull,
        isObject: _iso,
        isDate: _isd,
        isFunction: _isf,
        isEmpty: _ise,
        isNumber: _isnum,
        clone: function(a) {
          if (_iss(a))
            return "" + a;
          else if (_isb(a))
            return !!a;
          else if (_isd(a))
            return new Date(a.getTime());
          else if (_isf(a))
            return a;
          else if (_isa(a)) {
            var b = [];
            for (var i = 0; i < a.length; i++)
              b.push(this.clone(a[i]));
            return b;
          } else if (_iso(a)) {
            var c = {};
            for (var j in a)
              c[j] = this.clone(a[j]);
            return c;
          } else
            return a;
        },
        merge: function(a, b, collations) {
          var cMap = {},
              ar,
              i;
          collations = collations || [];
          for (i = 0; i < collations.length; i++)
            cMap[collations[i]] = true;
          var c = this.clone(a);
          for (i in b) {
            if (c[i] == null) {
              c[i] = b[i];
            } else if (_iss(b[i]) || _isb(b[i])) {
              if (!cMap[i]) {
                c[i] = b[i];
              } else {
                ar = [];
                ar.push.apply(ar, _isa(c[i]) ? c[i] : [c[i]]);
                ar.push.apply(ar, _isa(b[i]) ? b[i] : [b[i]]);
                c[i] = ar;
              }
            } else {
              if (_isa(b[i])) {
                ar = [];
                if (_isa(c[i]))
                  ar.push.apply(ar, c[i]);
                ar.push.apply(ar, b[i]);
                c[i] = ar;
              } else if (_iso(b[i])) {
                if (!_iso(c[i]))
                  c[i] = {};
                for (var j in b[i]) {
                  c[i][j] = b[i][j];
                }
              }
            }
          }
          return c;
        },
        replace: function(inObj, path, value) {
          if (inObj == null)
            return;
          var q = inObj,
              t = q;
          path.replace(/([^\.])+/g, function(term, lc, pos, str) {
            var array = term.match(/([^\[0-9]+){1}(\[)([0-9+])/),
                last = pos + term.length >= str.length,
                _getArray = function() {
                  return t[array[1]] || (function() {
                    t[array[1]] = [];
                    return t[array[1]];
                  })();
                };
            if (last) {
              if (array)
                _getArray()[array[3]] = value;
              else
                t[term] = value;
            } else {
              if (array) {
                var a = _getArray();
                t = a[array[3]] || (function() {
                  a[array[3]] = {};
                  return a[array[3]];
                })();
              } else
                t = t[term] || (function() {
                  t[term] = {};
                  return t[term];
                })();
            }
          });
          return inObj;
        },
        functionChain: function(successValue, failValue, fns) {
          for (var i = 0; i < fns.length; i++) {
            var o = fns[i][0][fns[i][1]].apply(fns[i][0], fns[i][2]);
            if (o === failValue) {
              return o;
            }
          }
          return successValue;
        },
        populate: function(model, values, functionPrefix) {
          var getValue = function(fromString) {
            var matches = fromString.match(/(\${.*?})/g);
            if (matches != null) {
              for (var i = 0; i < matches.length; i++) {
                var val = values[matches[i].substring(2, matches[i].length - 1)] || "";
                if (val != null) {
                  fromString = fromString.replace(matches[i], val);
                }
              }
            }
            return fromString;
          },
              _one = function(d) {
                if (d != null) {
                  if (_iss(d)) {
                    return getValue(d);
                  } else if (_isf(d) && (functionPrefix == null || (d.name || "").indexOf(functionPrefix) === 0)) {
                    return d(values);
                  } else if (_isa(d)) {
                    var r = [];
                    for (var i = 0; i < d.length; i++)
                      r.push(_one(d[i]));
                    return r;
                  } else if (_iso(d)) {
                    var s = {};
                    for (var j in d) {
                      s[j] = _one(d[j]);
                    }
                    return s;
                  } else {
                    return d;
                  }
                }
              };
          return _one(model);
        },
        findWithFunction: function(a, f) {
          if (a)
            for (var i = 0; i < a.length; i++)
              if (f(a[i]))
                return i;
          return -1;
        },
        removeWithFunction: function(a, f) {
          var idx = exports.findWithFunction(a, f);
          if (idx > -1)
            a.splice(idx, 1);
          return idx != -1;
        },
        remove: function(l, v) {
          var idx = l.indexOf(v);
          if (idx > -1)
            l.splice(idx, 1);
          return idx != -1;
        },
        addWithFunction: function(list, item, hashFunction) {
          if (exports.findWithFunction(list, hashFunction) == -1)
            list.push(item);
        },
        addToList: function(map, key, value, insertAtStart) {
          var l = map[key];
          if (l == null) {
            l = [];
            map[key] = l;
          }
          l[insertAtStart ? "unshift" : "push"](value);
          return l;
        },
        extend: function(child, parent, _protoFn) {
          var i;
          parent = _isa(parent) ? parent : [parent];
          for (i = 0; i < parent.length; i++) {
            for (var j in parent[i].prototype) {
              if (parent[i].prototype.hasOwnProperty(j)) {
                child.prototype[j] = parent[i].prototype[j];
              }
            }
          }
          var _makeFn = function(name, protoFn) {
            return function() {
              for (i = 0; i < parent.length; i++) {
                if (parent[i].prototype[name])
                  parent[i].prototype[name].apply(this, arguments);
              }
              return protoFn.apply(this, arguments);
            };
          };
          var _oneSet = function(fns) {
            for (var k in fns) {
              child.prototype[k] = _makeFn(k, fns[k]);
            }
          };
          if (arguments.length > 2) {
            for (i = 2; i < arguments.length; i++)
              _oneSet(arguments[i]);
          }
          return child;
        },
        uuid: function() {
          return ('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0,
                v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
          }));
        },
        logEnabled: true,
        log: function() {
          if (exports.logEnabled && typeof console != "undefined") {
            try {
              var msg = arguments[arguments.length - 1];
              console.log(msg);
            } catch (e) {}
          }
        },
        wrap: function(wrappedFunction, newFunction, returnOnThisValue) {
          wrappedFunction = wrappedFunction || function() {};
          newFunction = newFunction || function() {};
          return function() {
            var r = null;
            try {
              r = newFunction.apply(this, arguments);
            } catch (e) {
              exports.log("jsPlumb function failed : " + e);
            }
            if (returnOnThisValue == null || (r !== returnOnThisValue)) {
              try {
                r = wrappedFunction.apply(this, arguments);
              } catch (e) {
                exports.log("wrapped function failed : " + e);
              }
            }
            return r;
          };
        }
      };
      exports.EventGenerator = function() {
        var _listeners = {},
            eventsSuspended = false,
            eventsToDieOn = {"ready": true};
        this.bind = function(event, listener, insertAtStart) {
          var _one = function(evt) {
            exports.addToList(_listeners, evt, listener, insertAtStart);
            listener.__jsPlumb = listener.__jsPlumb || {};
            listener.__jsPlumb[jsPlumbUtil.uuid()] = evt;
          };
          if (typeof event === "string")
            _one(event);
          else if (event.length != null) {
            for (var i = 0; i < event.length; i++) {
              _one(event[i]);
            }
          }
          return this;
        };
        this.fire = function(event, value, originalEvent) {
          if (!eventsSuspended && _listeners[event]) {
            var l = _listeners[event].length,
                i = 0,
                _gone = false,
                ret = null;
            if (!this.shouldFireEvent || this.shouldFireEvent(event, value, originalEvent)) {
              while (!_gone && i < l && ret !== false) {
                if (eventsToDieOn[event])
                  _listeners[event][i].apply(this, [value, originalEvent]);
                else {
                  try {
                    ret = _listeners[event][i].apply(this, [value, originalEvent]);
                  } catch (e) {
                    exports.log("jsPlumb: fire failed for event " + event + " : " + e);
                  }
                }
                i++;
                if (_listeners == null || _listeners[event] == null)
                  _gone = true;
              }
            }
          }
          return this;
        };
        this.unbind = function(eventOrListener, listener) {
          if (arguments.length === 0) {
            _listeners = {};
          } else if (arguments.length === 1) {
            if (typeof eventOrListener === "string")
              delete _listeners[eventOrListener];
            else if (eventOrListener.__jsPlumb) {
              var evt;
              for (var i in eventOrListener.__jsPlumb) {
                evt = eventOrListener.__jsPlumb[i];
                exports.remove(_listeners[evt] || [], eventOrListener);
              }
            }
          } else if (arguments.length === 2) {
            exports.remove(_listeners[eventOrListener] || [], listener);
          }
          return this;
        };
        this.getListener = function(forEvent) {
          return _listeners[forEvent];
        };
        this.setSuspendEvents = function(val) {
          eventsSuspended = val;
        };
        this.isSuspendEvents = function() {
          return eventsSuspended;
        };
        this.silently = function(fn) {
          this.setSuspendEvents(true);
          try {
            fn();
          } catch (e) {
            jsPlumbUtil.log("Cannot execute silent function " + e);
          }
          this.setSuspendEvents(false);
        };
        this.cleanupListeners = function() {
          for (var i in _listeners) {
            _listeners[i] = null;
          }
        };
      };
      exports.EventGenerator.prototype = {cleanup: function() {
          this.cleanupListeners();
        }};
    }).call(this);
    ;
    (function() {
      "use strict";
      var root = this;
      var exports = root.jsPlumbUtil;
      exports.matchesSelector = function(el, selector, ctx) {
        ctx = ctx || el.parentNode;
        var possibles = ctx.querySelectorAll(selector);
        for (var i = 0; i < possibles.length; i++) {
          if (possibles[i] === el)
            return true;
        }
        return false;
      };
      exports.consume = function(e, doNotPreventDefault) {
        if (e.stopPropagation)
          e.stopPropagation();
        else
          e.returnValue = false;
        if (!doNotPreventDefault && e.preventDefault)
          e.preventDefault();
      };
      exports.sizeElement = function(el, x, y, w, h) {
        if (el) {
          el.style.height = h + "px";
          el.height = h;
          el.style.width = w + "px";
          el.width = w;
          el.style.left = x + "px";
          el.style.top = y + "px";
        }
      };
    }).call(this);
    (function() {
      "use strict";
      var root = this;
      var connectorTypes = [],
          rendererTypes;
      var _ju = root.jsPlumbUtil,
          _getOffset = function(el, _instance, relativeToRoot) {
            return _instance.getOffset(el, relativeToRoot);
          },
          _timestamp = function() {
            return "" + (new Date()).getTime();
          },
          _updateHoverStyle = function(component) {
            if (component._jsPlumb.paintStyle && component._jsPlumb.hoverPaintStyle) {
              var mergedHoverStyle = {};
              jsPlumb.extend(mergedHoverStyle, component._jsPlumb.paintStyle);
              jsPlumb.extend(mergedHoverStyle, component._jsPlumb.hoverPaintStyle);
              delete component._jsPlumb.hoverPaintStyle;
              if (mergedHoverStyle.gradient && component._jsPlumb.paintStyle.fillStyle)
                delete mergedHoverStyle.gradient;
              component._jsPlumb.hoverPaintStyle = mergedHoverStyle;
            }
          },
          events = ["tap", "dbltap", "click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "contextmenu"],
          eventFilters = {
            "mouseout": "mouseleave",
            "mouseexit": "mouseleave"
          },
          _updateAttachedElements = function(component, state, timestamp, sourceElement) {
            var affectedElements = component.getAttachedElements();
            if (affectedElements) {
              for (var i = 0,
                  j = affectedElements.length; i < j; i++) {
                if (!sourceElement || sourceElement != affectedElements[i])
                  affectedElements[i].setHover(state, true, timestamp);
              }
            }
          },
          _splitType = function(t) {
            return t == null ? null : t.split(" ");
          },
          _mapType = function(map, obj, typeId) {
            for (var i in obj)
              map[i] = typeId;
          },
          _each = function(fn, obj) {
            obj = _ju.isArray(obj) || (obj.length != null && !_ju.isString(obj)) ? obj : [obj];
            for (var i = 0; i < obj.length; i++) {
              try {
                fn.apply(obj[i], [obj[i]]);
              } catch (e) {
                _ju.log(".each iteration failed : " + e);
              }
            }
          },
          _applyTypes = function(component, params, doNotRepaint) {
            if (component.getDefaultType) {
              var td = component.getTypeDescriptor(),
                  map = {};
              var defType = component.getDefaultType();
              var o = _ju.merge({}, defType);
              _mapType(map, defType, "__default");
              for (var i = 0,
                  j = component._jsPlumb.types.length; i < j; i++) {
                var tid = component._jsPlumb.types[i];
                if (tid !== "__default") {
                  var _t = component._jsPlumb.instance.getType(tid, td);
                  if (_t != null) {
                    o = _ju.merge(o, _t, ["cssClass"]);
                    _mapType(map, _t, tid);
                  }
                }
              }
              if (params) {
                o = _ju.populate(o, params, "_");
              }
              component.applyType(o, doNotRepaint, map);
              if (!doNotRepaint)
                component.repaint();
            }
          },
          jsPlumbUIComponent = root.jsPlumbUIComponent = function(params) {
            _ju.EventGenerator.apply(this, arguments);
            var self = this,
                a = arguments,
                idPrefix = self.idPrefix,
                id = idPrefix + (new Date()).getTime();
            this._jsPlumb = {
              instance: params._jsPlumb,
              parameters: params.parameters || {},
              paintStyle: null,
              hoverPaintStyle: null,
              paintStyleInUse: null,
              hover: false,
              beforeDetach: params.beforeDetach,
              beforeDrop: params.beforeDrop,
              overlayPlacements: [],
              hoverClass: params.hoverClass || params._jsPlumb.Defaults.HoverClass,
              types: [],
              typeCache: {}
            };
            this.cacheTypeItem = function(key, item, typeId) {
              this._jsPlumb.typeCache[typeId] = this._jsPlumb.typeCache[typeId] || {};
              this._jsPlumb.typeCache[typeId][key] = item;
            };
            this.getCachedTypeItem = function(key, typeId) {
              return this._jsPlumb.typeCache[typeId] ? this._jsPlumb.typeCache[typeId][key] : null;
            };
            this.getId = function() {
              return id;
            };
            var o = params.overlays || [],
                oo = {};
            if (this.defaultOverlayKeys) {
              for (var i = 0; i < this.defaultOverlayKeys.length; i++)
                Array.prototype.push.apply(o, this._jsPlumb.instance.Defaults[this.defaultOverlayKeys[i]] || []);
              for (i = 0; i < o.length; i++) {
                var fo = jsPlumb.convertToFullOverlaySpec(o[i]);
                oo[fo[1].id] = fo;
              }
            }
            var _defaultType = {
              overlays: oo,
              parameters: params.parameters || {},
              scope: params.scope || this._jsPlumb.instance.getDefaultScope()
            };
            this.getDefaultType = function() {
              return _defaultType;
            };
            this.appendToDefaultType = function(obj) {
              for (var i in obj)
                _defaultType[i] = obj[i];
            };
            if (params.events) {
              for (i in params.events)
                self.bind(i, params.events[i]);
            }
            this.clone = function() {
              var o = {};
              this.constructor.apply(o, a);
              return o;
            }.bind(this);
            this.isDetachAllowed = function(connection) {
              var r = true;
              if (this._jsPlumb.beforeDetach) {
                try {
                  r = this._jsPlumb.beforeDetach(connection);
                } catch (e) {
                  _ju.log("jsPlumb: beforeDetach callback failed", e);
                }
              }
              return r;
            };
            this.isDropAllowed = function(sourceId, targetId, scope, connection, dropEndpoint, source, target) {
              var r = this._jsPlumb.instance.checkCondition("beforeDrop", {
                sourceId: sourceId,
                targetId: targetId,
                scope: scope,
                connection: connection,
                dropEndpoint: dropEndpoint,
                source: source,
                target: target
              });
              if (this._jsPlumb.beforeDrop) {
                try {
                  r = this._jsPlumb.beforeDrop({
                    sourceId: sourceId,
                    targetId: targetId,
                    scope: scope,
                    connection: connection,
                    dropEndpoint: dropEndpoint,
                    source: source,
                    target: target
                  });
                } catch (e) {
                  _ju.log("jsPlumb: beforeDrop callback failed", e);
                }
              }
              return r;
            };
            var boundListeners = [],
                bindAListener = function(obj, type, fn) {
                  boundListeners.push([obj, type, fn]);
                  obj.bind(type, fn);
                },
                domListeners = [];
            this.setListenerComponent = function(c) {
              for (var i = 0; i < domListeners.length; i++)
                domListeners[i][3] = c;
            };
          };
      var _removeTypeCssHelper = function(component, typeIndex) {
        var typeId = component._jsPlumb.types[typeIndex],
            type = component._jsPlumb.instance.getType(typeId, component.getTypeDescriptor());
        if (type != null) {
          if (type.cssClass && component.canvas)
            component._jsPlumb.instance.removeClass(component.canvas, type.cssClass);
        }
      };
      _ju.extend(root.jsPlumbUIComponent, _ju.EventGenerator, {
        getParameter: function(name) {
          return this._jsPlumb.parameters[name];
        },
        setParameter: function(name, value) {
          this._jsPlumb.parameters[name] = value;
        },
        getParameters: function() {
          return this._jsPlumb.parameters;
        },
        setParameters: function(p) {
          this._jsPlumb.parameters = p;
        },
        getClass: function() {
          return jsPlumb.getClass(this.canvas);
        },
        hasClass: function(clazz) {
          return jsPlumb.hasClass(this.canvas, clazz);
        },
        addClass: function(clazz) {
          jsPlumb.addClass(this.canvas, clazz);
        },
        removeClass: function(clazz) {
          jsPlumb.removeClass(this.canvas, clazz);
        },
        updateClasses: function(classesToAdd, classesToRemove) {
          jsPlumb.updateClasses(this.canvas, classesToAdd, classesToRemove);
        },
        setType: function(typeId, params, doNotRepaint) {
          this.clearTypes();
          this._jsPlumb.types = _splitType(typeId) || [];
          _applyTypes(this, params, doNotRepaint);
        },
        getType: function() {
          return this._jsPlumb.types;
        },
        reapplyTypes: function(params, doNotRepaint) {
          _applyTypes(this, params, doNotRepaint);
        },
        hasType: function(typeId) {
          return this._jsPlumb.types.indexOf(typeId) != -1;
        },
        addType: function(typeId, params, doNotRepaint) {
          var t = _splitType(typeId),
              _cont = false;
          if (t != null) {
            for (var i = 0,
                j = t.length; i < j; i++) {
              if (!this.hasType(t[i])) {
                this._jsPlumb.types.push(t[i]);
                _cont = true;
              }
            }
            if (_cont)
              _applyTypes(this, params, doNotRepaint);
          }
        },
        removeType: function(typeId, params, doNotRepaint) {
          var t = _splitType(typeId),
              _cont = false,
              _one = function(tt) {
                var idx = this._jsPlumb.types.indexOf(tt);
                if (idx != -1) {
                  _removeTypeCssHelper(this, idx);
                  this._jsPlumb.types.splice(idx, 1);
                  return true;
                }
                return false;
              }.bind(this);
          if (t != null) {
            for (var i = 0,
                j = t.length; i < j; i++) {
              _cont = _one(t[i]) || _cont;
            }
            if (_cont)
              _applyTypes(this, params, doNotRepaint);
          }
        },
        clearTypes: function(params, doNotRepaint) {
          var i = this._jsPlumb.types.length;
          for (var j = 0; j < i; j++) {
            _removeTypeCssHelper(this, 0);
            this._jsPlumb.types.splice(0, 1);
          }
          _applyTypes(this, params, doNotRepaint);
        },
        toggleType: function(typeId, params, doNotRepaint) {
          var t = _splitType(typeId);
          if (t != null) {
            for (var i = 0,
                j = t.length; i < j; i++) {
              var idx = this._jsPlumb.types.indexOf(t[i]);
              if (idx != -1) {
                _removeTypeCssHelper(this, idx);
                this._jsPlumb.types.splice(idx, 1);
              } else
                this._jsPlumb.types.push(t[i]);
            }
            _applyTypes(this, params, doNotRepaint);
          }
        },
        applyType: function(t, doNotRepaint) {
          this.setPaintStyle(t.paintStyle, doNotRepaint);
          this.setHoverPaintStyle(t.hoverPaintStyle, doNotRepaint);
          if (t.parameters) {
            for (var i in t.parameters)
              this.setParameter(i, t.parameters[i]);
          }
          this._jsPlumb.paintStyleInUse = this.getPaintStyle();
        },
        setPaintStyle: function(style, doNotRepaint) {
          this._jsPlumb.paintStyle = style;
          this._jsPlumb.paintStyleInUse = this._jsPlumb.paintStyle;
          _updateHoverStyle(this);
          if (!doNotRepaint)
            this.repaint();
        },
        getPaintStyle: function() {
          return this._jsPlumb.paintStyle;
        },
        setHoverPaintStyle: function(style, doNotRepaint) {
          this._jsPlumb.hoverPaintStyle = style;
          _updateHoverStyle(this);
          if (!doNotRepaint)
            this.repaint();
        },
        getHoverPaintStyle: function() {
          return this._jsPlumb.hoverPaintStyle;
        },
        destroy: function(force) {
          if (force || this.typeId == null) {
            this.cleanupListeners();
            this.clone = null;
            this._jsPlumb = null;
          }
        },
        isHover: function() {
          return this._jsPlumb.hover;
        },
        setHover: function(hover, ignoreAttachedElements, timestamp) {
          if (this._jsPlumb && !this._jsPlumb.instance.currentlyDragging && !this._jsPlumb.instance.isHoverSuspended()) {
            this._jsPlumb.hover = hover;
            if (this.canvas != null) {
              if (this._jsPlumb.instance.hoverClass != null) {
                var method = hover ? "addClass" : "removeClass";
                this._jsPlumb.instance[method](this.canvas, this._jsPlumb.instance.hoverClass);
              }
              if (this._jsPlumb.hoverClass != null) {
                this._jsPlumb.instance[method](this.canvas, this._jsPlumb.hoverClass);
              }
            }
            if (this._jsPlumb.hoverPaintStyle != null) {
              this._jsPlumb.paintStyleInUse = hover ? this._jsPlumb.hoverPaintStyle : this._jsPlumb.paintStyle;
              if (!this._jsPlumb.instance.isSuspendDrawing()) {
                timestamp = timestamp || _timestamp();
                this.repaint({
                  timestamp: timestamp,
                  recalc: false
                });
              }
            }
            if (this.getAttachedElements && !ignoreAttachedElements)
              _updateAttachedElements(this, hover, _timestamp(), this);
          }
        }
      });
      var _jsPlumbInstanceIndex = 0,
          getInstanceIndex = function() {
            var i = _jsPlumbInstanceIndex + 1;
            _jsPlumbInstanceIndex++;
            return i;
          };
      var jsPlumbInstance = window.jsPlumbInstance = function(_defaults) {
        this.Defaults = {
          Anchor: "Bottom",
          Anchors: [null, null],
          ConnectionsDetachable: true,
          ConnectionOverlays: [],
          Connector: "Bezier",
          Container: null,
          DoNotThrowErrors: false,
          DragOptions: {},
          DropOptions: {},
          Endpoint: "Dot",
          EndpointOverlays: [],
          Endpoints: [null, null],
          EndpointStyle: {fillStyle: "#456"},
          EndpointStyles: [null, null],
          EndpointHoverStyle: null,
          EndpointHoverStyles: [null, null],
          HoverPaintStyle: null,
          LabelStyle: {color: "black"},
          LogEnabled: false,
          Overlays: [],
          MaxConnections: 1,
          PaintStyle: {
            lineWidth: 4,
            strokeStyle: "#456"
          },
          ReattachConnections: false,
          RenderMode: "svg",
          Scope: "jsPlumb_DefaultScope"
        };
        if (_defaults)
          jsPlumb.extend(this.Defaults, _defaults);
        this.logEnabled = this.Defaults.LogEnabled;
        this._connectionTypes = {};
        this._endpointTypes = {};
        _ju.EventGenerator.apply(this);
        var _currentInstance = this,
            _instanceIndex = getInstanceIndex(),
            _bb = _currentInstance.bind,
            _initialDefaults = {},
            _zoom = 1,
            _info = function(el) {
              if (el == null)
                return null;
              else if (el.nodeType == 3 || el.nodeType == 8) {
                return {
                  el: el,
                  text: true
                };
              } else {
                var _el = _currentInstance.getElement(el);
                return {
                  el: _el,
                  id: (_ju.isString(el) && _el == null) ? el : _getId(_el)
                };
              }
            };
        this.getInstanceIndex = function() {
          return _instanceIndex;
        };
        this.setZoom = function(z, repaintEverything) {
          _zoom = z;
          _currentInstance.fire("zoom", _zoom);
          if (repaintEverything)
            _currentInstance.repaintEverything();
          return true;
        };
        this.getZoom = function() {
          return _zoom;
        };
        for (var i in this.Defaults)
          _initialDefaults[i] = this.Defaults[i];
        var _container,
            _containerDelegations = [];
        this.unbindContainer = function() {
          if (_container != null && _containerDelegations.length > 0) {
            for (var i = 0; i < _containerDelegations.length; i++) {
              _currentInstance.off(_container, _containerDelegations[i][0], _containerDelegations[i][1]);
            }
          }
        };
        this.setContainer = function(c) {
          this.unbindContainer();
          c = this.getElement(c);
          this.select().each(function(conn) {
            conn.moveParent(c);
          });
          this.selectEndpoints().each(function(ep) {
            ep.moveParent(c);
          });
          var previousContainer = _container;
          _container = c;
          _containerDelegations.length = 0;
          var _oneDelegateHandler = function(id, e) {
            var t = e.srcElement || e.target,
                jp = (t && t.parentNode ? t.parentNode._jsPlumb : null) || (t ? t._jsPlumb : null) || (t && t.parentNode && t.parentNode.parentNode ? t.parentNode.parentNode._jsPlumb : null);
            if (jp) {
              jp.fire(id, jp, e);
              _currentInstance.fire(id, jp.component || jp, e);
            }
          };
          var _addOneDelegate = function(eventId, selector, fn) {
            _containerDelegations.push([eventId, fn]);
            _currentInstance.on(_container, eventId, selector, fn);
          };
          var _oneDelegate = function(id) {
            _addOneDelegate(id, ".jsplumb-connector > *", function(e) {
              _oneDelegateHandler(id, e);
            });
            _addOneDelegate(id, ".jsplumb-endpoint, .jsplumb-endpoint > *, .jsplumb-endpoint svg *", function(e) {
              _oneDelegateHandler(id, e);
            });
            _addOneDelegate(id, ".jsplumb-overlay, .jsplumb-overlay *", function(e) {
              _oneDelegateHandler(id, e);
            });
          };
          for (var i = 0; i < events.length; i++)
            _oneDelegate(events[i]);
          for (var elId in managedElements) {
            var el = managedElements[elId].el;
            if (el.parentNode === previousContainer) {
              previousContainer.removeChild(el);
              _container.appendChild(el);
            }
          }
        };
        this.getContainer = function() {
          return _container;
        };
        this.bind = function(event, fn) {
          if ("ready" === event && initialized)
            fn();
          else
            _bb.apply(_currentInstance, [event, fn]);
        };
        _currentInstance.importDefaults = function(d) {
          for (var i in d) {
            _currentInstance.Defaults[i] = d[i];
          }
          if (d.Container)
            _currentInstance.setContainer(d.Container);
          return _currentInstance;
        };
        _currentInstance.restoreDefaults = function() {
          _currentInstance.Defaults = jsPlumb.extend({}, _initialDefaults);
          return _currentInstance;
        };
        var log = null,
            initialized = false,
            connections = [],
            endpointsByElement = {},
            endpointsByUUID = {},
            managedElements = {},
            offsets = {},
            offsetTimestamps = {},
            draggableStates = {},
            connectionBeingDragged = false,
            sizes = [],
            _suspendDrawing = false,
            _suspendedAt = null,
            DEFAULT_SCOPE = this.Defaults.Scope,
            renderMode = null,
            _curIdStamp = 1,
            _idstamp = function() {
              return "" + _curIdStamp++;
            },
            _appendElement = function(el, parent) {
              if (_container)
                _container.appendChild(el);
              else if (!parent)
                this.appendToRoot(el);
              else
                this.getElement(parent).appendChild(el);
            }.bind(this),
            _draw = function(element, ui, timestamp, clearEdits) {
              if (!jsPlumb.headless && !_suspendDrawing) {
                var id = _getId(element),
                    repaintEls = _currentInstance.getDragManager().getElementsForDraggable(id);
                if (timestamp == null)
                  timestamp = _timestamp();
                var o = _updateOffset({
                  elId: id,
                  offset: ui,
                  recalc: false,
                  timestamp: timestamp
                });
                if (repaintEls) {
                  for (var i in repaintEls) {
                    _updateOffset({
                      elId: repaintEls[i].id,
                      offset: {
                        left: o.o.left + repaintEls[i].offset.left,
                        top: o.o.top + repaintEls[i].offset.top
                      },
                      recalc: false,
                      timestamp: timestamp
                    });
                  }
                }
                _currentInstance.anchorManager.redraw(id, ui, timestamp, null, clearEdits);
                if (repaintEls) {
                  for (var j in repaintEls) {
                    _currentInstance.anchorManager.redraw(repaintEls[j].id, ui, timestamp, repaintEls[j].offset, clearEdits, true);
                  }
                }
              }
            },
            _getEndpoint = function(uuid) {
              return endpointsByUUID[uuid];
            },
            _initDraggableIfNecessary = function(element, isDraggable, dragOptions, id) {
              if (!jsPlumb.headless) {
                var _draggable = isDraggable == null ? false : isDraggable;
                if (_draggable) {
                  if (jsPlumb.isDragSupported(element, _currentInstance)) {
                    var options = dragOptions || _currentInstance.Defaults.DragOptions;
                    options = jsPlumb.extend({}, options);
                    if (!jsPlumb.isAlreadyDraggable(element, _currentInstance)) {
                      var dragEvent = jsPlumb.dragEvents.drag,
                          stopEvent = jsPlumb.dragEvents.stop,
                          startEvent = jsPlumb.dragEvents.start,
                          _del = _currentInstance.getElement(element),
                          _ancestor = _currentInstance.getDragManager().getDragAncestor(_del),
                          _noOffset = {
                            left: 0,
                            top: 0
                          },
                          _ancestorOffset = _noOffset,
                          _started = false;
                      _manage(id, element);
                      options[startEvent] = _ju.wrap(options[startEvent], function() {
                        _ancestorOffset = _ancestor != null ? _currentInstance.getOffset(_ancestor) : _noOffset;
                        _currentInstance.setHoverSuspended(true);
                        _currentInstance.select({source: element}).addClass(_currentInstance.elementDraggingClass + " " + _currentInstance.sourceElementDraggingClass, true);
                        _currentInstance.select({target: element}).addClass(_currentInstance.elementDraggingClass + " " + _currentInstance.targetElementDraggingClass, true);
                        _currentInstance.setConnectionBeingDragged(true);
                        if (options.canDrag)
                          return dragOptions.canDrag();
                      }, false);
                      options[dragEvent] = _ju.wrap(options[dragEvent], function() {
                        var ui = _currentInstance.getUIPosition(arguments, _currentInstance.getZoom());
                        ui.left += _ancestorOffset.left;
                        ui.top += _ancestorOffset.top;
                        _draw(element, ui, null, true);
                        if (_started)
                          _currentInstance.addClass(element, "jsplumb-dragged");
                        _started = true;
                      });
                      options[stopEvent] = _ju.wrap(options[stopEvent], function() {
                        var elements = arguments[0].selection;
                        var uip = _currentInstance.getUIPosition(arguments);
                        var _one = function(_e) {
                          _draw(_e[0], uip);
                          _currentInstance.removeClass(_e[0], "jsplumb-dragged");
                          _currentInstance.select({source: _e[0]}).removeClass(_currentInstance.elementDraggingClass + " " + _currentInstance.sourceElementDraggingClass, true);
                          _currentInstance.select({target: _e[0]}).removeClass(_currentInstance.elementDraggingClass + " " + _currentInstance.targetElementDraggingClass, true);
                          _currentInstance.getDragManager().dragEnded(_e[0]);
                        };
                        for (var i = 0; i < elements.length; i++)
                          _one(elements[i]);
                        _started = false;
                        _currentInstance.setHoverSuspended(false);
                        _currentInstance.setConnectionBeingDragged(false);
                      });
                      var elId = _getId(element);
                      draggableStates[elId] = true;
                      var draggable = draggableStates[elId];
                      options.disabled = draggable == null ? false : !draggable;
                      _currentInstance.initDraggable(element, options);
                      _currentInstance.getDragManager().register(element);
                    } else {
                      if (dragOptions.force) {
                        _currentInstance.initDraggable(element, options);
                      }
                    }
                  }
                }
              }
            },
            _scopeMatch = function(e1, e2) {
              var s1 = e1.scope.split(/\s/),
                  s2 = e2.scope.split(/\s/);
              for (var i = 0; i < s1.length; i++)
                for (var j = 0; j < s2.length; j++)
                  if (s2[j] == s1[i])
                    return true;
              return false;
            },
            _prepareConnectionParams = function(params, referenceParams) {
              var _p = jsPlumb.extend({}, params);
              if (referenceParams)
                jsPlumb.extend(_p, referenceParams);
              if (_p.source) {
                if (_p.source.endpoint)
                  _p.sourceEndpoint = _p.source;
                else
                  _p.source = _currentInstance.getElement(_p.source);
              }
              if (_p.target) {
                if (_p.target.endpoint)
                  _p.targetEndpoint = _p.target;
                else
                  _p.target = _currentInstance.getElement(_p.target);
              }
              if (params.uuids) {
                _p.sourceEndpoint = _getEndpoint(params.uuids[0]);
                _p.targetEndpoint = _getEndpoint(params.uuids[1]);
              }
              if (_p.sourceEndpoint && _p.sourceEndpoint.isFull()) {
                _ju.log(_currentInstance, "could not add connection; source endpoint is full");
                return;
              }
              if (_p.targetEndpoint && _p.targetEndpoint.isFull()) {
                _ju.log(_currentInstance, "could not add connection; target endpoint is full");
                return;
              }
              if (!_p.type && _p.sourceEndpoint)
                _p.type = _p.sourceEndpoint.connectionType;
              if (_p.sourceEndpoint && _p.sourceEndpoint.connectorOverlays) {
                _p.overlays = _p.overlays || [];
                for (var i = 0,
                    j = _p.sourceEndpoint.connectorOverlays.length; i < j; i++) {
                  _p.overlays.push(_p.sourceEndpoint.connectorOverlays[i]);
                }
              }
              if (_p.sourceEndpoint && _p.sourceEndpoint.scope) {
                _p.scope = _p.sourceEndpoint.scope;
              }
              if (!_p["pointer-events"] && _p.sourceEndpoint && _p.sourceEndpoint.connectorPointerEvents)
                _p["pointer-events"] = _p.sourceEndpoint.connectorPointerEvents;
              var _mergeOverrides = function(def, values) {
                var m = jsPlumb.extend({}, def);
                for (var i in values) {
                  if (values[i])
                    m[i] = values[i];
                }
                return m;
              };
              var _addEndpoint = function(el, def, idx) {
                return _currentInstance.addEndpoint(el, _mergeOverrides(def, {
                  anchor: _p.anchors ? _p.anchors[idx] : _p.anchor,
                  endpoint: _p.endpoints ? _p.endpoints[idx] : _p.endpoint,
                  paintStyle: _p.endpointStyles ? _p.endpointStyles[idx] : _p.endpointStyle,
                  hoverPaintStyle: _p.endpointHoverStyles ? _p.endpointHoverStyles[idx] : _p.endpointHoverStyle
                }));
              };
              var _oneElementDef = function(type, idx, defs, matchType) {
                if (_p[type] && !_p[type].endpoint && !_p[type + "Endpoint"] && !_p.newConnection) {
                  var tid = _getId(_p[type]),
                      tep = defs[tid];
                  tep = tep ? tep[matchType] : null;
                  if (tep) {
                    if (!tep.enabled)
                      return false;
                    var newEndpoint = tep.endpoint != null && tep.endpoint._jsPlumb ? tep.endpoint : _addEndpoint(_p[type], tep.def, idx);
                    if (newEndpoint.isFull())
                      return false;
                    _p[type + "Endpoint"] = newEndpoint;
                    newEndpoint._doNotDeleteOnDetach = false;
                    newEndpoint._deleteOnDetach = true;
                    if (tep.uniqueEndpoint) {
                      if (!tep.endpoint) {
                        tep.endpoint = newEndpoint;
                        newEndpoint._deleteOnDetach = false;
                        newEndpoint._doNotDeleteOnDetach = true;
                      } else
                        newEndpoint.finalEndpoint = tep.endpoint;
                    }
                  }
                }
              };
              if (_oneElementDef("source", 0, this.sourceEndpointDefinitions, _p.type || "default") === false)
                return;
              if (_oneElementDef("target", 1, this.targetEndpointDefinitions, _p.type || "default") === false)
                return;
              if (_p.sourceEndpoint && _p.targetEndpoint)
                if (!_scopeMatch(_p.sourceEndpoint, _p.targetEndpoint))
                  _p = null;
              return _p;
            }.bind(_currentInstance),
            _newConnection = function(params) {
              var connectionFunc = _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType();
              params._jsPlumb = _currentInstance;
              params.newConnection = _newConnection;
              params.newEndpoint = _newEndpoint;
              params.endpointsByUUID = endpointsByUUID;
              params.endpointsByElement = endpointsByElement;
              params.finaliseConnection = _finaliseConnection;
              params.id = "con_" + _idstamp();
              var con = new connectionFunc(params);
              if (con.isDetachable()) {
                con.endpoints[0].initDraggable("_jsPlumbSource");
                con.endpoints[1].initDraggable("_jsPlumbTarget");
              }
              return con;
            },
            _finaliseConnection = _currentInstance.finaliseConnection = function(jpc, params, originalEvent, doInformAnchorManager) {
              params = params || {};
              if (!jpc.suspendedEndpoint)
                connections.push(jpc);
              jpc.pending = null;
              jpc.endpoints[0].isTemporarySource = false;
              if (doInformAnchorManager !== false)
                _currentInstance.anchorManager.newConnection(jpc);
              _draw(jpc.source);
              if (!params.doNotFireConnectionEvent && params.fireEvent !== false) {
                var eventArgs = {
                  connection: jpc,
                  source: jpc.source,
                  target: jpc.target,
                  sourceId: jpc.sourceId,
                  targetId: jpc.targetId,
                  sourceEndpoint: jpc.endpoints[0],
                  targetEndpoint: jpc.endpoints[1]
                };
                _currentInstance.fire("connection", eventArgs, originalEvent);
              }
            },
            _newEndpoint = function(params, id) {
              var endpointFunc = _currentInstance.Defaults.EndpointType || jsPlumb.Endpoint;
              var _p = jsPlumb.extend({}, params);
              _p._jsPlumb = _currentInstance;
              _p.newConnection = _newConnection;
              _p.newEndpoint = _newEndpoint;
              _p.endpointsByUUID = endpointsByUUID;
              _p.endpointsByElement = endpointsByElement;
              _p.fireDetachEvent = fireDetachEvent;
              _p.elementId = id || _getId(_p.source);
              var ep = new endpointFunc(_p);
              ep.id = "ep_" + _idstamp();
              _manage(_p.elementId, _p.source);
              if (!jsPlumb.headless)
                _currentInstance.getDragManager().endpointAdded(_p.source, id);
              return ep;
            },
            _operation = function(elId, func, endpointFunc) {
              var endpoints = endpointsByElement[elId];
              if (endpoints && endpoints.length) {
                for (var i = 0,
                    ii = endpoints.length; i < ii; i++) {
                  for (var j = 0,
                      jj = endpoints[i].connections.length; j < jj; j++) {
                    var retVal = func(endpoints[i].connections[j]);
                    if (retVal)
                      return;
                  }
                  if (endpointFunc)
                    endpointFunc(endpoints[i]);
                }
              }
            },
            _setDraggable = function(element, draggable) {
              return jsPlumb.each(element, function(el) {
                if (_currentInstance.isDragSupported(el)) {
                  draggableStates[_currentInstance.getAttribute(el, "id")] = draggable;
                  _currentInstance.setElementDraggable(el, draggable);
                }
              });
            },
            _setVisible = function(el, state, alsoChangeEndpoints) {
              state = state === "block";
              var endpointFunc = null;
              if (alsoChangeEndpoints) {
                if (state)
                  endpointFunc = function(ep) {
                    ep.setVisible(true, true, true);
                  };
                else
                  endpointFunc = function(ep) {
                    ep.setVisible(false, true, true);
                  };
              }
              var info = _info(el);
              _operation(info.id, function(jpc) {
                if (state && alsoChangeEndpoints) {
                  var oidx = jpc.sourceId === info.id ? 1 : 0;
                  if (jpc.endpoints[oidx].isVisible())
                    jpc.setVisible(true);
                } else
                  jpc.setVisible(state);
              }, endpointFunc);
            },
            _toggleDraggable = function(el) {
              return jsPlumb.each(el, function(el) {
                var elId = _currentInstance.getAttribute(el, "id");
                var state = draggableStates[elId] == null ? false : draggableStates[elId];
                state = !state;
                draggableStates[elId] = state;
                _currentInstance.setDraggable(el, state);
                return state;
              }.bind(this));
            },
            _toggleVisible = function(elId, changeEndpoints) {
              var endpointFunc = null;
              if (changeEndpoints) {
                endpointFunc = function(ep) {
                  var state = ep.isVisible();
                  ep.setVisible(!state);
                };
              }
              _operation(elId, function(jpc) {
                var state = jpc.isVisible();
                jpc.setVisible(!state);
              }, endpointFunc);
            },
            _getCachedData = function(elId) {
              var o = offsets[elId];
              if (!o)
                return _updateOffset({elId: elId});
              else
                return {
                  o: o,
                  s: sizes[elId]
                };
            },
            _getId = function(element, uuid, doNotCreateIfNotFound) {
              if (_ju.isString(element))
                return element;
              if (element == null)
                return null;
              var id = _currentInstance.getAttribute(element, "id");
              if (!id || id === "undefined") {
                if (arguments.length == 2 && arguments[1] !== undefined)
                  id = uuid;
                else if (arguments.length == 1 || (arguments.length == 3 && !arguments[2]))
                  id = "jsPlumb_" + _instanceIndex + "_" + _idstamp();
                if (!doNotCreateIfNotFound)
                  _currentInstance.setAttribute(element, "id", id);
              }
              return id;
            };
        this.setConnectionBeingDragged = function(v) {
          connectionBeingDragged = v;
        };
        this.isConnectionBeingDragged = function() {
          return connectionBeingDragged;
        };
        this.getManagedElements = function() {
          return managedElements;
        };
        this.getRenderMode = function() {
          return "svg";
        };
        this.connectorClass = "jsplumb-connector";
        this.connectorOutlineClass = "jsplumb-connector-outline";
        this.editableConnectorClass = "jsplumb-connector-editable";
        this.connectedClass = "jsplumb-connected";
        this.hoverClass = "jsplumb-hover";
        this.endpointClass = "jsplumb-endpoint";
        this.endpointConnectedClass = "jsplumb-endpoint-connected";
        this.endpointFullClass = "jsplumb-endpoint-full";
        this.endpointDropAllowedClass = "jsplumb-endpoint-drop-allowed";
        this.endpointDropForbiddenClass = "jsplumb-endpoint-drop-forbidden";
        this.overlayClass = "jsplumb-overlay";
        this.draggingClass = "jsplumb-dragging";
        this.elementDraggingClass = "jsplumb-element-dragging";
        this.sourceElementDraggingClass = "jsplumb-source-element-dragging";
        this.targetElementDraggingClass = "jsplumb-target-element-dragging";
        this.endpointAnchorClassPrefix = "jsplumb-endpoint-anchor";
        this.hoverSourceClass = "jsplumb-source-hover";
        this.hoverTargetClass = "jsplumb-target-hover";
        this.dragSelectClass = "jsplumb-drag-select";
        this.Anchors = {};
        this.Connectors = {"svg": {}};
        this.Endpoints = {"svg": {}};
        this.Overlays = {"svg": {}};
        this.ConnectorRenderers = {};
        this.SVG = "svg";
        this.addEndpoint = function(el, params, referenceParams) {
          referenceParams = referenceParams || {};
          var p = jsPlumb.extend({}, referenceParams);
          jsPlumb.extend(p, params);
          p.endpoint = p.endpoint || _currentInstance.Defaults.Endpoint;
          p.paintStyle = p.paintStyle || _currentInstance.Defaults.EndpointStyle;
          var results = [],
              inputs = (_ju.isArray(el) || (el.length != null && !_ju.isString(el))) ? el : [el];
          for (var i = 0,
              j = inputs.length; i < j; i++) {
            p.source = _currentInstance.getElement(inputs[i]);
            _ensureContainer(p.source);
            var id = _getId(p.source),
                e = _newEndpoint(p, id);
            var myOffset = _manage(id, p.source).info.o;
            _ju.addToList(endpointsByElement, id, e);
            if (!_suspendDrawing) {
              e.paint({
                anchorLoc: e.anchor.compute({
                  xy: [myOffset.left, myOffset.top],
                  wh: sizes[id],
                  element: e,
                  timestamp: _suspendedAt
                }),
                timestamp: _suspendedAt
              });
            }
            results.push(e);
            e._doNotDeleteOnDetach = true;
          }
          return results.length == 1 ? results[0] : results;
        };
        this.addEndpoints = function(el, endpoints, referenceParams) {
          var results = [];
          for (var i = 0,
              j = endpoints.length; i < j; i++) {
            var e = _currentInstance.addEndpoint(el, endpoints[i], referenceParams);
            if (_ju.isArray(e))
              Array.prototype.push.apply(results, e);
            else
              results.push(e);
          }
          return results;
        };
        this.animate = function(el, properties, options) {
          if (!this.animationSupported)
            return false;
          options = options || {};
          var del = _currentInstance.getElement(el),
              id = _getId(del),
              stepFunction = jsPlumb.animEvents.step,
              completeFunction = jsPlumb.animEvents.complete;
          options[stepFunction] = _ju.wrap(options[stepFunction], function() {
            _currentInstance.revalidate(id);
          });
          options[completeFunction] = _ju.wrap(options[completeFunction], function() {
            _currentInstance.revalidate(id);
          });
          _currentInstance.doAnimate(del, properties, options);
        };
        this.checkCondition = function(conditionName, args) {
          var l = _currentInstance.getListener(conditionName),
              r = true;
          if (l && l.length > 0) {
            var values = Array.prototype.slice.call(arguments, 1);
            try {
              for (var i = 0,
                  j = l.length; i < j; i++) {
                r = r && l[i].apply(l[i], values);
              }
            } catch (e) {
              _ju.log(_currentInstance, "cannot check condition [" + conditionName + "]" + e);
            }
          }
          return r;
        };
        this.connect = function(params, referenceParams) {
          var _p = _prepareConnectionParams(params, referenceParams),
              jpc;
          if (_p) {
            if (_p.source == null && _p.sourceEndpoint == null) {
              _ju.log("Cannot establish connection - source does not exist");
              return;
            }
            if (_p.target == null && _p.targetEndpoint == null) {
              _ju.log("Cannot establish connection - target does not exist");
              return;
            }
            _ensureContainer(_p.source);
            jpc = _newConnection(_p);
            _finaliseConnection(jpc, _p);
          }
          return jpc;
        };
        var stTypes = [{
          el: "source",
          elId: "sourceId",
          epDefs: "sourceEndpointDefinitions"
        }, {
          el: "target",
          elId: "targetId",
          epDefs: "targetEndpointDefinitions"
        }];
        var _set = function(c, el, idx, doNotRepaint) {
          var ep,
              _st = stTypes[idx],
              cId = c[_st.elId],
              cEl = c[_st.el],
              sid,
              sep,
              oldEndpoint = c.endpoints[idx];
          var evtParams = {
            index: idx,
            originalSourceId: idx === 0 ? cId : c.sourceId,
            newSourceId: c.sourceId,
            originalTargetId: idx == 1 ? cId : c.targetId,
            newTargetId: c.targetId,
            connection: c
          };
          if (el.constructor == jsPlumb.Endpoint) {
            ep = el;
            ep.addConnection(c);
          } else {
            sid = _getId(el);
            sep = this[_st.epDefs][sid];
            if (sid === c[_st.elId])
              ep = null;
            else if (sep) {
              for (var t in sep) {
                if (!sep[t].enabled)
                  return;
                ep = sep[t].endpoint != null && sep[t].endpoint._jsPlumb ? sep[t].endpoint : this.addEndpoint(el, sep[t].def);
                if (sep[t].uniqueEndpoint)
                  sep[t].endpoint = ep;
                ep._doNotDeleteOnDetach = false;
                ep._deleteOnDetach = true;
                ep.addConnection(c);
              }
            } else {
              ep = c.makeEndpoint(idx === 0, el, sid);
              ep._doNotDeleteOnDetach = false;
              ep._deleteOnDetach = true;
            }
          }
          if (ep != null) {
            oldEndpoint.detachFromConnection(c);
            c.endpoints[idx] = ep;
            c[_st.el] = ep.element;
            c[_st.elId] = ep.elementId;
            evtParams[idx === 0 ? "newSourceId" : "newTargetId"] = ep.elementId;
            fireMoveEvent(evtParams);
            if (!doNotRepaint)
              c.repaint();
          }
          return evtParams;
        }.bind(this);
        this.setSource = function(connection, el, doNotRepaint) {
          var p = _set(connection, el, 0, doNotRepaint);
          this.anchorManager.sourceChanged(p.originalSourceId, p.newSourceId, connection);
        };
        this.setTarget = function(connection, el, doNotRepaint) {
          var p = _set(connection, el, 1, doNotRepaint);
          this.anchorManager.updateOtherEndpoint(p.originalSourceId, p.originalTargetId, p.newTargetId, connection);
        };
        this.deleteEndpoint = function(object, dontUpdateHover) {
          var endpoint = (typeof object === "string") ? endpointsByUUID[object] : object;
          if (endpoint) {
            _currentInstance.deleteObject({
              endpoint: endpoint,
              dontUpdateHover: dontUpdateHover
            });
          }
          return _currentInstance;
        };
        this.deleteEveryEndpoint = function() {
          var _is = _currentInstance.setSuspendDrawing(true);
          for (var id in endpointsByElement) {
            var endpoints = endpointsByElement[id];
            if (endpoints && endpoints.length) {
              for (var i = 0,
                  j = endpoints.length; i < j; i++) {
                _currentInstance.deleteEndpoint(endpoints[i], true);
              }
            }
          }
          endpointsByElement = {};
          managedElements = {};
          endpointsByUUID = {};
          offsets = {};
          offsetTimestamps = {};
          _currentInstance.anchorManager.reset();
          _currentInstance.getDragManager().reset();
          if (!_is)
            _currentInstance.setSuspendDrawing(false);
          return _currentInstance;
        };
        var fireDetachEvent = function(jpc, doFireEvent, originalEvent) {
          var connType = _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType(),
              argIsConnection = jpc.constructor == connType,
              params = argIsConnection ? {
                connection: jpc,
                source: jpc.source,
                target: jpc.target,
                sourceId: jpc.sourceId,
                targetId: jpc.targetId,
                sourceEndpoint: jpc.endpoints[0],
                targetEndpoint: jpc.endpoints[1]
              } : jpc;
          if (doFireEvent)
            _currentInstance.fire("connectionDetached", params, originalEvent);
          _currentInstance.anchorManager.connectionDetached(params);
        };
        var fireMoveEvent = _currentInstance.fireMoveEvent = function(params, evt) {
          _currentInstance.fire("connectionMoved", params, evt);
        };
        this.unregisterEndpoint = function(endpoint) {
          if (endpoint._jsPlumb.uuid)
            endpointsByUUID[endpoint._jsPlumb.uuid] = null;
          _currentInstance.anchorManager.deleteEndpoint(endpoint);
          for (var e in endpointsByElement) {
            var endpoints = endpointsByElement[e];
            if (endpoints) {
              var newEndpoints = [];
              for (var i = 0,
                  j = endpoints.length; i < j; i++)
                if (endpoints[i] != endpoint)
                  newEndpoints.push(endpoints[i]);
              endpointsByElement[e] = newEndpoints;
            }
            if (endpointsByElement[e].length < 1) {
              delete endpointsByElement[e];
            }
          }
        };
        this.detach = function() {
          if (arguments.length === 0)
            return;
          var connType = _currentInstance.Defaults.ConnectionType || _currentInstance.getDefaultConnectionType(),
              firstArgIsConnection = arguments[0].constructor == connType,
              params = arguments.length == 2 ? firstArgIsConnection ? (arguments[1] || {}) : arguments[0] : arguments[0],
              fireEvent = (params.fireEvent !== false),
              forceDetach = params.forceDetach,
              conn = firstArgIsConnection ? arguments[0] : params.connection;
          if (conn) {
            if (forceDetach || _ju.functionChain(true, false, [[conn.endpoints[0], "isDetachAllowed", [conn]], [conn.endpoints[1], "isDetachAllowed", [conn]], [conn, "isDetachAllowed", [conn]], [_currentInstance, "checkCondition", ["beforeDetach", conn]]])) {
              conn.endpoints[0].detach(conn, false, true, fireEvent);
            }
          } else {
            var _p = jsPlumb.extend({}, params);
            if (_p.uuids) {
              _getEndpoint(_p.uuids[0]).detachFrom(_getEndpoint(_p.uuids[1]), fireEvent);
            } else if (_p.sourceEndpoint && _p.targetEndpoint) {
              _p.sourceEndpoint.detachFrom(_p.targetEndpoint);
            } else {
              var sourceId = _getId(_currentInstance.getElement(_p.source)),
                  targetId = _getId(_currentInstance.getElement(_p.target));
              _operation(sourceId, function(jpc) {
                if ((jpc.sourceId == sourceId && jpc.targetId == targetId) || (jpc.targetId == sourceId && jpc.sourceId == targetId)) {
                  if (_currentInstance.checkCondition("beforeDetach", jpc)) {
                    jpc.endpoints[0].detach(jpc, false, true, fireEvent);
                  }
                }
              });
            }
          }
        };
        this.detachAllConnections = function(el, params) {
          params = params || {};
          el = _currentInstance.getElement(el);
          var id = _getId(el),
              endpoints = endpointsByElement[id];
          if (endpoints && endpoints.length) {
            for (var i = 0,
                j = endpoints.length; i < j; i++) {
              endpoints[i].detachAll(params.fireEvent !== false, params.forceDetach);
            }
          }
          return _currentInstance;
        };
        this.detachEveryConnection = function(params) {
          params = params || {};
          _currentInstance.batch(function() {
            for (var id in endpointsByElement) {
              var endpoints = endpointsByElement[id];
              if (endpoints && endpoints.length) {
                for (var i = 0,
                    j = endpoints.length; i < j; i++) {
                  endpoints[i].detachAll(params.fireEvent !== false, params.forceDetach);
                }
              }
            }
            connections.length = 0;
          });
          return _currentInstance;
        };
        this.deleteObject = function(params) {
          var result = {
            endpoints: {},
            connections: {},
            endpointCount: 0,
            connectionCount: 0
          },
              fireEvent = params.fireEvent !== false,
              deleteAttachedObjects = params.deleteAttachedObjects !== false;
          var unravelConnection = function(connection) {
            if (connection != null && result.connections[connection.id] == null) {
              if (!params.dontUpdateHover && connection._jsPlumb != null)
                connection.setHover(false);
              result.connections[connection.id] = connection;
              result.connectionCount++;
              if (deleteAttachedObjects) {
                for (var j = 0; j < connection.endpoints.length; j++) {
                  if (connection.endpoints[j]._deleteOnDetach)
                    unravelEndpoint(connection.endpoints[j]);
                }
              }
            }
          };
          var unravelEndpoint = function(endpoint) {
            if (endpoint != null && result.endpoints[endpoint.id] == null) {
              if (!params.dontUpdateHover && endpoint._jsPlumb != null)
                endpoint.setHover(false);
              result.endpoints[endpoint.id] = endpoint;
              result.endpointCount++;
              if (deleteAttachedObjects) {
                for (var i = 0; i < endpoint.connections.length; i++) {
                  var c = endpoint.connections[i];
                  unravelConnection(c);
                }
              }
            }
          };
          if (params.connection)
            unravelConnection(params.connection);
          else
            unravelEndpoint(params.endpoint);
          for (var i in result.connections) {
            var c = result.connections[i];
            if (c._jsPlumb) {
              _ju.removeWithFunction(connections, function(_c) {
                return c.id == _c.id;
              });
              fireDetachEvent(c, params.fireEvent === false ? false : !c.pending, params.originalEvent);
              c.endpoints[0].detachFromConnection(c);
              c.endpoints[1].detachFromConnection(c);
              c.cleanup(true);
              c.destroy(true);
            }
          }
          for (var j in result.endpoints) {
            var e = result.endpoints[j];
            if (e._jsPlumb) {
              _currentInstance.unregisterEndpoint(e);
              e.cleanup(true);
              e.destroy(true);
            }
          }
          return result;
        };
        this.draggable = function(el, options) {
          var info;
          _each(function(_el) {
            info = _info(_el);
            if (info.el)
              _initDraggableIfNecessary(info.el, true, options, info.id);
          }, el);
          return _currentInstance;
        };
        this.droppable = function(el, options) {
          var info;
          options = options || {};
          options.allowLoopback = false;
          _each(function(_el) {
            info = _info(_el);
            if (info.el)
              _currentInstance.initDroppable(info.el, options);
          }, el);
          return _currentInstance;
        };
        var _setOperation = function(list, func, args, selector) {
          for (var i = 0,
              j = list.length; i < j; i++) {
            list[i][func].apply(list[i], args);
          }
          return selector(list);
        },
            _getOperation = function(list, func, args) {
              var out = [];
              for (var i = 0,
                  j = list.length; i < j; i++) {
                out.push([list[i][func].apply(list[i], args), list[i]]);
              }
              return out;
            },
            setter = function(list, func, selector) {
              return function() {
                return _setOperation(list, func, arguments, selector);
              };
            },
            getter = function(list, func) {
              return function() {
                return _getOperation(list, func, arguments);
              };
            },
            prepareList = function(input, doNotGetIds) {
              var r = [];
              if (input) {
                if (typeof input == 'string') {
                  if (input === "*")
                    return input;
                  r.push(input);
                } else {
                  if (doNotGetIds)
                    r = input;
                  else {
                    if (input.length) {
                      for (var i = 0,
                          j = input.length; i < j; i++)
                        r.push(_info(input[i]).id);
                    } else
                      r.push(_info(input).id);
                  }
                }
              }
              return r;
            },
            filterList = function(list, value, missingIsFalse) {
              if (list === "*")
                return true;
              return list.length > 0 ? list.indexOf(value) != -1 : !missingIsFalse;
            };
        this.getConnections = function(options, flat) {
          if (!options) {
            options = {};
          } else if (options.constructor == String) {
            options = {"scope": options};
          }
          var scope = options.scope || _currentInstance.getDefaultScope(),
              scopes = prepareList(scope, true),
              sources = prepareList(options.source),
              targets = prepareList(options.target),
              results = (!flat && scopes.length > 1) ? {} : [],
              _addOne = function(scope, obj) {
                if (!flat && scopes.length > 1) {
                  var ss = results[scope];
                  if (ss == null) {
                    ss = results[scope] = [];
                  }
                  ss.push(obj);
                } else
                  results.push(obj);
              };
          for (var j = 0,
              jj = connections.length; j < jj; j++) {
            var c = connections[j];
            if (filterList(scopes, c.scope) && filterList(sources, c.sourceId) && filterList(targets, c.targetId))
              _addOne(c.scope, c);
          }
          return results;
        };
        var _curryEach = function(list, executor) {
          return function(f) {
            for (var i = 0,
                ii = list.length; i < ii; i++) {
              f(list[i]);
            }
            return executor(list);
          };
        },
            _curryGet = function(list) {
              return function(idx) {
                return list[idx];
              };
            };
        var _makeCommonSelectHandler = function(list, executor) {
          var out = {
            length: list.length,
            each: _curryEach(list, executor),
            get: _curryGet(list)
          },
              setters = ["setHover", "removeAllOverlays", "setLabel", "addClass", "addOverlay", "removeOverlay", "removeOverlays", "showOverlay", "hideOverlay", "showOverlays", "hideOverlays", "setPaintStyle", "setHoverPaintStyle", "setSuspendEvents", "setParameter", "setParameters", "setVisible", "repaint", "addType", "toggleType", "removeType", "removeClass", "setType", "bind", "unbind"],
              getters = ["getLabel", "getOverlay", "isHover", "getParameter", "getParameters", "getPaintStyle", "getHoverPaintStyle", "isVisible", "hasType", "getType", "isSuspendEvents"],
              i,
              ii;
          for (i = 0, ii = setters.length; i < ii; i++)
            out[setters[i]] = setter(list, setters[i], executor);
          for (i = 0, ii = getters.length; i < ii; i++)
            out[getters[i]] = getter(list, getters[i]);
          return out;
        };
        var _makeConnectionSelectHandler = function(list) {
          var common = _makeCommonSelectHandler(list, _makeConnectionSelectHandler);
          return jsPlumb.extend(common, {
            setDetachable: setter(list, "setDetachable", _makeConnectionSelectHandler),
            setReattach: setter(list, "setReattach", _makeConnectionSelectHandler),
            setConnector: setter(list, "setConnector", _makeConnectionSelectHandler),
            detach: function() {
              for (var i = 0,
                  ii = list.length; i < ii; i++)
                _currentInstance.detach(list[i]);
            },
            isDetachable: getter(list, "isDetachable"),
            isReattach: getter(list, "isReattach")
          });
        };
        var _makeEndpointSelectHandler = function(list) {
          var common = _makeCommonSelectHandler(list, _makeEndpointSelectHandler);
          return jsPlumb.extend(common, {
            setEnabled: setter(list, "setEnabled", _makeEndpointSelectHandler),
            setAnchor: setter(list, "setAnchor", _makeEndpointSelectHandler),
            isEnabled: getter(list, "isEnabled"),
            detachAll: function() {
              for (var i = 0,
                  ii = list.length; i < ii; i++)
                list[i].detachAll();
            },
            "remove": function() {
              for (var i = 0,
                  ii = list.length; i < ii; i++)
                _currentInstance.deleteObject({endpoint: list[i]});
            }
          });
        };
        this.select = function(params) {
          params = params || {};
          params.scope = params.scope || "*";
          return _makeConnectionSelectHandler(params.connections || _currentInstance.getConnections(params, true));
        };
        this.selectEndpoints = function(params) {
          params = params || {};
          params.scope = params.scope || "*";
          var noElementFilters = !params.element && !params.source && !params.target,
              elements = noElementFilters ? "*" : prepareList(params.element),
              sources = noElementFilters ? "*" : prepareList(params.source),
              targets = noElementFilters ? "*" : prepareList(params.target),
              scopes = prepareList(params.scope, true);
          var ep = [];
          for (var el in endpointsByElement) {
            var either = filterList(elements, el, true),
                source = filterList(sources, el, true),
                sourceMatchExact = sources != "*",
                target = filterList(targets, el, true),
                targetMatchExact = targets != "*";
            if (either || source || target) {
              inner: for (var i = 0,
                  ii = endpointsByElement[el].length; i < ii; i++) {
                var _ep = endpointsByElement[el][i];
                if (filterList(scopes, _ep.scope, true)) {
                  var noMatchSource = (sourceMatchExact && sources.length > 0 && !_ep.isSource),
                      noMatchTarget = (targetMatchExact && targets.length > 0 && !_ep.isTarget);
                  if (noMatchSource || noMatchTarget)
                    continue inner;
                  ep.push(_ep);
                }
              }
            }
          }
          return _makeEndpointSelectHandler(ep);
        };
        this.getAllConnections = function() {
          return connections;
        };
        this.getDefaultScope = function() {
          return DEFAULT_SCOPE;
        };
        this.getEndpoint = _getEndpoint;
        this.getEndpoints = function(el) {
          return endpointsByElement[_info(el).id];
        };
        this.getDefaultEndpointType = function() {
          return jsPlumb.Endpoint;
        };
        this.getDefaultConnectionType = function() {
          return jsPlumb.Connection;
        };
        this.getId = _getId;
        this.appendElement = _appendElement;
        var _hoverSuspended = false;
        this.isHoverSuspended = function() {
          return _hoverSuspended;
        };
        this.setHoverSuspended = function(s) {
          _hoverSuspended = s;
        };
        this.hide = function(el, changeEndpoints) {
          _setVisible(el, "none", changeEndpoints);
          return _currentInstance;
        };
        this.idstamp = _idstamp;
        this.connectorsInitialized = false;
        this.registerConnectorType = function(connector, name) {
          connectorTypes.push([connector, name]);
        };
        var _ensureContainer = function(candidate) {
          if (!_container && candidate) {
            var can = _currentInstance.getElement(candidate);
            if (can.offsetParent)
              _currentInstance.setContainer(can.offsetParent);
          }
        };
        var _getContainerFromDefaults = function() {
          if (_currentInstance.Defaults.Container)
            _currentInstance.setContainer(_currentInstance.Defaults.Container);
        };
        var _manage = _currentInstance.manage = function(id, element, transient) {
          if (!managedElements[id]) {
            managedElements[id] = {
              el: element,
              endpoints: [],
              connections: []
            };
            managedElements[id].info = _updateOffset({
              elId: id,
              timestamp: _suspendedAt
            });
            if (!transient) {
              _currentInstance.fire("manageElement", {
                id: id,
                info: managedElements[id].info,
                el: element
              });
            }
          }
          return managedElements[id];
        };
        var _unmanage = function(id) {
          if (managedElements[id]) {
            delete managedElements[id];
            _currentInstance.fire("unmanageElement", id);
          }
        };
        var _updateOffset = this.updateOffset = function(params) {
          var timestamp = params.timestamp,
              recalc = params.recalc,
              offset = params.offset,
              elId = params.elId,
              s;
          if (_suspendDrawing && !timestamp)
            timestamp = _suspendedAt;
          if (!recalc) {
            if (timestamp && timestamp === offsetTimestamps[elId]) {
              return {
                o: params.offset || offsets[elId],
                s: sizes[elId]
              };
            }
          }
          if (recalc || (!offset && offsets[elId] == null)) {
            s = managedElements[elId] ? managedElements[elId].el : null;
            if (s != null) {
              sizes[elId] = _currentInstance.getSize(s);
              offsets[elId] = _currentInstance.getOffset(s);
              offsetTimestamps[elId] = timestamp;
            }
          } else {
            offsets[elId] = offset || offsets[elId];
            if (sizes[elId] == null) {
              s = managedElements[elId].el;
              if (s != null)
                sizes[elId] = _currentInstance.getSize(s);
            }
            offsetTimestamps[elId] = timestamp;
          }
          if (offsets[elId] && !offsets[elId].right) {
            offsets[elId].right = offsets[elId].left + sizes[elId][0];
            offsets[elId].bottom = offsets[elId].top + sizes[elId][1];
            offsets[elId].width = sizes[elId][0];
            offsets[elId].height = sizes[elId][1];
            offsets[elId].centerx = offsets[elId].left + (offsets[elId].width / 2);
            offsets[elId].centery = offsets[elId].top + (offsets[elId].height / 2);
          }
          return {
            o: offsets[elId],
            s: sizes[elId]
          };
        };
        this.init = function() {
          rendererTypes = jsPlumb.getRenderModes();
          var _oneType = function(renderer, name, fn) {
            jsPlumb.Connectors[renderer][name] = function() {
              fn.apply(this, arguments);
              jsPlumb.ConnectorRenderers[renderer].apply(this, arguments);
            };
            _ju.extend(jsPlumb.Connectors[renderer][name], [fn, jsPlumb.ConnectorRenderers[renderer]]);
          };
          if (!jsPlumb.connectorsInitialized) {
            for (var i = 0; i < connectorTypes.length; i++) {
              for (var j = 0; j < rendererTypes.length; j++) {
                _oneType(rendererTypes[j], connectorTypes[i][1], connectorTypes[i][0]);
              }
            }
            jsPlumb.connectorsInitialized = true;
          }
          if (!initialized) {
            _getContainerFromDefaults();
            _currentInstance.anchorManager = new jsPlumb.AnchorManager({jsPlumbInstance: _currentInstance});
            initialized = true;
            _currentInstance.fire("ready", _currentInstance);
          }
        }.bind(this);
        this.log = log;
        this.jsPlumbUIComponent = jsPlumbUIComponent;
        this.makeAnchor = function() {
          var pp,
              _a = function(t, p) {
                if (jsPlumb.Anchors[t])
                  return new jsPlumb.Anchors[t](p);
                if (!_currentInstance.Defaults.DoNotThrowErrors)
                  throw {msg: "jsPlumb: unknown anchor type '" + t + "'"};
              };
          if (arguments.length === 0)
            return null;
          var specimen = arguments[0],
              elementId = arguments[1],
              jsPlumbInstance = arguments[2],
              newAnchor = null;
          if (specimen.compute && specimen.getOrientation)
            return specimen;
          else if (typeof specimen == "string") {
            newAnchor = _a(arguments[0], {
              elementId: elementId,
              jsPlumbInstance: _currentInstance
            });
          } else if (_ju.isArray(specimen)) {
            if (_ju.isArray(specimen[0]) || _ju.isString(specimen[0])) {
              if (specimen.length == 2 && _ju.isObject(specimen[1])) {
                if (_ju.isString(specimen[0])) {
                  pp = jsPlumb.extend({
                    elementId: elementId,
                    jsPlumbInstance: _currentInstance
                  }, specimen[1]);
                  newAnchor = _a(specimen[0], pp);
                } else {
                  pp = jsPlumb.extend({
                    elementId: elementId,
                    jsPlumbInstance: _currentInstance,
                    anchors: specimen[0]
                  }, specimen[1]);
                  newAnchor = new jsPlumb.DynamicAnchor(pp);
                }
              } else
                newAnchor = new jsPlumb.DynamicAnchor({
                  anchors: specimen,
                  selector: null,
                  elementId: elementId,
                  jsPlumbInstance: _currentInstance
                });
            } else {
              var anchorParams = {
                x: specimen[0],
                y: specimen[1],
                orientation: (specimen.length >= 4) ? [specimen[2], specimen[3]] : [0, 0],
                offsets: (specimen.length >= 6) ? [specimen[4], specimen[5]] : [0, 0],
                elementId: elementId,
                jsPlumbInstance: _currentInstance,
                cssClass: specimen.length == 7 ? specimen[6] : null
              };
              newAnchor = new jsPlumb.Anchor(anchorParams);
              newAnchor.clone = function() {
                return new jsPlumb.Anchor(anchorParams);
              };
            }
          }
          if (!newAnchor.id)
            newAnchor.id = "anchor_" + _idstamp();
          return newAnchor;
        };
        this.makeAnchors = function(types, elementId, jsPlumbInstance) {
          var r = [];
          for (var i = 0,
              ii = types.length; i < ii; i++) {
            if (typeof types[i] == "string")
              r.push(jsPlumb.Anchors[types[i]]({
                elementId: elementId,
                jsPlumbInstance: jsPlumbInstance
              }));
            else if (_ju.isArray(types[i]))
              r.push(_currentInstance.makeAnchor(types[i], elementId, jsPlumbInstance));
          }
          return r;
        };
        this.makeDynamicAnchor = function(anchors, anchorSelector) {
          return new jsPlumb.DynamicAnchor({
            anchors: anchors,
            selector: anchorSelector,
            elementId: null,
            jsPlumbInstance: _currentInstance
          });
        };
        this.targetEndpointDefinitions = {};
        var _setEndpointPaintStylesAndAnchor = function(ep, epIndex, _instance) {};
        this.sourceEndpointDefinitions = {};
        var selectorFilter = function(evt, _el, selector, _instance, negate) {
          var t = evt.target || evt.srcElement,
              ok = false,
              sel = _instance.getSelector(_el, selector);
          for (var j = 0; j < sel.length; j++) {
            if (sel[j] == t) {
              ok = true;
              break;
            }
          }
          return negate ? !ok : ok;
        };
        var _makeElementDropHandler = function(elInfo, p, dropOptions, isSource, isTarget) {
          var proxyComponent = new jsPlumbUIComponent(p);
          var _drop = p._jsPlumb.EndpointDropHandler({
            jsPlumb: _currentInstance,
            enabled: function() {
              return elInfo.def.enabled;
            },
            isFull: function() {
              var targetCount = _currentInstance.select({target: elInfo.id}).length;
              return elInfo.def.maxConnections > 0 && targetCount >= elInfo.def.maxConnections;
            },
            element: elInfo.el,
            elementId: elInfo.id,
            isSource: isSource,
            isTarget: isTarget,
            addClass: function(clazz) {
              _currentInstance.addClass(elInfo.el, clazz);
            },
            removeClass: function(clazz) {
              _currentInstance.removeClass(elInfo.el, clazz);
            },
            onDrop: function(jpc) {
              var source = jpc.endpoints[0];
              source.anchor.locked = false;
            },
            isDropAllowed: function() {
              return proxyComponent.isDropAllowed.apply(proxyComponent, arguments);
            },
            isRedrop: function(jpc) {
              return (jpc.suspendedElement != null && jpc.suspendedEndpoint != null && jpc.suspendedEndpoint.element === elInfo.el);
            },
            getEndpoint: function(jpc) {
              var newEndpoint = elInfo.def.endpoint;
              if (newEndpoint == null || newEndpoint._jsPlumb == null) {
                var eps = _currentInstance.deriveEndpointAndAnchorSpec(jpc.getType().join(" "), true);
                var pp = eps.endpoints ? jsPlumb.extend(p, {endpoint: elInfo.def.def.endpoint || eps.endpoints[1]}) : p;
                if (eps.anchors) {
                  pp = jsPlumb.extend(pp, {anchor: elInfo.def.def.anchor || eps.anchors[1]});
                }
                newEndpoint = _currentInstance.addEndpoint(elInfo.el, pp);
                newEndpoint._mtNew = true;
              }
              if (p.uniqueEndpoint)
                elInfo.def.endpoint = newEndpoint;
              newEndpoint._doNotDeleteOnDetach = false;
              newEndpoint._deleteOnDetach = true;
              if (jpc.isDetachable())
                newEndpoint.initDraggable();
              if (newEndpoint.anchor.positionFinder != null) {
                var dropPosition = _currentInstance.getUIPosition(arguments, _currentInstance.getZoom()),
                    elPosition = _currentInstance.getOffset(elInfo.el),
                    elSize = _currentInstance.getSize(elInfo.el),
                    ap = newEndpoint.anchor.positionFinder(dropPosition, elPosition, elSize, newEndpoint.anchor.constructorParams);
                newEndpoint.anchor.x = ap[0];
                newEndpoint.anchor.y = ap[1];
              }
              return newEndpoint;
            },
            maybeCleanup: function(ep) {
              if (ep._mtNew && ep.connections.length === 0) {
                _currentInstance.deleteObject({endpoint: ep});
              } else
                delete ep._mtNew;
            }
          });
          var dropEvent = jsPlumb.dragEvents.drop;
          dropOptions.scope = dropOptions.scope || (p.scope || _currentInstance.Defaults.Scope);
          dropOptions[dropEvent] = _ju.wrap(dropOptions[dropEvent], _drop, true);
          if (isTarget) {
            dropOptions[jsPlumb.dragEvents.over] = function() {
              return true;
            };
          }
          if (p.allowLoopback === false) {
            dropOptions.canDrop = function(_drag) {
              var de = _drag.getDragElement()._jsPlumbRelatedElement;
              return de != elInfo.el;
            };
          }
          _currentInstance.initDroppable(elInfo.el, dropOptions, "internal");
          return _drop;
        };
        this.makeTarget = function(el, params, referenceParams) {
          var p = jsPlumb.extend({_jsPlumb: this}, referenceParams);
          jsPlumb.extend(p, params);
          _setEndpointPaintStylesAndAnchor(p, 1, this);
          var deleteEndpointsOnDetach = !(p.deleteEndpointsOnDetach === false),
              maxConnections = p.maxConnections || -1,
              _doOne = function(el) {
                var elInfo = _info(el),
                    elid = elInfo.id,
                    dropOptions = jsPlumb.extend({}, p.dropOptions || {}),
                    type = "default";
                this.targetEndpointDefinitions[elid] = this.targetEndpointDefinitions[elid] || {};
                _ensureContainer(elid);
                var _def = {
                  def: jsPlumb.extend({}, p),
                  uniqueEndpoint: p.uniqueEndpoint,
                  maxConnections: maxConnections,
                  enabled: true
                };
                elInfo.def = _def;
                this.targetEndpointDefinitions[elid][type] = _def;
                _makeElementDropHandler(elInfo, p, dropOptions, p.isSource === true, true);
                elInfo.el._katavorioDrop[elInfo.el._katavorioDrop.length - 1].targetDef = _def;
              }.bind(this);
          var inputs = el.length && el.constructor != String ? el : [el];
          for (var i = 0,
              ii = inputs.length; i < ii; i++) {
            _doOne(inputs[i]);
          }
          return this;
        };
        this.unmakeTarget = function(el, doNotClearArrays) {
          var info = _info(el);
          jsPlumb.destroyDroppable(info.el);
          if (!doNotClearArrays) {
            delete this.targetEndpointDefinitions[info.id];
          }
          return this;
        };
        this.makeSource = function(el, params, referenceParams) {
          var p = jsPlumb.extend({_jsPlumb: this}, referenceParams);
          jsPlumb.extend(p, params);
          var type = p.connectionType || "default";
          var aae = _currentInstance.deriveEndpointAndAnchorSpec(type);
          p.endpoint = p.endpoint || aae.endpoints[0];
          p.anchor = p.anchor || aae.anchors[0];
          _setEndpointPaintStylesAndAnchor(p, 0, this);
          var maxConnections = p.maxConnections || -1,
              onMaxConnections = p.onMaxConnections,
              _doOne = function(elInfo) {
                var elid = elInfo.id,
                    _del = this.getElement(elInfo.el);
                this.sourceEndpointDefinitions[elid] = this.sourceEndpointDefinitions[elid] || {};
                _ensureContainer(elid);
                var _def = {
                  def: jsPlumb.extend({}, p),
                  uniqueEndpoint: p.uniqueEndpoint,
                  maxConnections: maxConnections,
                  enabled: true
                };
                this.sourceEndpointDefinitions[elid][type] = _def;
                elInfo.def = _def;
                var stopEvent = jsPlumb.dragEvents.stop,
                    dragEvent = jsPlumb.dragEvents.drag,
                    dragOptions = jsPlumb.extend({}, p.dragOptions || {}),
                    existingDrag = dragOptions.drag,
                    existingStop = dragOptions.stop,
                    ep = null,
                    endpointAddedButNoDragYet = false;
                dragOptions.scope = dragOptions.scope || p.scope;
                dragOptions[dragEvent] = _ju.wrap(dragOptions[dragEvent], function() {
                  if (existingDrag)
                    existingDrag.apply(this, arguments);
                  endpointAddedButNoDragYet = false;
                });
                dragOptions[stopEvent] = _ju.wrap(dragOptions[stopEvent], function() {
                  if (existingStop)
                    existingStop.apply(this, arguments);
                  this.currentlyDragging = false;
                  if (ep._jsPlumb != null) {
                    var anchorDef = p.anchor || this.Defaults.Anchor,
                        oldAnchor = ep.anchor,
                        oldConnection = ep.connections[0];
                    var newAnchor = this.makeAnchor(anchorDef, elid, this),
                        _el = ep.element;
                    if (newAnchor.positionFinder != null) {
                      var elPosition = _currentInstance.getOffset(_el),
                          elSize = this.getSize(_el),
                          dropPosition = {
                            left: elPosition.left + (oldAnchor.x * elSize[0]),
                            top: elPosition.top + (oldAnchor.y * elSize[1])
                          },
                          ap = newAnchor.positionFinder(dropPosition, elPosition, elSize, newAnchor.constructorParams);
                      newAnchor.x = ap[0];
                      newAnchor.y = ap[1];
                    }
                    ep.setAnchor(newAnchor, true);
                    ep.repaint();
                    this.repaint(ep.elementId);
                    if (oldConnection != null)
                      this.repaint(oldConnection.targetId);
                  }
                }.bind(this));
                var mouseDownListener = function(e) {
                  if (e.which === 3 || e.button === 2)
                    return;
                  var def = this.sourceEndpointDefinitions[elid][type];
                  if (!def.enabled)
                    return;
                  elid = this.getId(this.getElement(elInfo.el));
                  if (p.filter) {
                    var r = _ju.isString(p.filter) ? selectorFilter(e, elInfo.el, p.filter, this, p.filterExclude) : p.filter(e, elInfo.el);
                    if (r === false)
                      return;
                  }
                  var sourceCount = this.select({source: elid}).length;
                  if (def.maxConnections >= 0 && (sourceCount >= def.maxConnections)) {
                    if (onMaxConnections) {
                      onMaxConnections({
                        element: elInfo.el,
                        maxConnections: maxConnections
                      }, e);
                    }
                    return false;
                  }
                  var elxy = jsPlumb.getPositionOnElement(e, _del, _zoom);
                  var tempEndpointParams = {};
                  jsPlumb.extend(tempEndpointParams, p);
                  tempEndpointParams.isTemporarySource = true;
                  tempEndpointParams.anchor = [elxy[0], elxy[1], 0, 0];
                  tempEndpointParams.dragOptions = dragOptions;
                  if (def.def.scope)
                    tempEndpointParams.scope = def.def.scope;
                  ep = this.addEndpoint(elid, tempEndpointParams);
                  endpointAddedButNoDragYet = true;
                  ep._doNotDeleteOnDetach = false;
                  ep._deleteOnDetach = true;
                  if (def.uniqueEndpoint) {
                    if (!def.endpoint) {
                      def.endpoint = ep;
                      ep._deleteOnDetach = false;
                      ep._doNotDeleteOnDetach = true;
                    } else
                      ep.finalEndpoint = def.endpoint;
                  }
                  var _delTempEndpoint = function() {
                    _currentInstance.off(ep.canvas, "mouseup", _delTempEndpoint);
                    _currentInstance.off(elInfo.el, "mouseup", _delTempEndpoint);
                    if (endpointAddedButNoDragYet) {
                      endpointAddedButNoDragYet = false;
                      _currentInstance.deleteEndpoint(ep);
                    }
                  };
                  _currentInstance.on(ep.canvas, "mouseup", _delTempEndpoint);
                  _currentInstance.on(elInfo.el, "mouseup", _delTempEndpoint);
                  var payload = {};
                  if (def.def.extract) {
                    for (var att in def.def.extract) {
                      var v = e.srcElement.getAttribute(att);
                      if (v) {
                        payload[def.def.extract[att]] = v;
                      }
                    }
                  }
                  _currentInstance.trigger(ep.canvas, "mousedown", e, payload);
                  _ju.consume(e);
                }.bind(this);
                this.on(elInfo.el, "mousedown", mouseDownListener);
                _def.trigger = mouseDownListener;
                if (p.filter && (_ju.isString(p.filter) || _ju.isFunction(p.filter))) {
                  _currentInstance.setDragFilter(elInfo.el, p.filter);
                }
                var dropOptions = jsPlumb.extend({}, p.dropOptions || {});
                _makeElementDropHandler(elInfo, p, dropOptions, true, p.isTarget === true);
              }.bind(this);
          var inputs = el.length && el.constructor != String ? el : [el];
          for (var i = 0,
              ii = inputs.length; i < ii; i++) {
            _doOne(_info(inputs[i]));
          }
          return this;
        };
        this.unmakeSource = function(el, connectionType, doNotClearArrays) {
          var info = _info(el);
          var eldefs = this.sourceEndpointDefinitions[info.id];
          if (eldefs) {
            for (var def in eldefs) {
              if (connectionType == null || connectionType === def) {
                var mouseDownListener = eldefs[def].trigger;
                if (mouseDownListener)
                  _currentInstance.off(info.el, "mousedown", mouseDownListener);
                if (!doNotClearArrays) {
                  delete this.sourceEndpointDefinitions[info.id][def];
                }
              }
            }
          }
          return this;
        };
        this.unmakeEverySource = function() {
          for (var i in this.sourceEndpointDefinitions)
            _currentInstance.unmakeSource(i, null, true);
          this.sourceEndpointDefinitions = {};
          return this;
        };
        var _getScope = function(el, types, connectionType) {
          types = _ju.isArray(types) ? types : [types];
          var id = _getId(el);
          connectionType = connectionType || "default";
          for (var i = 0; i < types.length; i++) {
            var eldefs = this[types[i]][id];
            if (eldefs && eldefs[connectionType])
              return eldefs[connectionType].def.scope || this.Defaults.Scope;
          }
        }.bind(this);
        var _setScope = function(el, scope, types, connectionType) {
          types = _ju.isArray(types) ? types : [types];
          var id = _getId(el);
          connectionType = connectionType || "default";
          for (var i = 0; i < types.length; i++) {
            var eldefs = this[types[i]][id];
            if (eldefs && eldefs[connectionType]) {
              eldefs[connectionType].def.scope = scope;
            }
          }
        }.bind(this);
        this.getScope = function(el, scope) {
          return _getScope(el, ["sourceEndpointDefinitions", "targetEndpointDefinitions"]);
        };
        this.getSourceScope = function(el) {
          return _getScope(el, "sourceEndpointDefinitions");
        };
        this.getTargetScope = function(el) {
          return _getScope(el, "targetEndpointDefinitions");
        };
        this.setScope = function(el, scope, connectionType) {
          this.setSourceScope(el, scope, connectionType);
          this.setTargetScope(el, scope, connectionType);
        };
        this.setSourceScope = function(el, scope, connectionType) {
          _setScope(el, scope, "sourceEndpointDefinitions", connectionType);
          this.setDragScope(el, scope);
        };
        this.setTargetScope = function(el, scope, connectionType) {
          _setScope(el, scope, "targetEndpointDefinitions", connectionType);
          this.setDropScope(el, scope);
        };
        this.unmakeEveryTarget = function() {
          for (var i in this.targetEndpointDefinitions)
            _currentInstance.unmakeTarget(i, true);
          this.targetEndpointDefinitions = {};
          return this;
        };
        var _setEnabled = function(type, el, state, toggle, connectionType) {
          var a = type == "source" ? this.sourceEndpointDefinitions : this.targetEndpointDefinitions;
          connectionType = connectionType || "default";
          if (_ju.isString(el) && a[el] && a[el][connectionType]) {
            a[el][connectionType].enabled = toggle ? !a[el][connectionType].enabled : state;
          } else if (el.length) {
            for (var i = 0,
                ii = el.length; i < ii; i++) {
              var info = _info(el[i]);
              if (a[info.id] && a[info.id][connectionType])
                a[info.id][connectionType].enabled = toggle ? !a[info.id][connectionType].enabled : state;
            }
          } else {
            var id = _info(el).id;
            if (a[id] && a[id][connectionType])
              a[id][connectionType].enabled = toggle ? !a[id][connectionType].enabled : state;
          }
          return this;
        }.bind(this);
        var _first = function(el, fn) {
          if (_ju.isString(el) || !el.length)
            return fn.apply(this, [el]);
          else if (el.length)
            return fn.apply(this, [el[0]]);
        }.bind(this);
        this.toggleSourceEnabled = function(el, connectionType) {
          _setEnabled("source", el, null, true, connectionType);
          return this.isSourceEnabled(el, connectionType);
        };
        this.setSourceEnabled = function(el, state, connectionType) {
          return _setEnabled("source", el, state, null, connectionType);
        };
        this.isSource = function(el, connectionType) {
          connectionType = connectionType || "default";
          return _first(el, function(_el) {
            var eldefs = this.sourceEndpointDefinitions[_info(_el).id];
            return eldefs != null && eldefs[connectionType] != null;
          }.bind(this));
        };
        this.isSourceEnabled = function(el, connectionType) {
          connectionType = connectionType || "default";
          return _first(el, function(_el) {
            var sep = this.sourceEndpointDefinitions[_info(_el).id];
            return sep && sep[connectionType] && sep[connectionType].enabled === true;
          }.bind(this));
        };
        this.toggleTargetEnabled = function(el, connectionType) {
          _setEnabled("target", el, null, true, connectionType);
          return this.isTargetEnabled(el, connectionType);
        };
        this.isTarget = function(el, connectionType) {
          connectionType = connectionType || "default";
          return _first(el, function(_el) {
            var eldefs = this.targetEndpointDefinitions[_info(_el).id];
            return eldefs != null && eldefs[connectionType] != null;
          }.bind(this));
        };
        this.isTargetEnabled = function(el, connectionType) {
          connectionType = connectionType || "default";
          return _first(el, function(_el) {
            var tep = this.targetEndpointDefinitions[_info(_el).id];
            return tep && tep[connectionType] && tep[connectionType].enabled === true;
          }.bind(this));
        };
        this.setTargetEnabled = function(el, state, connectionType) {
          return _setEnabled("target", el, state, null, connectionType);
        };
        this.ready = function(fn) {
          _currentInstance.bind("ready", fn);
        };
        var _elEach = function(el, fn) {
          if (typeof el == 'object' && el.length)
            for (var i = 0,
                ii = el.length; i < ii; i++) {
              fn(el[i]);
            }
          else
            fn(el);
          return _currentInstance;
        };
        this.repaint = function(el, ui, timestamp) {
          return _elEach(el, function(_el) {
            _draw(_el, ui, timestamp);
          });
        };
        this.revalidate = function(el, timestamp, isIdAlready) {
          return _elEach(el, function(_el) {
            var elId = isIdAlready ? _el : _currentInstance.getId(_el);
            _currentInstance.updateOffset({
              elId: elId,
              recalc: true,
              timestamp: timestamp
            });
            _currentInstance.repaint(_el);
          });
        };
        this.repaintEverything = function() {
          var timestamp = _timestamp(),
              elId;
          for (elId in endpointsByElement) {
            _currentInstance.updateOffset({
              elId: elId,
              recalc: true,
              timestamp: timestamp
            });
          }
          for (elId in endpointsByElement) {
            _draw(elId, null, timestamp);
          }
          return this;
        };
        this.removeAllEndpoints = function(el, recurse, affectedElements) {
          affectedElements = affectedElements || [];
          var _one = function(_el) {
            var info = _info(_el),
                ebe = endpointsByElement[info.id],
                i,
                ii;
            if (ebe) {
              affectedElements.push(info);
              for (i = 0, ii = ebe.length; i < ii; i++)
                _currentInstance.deleteEndpoint(ebe[i], false);
            }
            delete endpointsByElement[info.id];
            if (recurse) {
              if (info.el && info.el.nodeType != 3 && info.el.nodeType != 8) {
                for (i = 0, ii = info.el.childNodes.length; i < ii; i++) {
                  _one(info.el.childNodes[i]);
                }
              }
            }
          };
          _one(el);
          return this;
        };
        var _doRemove = function(info, affectedElements) {
          _currentInstance.removeAllEndpoints(info.id, true, affectedElements);
          var _one = function(_info) {
            _currentInstance.getDragManager().elementRemoved(_info.id);
            _currentInstance.anchorManager.clearFor(_info.id);
            _currentInstance.anchorManager.removeFloatingConnection(_info.id);
            delete _currentInstance.floatingConnections[_info.id];
            delete managedElements[_info.id];
            delete offsets[_info.id];
            if (_info.el) {
              _currentInstance.removeElement(_info.el);
              _info.el._jsPlumb = null;
            }
          };
          for (var ae = 1; ae < affectedElements.length; ae++) {
            _one(affectedElements[ae]);
          }
          _one(info);
        };
        this.remove = function(el, doNotRepaint) {
          var info = _info(el),
              affectedElements = [];
          if (info.text) {
            info.el.parentNode.removeChild(info.el);
          } else if (info.id) {
            _currentInstance.batch(function() {
              _doRemove(info, affectedElements);
            }, doNotRepaint === false);
          }
          return _currentInstance;
        };
        this.empty = function(el, doNotRepaint) {
          var affectedElements = [];
          var _one = function(el, dontRemoveFocus) {
            var info = _info(el);
            if (info.text) {
              info.el.parentNode.removeChild(info.el);
            } else if (info.el) {
              while (info.el.childNodes.length > 0) {
                _one(info.el.childNodes[0]);
              }
              if (!dontRemoveFocus)
                _doRemove(info, affectedElements);
            }
          };
          _currentInstance.batch(function() {
            _one(el, true);
          }, doNotRepaint === false);
          return _currentInstance;
        };
        this.reset = function() {
          _currentInstance.silently(function() {
            _currentInstance.deleteEveryEndpoint();
            _currentInstance.unbind();
            this.targetEndpointDefinitions = {};
            this.sourceEndpointDefinitions = {};
            connections.length = 0;
            if (this.doReset)
              this.doReset();
          }.bind(this));
        };
        var _clearObject = function(obj) {
          if (obj.canvas && obj.canvas.parentNode)
            obj.canvas.parentNode.removeChild(obj.canvas);
          obj.cleanup();
          obj.destroy();
        };
        this.clear = function() {
          _currentInstance.select().each(_clearObject);
          _currentInstance.selectEndpoints().each(_clearObject);
          endpointsByElement = {};
          endpointsByUUID = {};
        };
        this.setDefaultScope = function(scope) {
          DEFAULT_SCOPE = scope;
          return _currentInstance;
        };
        this.setDraggable = _setDraggable;
        this.deriveEndpointAndAnchorSpec = function(type, dontPrependDefault) {
          var bits = ((dontPrependDefault ? "" : "default ") + type).split(/[\s]/),
              eps = null,
              ep = null,
              a = null,
              as = null;
          for (var i = 0; i < bits.length; i++) {
            var _t = _currentInstance.getType(bits[i], "connection");
            if (_t) {
              if (_t.endpoints)
                eps = _t.endpoints;
              if (_t.endpoint)
                ep = _t.endpoint;
              if (_t.anchors)
                as = _t.anchors;
              if (_t.anchor)
                a = _t.anchor;
            }
          }
          return {
            endpoints: eps ? eps : [ep, ep],
            anchors: as ? as : [a, a]
          };
        };
        this.setId = function(el, newId, doNotSetAttribute) {
          var id;
          if (_ju.isString(el)) {
            id = el;
          } else {
            el = this.getElement(el);
            id = this.getId(el);
          }
          var sConns = this.getConnections({
            source: id,
            scope: '*'
          }, true),
              tConns = this.getConnections({
                target: id,
                scope: '*'
              }, true);
          newId = "" + newId;
          if (!doNotSetAttribute) {
            el = this.getElement(id);
            this.setAttribute(el, "id", newId);
          } else
            el = this.getElement(newId);
          endpointsByElement[newId] = endpointsByElement[id] || [];
          for (var i = 0,
              ii = endpointsByElement[newId].length; i < ii; i++) {
            endpointsByElement[newId][i].setElementId(newId);
            endpointsByElement[newId][i].setReferenceElement(el);
          }
          delete endpointsByElement[id];
          this.sourceEndpointDefinitions[newId] = this.sourceEndpointDefinitions[id];
          delete this.sourceEndpointDefinitions[id];
          this.targetEndpointDefinitions[newId] = this.targetEndpointDefinitions[id];
          delete this.targetEndpointDefinitions[id];
          this.anchorManager.changeId(id, newId);
          this.getDragManager().changeId(id, newId);
          managedElements[newId] = managedElements[id];
          delete managedElements[id];
          var _conns = function(list, epIdx, type) {
            for (var i = 0,
                ii = list.length; i < ii; i++) {
              list[i].endpoints[epIdx].setElementId(newId);
              list[i].endpoints[epIdx].setReferenceElement(el);
              list[i][type + "Id"] = newId;
              list[i][type] = el;
            }
          };
          _conns(sConns, 0, "source");
          _conns(tConns, 1, "target");
          this.repaint(newId);
        };
        this.setDebugLog = function(debugLog) {
          log = debugLog;
        };
        this.setSuspendDrawing = function(val, repaintAfterwards) {
          var curVal = _suspendDrawing;
          _suspendDrawing = val;
          if (val)
            _suspendedAt = new Date().getTime();
          else
            _suspendedAt = null;
          if (repaintAfterwards)
            this.repaintEverything();
          return curVal;
        };
        this.isSuspendDrawing = function() {
          return _suspendDrawing;
        };
        this.getSuspendedAt = function() {
          return _suspendedAt;
        };
        this.batch = function(fn, doNotRepaintAfterwards) {
          var _wasSuspended = this.isSuspendDrawing();
          if (!_wasSuspended)
            this.setSuspendDrawing(true);
          try {
            fn();
          } catch (e) {
            _ju.log("Function run while suspended failed", e);
          }
          if (!_wasSuspended)
            this.setSuspendDrawing(false, !doNotRepaintAfterwards);
        };
        this.doWhileSuspended = this.batch;
        this.getCachedData = _getCachedData;
        this.timestamp = _timestamp;
        this.show = function(el, changeEndpoints) {
          _setVisible(el, "block", changeEndpoints);
          return _currentInstance;
        };
        this.toggleVisible = _toggleVisible;
        this.toggleDraggable = _toggleDraggable;
        this.addListener = this.bind;
      };
      _ju.extend(jsPlumbInstance, _ju.EventGenerator, {
        setAttribute: function(el, a, v) {
          this.setAttribute(el, a, v);
        },
        getAttribute: function(el, a) {
          return this.getAttribute(jsPlumb.getElement(el), a);
        },
        convertToFullOverlaySpec: function(spec) {
          if (_ju.isString(spec)) {
            spec = [spec, {}];
          }
          spec[1].id = spec[1].id || _ju.uuid();
          return spec;
        },
        registerConnectionType: function(id, type) {
          this._connectionTypes[id] = jsPlumb.extend({}, type);
          if (type.overlays) {
            var to = {};
            for (var i = 0; i < type.overlays.length; i++) {
              var fo = this.convertToFullOverlaySpec(type.overlays[i]);
              to[fo[1].id] = fo;
            }
            this._connectionTypes[id].overlays = to;
          }
        },
        registerConnectionTypes: function(types) {
          for (var i in types)
            this.registerConnectionType(i, types[i]);
        },
        registerEndpointType: function(id, type) {
          this._endpointTypes[id] = jsPlumb.extend({}, type);
          if (type.overlays) {
            var to = {};
            for (var i = 0; i < type.overlays.length; i++) {
              var fo = this.convertToFullOverlaySpec(type.overlays[i]);
              to[fo[1].id] = fo;
            }
            this._endpointTypes[id].overlays = to;
          }
        },
        registerEndpointTypes: function(types) {
          for (var i in types)
            this.registerEndpointType(i, types[i]);
        },
        getType: function(id, typeDescriptor) {
          return typeDescriptor === "connection" ? this._connectionTypes[id] : this._endpointTypes[id];
        },
        setIdChanged: function(oldId, newId) {
          this.setId(oldId, newId, true);
        },
        setParent: function(el, newParent) {
          var _dom = this.getElement(el),
              _id = this.getId(_dom),
              _pdom = this.getElement(newParent),
              _pid = this.getId(_pdom);
          _dom.parentNode.removeChild(_dom);
          _pdom.appendChild(_dom);
          this.getDragManager().setParent(_dom, _id, _pdom, _pid);
        },
        extend: function(o1, o2, names) {
          var i;
          if (names) {
            for (i = 0; i < names.length; i++)
              o1[names[i]] = o2[names[i]];
          } else
            for (i in o2)
              o1[i] = o2[i];
          return o1;
        },
        floatingConnections: {},
        getFloatingAnchorIndex: function(jpc) {
          return jpc.endpoints[0].isFloating() ? 0 : jpc.endpoints[1].isFloating() ? 1 : -1;
        }
      });
      var jsPlumb = new jsPlumbInstance();
      root.jsPlumb = jsPlumb;
      jsPlumb.getInstance = function(_defaults) {
        var j = new jsPlumbInstance(_defaults);
        j.init();
        return j;
      };
      jsPlumb.each = function(spec, fn) {
        if (spec == null)
          return;
        if (typeof spec === "string")
          fn(jsPlumb.getElement(spec));
        else if (spec.length != null) {
          for (var i = 0; i < spec.length; i++)
            fn(jsPlumb.getElement(spec[i]));
        } else
          fn(spec);
      };
      if (typeof define === "function") {
        define("jsplumb", [], function() {
          return jsPlumb;
        });
        define("jsplumbinstance", [], function() {
          return jsPlumb.getInstance();
        });
      }
      if (typeof exports !== 'undefined') {
        exports.jsPlumb = jsPlumb;
      }
    }).call(this);
    ;
    (function() {
      var root = this,
          _ju = root.jsPlumbUtil;
      var svgAvailable = !!window.SVGAngle || document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"),
          _genLoc = function(e, prefix) {
            if (e == null)
              return [0, 0];
            var ts = _touches(e),
                t = _getTouch(ts, 0);
            return [t[prefix + "X"], t[prefix + "Y"]];
          },
          _pageLocation = function(e) {
            if (e == null)
              return [0, 0];
            return _genLoc(e, "page");
          },
          _screenLocation = function(e) {
            return _genLoc(e, "screen");
          },
          _clientLocation = function(e) {
            return _genLoc(e, "client");
          },
          _getTouch = function(touches, idx) {
            return touches.item ? touches.item(idx) : touches[idx];
          },
          _touches = function(e) {
            return e.touches && e.touches.length > 0 ? e.touches : e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches : e.targetTouches && e.targetTouches.length > 0 ? e.targetTouches : [e];
          };
      var DragManager = function(_currentInstance) {
        var _draggables = {},
            _dlist = [],
            _delements = {},
            _elementsWithEndpoints = {},
            _draggablesForElements = {};
        this.register = function(el) {
          var id = _currentInstance.getId(el),
              parentOffset = _currentInstance.getOffset(el);
          if (!_draggables[id]) {
            _draggables[id] = el;
            _dlist.push(el);
            _delements[id] = {};
          }
          var _oneLevel = function(p) {
            if (p) {
              for (var i = 0; i < p.childNodes.length; i++) {
                if (p.childNodes[i].nodeType != 3 && p.childNodes[i].nodeType != 8) {
                  var cEl = jsPlumb.getElement(p.childNodes[i]),
                      cid = _currentInstance.getId(p.childNodes[i], null, true);
                  if (cid && _elementsWithEndpoints[cid] && _elementsWithEndpoints[cid] > 0) {
                    var cOff = _currentInstance.getOffset(cEl);
                    _delements[id][cid] = {
                      id: cid,
                      offset: {
                        left: cOff.left - parentOffset.left,
                        top: cOff.top - parentOffset.top
                      }
                    };
                    _draggablesForElements[cid] = id;
                  }
                  _oneLevel(p.childNodes[i]);
                }
              }
            }
          };
          _oneLevel(el);
        };
        this.updateOffsets = function(elId) {
          if (elId != null) {
            var domEl = jsPlumb.getElement(elId),
                id = _currentInstance.getId(domEl),
                children = _delements[id],
                parentOffset = _currentInstance.getOffset(domEl);
            if (children) {
              for (var i in children) {
                if (children.hasOwnProperty(i)) {
                  var cel = jsPlumb.getElement(i),
                      cOff = _currentInstance.getOffset(cel);
                  _delements[id][i] = {
                    id: i,
                    offset: {
                      left: cOff.left - parentOffset.left,
                      top: cOff.top - parentOffset.top
                    }
                  };
                  _draggablesForElements[i] = id;
                }
              }
            }
          }
        };
        this.endpointAdded = function(el, id) {
          id = id || _currentInstance.getId(el);
          var b = document.body,
              p = el.parentNode;
          _elementsWithEndpoints[id] = _elementsWithEndpoints[id] ? _elementsWithEndpoints[id] + 1 : 1;
          while (p != null && p != b) {
            var pid = _currentInstance.getId(p, null, true);
            if (pid && _draggables[pid]) {
              var pLoc = _currentInstance.getOffset(p);
              if (_delements[pid][id] == null) {
                var cLoc = _currentInstance.getOffset(el);
                _delements[pid][id] = {
                  id: id,
                  offset: {
                    left: cLoc.left - pLoc.left,
                    top: cLoc.top - pLoc.top
                  }
                };
                _draggablesForElements[id] = pid;
              }
              break;
            }
            p = p.parentNode;
          }
        };
        this.endpointDeleted = function(endpoint) {
          if (_elementsWithEndpoints[endpoint.elementId]) {
            _elementsWithEndpoints[endpoint.elementId]--;
            if (_elementsWithEndpoints[endpoint.elementId] <= 0) {
              for (var i in _delements) {
                if (_delements.hasOwnProperty(i) && _delements[i]) {
                  delete _delements[i][endpoint.elementId];
                  delete _draggablesForElements[endpoint.elementId];
                }
              }
            }
          }
        };
        this.changeId = function(oldId, newId) {
          _delements[newId] = _delements[oldId];
          _delements[oldId] = {};
          _draggablesForElements[newId] = _draggablesForElements[oldId];
          _draggablesForElements[oldId] = null;
        };
        this.getElementsForDraggable = function(id) {
          return _delements[id];
        };
        this.elementRemoved = function(elementId) {
          var elId = _draggablesForElements[elementId];
          if (elId) {
            delete _delements[elId][elementId];
            delete _draggablesForElements[elementId];
          }
        };
        this.reset = function() {
          _draggables = {};
          _dlist = [];
          _delements = {};
          _elementsWithEndpoints = {};
        };
        this.dragEnded = function(el) {
          var id = _currentInstance.getId(el),
              ancestor = _draggablesForElements[id];
          if (ancestor)
            this.updateOffsets(ancestor);
        };
        this.setParent = function(el, elId, p, pId) {
          var current = _draggablesForElements[elId];
          if (current) {
            if (!_delements[pId])
              _delements[pId] = {};
            _delements[pId][elId] = _delements[current][elId];
            delete _delements[current][elId];
            var pLoc = _currentInstance.getOffset(p),
                cLoc = _currentInstance.getOffset(el);
            _delements[pId][elId].offset = {
              left: cLoc.left - pLoc.left,
              top: cLoc.top - pLoc.top
            };
            _draggablesForElements[elId] = pId;
          }
        };
        this.getDragAncestor = function(el) {
          var de = jsPlumb.getElement(el),
              id = _currentInstance.getId(de),
              aid = _draggablesForElements[id];
          if (aid)
            return jsPlumb.getElement(aid);
          else
            return null;
        };
      };
      var trim = function(str) {
        return str == null ? null : (str.replace(/^\s\s*/, '').replace(/\s\s*$/, ''));
      },
          _setClassName = function(el, cn) {
            cn = trim(cn);
            if (typeof el.className.baseVal != "undefined")
              el.className.baseVal = cn;
            else
              el.className = cn;
          },
          _getClassName = function(el) {
            return (typeof el.className.baseVal == "undefined") ? el.className : el.className.baseVal;
          },
          _classManip = function(el, classesToAdd, classesToRemove) {
            classesToAdd = classesToAdd == null ? [] : jsPlumbUtil.isArray(classesToAdd) ? classesToAdd : classesToAdd.split(/\s+/);
            classesToRemove = classesToRemove == null ? [] : jsPlumbUtil.isArray(classesToRemove) ? classesToRemove : classesToRemove.split(/\s+/);
            var className = _getClassName(el),
                curClasses = className.split(/\s+/);
            var _oneSet = function(add, classes) {
              for (var i = 0; i < classes.length; i++) {
                if (add) {
                  if (curClasses.indexOf(classes[i]) == -1)
                    curClasses.push(classes[i]);
                } else {
                  var idx = curClasses.indexOf(classes[i]);
                  if (idx != -1)
                    curClasses.splice(idx, 1);
                }
              }
            };
            _oneSet(true, classesToAdd);
            _oneSet(false, classesToRemove);
            _setClassName(el, curClasses.join(" "));
          };
      jsPlumb.extend(jsPlumbInstance.prototype, {
        headless: false,
        pageLocation: _pageLocation,
        screenLocation: _screenLocation,
        clientLocation: _clientLocation,
        getDragManager: function() {
          if (this.dragManager == null)
            this.dragManager = new DragManager(this);
          return this.dragManager;
        },
        recalculateOffsets: function(elId) {
          this.getDragManager().updateOffsets(elId);
        },
        createElement: function(tag, style, clazz, atts) {
          return this.createElementNS(null, tag, style, clazz, atts);
        },
        createElementNS: function(ns, tag, style, clazz, atts) {
          var e = ns == null ? document.createElement(tag) : document.createElementNS(ns, tag);
          var i;
          style = style || {};
          for (i in style)
            e.style[i] = style[i];
          if (clazz)
            e.className = clazz;
          atts = atts || {};
          for (i in atts)
            e.setAttribute(i, "" + atts[i]);
          return e;
        },
        getAttribute: function(el, attName) {
          return el.getAttribute != null ? el.getAttribute(attName) : null;
        },
        setAttribute: function(el, a, v) {
          if (el.setAttribute != null)
            el.setAttribute(a, v);
        },
        setAttributes: function(el, atts) {
          for (var i in atts)
            if (atts.hasOwnProperty(i))
              el.setAttribute(i, atts[i]);
        },
        appendToRoot: function(node) {
          document.body.appendChild(node);
        },
        getRenderModes: function() {
          return ["svg"];
        },
        getClass: _getClassName,
        addClass: function(el, clazz) {
          jsPlumb.each(el, function(e) {
            _classManip(e, clazz);
          });
        },
        hasClass: function(el, clazz) {
          el = jsPlumb.getElement(el);
          if (el.classList)
            return el.classList.contains(clazz);
          else {
            return _getClassName(el).indexOf(clazz) != -1;
          }
        },
        removeClass: function(el, clazz) {
          jsPlumb.each(el, function(e) {
            _classManip(e, null, clazz);
          });
        },
        updateClasses: function(el, toAdd, toRemove) {
          jsPlumb.each(el, function(e) {
            _classManip(e, toAdd, toRemove);
          });
        },
        setClass: function(el, clazz) {
          jsPlumb.each(el, function(e) {
            _setClassName(e, clazz);
          });
        },
        setPosition: function(el, p) {
          el.style.left = p.left + "px";
          el.style.top = p.top + "px";
        },
        getPosition: function(el) {
          var _one = function(prop) {
            var v = el.style[prop];
            return v ? v.substring(0, v.length - 2) : 0;
          };
          return {
            left: _one("left"),
            top: _one("top")
          };
        },
        getStyle: function(el, prop) {
          if (typeof window.getComputedStyle !== 'undefined') {
            return getComputedStyle(el, null).getPropertyValue(prop);
          } else {
            return el.currentStyle[prop];
          }
        },
        getSelector: function(ctx, spec) {
          var sel = null;
          if (arguments.length == 1) {
            sel = ctx.nodeType != null ? ctx : document.querySelectorAll(ctx);
          } else
            sel = ctx.querySelectorAll(spec);
          return sel;
        },
        getOffset: function(el, relativeToRoot, container) {
          el = jsPlumb.getElement(el);
          container = container || this.getContainer();
          var out = {
            left: el.offsetLeft,
            top: el.offsetTop
          },
              op = (relativeToRoot || (container != null && (el != container && el.offsetParent != container))) ? el.offsetParent : null,
              _maybeAdjustScroll = function(offsetParent) {
                if (offsetParent != null && offsetParent !== document.body && (offsetParent.scrollTop > 0 || offsetParent.scrollLeft > 0)) {
                  out.left -= offsetParent.scrollLeft;
                  out.top -= offsetParent.scrollTop;
                }
              }.bind(this);
          while (op != null) {
            out.left += op.offsetLeft;
            out.top += op.offsetTop;
            _maybeAdjustScroll(op);
            op = relativeToRoot ? op.offsetParent : op.offsetParent == container ? null : op.offsetParent;
          }
          if (container != null && !relativeToRoot && (container.scrollTop > 0 || container.scrollLeft > 0)) {
            var pp = el.offsetParent != null ? this.getStyle(el.offsetParent, "position") : "static",
                p = this.getStyle(el, "position");
            if (p !== "absolute" && p !== "fixed" && pp !== "absolute" && pp != "fixed") {
              out.left -= container.scrollLeft;
              out.top -= container.scrollTop;
            }
          }
          return out;
        },
        getPositionOnElement: function(evt, el, zoom) {
          var box = typeof el.getBoundingClientRect !== "undefined" ? el.getBoundingClientRect() : {
            left: 0,
            top: 0,
            width: 0,
            height: 0
          },
              body = document.body,
              docElem = document.documentElement,
              scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
              scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
              clientTop = docElem.clientTop || body.clientTop || 0,
              clientLeft = docElem.clientLeft || body.clientLeft || 0,
              pst = 0,
              psl = 0,
              top = box.top + scrollTop - clientTop + (pst * zoom),
              left = box.left + scrollLeft - clientLeft + (psl * zoom),
              cl = jsPlumb.pageLocation(evt),
              w = box.width || (el.offsetWidth * zoom),
              h = box.height || (el.offsetHeight * zoom),
              x = (cl[0] - left) / w,
              y = (cl[1] - top) / h;
          return [x, y];
        },
        getAbsolutePosition: function(el) {
          var _one = function(s) {
            var ss = el.style[s];
            if (ss)
              return parseFloat(ss.substring(0, ss.length - 2));
          };
          return [_one("left"), _one("top")];
        },
        setAbsolutePosition: function(el, xy, animateFrom, animateOptions) {
          if (animateFrom) {
            this.animate(el, {
              left: "+=" + (xy[0] - animateFrom[0]),
              top: "+=" + (xy[1] - animateFrom[1])
            }, animateOptions);
          } else {
            el.style.left = xy[0] + "px";
            el.style.top = xy[1] + "px";
          }
        },
        getSize: function(el) {
          return [el.offsetWidth, el.offsetHeight];
        },
        getWidth: function(el) {
          return el.offsetWidth;
        },
        getHeight: function(el) {
          return el.offsetHeight;
        }
      });
    }).call(this);
    ;
    (function() {
      "use strict";
      var root = this,
          _jp = root.jsPlumb,
          _ju = root.jsPlumbUtil;
      var _internalLabelOverlayId = "__label",
          _makeLabelOverlay = function(component, params) {
            var _params = {
              cssClass: params.cssClass,
              labelStyle: component.labelStyle,
              id: _internalLabelOverlayId,
              component: component,
              _jsPlumb: component._jsPlumb.instance
            },
                mergedParams = jsPlumb.extend(_params, params);
            return new _jp.Overlays[component._jsPlumb.instance.getRenderMode()].Label(mergedParams);
          },
          _processOverlay = function(component, o) {
            var _newOverlay = null;
            if (_ju.isArray(o)) {
              var type = o[0],
                  p = _jp.extend({
                    component: component,
                    _jsPlumb: component._jsPlumb.instance
                  }, o[1]);
              if (o.length == 3)
                _jp.extend(p, o[2]);
              _newOverlay = new _jp.Overlays[component._jsPlumb.instance.getRenderMode()][type](p);
            } else if (o.constructor == String) {
              _newOverlay = new _jp.Overlays[component._jsPlumb.instance.getRenderMode()][o]({
                component: component,
                _jsPlumb: component._jsPlumb.instance
              });
            } else {
              _newOverlay = o;
            }
            _newOverlay.id = _newOverlay.id || _ju.uuid();
            component.cacheTypeItem("overlay", _newOverlay, _newOverlay.id);
            component._jsPlumb.overlays[_newOverlay.id] = _newOverlay;
            return _newOverlay;
          };
      _jp.OverlayCapableJsPlumbUIComponent = function(params) {
        jsPlumbUIComponent.apply(this, arguments);
        this._jsPlumb.overlays = {};
        this._jsPlumb.overlayPositions = {};
        if (params.label) {
          this.getDefaultType().overlays[_internalLabelOverlayId] = ["Label", {
            label: params.label,
            location: params.labelLocation || this.defaultLabelLocation || 0.5,
            labelStyle: params.labelStyle || this._jsPlumb.instance.Defaults.LabelStyle,
            id: _internalLabelOverlayId
          }];
        }
        this.setListenerComponent = function(c) {
          if (this._jsPlumb) {
            for (var i in this._jsPlumb.overlays)
              this._jsPlumb.overlays[i].setListenerComponent(c);
          }
        };
      };
      _jp.OverlayCapableJsPlumbUIComponent.applyType = function(component, t) {
        if (t.overlays) {
          var keep = {},
              i;
          for (i in t.overlays) {
            var existing = component._jsPlumb.overlays[t.overlays[i][1].id];
            if (existing) {
              existing.updateFrom(t.overlays[i][1]);
              keep[t.overlays[i][1].id] = true;
            } else {
              var c = component.getCachedTypeItem("overlay", t.overlays[i][1].id);
              if (c != null) {
                c.reattach(component._jsPlumb.instance);
                c.updateFrom(t.overlays[i][1]);
                component._jsPlumb.overlays[c.id] = c;
              } else {
                c = component.addOverlay(t.overlays[i], true);
              }
              keep[c.id] = true;
            }
          }
          for (i in component._jsPlumb.overlays) {
            if (keep[component._jsPlumb.overlays[i].id] == null)
              component.removeOverlay(component._jsPlumb.overlays[i].id, true);
          }
        }
      };
      _ju.extend(_jp.OverlayCapableJsPlumbUIComponent, root.jsPlumbUIComponent, {
        setHover: function(hover, ignoreAttachedElements) {
          if (this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged()) {
            for (var i in this._jsPlumb.overlays) {
              this._jsPlumb.overlays[i][hover ? "addClass" : "removeClass"](this._jsPlumb.instance.hoverClass);
            }
          }
        },
        addOverlay: function(overlay, doNotRepaint) {
          var o = _processOverlay(this, overlay);
          if (!doNotRepaint)
            this.repaint();
          return o;
        },
        getOverlay: function(id) {
          return this._jsPlumb.overlays[id];
        },
        getOverlays: function() {
          return this._jsPlumb.overlays;
        },
        hideOverlay: function(id) {
          var o = this.getOverlay(id);
          if (o)
            o.hide();
        },
        hideOverlays: function() {
          for (var i in this._jsPlumb.overlays)
            this._jsPlumb.overlays[i].hide();
        },
        showOverlay: function(id) {
          var o = this.getOverlay(id);
          if (o)
            o.show();
        },
        showOverlays: function() {
          for (var i in this._jsPlumb.overlays)
            this._jsPlumb.overlays[i].show();
        },
        removeAllOverlays: function(doNotRepaint) {
          for (var i in this._jsPlumb.overlays) {
            if (this._jsPlumb.overlays[i].cleanup)
              this._jsPlumb.overlays[i].cleanup();
          }
          this._jsPlumb.overlays = {};
          this._jsPlumb.overlayPositions = null;
          if (!doNotRepaint)
            this.repaint();
        },
        removeOverlay: function(overlayId, dontCleanup) {
          var o = this._jsPlumb.overlays[overlayId];
          if (o) {
            if (!dontCleanup && o.cleanup)
              o.cleanup();
            delete this._jsPlumb.overlays[overlayId];
            if (this._jsPlumb.overlayPositions)
              delete this._jsPlumb.overlayPositions[overlayId];
          }
        },
        removeOverlays: function() {
          for (var i = 0,
              j = arguments.length; i < j; i++)
            this.removeOverlay(arguments[i]);
        },
        moveParent: function(newParent) {
          if (this.bgCanvas) {
            this.bgCanvas.parentNode.removeChild(this.bgCanvas);
            newParent.appendChild(this.bgCanvas);
          }
          if (this.canvas && this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
            newParent.appendChild(this.canvas);
            for (var i in this._jsPlumb.overlays) {
              if (this._jsPlumb.overlays[i].isAppendedAtTopLevel) {
                var el = this._jsPlumb.overlays[i].getElement();
                el.parentNode.removeChild(el);
                newParent.appendChild(el);
              }
            }
          }
        },
        getLabel: function() {
          var lo = this.getOverlay(_internalLabelOverlayId);
          return lo != null ? lo.getLabel() : null;
        },
        getLabelOverlay: function() {
          return this.getOverlay(_internalLabelOverlayId);
        },
        setLabel: function(l) {
          var lo = this.getOverlay(_internalLabelOverlayId);
          if (!lo) {
            var params = l.constructor == String || l.constructor == Function ? {label: l} : l;
            lo = _makeLabelOverlay(this, params);
            this._jsPlumb.overlays[_internalLabelOverlayId] = lo;
          } else {
            if (l.constructor == String || l.constructor == Function)
              lo.setLabel(l);
            else {
              if (l.label)
                lo.setLabel(l.label);
              if (l.location)
                lo.setLocation(l.location);
            }
          }
          if (!this._jsPlumb.instance.isSuspendDrawing())
            this.repaint();
        },
        cleanup: function(force) {
          for (var i in this._jsPlumb.overlays) {
            this._jsPlumb.overlays[i].cleanup(force);
            this._jsPlumb.overlays[i].destroy(force);
          }
          if (force) {
            this._jsPlumb.overlays = {};
            this._jsPlumb.overlayPositions = null;
          }
        },
        setVisible: function(v) {
          this[v ? "showOverlays" : "hideOverlays"]();
        },
        setAbsoluteOverlayPosition: function(overlay, xy) {
          this._jsPlumb.overlayPositions[overlay.id] = xy;
        },
        getAbsoluteOverlayPosition: function(overlay) {
          return this._jsPlumb.overlayPositions ? this._jsPlumb.overlayPositions[overlay.id] : null;
        },
        _clazzManip: function(action, clazz, dontUpdateOverlays) {
          if (!dontUpdateOverlays) {
            for (var i in this._jsPlumb.overlays) {
              this._jsPlumb.overlays[i][action + "Class"](clazz);
            }
          }
        },
        addClass: function(clazz, dontUpdateOverlays) {
          this._clazzManip("add", clazz, dontUpdateOverlays);
        },
        removeClass: function(clazz, dontUpdateOverlays) {
          this._clazzManip("remove", clazz, dontUpdateOverlays);
        }
      });
    }).call(this);
    (function() {
      "use strict";
      var root = this,
          _jp = root.jsPlumb,
          _ju = root.jsPlumbUtil;
      var _makeConnectionDragHandler = function(endpoint, placeholder, _jsPlumb) {
        var stopped = false;
        return {
          drag: function() {
            if (stopped) {
              stopped = false;
              return true;
            }
            if (placeholder.element) {
              var _ui = _jsPlumb.getUIPosition(arguments, _jsPlumb.getZoom());
              jsPlumb.setPosition(placeholder.element, _ui);
              _jsPlumb.repaint(placeholder.element, _ui);
              endpoint.paint({anchorPoint: endpoint.anchor.getCurrentLocation({element: endpoint.element})});
            }
          },
          stopDrag: function() {
            stopped = true;
          }
        };
      };
      var _makeDraggablePlaceholder = function(placeholder, _jsPlumb, ipco, ips) {
        var n = jsPlumb.createElement("div", {position: "absolute"});
        _jsPlumb.appendElement(n);
        var id = _jsPlumb.getId(n);
        jsPlumb.setPosition(n, ipco);
        n.style.width = ips[0] + "px";
        n.style.height = ips[1] + "px";
        _jsPlumb.manage(id, n, true);
        placeholder.id = id;
        placeholder.element = n;
      };
      var _makeFloatingEndpoint = function(paintStyle, referenceAnchor, endpoint, referenceCanvas, sourceElement, _jsPlumb, _newEndpoint, scope) {
        var floatingAnchor = new _jp.FloatingAnchor({
          reference: referenceAnchor,
          referenceCanvas: referenceCanvas,
          jsPlumbInstance: _jsPlumb
        });
        return _newEndpoint({
          paintStyle: paintStyle,
          endpoint: endpoint,
          anchor: floatingAnchor,
          source: sourceElement,
          scope: scope
        });
      };
      var typeParameters = ["connectorStyle", "connectorHoverStyle", "connectorOverlays", "connector", "connectionType", "connectorClass", "connectorHoverClass"];
      var findConnectionToUseForDynamicAnchor = function(ep, elementWithPrecedence) {
        var idx = 0;
        if (elementWithPrecedence != null) {
          for (var i = 0; i < ep.connections.length; i++) {
            if (ep.connections[i].sourceId == elementWithPrecedence || ep.connections[i].targetId == elementWithPrecedence) {
              idx = i;
              break;
            }
          }
        }
        return ep.connections[idx];
      };
      _jp.Endpoint = function(params) {
        var _jsPlumb = params._jsPlumb,
            _newConnection = params.newConnection,
            _newEndpoint = params.newEndpoint;
        this.idPrefix = "_jsplumb_e_";
        this.defaultLabelLocation = [0.5, 0.5];
        this.defaultOverlayKeys = ["Overlays", "EndpointOverlays"];
        _jp.OverlayCapableJsPlumbUIComponent.apply(this, arguments);
        this.appendToDefaultType({
          connectionType: params.connectionType,
          maxConnections: params.maxConnections == null ? this._jsPlumb.instance.Defaults.MaxConnections : params.maxConnections,
          paintStyle: params.endpointStyle || params.paintStyle || params.style || this._jsPlumb.instance.Defaults.EndpointStyle || _jp.Defaults.EndpointStyle,
          hoverPaintStyle: params.endpointHoverStyle || params.hoverPaintStyle || this._jsPlumb.instance.Defaults.EndpointHoverStyle || _jp.Defaults.EndpointHoverStyle,
          connectorStyle: params.connectorStyle,
          connectorHoverStyle: params.connectorHoverStyle,
          connectorClass: params.connectorClass,
          connectorHoverClass: params.connectorHoverClass,
          connectorOverlays: params.connectorOverlays,
          connector: params.connector,
          connectorTooltip: params.connectorTooltip
        });
        this._jsPlumb.enabled = !(params.enabled === false);
        this._jsPlumb.visible = true;
        this.element = _jp.getElement(params.source);
        this._jsPlumb.uuid = params.uuid;
        this._jsPlumb.floatingEndpoint = null;
        var inPlaceCopy = null;
        if (this._jsPlumb.uuid)
          params.endpointsByUUID[this._jsPlumb.uuid] = this;
        this.elementId = params.elementId;
        this.dragProxy = params.dragProxy;
        this._jsPlumb.connectionCost = params.connectionCost;
        this._jsPlumb.connectionsDirected = params.connectionsDirected;
        this._jsPlumb.currentAnchorClass = "";
        this._jsPlumb.events = {};
        var _updateAnchorClass = function() {
          var oldAnchorClass = _jsPlumb.endpointAnchorClassPrefix + "-" + this._jsPlumb.currentAnchorClass;
          this._jsPlumb.currentAnchorClass = this.anchor.getCssClass();
          var anchorClass = _jsPlumb.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? "-" + this._jsPlumb.currentAnchorClass : "");
          this.removeClass(oldAnchorClass);
          this.addClass(anchorClass);
          jsPlumb.updateClasses(this.element, anchorClass, oldAnchorClass);
        }.bind(this);
        this.prepareAnchor = function(anchorParams) {
          var a = this._jsPlumb.instance.makeAnchor(anchorParams, this.elementId, _jsPlumb);
          a.bind("anchorChanged", function(currentAnchor) {
            this.fire("anchorChanged", {
              endpoint: this,
              anchor: currentAnchor
            });
            _updateAnchorClass();
          }.bind(this));
          return a;
        };
        this.setPreparedAnchor = function(anchor, doNotRepaint) {
          this._jsPlumb.instance.continuousAnchorFactory.clear(this.elementId);
          this.anchor = anchor;
          _updateAnchorClass();
          if (!doNotRepaint)
            this._jsPlumb.instance.repaint(this.elementId);
          return this;
        };
        this.setAnchor = function(anchorParams, doNotRepaint) {
          var a = this.prepareAnchor(anchorParams);
          this.setPreparedAnchor(a, doNotRepaint);
          return this;
        };
        var internalHover = function(state) {
          if (this.connections.length > 0) {
            for (var i = 0; i < this.connections.length; i++)
              this.connections[i].setHover(state, false);
          } else
            this.setHover(state);
        }.bind(this);
        this.bind("mouseover", function() {
          internalHover(true);
        });
        this.bind("mouseout", function() {
          internalHover(false);
        });
        if (!params._transient)
          this._jsPlumb.instance.anchorManager.add(this, this.elementId);
        this.prepareEndpoint = function(ep, typeId) {
          var _e = function(t, p) {
            var rm = _jsPlumb.getRenderMode();
            if (_jp.Endpoints[rm][t])
              return new _jp.Endpoints[rm][t](p);
            if (!_jsPlumb.Defaults.DoNotThrowErrors)
              throw {msg: "jsPlumb: unknown endpoint type '" + t + "'"};
          };
          var endpointArgs = {
            _jsPlumb: this._jsPlumb.instance,
            cssClass: params.cssClass,
            container: params.container,
            tooltip: params.tooltip,
            connectorTooltip: params.connectorTooltip,
            endpoint: this
          };
          var endpoint;
          if (_ju.isString(ep))
            endpoint = _e(ep, endpointArgs);
          else if (_ju.isArray(ep)) {
            endpointArgs = _ju.merge(ep[1], endpointArgs);
            endpoint = _e(ep[0], endpointArgs);
          } else {
            endpoint = ep.clone();
          }
          endpoint.clone = function() {
            if (_ju.isString(ep))
              return _e(ep, endpointArgs);
            else if (_ju.isArray(ep)) {
              endpointArgs = _ju.merge(ep[1], endpointArgs);
              return _e(ep[0], endpointArgs);
            }
          }.bind(this);
          endpoint.typeId = typeId;
          return endpoint;
        };
        this.setEndpoint = function(ep, doNotRepaint) {
          var _ep = this.prepareEndpoint(ep);
          this.setPreparedEndpoint(_ep, true);
        };
        this.setPreparedEndpoint = function(ep, doNotRepaint) {
          if (this.endpoint != null) {
            this.endpoint.cleanup();
            this.endpoint.destroy();
          }
          this.endpoint = ep;
          this.type = this.endpoint.type;
          this.canvas = this.endpoint.canvas;
        };
        _jp.extend(this, params, typeParameters);
        this.isSource = params.isSource || false;
        this.isTemporarySource = params.isTemporarySource || false;
        this.isTarget = params.isTarget || false;
        this.connections = params.connections || [];
        this.connectorPointerEvents = params["connector-pointer-events"];
        this.scope = params.scope || _jsPlumb.getDefaultScope();
        this.timestamp = null;
        this.reattachConnections = params.reattach || _jsPlumb.Defaults.ReattachConnections;
        this.connectionsDetachable = _jsPlumb.Defaults.ConnectionsDetachable;
        if (params.connectionsDetachable === false || params.detachable === false)
          this.connectionsDetachable = false;
        this.dragAllowedWhenFull = params.dragAllowedWhenFull !== false;
        if (params.onMaxConnections)
          this.bind("maxConnections", params.onMaxConnections);
        this.addConnection = function(connection) {
          this.connections.push(connection);
          this[(this.connections.length > 0 ? "add" : "remove") + "Class"](_jsPlumb.endpointConnectedClass);
          this[(this.isFull() ? "add" : "remove") + "Class"](_jsPlumb.endpointFullClass);
        };
        this.detachFromConnection = function(connection, idx, doNotCleanup) {
          idx = idx == null ? this.connections.indexOf(connection) : idx;
          if (idx >= 0) {
            this.connections.splice(idx, 1);
            this[(this.connections.length > 0 ? "add" : "remove") + "Class"](_jsPlumb.endpointConnectedClass);
            this[(this.isFull() ? "add" : "remove") + "Class"](_jsPlumb.endpointFullClass);
          }
          if (!doNotCleanup && this._deleteOnDetach && this.connections.length === 0) {
            _jsPlumb.deleteObject({
              endpoint: this,
              fireEvent: false,
              deleteAttachedObjects: false
            });
          }
        };
        this.detach = function(connection, ignoreTarget, forceDetach, fireEvent, originalEvent, endpointBeingDeleted, connectionIndex) {
          var idx = connectionIndex == null ? this.connections.indexOf(connection) : connectionIndex,
              actuallyDetached = false;
          fireEvent = (fireEvent !== false);
          if (idx >= 0) {
            if (forceDetach || connection._forceDetach || (connection.isDetachable() && connection.isDetachAllowed(connection) && this.isDetachAllowed(connection) && _jsPlumb.checkCondition("beforeDetach", connection, endpointBeingDeleted))) {
              _jsPlumb.deleteObject({
                connection: connection,
                fireEvent: (!ignoreTarget && fireEvent),
                originalEvent: originalEvent,
                deleteAttachedObjects: false
              });
              actuallyDetached = true;
            }
          }
          return actuallyDetached;
        };
        this.detachAll = function(fireEvent, forceDetach) {
          var unaffectedConns = [];
          while (this.connections.length > 0) {
            var actuallyDetached = this.detach(this.connections[0], false, forceDetach === true, fireEvent !== false, null, this, 0);
            if (!actuallyDetached) {
              unaffectedConns.push(this.connections[0]);
              this.connections.splice(0, 1);
            }
          }
          this.connections = unaffectedConns;
          return this;
        };
        this.detachFrom = function(targetEndpoint, fireEvent, originalEvent) {
          var c = [];
          for (var i = 0; i < this.connections.length; i++) {
            if (this.connections[i].endpoints[1] == targetEndpoint || this.connections[i].endpoints[0] == targetEndpoint) {
              c.push(this.connections[i]);
            }
          }
          for (var j = 0; j < c.length; j++) {
            this.detach(c[j], false, true, fireEvent, originalEvent);
          }
          return this;
        };
        this.getElement = function() {
          return this.element;
        };
        this.setElement = function(el) {
          var parentId = this._jsPlumb.instance.getId(el),
              curId = this.elementId;
          _ju.removeWithFunction(params.endpointsByElement[this.elementId], function(e) {
            return e.id == this.id;
          }.bind(this));
          this.element = jsPlumb.getElement(el);
          this.elementId = _jsPlumb.getId(this.element);
          _jsPlumb.anchorManager.rehomeEndpoint(this, curId, this.element);
          _jsPlumb.dragManager.endpointAdded(this.element);
          _ju.addToList(params.endpointsByElement, parentId, this);
          return this;
        };
        this.makeInPlaceCopy = function() {
          var loc = this.anchor.getCurrentLocation({element: this}),
              o = this.anchor.getOrientation(this),
              acc = this.anchor.getCssClass(),
              inPlaceAnchor = {
                bind: function() {},
                compute: function() {
                  return [loc[0], loc[1]];
                },
                getCurrentLocation: function() {
                  return [loc[0], loc[1]];
                },
                getOrientation: function() {
                  return o;
                },
                getCssClass: function() {
                  return acc;
                }
              };
          return _newEndpoint({
            dropOptions: params.dropOptions,
            anchor: inPlaceAnchor,
            source: this.element,
            paintStyle: this.getPaintStyle(),
            endpoint: params.hideOnDrag ? "Blank" : this.endpoint,
            _transient: true,
            scope: this.scope,
            reference: this
          });
        };
        this.connectorSelector = function() {
          var candidate = this.connections[0];
          if (candidate)
            return candidate;
          else {
            return (this.connections.length < this._jsPlumb.maxConnections) || this._jsPlumb.maxConnections == -1 ? null : candidate;
          }
        };
        this.setStyle = this.setPaintStyle;
        this.paint = function(params) {
          params = params || {};
          var timestamp = params.timestamp,
              recalc = !(params.recalc === false);
          if (!timestamp || this.timestamp !== timestamp) {
            var info = _jsPlumb.updateOffset({
              elId: this.elementId,
              timestamp: timestamp
            });
            var xy = params.offset ? params.offset.o : info.o;
            if (xy != null) {
              var ap = params.anchorPoint,
                  connectorPaintStyle = params.connectorPaintStyle;
              if (ap == null) {
                var wh = params.dimensions || info.s,
                    anchorParams = {
                      xy: [xy.left, xy.top],
                      wh: wh,
                      element: this,
                      timestamp: timestamp
                    };
                if (recalc && this.anchor.isDynamic && this.connections.length > 0) {
                  var c = findConnectionToUseForDynamicAnchor(this, params.elementWithPrecedence),
                      oIdx = c.endpoints[0] == this ? 1 : 0,
                      oId = oIdx === 0 ? c.sourceId : c.targetId,
                      oInfo = _jsPlumb.getCachedData(oId),
                      oOffset = oInfo.o,
                      oWH = oInfo.s;
                  anchorParams.txy = [oOffset.left, oOffset.top];
                  anchorParams.twh = oWH;
                  anchorParams.tElement = c.endpoints[oIdx];
                }
                ap = this.anchor.compute(anchorParams);
              }
              this.endpoint.compute(ap, this.anchor.getOrientation(this), this._jsPlumb.paintStyleInUse, connectorPaintStyle || this.paintStyleInUse);
              this.endpoint.paint(this._jsPlumb.paintStyleInUse, this.anchor);
              this.timestamp = timestamp;
              for (var i in this._jsPlumb.overlays) {
                if (this._jsPlumb.overlays.hasOwnProperty(i)) {
                  var o = this._jsPlumb.overlays[i];
                  if (o.isVisible()) {
                    this._jsPlumb.overlayPlacements[i] = o.draw(this.endpoint, this._jsPlumb.paintStyleInUse);
                    o.paint(this._jsPlumb.overlayPlacements[i]);
                  }
                }
              }
            }
          }
        };
        this.getTypeDescriptor = function() {
          return "endpoint";
        };
        this.isVisible = function() {
          return this._jsPlumb.visible;
        };
        this.repaint = this.paint;
        var draggingInitialised = false;
        this.initDraggable = function() {
          if (!draggingInitialised && _jp.isDragSupported(this.element)) {
            var placeholderInfo = {
              id: null,
              element: null
            },
                jpc = null,
                existingJpc = false,
                existingJpcParams = null,
                _dragHandler = _makeConnectionDragHandler(this, placeholderInfo, _jsPlumb),
                dragOptions = params.dragOptions || {},
                defaultOpts = {},
                startEvent = _jp.dragEvents.start,
                stopEvent = _jp.dragEvents.stop,
                dragEvent = _jp.dragEvents.drag,
                beforeStartEvent = _jp.dragEvents.beforeStart,
                payload;
            var beforeStart = function(beforeStartParams) {
              payload = beforeStartParams.e.payload || {};
            };
            var start = function(startParams) {
              jpc = this.connectorSelector();
              var _continue = true;
              if (!this.isEnabled())
                _continue = false;
              if (jpc == null && !this.isSource && !this.isTemporarySource)
                _continue = false;
              if (this.isSource && this.isFull() && !(jpc != null && this.dragAllowedWhenFull))
                _continue = false;
              if (jpc != null && !jpc.isDetachable(this))
                _continue = false;
              var beforeDrag = _jsPlumb.checkCondition(jpc == null ? "beforeDrag" : "beforeStartDetach", {
                endpoint: this,
                source: this.element,
                sourceId: this.elementId,
                connection: jpc
              });
              if (beforeDrag === false)
                _continue = false;
              else if (typeof beforeDrag === "object") {
                jsPlumb.extend(beforeDrag, payload || {});
              } else
                beforeDrag = payload || {};
              if (_continue === false) {
                if (_jsPlumb.stopDrag)
                  _jsPlumb.stopDrag(this.canvas);
                _dragHandler.stopDrag();
                return false;
              }
              for (var i = 0; i < this.connections.length; i++)
                this.connections[i].setHover(false);
              this.addClass("endpointDrag");
              _jsPlumb.setConnectionBeingDragged(true);
              if (jpc && !this.isFull() && this.isSource)
                jpc = null;
              _jsPlumb.updateOffset({elId: this.elementId});
              var ipco = this._jsPlumb.instance.getOffset(this.canvas),
                  canvasElement = this.canvas,
                  ips = this._jsPlumb.instance.getSize(this.canvas);
              _makeDraggablePlaceholder(placeholderInfo, _jsPlumb, ipco, ips);
              _jsPlumb.setAttributes(this.canvas, {
                "dragId": placeholderInfo.id,
                "elId": this.elementId
              });
              var endpointToFloat = this.dragProxy || this.endpoint;
              if (this.dragProxy == null && this.connectionType != null) {
                var aae = this._jsPlumb.instance.deriveEndpointAndAnchorSpec(this.connectionType);
                if (aae.endpoints[1])
                  endpointToFloat = aae.endpoints[1];
              }
              var centerAnchor = this._jsPlumb.instance.makeAnchor("Center");
              centerAnchor.isFloating = true;
              this._jsPlumb.floatingEndpoint = _makeFloatingEndpoint(this.getPaintStyle(), centerAnchor, endpointToFloat, this.canvas, placeholderInfo.element, _jsPlumb, _newEndpoint, this.scope);
              var _savedAnchor = this._jsPlumb.floatingEndpoint.anchor;
              if (jpc == null) {
                this.setHover(false, false);
                jpc = _newConnection({
                  sourceEndpoint: this,
                  targetEndpoint: this._jsPlumb.floatingEndpoint,
                  source: this.element,
                  target: placeholderInfo.element,
                  anchors: [this.anchor, this._jsPlumb.floatingEndpoint.anchor],
                  paintStyle: params.connectorStyle,
                  hoverPaintStyle: params.connectorHoverStyle,
                  connector: params.connector,
                  overlays: params.connectorOverlays,
                  type: this.connectionType,
                  cssClass: this.connectorClass,
                  hoverClass: this.connectorHoverClass,
                  scope: params.scope,
                  data: beforeDrag
                });
                jpc.pending = true;
                jpc.addClass(_jsPlumb.draggingClass);
                this._jsPlumb.floatingEndpoint.addClass(_jsPlumb.draggingClass);
                this._jsPlumb.floatingEndpoint.anchor = _savedAnchor;
                _jsPlumb.fire("connectionDrag", jpc);
                _jsPlumb.anchorManager.newConnection(jpc);
              } else {
                existingJpc = true;
                jpc.setHover(false);
                var anchorIdx = jpc.endpoints[0].id == this.id ? 0 : 1;
                this.detachFromConnection(jpc, null, true);
                var dragScope = _jsPlumb.getDragScope(canvasElement);
                _jsPlumb.setAttribute(this.canvas, "originalScope", dragScope);
                _jsPlumb.fire("connectionDrag", jpc);
                if (anchorIdx === 0) {
                  existingJpcParams = [jpc.source, jpc.sourceId, canvasElement, dragScope];
                  jpc.source = placeholderInfo.element;
                  jpc.sourceId = placeholderInfo.id;
                  _jsPlumb.anchorManager.sourceChanged(jpc.endpoints[anchorIdx].elementId, jpc.sourceId, jpc);
                } else {
                  existingJpcParams = [jpc.target, jpc.targetId, canvasElement, dragScope];
                  jpc.target = placeholderInfo.element;
                  jpc.targetId = placeholderInfo.id;
                  _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.endpoints[anchorIdx].elementId, jpc.targetId, jpc);
                }
                jpc.suspendedEndpoint = jpc.endpoints[anchorIdx];
                jpc.suspendedElement = jpc.endpoints[anchorIdx].getElement();
                jpc.suspendedElementId = jpc.endpoints[anchorIdx].elementId;
                jpc.suspendedElementType = anchorIdx === 0 ? "source" : "target";
                jpc.suspendedEndpoint.setHover(false);
                this._jsPlumb.floatingEndpoint.referenceEndpoint = jpc.suspendedEndpoint;
                jpc.endpoints[anchorIdx] = this._jsPlumb.floatingEndpoint;
                jpc.addClass(_jsPlumb.draggingClass);
                this._jsPlumb.floatingEndpoint.addClass(_jsPlumb.draggingClass);
              }
              _jsPlumb.floatingConnections[placeholderInfo.id] = jpc;
              _ju.addToList(params.endpointsByElement, placeholderInfo.id, this._jsPlumb.floatingEndpoint);
              _jsPlumb.currentlyDragging = true;
            }.bind(this);
            var stop = function() {
              _jsPlumb.setConnectionBeingDragged(false);
              if (jpc && jpc.endpoints != null) {
                var originalEvent = _jsPlumb.getDropEvent(arguments);
                var idx = _jsPlumb.getFloatingAnchorIndex(jpc);
                jpc.endpoints[idx === 0 ? 1 : 0].anchor.locked = false;
                jpc.removeClass(_jsPlumb.draggingClass);
                if (this._jsPlumb && (jpc.deleteConnectionNow || jpc.endpoints[idx] == this._jsPlumb.floatingEndpoint)) {
                  if (existingJpc && jpc.suspendedEndpoint) {
                    if (idx === 0) {
                      jpc.floatingElement = jpc.source;
                      jpc.floatingId = jpc.sourceId;
                      jpc.floatingEndpoint = jpc.endpoints[0];
                      jpc.floatingIndex = 0;
                      jpc.source = existingJpcParams[0];
                      jpc.sourceId = existingJpcParams[1];
                    } else {
                      jpc.floatingElement = jpc.target;
                      jpc.floatingId = jpc.targetId;
                      jpc.floatingEndpoint = jpc.endpoints[1];
                      jpc.floatingIndex = 1;
                      jpc.target = existingJpcParams[0];
                      jpc.targetId = existingJpcParams[1];
                    }
                    var fe = this._jsPlumb.floatingEndpoint;
                    _jsPlumb.setDragScope(existingJpcParams[2], existingJpcParams[3]);
                    jpc.endpoints[idx] = jpc.suspendedEndpoint;
                    if (jpc.isReattach() || jpc._forceReattach || jpc._forceDetach || !jpc.endpoints[idx === 0 ? 1 : 0].detach(jpc, false, false, true, originalEvent, true)) {
                      jpc.setHover(false);
                      jpc._forceDetach = null;
                      jpc._forceReattach = null;
                      this._jsPlumb.floatingEndpoint.detachFromConnection(jpc);
                      jpc.suspendedEndpoint.addConnection(jpc);
                      if (idx == 1) {
                        _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.floatingId, jpc.targetId, jpc);
                      } else {
                        _jsPlumb.anchorManager.sourceChanged(jpc.floatingId, jpc.sourceId, jpc);
                      }
                      _jsPlumb.repaint(existingJpcParams[1]);
                    } else {
                      _jsPlumb.deleteObject({endpoint: fe});
                    }
                  }
                }
                if (this.deleteAfterDragStop) {
                  _jsPlumb.deleteObject({endpoint: this});
                } else {
                  if (this._jsPlumb) {
                    this.paint({recalc: false});
                  }
                }
                _jsPlumb.fire("connectionDragStop", jpc, originalEvent);
                if (jpc.pending) {
                  _jsPlumb.fire("connectionAborted", jpc, originalEvent);
                }
                _jsPlumb.currentlyDragging = false;
                jpc = null;
              }
              if (placeholderInfo && placeholderInfo.element) {
                _jsPlumb.remove(placeholderInfo.element, false, false);
              }
              if (inPlaceCopy) {
                _jsPlumb.deleteObject({endpoint: inPlaceCopy});
              }
              if (this._jsPlumb) {
                this.canvas.style.visibility = "visible";
                this.anchor.locked = false;
                this._jsPlumb.floatingEndpoint = null;
              }
            }.bind(this);
            dragOptions = _jp.extend(defaultOpts, dragOptions);
            dragOptions.scope = this.scope || dragOptions.scope;
            dragOptions[beforeStartEvent] = _ju.wrap(dragOptions[beforeStartEvent], beforeStart, false);
            dragOptions[startEvent] = _ju.wrap(dragOptions[startEvent], start, false);
            dragOptions[dragEvent] = _ju.wrap(dragOptions[dragEvent], _dragHandler.drag);
            dragOptions[stopEvent] = _ju.wrap(dragOptions[stopEvent], stop);
            dragOptions.multipleDrop = false;
            dragOptions.canDrag = function() {
              return this.isSource || this.isTemporarySource || this.connections.length > 0;
            }.bind(this);
            _jsPlumb.initDraggable(this.canvas, dragOptions, "internal");
            this.canvas._jsPlumbRelatedElement = this.element;
            draggingInitialised = true;
          }
        };
        var ep = params.endpoint || this._jsPlumb.instance.Defaults.Endpoint || _jp.Defaults.Endpoint;
        this.setEndpoint(ep, true);
        var anchorParamsToUse = params.anchor ? params.anchor : params.anchors ? params.anchors : (_jsPlumb.Defaults.Anchor || "Top");
        this.setAnchor(anchorParamsToUse, true);
        var type = ["default", (params.type || "")].join(" ");
        this.addType(type, params.data, true);
        this.canvas = this.endpoint.canvas;
        this.canvas._jsPlumb = this;
        this.initDraggable();
        var _initDropTarget = function(canvas, isTransient, endpoint, referenceEndpoint) {
          if (_jp.isDropSupported(this.element)) {
            var dropOptions = params.dropOptions || _jsPlumb.Defaults.DropOptions || _jp.Defaults.DropOptions;
            dropOptions = _jp.extend({}, dropOptions);
            dropOptions.scope = dropOptions.scope || this.scope;
            var dropEvent = _jp.dragEvents.drop,
                overEvent = _jp.dragEvents.over,
                outEvent = _jp.dragEvents.out,
                _ep = this,
                drop = _jsPlumb.EndpointDropHandler({
                  getEndpoint: function() {
                    return _ep;
                  },
                  jsPlumb: _jsPlumb,
                  enabled: function() {
                    return endpoint != null ? endpoint.isEnabled() : true;
                  },
                  isFull: function() {
                    return endpoint.isFull();
                  },
                  element: this.element,
                  elementId: this.elementId,
                  isSource: this.isSource,
                  isTarget: this.isTarget,
                  addClass: function(clazz) {
                    _ep.addClass(clazz);
                  },
                  removeClass: function(clazz) {
                    _ep.removeClass(clazz);
                  },
                  isDropAllowed: function() {
                    return _ep.isDropAllowed.apply(_ep, arguments);
                  },
                  reference: referenceEndpoint,
                  isRedrop: function(jpc, dhParams) {
                    return jpc.suspendedEndpoint && dhParams.reference && (jpc.suspendedEndpoint.id === dhParams.reference.id);
                  }
                });
            dropOptions[dropEvent] = _ju.wrap(dropOptions[dropEvent], drop, true);
            dropOptions[overEvent] = _ju.wrap(dropOptions[overEvent], function() {
              var draggable = _jp.getDragObject(arguments),
                  id = _jsPlumb.getAttribute(_jp.getElement(draggable), "dragId"),
                  _jpc = _jsPlumb.floatingConnections[id];
              if (_jpc != null) {
                var idx = _jsPlumb.getFloatingAnchorIndex(_jpc);
                var _cont = (this.isTarget && idx !== 0) || (_jpc.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id == _jpc.suspendedEndpoint.id);
                if (_cont) {
                  var bb = _jsPlumb.checkCondition("checkDropAllowed", {
                    sourceEndpoint: _jpc.endpoints[idx],
                    targetEndpoint: this,
                    connection: _jpc
                  });
                  this[(bb ? "add" : "remove") + "Class"](_jsPlumb.endpointDropAllowedClass);
                  this[(bb ? "remove" : "add") + "Class"](_jsPlumb.endpointDropForbiddenClass);
                  _jpc.endpoints[idx].anchor.over(this.anchor, this);
                }
              }
            }.bind(this));
            dropOptions[outEvent] = _ju.wrap(dropOptions[outEvent], function() {
              var draggable = _jp.getDragObject(arguments),
                  id = draggable == null ? null : _jsPlumb.getAttribute(_jp.getElement(draggable), "dragId"),
                  _jpc = id ? _jsPlumb.floatingConnections[id] : null;
              if (_jpc != null) {
                var idx = _jsPlumb.getFloatingAnchorIndex(_jpc);
                var _cont = (this.isTarget && idx !== 0) || (_jpc.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id == _jpc.suspendedEndpoint.id);
                if (_cont) {
                  this.removeClass(_jsPlumb.endpointDropAllowedClass);
                  this.removeClass(_jsPlumb.endpointDropForbiddenClass);
                  _jpc.endpoints[idx].anchor.out();
                }
              }
            }.bind(this));
            _jsPlumb.initDroppable(canvas, dropOptions, "internal", isTransient);
          }
        }.bind(this);
        if (!this.anchor.isFloating)
          _initDropTarget(this.canvas, !(params._transient || this.anchor.isFloating), this, params.reference);
        return this;
      };
      _ju.extend(_jp.Endpoint, _jp.OverlayCapableJsPlumbUIComponent, {
        setVisible: function(v, doNotChangeConnections, doNotNotifyOtherEndpoint) {
          this._jsPlumb.visible = v;
          if (this.canvas)
            this.canvas.style.display = v ? "block" : "none";
          this[v ? "showOverlays" : "hideOverlays"]();
          if (!doNotChangeConnections) {
            for (var i = 0; i < this.connections.length; i++) {
              this.connections[i].setVisible(v);
              if (!doNotNotifyOtherEndpoint) {
                var oIdx = this === this.connections[i].endpoints[0] ? 1 : 0;
                if (this.connections[i].endpoints[oIdx].connections.length == 1)
                  this.connections[i].endpoints[oIdx].setVisible(v, true, true);
              }
            }
          }
        },
        getAttachedElements: function() {
          return this.connections;
        },
        applyType: function(t, doNotRepaint) {
          this.setPaintStyle(t.endpointStyle || t.paintStyle, doNotRepaint);
          this.setHoverPaintStyle(t.endpointHoverStyle || t.hoverPaintStyle, doNotRepaint);
          if (t.maxConnections != null)
            this._jsPlumb.maxConnections = t.maxConnections;
          if (t.scope)
            this.scope = t.scope;
          _jp.extend(this, t, typeParameters);
          if (t.cssClass != null && this.canvas)
            this._jsPlumb.instance.addClass(this.canvas, t.cssClass);
          _jp.OverlayCapableJsPlumbUIComponent.applyType(this, t);
        },
        isEnabled: function() {
          return this._jsPlumb.enabled;
        },
        setEnabled: function(e) {
          this._jsPlumb.enabled = e;
        },
        cleanup: function() {
          var anchorClass = this._jsPlumb.instance.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? "-" + this._jsPlumb.currentAnchorClass : "");
          jsPlumb.removeClass(this.element, anchorClass);
          this.anchor = null;
          this.endpoint.cleanup(true);
          this.endpoint.destroy();
          this.endpoint = null;
          this._jsPlumb.instance.destroyDraggable(this.canvas, "internal");
          this._jsPlumb.instance.destroyDroppable(this.canvas, "internal");
        },
        setHover: function(h) {
          if (this.endpoint && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged())
            this.endpoint.setHover(h);
        },
        isFull: function() {
          return this._jsPlumb.maxConnections === 0 ? true : !(this.isFloating() || this._jsPlumb.maxConnections < 0 || this.connections.length < this._jsPlumb.maxConnections);
        },
        isFloating: function() {
          return this.anchor != null && this.anchor.isFloating;
        },
        isConnectedTo: function(endpoint) {
          var found = false;
          if (endpoint) {
            for (var i = 0; i < this.connections.length; i++) {
              if (this.connections[i].endpoints[1] == endpoint || this.connections[i].endpoints[0] == endpoint) {
                found = true;
                break;
              }
            }
          }
          return found;
        },
        getConnectionCost: function() {
          return this._jsPlumb.connectionCost;
        },
        setConnectionCost: function(c) {
          this._jsPlumb.connectionCost = c;
        },
        areConnectionsDirected: function() {
          return this._jsPlumb.connectionsDirected;
        },
        setConnectionsDirected: function(b) {
          this._jsPlumb.connectionsDirected = b;
        },
        setElementId: function(_elId) {
          this.elementId = _elId;
          this.anchor.elementId = _elId;
        },
        setReferenceElement: function(_el) {
          this.element = _jp.getElement(_el);
        },
        setDragAllowedWhenFull: function(allowed) {
          this.dragAllowedWhenFull = allowed;
        },
        equals: function(endpoint) {
          return this.anchor.equals(endpoint.anchor);
        },
        getUuid: function() {
          return this._jsPlumb.uuid;
        },
        computeAnchor: function(params) {
          return this.anchor.compute(params);
        }
      });
      root.jsPlumbInstance.prototype.EndpointDropHandler = function(dhParams) {
        return function(e) {
          var _jsPlumb = dhParams.jsPlumb;
          dhParams.removeClass(_jsPlumb.endpointDropAllowedClass);
          dhParams.removeClass(_jsPlumb.endpointDropForbiddenClass);
          var originalEvent = _jsPlumb.getDropEvent(arguments),
              draggable = _jsPlumb.getDragObject(arguments),
              id = _jsPlumb.getAttribute(draggable, "dragId"),
              elId = _jsPlumb.getAttribute(draggable, "elId"),
              scope = _jsPlumb.getAttribute(draggable, "originalScope"),
              jpc = _jsPlumb.floatingConnections[id];
          if (jpc == null)
            return;
          var existingConnection = jpc.suspendedEndpoint != null;
          if (existingConnection && jpc.suspendedEndpoint._jsPlumb == null)
            return;
          var _ep = dhParams.getEndpoint(jpc);
          if (_ep == null)
            return;
          if (dhParams.isRedrop(jpc, dhParams)) {
            jpc._forceReattach = true;
            jpc.setHover(false);
            if (dhParams.maybeCleanup)
              dhParams.maybeCleanup(_ep);
            return;
          }
          var idx = _jsPlumb.getFloatingAnchorIndex(jpc);
          if ((idx === 0 && !dhParams.isSource) || (idx === 1 && !dhParams.isTarget)) {
            if (dhParams.maybeCleanup)
              dhParams.maybeCleanup(_ep);
            return;
          }
          if (dhParams.onDrop)
            dhParams.onDrop(jpc);
          if (scope)
            _jsPlumb.setDragScope(draggable, scope);
          var isFull = dhParams.isFull(e);
          if (isFull) {
            _ep.fire("maxConnections", {
              endpoint: this,
              connection: jpc,
              maxConnections: _ep._jsPlumb.maxConnections
            }, originalEvent);
          }
          if (!isFull && dhParams.enabled()) {
            var _doContinue = true;
            if (idx === 0) {
              jpc.floatingElement = jpc.source;
              jpc.floatingId = jpc.sourceId;
              jpc.floatingEndpoint = jpc.endpoints[0];
              jpc.floatingIndex = 0;
              jpc.source = dhParams.element;
              jpc.sourceId = dhParams.elementId;
            } else {
              jpc.floatingElement = jpc.target;
              jpc.floatingId = jpc.targetId;
              jpc.floatingEndpoint = jpc.endpoints[1];
              jpc.floatingIndex = 1;
              jpc.target = dhParams.element;
              jpc.targetId = dhParams.elementId;
            }
            if (existingConnection && jpc.suspendedEndpoint.id != _ep.id) {
              if (!jpc.isDetachAllowed(jpc) || !jpc.endpoints[idx].isDetachAllowed(jpc) || !jpc.suspendedEndpoint.isDetachAllowed(jpc) || !_jsPlumb.checkCondition("beforeDetach", jpc))
                _doContinue = false;
            }
            var continueFunction = function(optionalData) {
              jpc.endpoints[idx].detachFromConnection(jpc);
              if (jpc.suspendedEndpoint)
                jpc.suspendedEndpoint.detachFromConnection(jpc);
              jpc.endpoints[idx] = _ep;
              _ep.addConnection(jpc);
              var params = _ep.getParameters();
              for (var aParam in params)
                jpc.setParameter(aParam, params[aParam]);
              if (!existingConnection) {
                if (params.draggable)
                  _jsPlumb.initDraggable(this.element, dragOptions, "internal", _jsPlumb);
              } else {
                var suspendedElementId = jpc.suspendedEndpoint.elementId;
                _jsPlumb.fireMoveEvent({
                  index: idx,
                  originalSourceId: idx === 0 ? suspendedElementId : jpc.sourceId,
                  newSourceId: idx === 0 ? _ep.elementId : jpc.sourceId,
                  originalTargetId: idx == 1 ? suspendedElementId : jpc.targetId,
                  newTargetId: idx == 1 ? _ep.elementId : jpc.targetId,
                  originalSourceEndpoint: idx === 0 ? jpc.suspendedEndpoint : jpc.endpoints[0],
                  newSourceEndpoint: idx === 0 ? _ep : jpc.endpoints[0],
                  originalTargetEndpoint: idx == 1 ? jpc.suspendedEndpoint : jpc.endpoints[1],
                  newTargetEndpoint: idx == 1 ? _ep : jpc.endpoints[1],
                  connection: jpc
                }, originalEvent);
              }
              if (idx == 1) {
                _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.floatingId, jpc.targetId, jpc);
              } else {
                _jsPlumb.anchorManager.sourceChanged(jpc.floatingId, jpc.sourceId, jpc);
              }
              if (jpc.endpoints[0].finalEndpoint) {
                var _toDelete = jpc.endpoints[0];
                _toDelete.detachFromConnection(jpc);
                jpc.endpoints[0] = jpc.endpoints[0].finalEndpoint;
                jpc.endpoints[0].addConnection(jpc);
              }
              if (jsPlumbUtil.isObject(optionalData)) {
                jpc.mergeData(optionalData);
              }
              _jsPlumb.finaliseConnection(jpc, null, originalEvent, false);
              jpc.setHover(false);
            }.bind(this);
            var dontContinueFunction = function() {
              if (jpc.suspendedEndpoint) {
                jpc.endpoints[idx] = jpc.suspendedEndpoint;
                jpc.setHover(false);
                jpc._forceDetach = true;
                if (idx === 0) {
                  jpc.source = jpc.suspendedEndpoint.element;
                  jpc.sourceId = jpc.suspendedEndpoint.elementId;
                } else {
                  jpc.target = jpc.suspendedEndpoint.element;
                  jpc.targetId = jpc.suspendedEndpoint.elementId;
                }
                jpc.suspendedEndpoint.addConnection(jpc);
                if (idx == 1) {
                  _jsPlumb.anchorManager.updateOtherEndpoint(jpc.sourceId, jpc.floatingId, jpc.targetId, jpc);
                } else {
                  _jsPlumb.anchorManager.sourceChanged(jpc.floatingId, jpc.sourceId, jpc);
                }
                _jsPlumb.repaint(jpc.sourceId);
                jpc._forceDetach = false;
              }
            };
            _doContinue = _doContinue && dhParams.isDropAllowed(jpc.sourceId, jpc.targetId, jpc.scope, jpc, _ep);
            if (_doContinue) {
              continueFunction(_doContinue);
              return true;
            } else {
              dontContinueFunction();
            }
          }
          if (dhParams.maybeCleanup)
            dhParams.maybeCleanup(_ep);
          _jsPlumb.currentlyDragging = false;
        };
      };
    }).call(this);
    ;
    (function() {
      "use strict";
      var root = this,
          _jp = root.jsPlumb,
          _ju = root.jsPlumbUtil;
      var makeConnector = function(_jsPlumb, renderMode, connectorName, connectorArgs, forComponent) {
        if (!_jsPlumb.Defaults.DoNotThrowErrors && jsPlumb.Connectors[renderMode][connectorName] == null)
          throw {msg: "jsPlumb: unknown connector type '" + connectorName + "'"};
        return new _jp.Connectors[renderMode][connectorName](connectorArgs, forComponent);
      },
          _makeAnchor = function(anchorParams, elementId, _jsPlumb) {
            return (anchorParams) ? _jsPlumb.makeAnchor(anchorParams, elementId, _jsPlumb) : null;
          },
          _updateConnectedClass = function(conn, element, _jsPlumb, remove) {
            if (element != null) {
              element._jsPlumbConnections = element._jsPlumbConnections || {};
              if (remove)
                delete element._jsPlumbConnections[conn.id];
              else
                element._jsPlumbConnections[conn.id] = true;
              if (_ju.isEmpty(element._jsPlumbConnections)) {
                _jsPlumb.removeClass(element, _jsPlumb.connectedClass);
              } else
                _jsPlumb.addClass(element, _jsPlumb.connectedClass);
            }
          };
      _jp.Connection = function(params) {
        var _newEndpoint = params.newEndpoint;
        this.id = params.id;
        this.connector = null;
        this.idPrefix = "_jsplumb_c_";
        this.defaultLabelLocation = 0.5;
        this.defaultOverlayKeys = ["Overlays", "ConnectionOverlays"];
        this.previousConnection = params.previousConnection;
        this.source = _jp.getElement(params.source);
        this.target = _jp.getElement(params.target);
        if (params.sourceEndpoint)
          this.source = params.sourceEndpoint.getElement();
        if (params.targetEndpoint)
          this.target = params.targetEndpoint.getElement();
        _jp.OverlayCapableJsPlumbUIComponent.apply(this, arguments);
        this.sourceId = this._jsPlumb.instance.getId(this.source);
        this.targetId = this._jsPlumb.instance.getId(this.target);
        this.scope = params.scope;
        this.endpoints = [];
        this.endpointStyles = [];
        var _jsPlumb = this._jsPlumb.instance;
        _jsPlumb.manage(this.sourceId, this.source);
        _jsPlumb.manage(this.targetId, this.target);
        this._jsPlumb.visible = true;
        this._jsPlumb.editable = params.editable === true;
        this._jsPlumb.params = {
          cssClass: params.cssClass,
          container: params.container,
          "pointer-events": params["pointer-events"],
          editorParams: params.editorParams,
          overlays: params.overlays
        };
        this._jsPlumb.lastPaintedAt = null;
        this.bind("mouseover", function() {
          this.setHover(true);
        }.bind(this));
        this.bind("mouseout", function() {
          this.setHover(false);
        }.bind(this));
        this.editableRequested = params.editable !== false;
        this.setEditable = function(e) {
          return this.connector ? this.connector.setEditable(e) : false;
        };
        this.isEditable = function() {
          return this.connector ? this.connector.isEditable() : false;
        };
        this.isEditing = function() {
          return this.connector ? this.connector.isEditing() : false;
        };
        this.makeEndpoint = function(isSource, el, elId, ep) {
          elId = elId || this._jsPlumb.instance.getId(el);
          return this.prepareEndpoint(_jsPlumb, _newEndpoint, this, ep, isSource ? 0 : 1, params, el, elId);
        };
        if (params.type) {
          params.endpoints = this._jsPlumb.instance.deriveEndpointAndAnchorSpec(params.type).endpoints;
        }
        var eS = this.makeEndpoint(true, this.source, this.sourceId, params.sourceEndpoint),
            eT = this.makeEndpoint(false, this.target, this.targetId, params.targetEndpoint);
        if (eS)
          _ju.addToList(params.endpointsByElement, this.sourceId, eS);
        if (eT)
          _ju.addToList(params.endpointsByElement, this.targetId, eT);
        if (!this.scope)
          this.scope = this.endpoints[0].scope;
        if (params.deleteEndpointsOnDetach != null) {
          this.endpoints[0]._deleteOnDetach = params.deleteEndpointsOnDetach;
          this.endpoints[1]._deleteOnDetach = params.deleteEndpointsOnDetach;
        } else {
          if (!this.endpoints[0]._doNotDeleteOnDetach)
            this.endpoints[0]._deleteOnDetach = true;
          if (!this.endpoints[1]._doNotDeleteOnDetach)
            this.endpoints[1]._deleteOnDetach = true;
        }
        var _detachable = _jsPlumb.Defaults.ConnectionsDetachable;
        if (params.detachable === false)
          _detachable = false;
        if (this.endpoints[0].connectionsDetachable === false)
          _detachable = false;
        if (this.endpoints[1].connectionsDetachable === false)
          _detachable = false;
        var _reattach = params.reattach || this.endpoints[0].reattachConnections || this.endpoints[1].reattachConnections || _jsPlumb.Defaults.ReattachConnections;
        this.appendToDefaultType({
          detachable: _detachable,
          reattach: _reattach,
          paintStyle: this.endpoints[0].connectorStyle || this.endpoints[1].connectorStyle || params.paintStyle || _jsPlumb.Defaults.PaintStyle || jsPlumb.Defaults.PaintStyle,
          hoverPaintStyle: this.endpoints[0].connectorHoverStyle || this.endpoints[1].connectorHoverStyle || params.hoverPaintStyle || _jsPlumb.Defaults.HoverPaintStyle || jsPlumb.Defaults.HoverPaintStyle
        });
        var _suspendedAt = _jsPlumb.getSuspendedAt();
        if (!_jsPlumb.isSuspendDrawing()) {
          var myInfo = _jsPlumb.getCachedData(this.sourceId),
              myOffset = myInfo.o,
              myWH = myInfo.s,
              otherInfo = _jsPlumb.getCachedData(this.targetId),
              otherOffset = otherInfo.o,
              otherWH = otherInfo.s,
              initialTimestamp = _suspendedAt || _jsPlumb.timestamp(),
              anchorLoc = this.endpoints[0].anchor.compute({
                xy: [myOffset.left, myOffset.top],
                wh: myWH,
                element: this.endpoints[0],
                elementId: this.endpoints[0].elementId,
                txy: [otherOffset.left, otherOffset.top],
                twh: otherWH,
                tElement: this.endpoints[1],
                timestamp: initialTimestamp
              });
          this.endpoints[0].paint({
            anchorLoc: anchorLoc,
            timestamp: initialTimestamp
          });
          anchorLoc = this.endpoints[1].anchor.compute({
            xy: [otherOffset.left, otherOffset.top],
            wh: otherWH,
            element: this.endpoints[1],
            elementId: this.endpoints[1].elementId,
            txy: [myOffset.left, myOffset.top],
            twh: myWH,
            tElement: this.endpoints[0],
            timestamp: initialTimestamp
          });
          this.endpoints[1].paint({
            anchorLoc: anchorLoc,
            timestamp: initialTimestamp
          });
        }
        this.getTypeDescriptor = function() {
          return "connection";
        };
        this.getAttachedElements = function() {
          return this.endpoints;
        };
        this.isDetachable = function() {
          return this._jsPlumb.detachable === true;
        };
        this.setDetachable = function(detachable) {
          this._jsPlumb.detachable = detachable === true;
        };
        this.isReattach = function() {
          return this._jsPlumb.reattach === true || this.endpoints[0].reattachConnections === true || this.endpoints[1].reattachConnections === true;
        };
        this.setReattach = function(reattach) {
          this._jsPlumb.reattach = reattach === true;
        };
        this._jsPlumb.cost = params.cost || this.endpoints[0].getConnectionCost();
        this._jsPlumb.directed = params.directed;
        if (params.directed == null)
          this._jsPlumb.directed = this.endpoints[0].areConnectionsDirected();
        var _p = jsPlumb.extend({}, this.endpoints[1].getParameters());
        _jp.extend(_p, this.endpoints[0].getParameters());
        _jp.extend(_p, this.getParameters());
        this.setParameters(_p);
        this.setConnector(this.endpoints[0].connector || this.endpoints[1].connector || params.connector || _jsPlumb.Defaults.Connector || _jp.Defaults.Connector, true);
        if (params.geometry) {
          this.connector.setGeometry(params.geometry);
        }
        var data = params.data == null || !jsPlumbUtil.isObject(params.data) ? {} : params.data;
        this.getData = function() {
          return data;
        };
        this.setData = function(d) {
          data = d || {};
        };
        this.mergeData = function(d) {
          data = jsPlumb.extend(data, d);
        };
        var _types = ["default", this.endpoints[0].connectionType, this.endpoints[1].connectionType, params.type].join(" ");
        if (/[^\s]/.test(_types))
          this.addType(_types, params.data, true);
        this.updateConnectedClass();
      };
      _ju.extend(_jp.Connection, _jp.OverlayCapableJsPlumbUIComponent, {
        applyType: function(t, doNotRepaint, typeMap) {
          if (t.detachable != null)
            this.setDetachable(t.detachable);
          if (t.reattach != null)
            this.setReattach(t.reattach);
          if (t.scope)
            this.scope = t.scope;
          if (t.cssClass != null && this.canvas)
            this._jsPlumb.instance.addClass(this.canvas, t.cssClass);
          var _anchors = null;
          if (t.anchor) {
            _anchors = this.getCachedTypeItem("anchors", typeMap.anchor);
            if (_anchors == null) {
              _anchors = [this._jsPlumb.instance.makeAnchor(t.anchor), this._jsPlumb.instance.makeAnchor(t.anchor)];
              this.cacheTypeItem("anchors", _anchors, typeMap.anchor);
            }
          } else if (t.anchors) {
            _anchors = this.getCachedTypeItem("anchors", typeMap.anchors);
            if (_anchors == null) {
              _anchors = [this._jsPlumb.instance.makeAnchor(t.anchors[0]), this._jsPlumb.instance.makeAnchor(t.anchors[1])];
              this.cacheTypeItem("anchors", _anchors, typeMap.anchors);
            }
          }
          if (_anchors != null) {
            this.endpoints[0].anchor = _anchors[0];
            this.endpoints[1].anchor = _anchors[1];
            if (this.endpoints[1].anchor.isDynamic)
              this._jsPlumb.instance.repaint(this.endpoints[1].elementId);
          }
          _jp.OverlayCapableJsPlumbUIComponent.applyType(this, t);
        },
        addClass: function(c, informEndpoints) {
          if (informEndpoints) {
            this.endpoints[0].addClass(c);
            this.endpoints[1].addClass(c);
            if (this.suspendedEndpoint)
              this.suspendedEndpoint.addClass(c);
          }
          if (this.connector) {
            this.connector.addClass(c);
          }
        },
        removeClass: function(c, informEndpoints) {
          if (informEndpoints) {
            this.endpoints[0].removeClass(c);
            this.endpoints[1].removeClass(c);
            if (this.suspendedEndpoint)
              this.suspendedEndpoint.removeClass(c);
          }
          if (this.connector) {
            this.connector.removeClass(c);
          }
        },
        isVisible: function() {
          return this._jsPlumb.visible;
        },
        setVisible: function(v) {
          this._jsPlumb.visible = v;
          if (this.connector)
            this.connector.setVisible(v);
          this.repaint();
        },
        cleanup: function() {
          this.updateConnectedClass(true);
          this.endpoints = null;
          this.source = null;
          this.target = null;
          if (this.connector != null) {
            this.connector.cleanup(true);
            this.connector.destroy(true);
          }
          this.connector = null;
        },
        updateConnectedClass: function(remove) {
          if (this._jsPlumb) {
            _updateConnectedClass(this, this.source, this._jsPlumb.instance, remove);
            _updateConnectedClass(this, this.target, this._jsPlumb.instance, remove);
          }
        },
        setHover: function(state) {
          if (this.connector && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged()) {
            this.connector.setHover(state);
            root.jsPlumb[state ? "addClass" : "removeClass"](this.source, this._jsPlumb.instance.hoverSourceClass);
            root.jsPlumb[state ? "addClass" : "removeClass"](this.target, this._jsPlumb.instance.hoverTargetClass);
          }
        },
        getUuids: function() {
          return [this.endpoints[0].getUuid(), this.endpoints[1].getUuid()];
        },
        getCost: function() {
          return this._jsPlumb ? this._jsPlumb.cost : -Infinity;
        },
        setCost: function(c) {
          this._jsPlumb.cost = c;
        },
        isDirected: function() {
          return this._jsPlumb.directed === true;
        },
        getConnector: function() {
          return this.connector;
        },
        getGeometry: function() {
          return this.connector ? this.connector.getGeometry() : null;
        },
        setGeometry: function(g) {
          if (this.connector)
            this.connector.setGeometry(g);
        },
        prepareConnector: function(connectorSpec, typeId) {
          var connectorArgs = {
            _jsPlumb: this._jsPlumb.instance,
            cssClass: (this._jsPlumb.params.cssClass || "") + (this.isEditable() ? this._jsPlumb.instance.editableConnectorClass : ""),
            container: this._jsPlumb.params.container,
            "pointer-events": this._jsPlumb.params["pointer-events"],
            editable: this.editableRequested
          },
              renderMode = this._jsPlumb.instance.getRenderMode(),
              connector;
          if (_ju.isString(connectorSpec))
            connector = makeConnector(this._jsPlumb.instance, renderMode, connectorSpec, connectorArgs, this);
          else if (_ju.isArray(connectorSpec)) {
            if (connectorSpec.length == 1)
              connector = makeConnector(this._jsPlumb.instance, renderMode, connectorSpec[0], connectorArgs, this);
            else
              connector = makeConnector(this._jsPlumb.instance, renderMode, connectorSpec[0], _ju.merge(connectorSpec[1], connectorArgs), this);
          }
          if (typeId != null)
            connector.typeId = typeId;
          return connector;
        },
        setPreparedConnector: function(connector, doNotRepaint, doNotChangeListenerComponent, typeId) {
          var previous,
              previousClasses = "";
          if (this.connector != null) {
            previous = this.connector;
            previousClasses = previous.getClass();
            this.connector.cleanup();
            this.connector.destroy();
          }
          this.connector = connector;
          if (typeId) {
            this.cacheTypeItem("connector", connector, typeId);
          }
          this.canvas = this.connector.canvas;
          this.bgCanvas = this.connector.bgCanvas;
          this.addClass(previousClasses);
          if (this.canvas)
            this.canvas._jsPlumb = this;
          if (this.bgCanvas)
            this.bgCanvas._jsPlumb = this;
          if (previous != null) {
            var o = this.getOverlays();
            for (var i = 0; i < o.length; i++) {
              if (o[i].transfer)
                o[i].transfer(this.connector);
            }
          }
          if (!doNotChangeListenerComponent)
            this.setListenerComponent(this.connector);
          if (!doNotRepaint)
            this.repaint();
        },
        setConnector: function(connectorSpec, doNotRepaint, doNotChangeListenerComponent, typeId) {
          var connector = this.prepareConnector(connectorSpec, typeId);
          this.setPreparedConnector(connector, doNotRepaint, doNotChangeListenerComponent, typeId);
        },
        paint: function(params) {
          if (!this._jsPlumb.instance.isSuspendDrawing() && this._jsPlumb.visible) {
            params = params || {};
            var timestamp = params.timestamp,
                swap = false,
                tId = swap ? this.sourceId : this.targetId,
                sId = swap ? this.targetId : this.sourceId,
                tIdx = swap ? 0 : 1,
                sIdx = swap ? 1 : 0;
            if (timestamp == null || timestamp != this._jsPlumb.lastPaintedAt) {
              var sourceInfo = this._jsPlumb.instance.updateOffset({elId: sId}).o,
                  targetInfo = this._jsPlumb.instance.updateOffset({elId: tId}).o,
                  sE = this.endpoints[sIdx],
                  tE = this.endpoints[tIdx];
              var sAnchorP = sE.anchor.getCurrentLocation({
                xy: [sourceInfo.left, sourceInfo.top],
                wh: [sourceInfo.width, sourceInfo.height],
                element: sE,
                timestamp: timestamp
              }),
                  tAnchorP = tE.anchor.getCurrentLocation({
                    xy: [targetInfo.left, targetInfo.top],
                    wh: [targetInfo.width, targetInfo.height],
                    element: tE,
                    timestamp: timestamp
                  });
              this.connector.resetBounds();
              this.connector.compute({
                sourcePos: sAnchorP,
                targetPos: tAnchorP,
                sourceEndpoint: this.endpoints[sIdx],
                targetEndpoint: this.endpoints[tIdx],
                lineWidth: this._jsPlumb.paintStyleInUse.lineWidth,
                sourceInfo: sourceInfo,
                targetInfo: targetInfo
              });
              var overlayExtents = {
                minX: Infinity,
                minY: Infinity,
                maxX: -Infinity,
                maxY: -Infinity
              };
              for (var i in this._jsPlumb.overlays) {
                if (this._jsPlumb.overlays.hasOwnProperty(i)) {
                  var o = this._jsPlumb.overlays[i];
                  if (o.isVisible()) {
                    this._jsPlumb.overlayPlacements[i] = o.draw(this.connector, this._jsPlumb.paintStyleInUse, this.getAbsoluteOverlayPosition(o));
                    overlayExtents.minX = Math.min(overlayExtents.minX, this._jsPlumb.overlayPlacements[i].minX);
                    overlayExtents.maxX = Math.max(overlayExtents.maxX, this._jsPlumb.overlayPlacements[i].maxX);
                    overlayExtents.minY = Math.min(overlayExtents.minY, this._jsPlumb.overlayPlacements[i].minY);
                    overlayExtents.maxY = Math.max(overlayExtents.maxY, this._jsPlumb.overlayPlacements[i].maxY);
                  }
                }
              }
              var lineWidth = parseFloat(this._jsPlumb.paintStyleInUse.lineWidth || 1) / 2,
                  outlineWidth = parseFloat(this._jsPlumb.paintStyleInUse.lineWidth || 0),
                  extents = {
                    xmin: Math.min(this.connector.bounds.minX - (lineWidth + outlineWidth), overlayExtents.minX),
                    ymin: Math.min(this.connector.bounds.minY - (lineWidth + outlineWidth), overlayExtents.minY),
                    xmax: Math.max(this.connector.bounds.maxX + (lineWidth + outlineWidth), overlayExtents.maxX),
                    ymax: Math.max(this.connector.bounds.maxY + (lineWidth + outlineWidth), overlayExtents.maxY)
                  };
              this.connector.paint(this._jsPlumb.paintStyleInUse, null, extents);
              for (var j in this._jsPlumb.overlays) {
                if (this._jsPlumb.overlays.hasOwnProperty(j)) {
                  var p = this._jsPlumb.overlays[j];
                  if (p.isVisible()) {
                    p.paint(this._jsPlumb.overlayPlacements[j], extents);
                  }
                }
              }
            }
            this._jsPlumb.lastPaintedAt = timestamp;
          }
        },
        repaint: function(params) {
          params = params || {};
          this.paint({
            elId: this.sourceId,
            recalc: !(params.recalc === false),
            timestamp: params.timestamp
          });
        },
        prepareEndpoint: function(_jsPlumb, _newEndpoint, conn, existing, index, params, element, elementId) {
          var e;
          if (existing) {
            conn.endpoints[index] = existing;
            existing.addConnection(conn);
          } else {
            if (!params.endpoints)
              params.endpoints = [null, null];
            var ep = params.endpoints[index] || params.endpoint || _jsPlumb.Defaults.Endpoints[index] || jsPlumb.Defaults.Endpoints[index] || _jsPlumb.Defaults.Endpoint || jsPlumb.Defaults.Endpoint;
            if (!params.endpointStyles)
              params.endpointStyles = [null, null];
            if (!params.endpointHoverStyles)
              params.endpointHoverStyles = [null, null];
            var es = params.endpointStyles[index] || params.endpointStyle || _jsPlumb.Defaults.EndpointStyles[index] || jsPlumb.Defaults.EndpointStyles[index] || _jsPlumb.Defaults.EndpointStyle || jsPlumb.Defaults.EndpointStyle;
            if (es.fillStyle == null && params.paintStyle != null)
              es.fillStyle = params.paintStyle.strokeStyle;
            if (es.outlineColor == null && params.paintStyle != null)
              es.outlineColor = params.paintStyle.outlineColor;
            if (es.outlineWidth == null && params.paintStyle != null)
              es.outlineWidth = params.paintStyle.outlineWidth;
            var ehs = params.endpointHoverStyles[index] || params.endpointHoverStyle || _jsPlumb.Defaults.EndpointHoverStyles[index] || jsPlumb.Defaults.EndpointHoverStyles[index] || _jsPlumb.Defaults.EndpointHoverStyle || jsPlumb.Defaults.EndpointHoverStyle;
            if (params.hoverPaintStyle != null) {
              if (ehs == null)
                ehs = {};
              if (ehs.fillStyle == null) {
                ehs.fillStyle = params.hoverPaintStyle.strokeStyle;
              }
            }
            var a = params.anchors ? params.anchors[index] : params.anchor ? params.anchor : _makeAnchor(_jsPlumb.Defaults.Anchors[index], elementId, _jsPlumb) || _makeAnchor(_jp.Defaults.Anchors[index], elementId, _jsPlumb) || _makeAnchor(_jsPlumb.Defaults.Anchor, elementId, _jsPlumb) || _makeAnchor(_jp.Defaults.Anchor, elementId, _jsPlumb),
                u = params.uuids ? params.uuids[index] : null;
            e = _newEndpoint({
              paintStyle: es,
              hoverPaintStyle: ehs,
              endpoint: ep,
              connections: [conn],
              uuid: u,
              anchor: a,
              source: element,
              scope: params.scope,
              reattach: params.reattach || _jsPlumb.Defaults.ReattachConnections,
              detachable: params.detachable || _jsPlumb.Defaults.ConnectionsDetachable
            });
            conn.endpoints[index] = e;
            if (params.drawEndpoints === false)
              e.setVisible(false, true, true);
          }
          return e;
        }
      });
    }).call(this);
    ;
    (function() {
      "use strict";
      var root = this,
          _ju = root.jsPlumbUtil,
          _jp = root.jsPlumb;
      _jp.AnchorManager = function(params) {
        var _amEndpoints = {},
            continuousAnchorLocations = {},
            userDefinedContinuousAnchorLocations = {},
            continuousAnchorOrientations = {},
            Orientation = {
              HORIZONTAL: "horizontal",
              VERTICAL: "vertical",
              DIAGONAL: "diagonal",
              IDENTITY: "identity"
            },
            axes = ["left", "top", "right", "bottom"],
            connectionsByElementId = {},
            self = this,
            anchorLists = {},
            jsPlumbInstance = params.jsPlumbInstance,
            floatingConnections = {},
            calculateOrientation = function(sourceId, targetId, sd, td, sourceAnchor, targetAnchor) {
              if (sourceId === targetId)
                return {
                  orientation: Orientation.IDENTITY,
                  a: ["top", "top"]
                };
              var theta = Math.atan2((td.centery - sd.centery), (td.centerx - sd.centerx)),
                  theta2 = Math.atan2((sd.centery - td.centery), (sd.centerx - td.centerx));
              var candidates = [],
                  midpoints = {};
              (function(types, dim) {
                for (var i = 0; i < types.length; i++) {
                  midpoints[types[i]] = {
                    "left": [dim[i].left, dim[i].centery],
                    "right": [dim[i].right, dim[i].centery],
                    "top": [dim[i].centerx, dim[i].top],
                    "bottom": [dim[i].centerx, dim[i].bottom]
                  };
                }
              })(["source", "target"], [sd, td]);
              for (var sf = 0; sf < axes.length; sf++) {
                for (var tf = 0; tf < axes.length; tf++) {
                  candidates.push({
                    source: axes[sf],
                    target: axes[tf],
                    dist: Biltong.lineLength(midpoints.source[axes[sf]], midpoints.target[axes[tf]])
                  });
                }
              }
              candidates.sort(function(a, b) {
                return a.dist < b.dist ? -1 : a.dist > b.dist ? 1 : 0;
              });
              var sourceEdge = candidates[0].source,
                  targetEdge = candidates[0].target;
              for (var i = 0; i < candidates.length; i++) {
                if (!sourceAnchor.isContinuous || sourceAnchor.isEdgeSupported(candidates[i].source))
                  sourceEdge = candidates[i].source;
                else
                  sourceEdge = null;
                if (!targetAnchor.isContinuous || targetAnchor.isEdgeSupported(candidates[i].target))
                  targetEdge = candidates[i].target;
                else {
                  targetEdge = null;
                }
                if (sourceEdge != null && targetEdge != null)
                  break;
              }
              return {
                a: [sourceEdge, targetEdge],
                theta: theta,
                theta2: theta2
              };
            },
            placeAnchorsOnLine = function(desc, elementDimensions, elementPosition, connections, horizontal, otherMultiplier, reverse) {
              var a = [],
                  step = elementDimensions[horizontal ? 0 : 1] / (connections.length + 1);
              for (var i = 0; i < connections.length; i++) {
                var val = (i + 1) * step,
                    other = otherMultiplier * elementDimensions[horizontal ? 1 : 0];
                if (reverse)
                  val = elementDimensions[horizontal ? 0 : 1] - val;
                var dx = (horizontal ? val : other),
                    x = elementPosition[0] + dx,
                    xp = dx / elementDimensions[0],
                    dy = (horizontal ? other : val),
                    y = elementPosition[1] + dy,
                    yp = dy / elementDimensions[1];
                a.push([x, y, xp, yp, connections[i][1], connections[i][2]]);
              }
              return a;
            },
            currySort = function(reverseAngles) {
              return function(a, b) {
                var r = true;
                if (reverseAngles) {
                  r = a[0][0] < b[0][0];
                } else {
                  r = a[0][0] > b[0][0];
                }
                return r === false ? -1 : 1;
              };
            },
            leftSort = function(a, b) {
              var p1 = a[0][0] < 0 ? -Math.PI - a[0][0] : Math.PI - a[0][0],
                  p2 = b[0][0] < 0 ? -Math.PI - b[0][0] : Math.PI - b[0][0];
              if (p1 > p2)
                return 1;
              else
                return a[0][1] > b[0][1] ? 1 : -1;
            },
            edgeSortFunctions = {
              "top": function(a, b) {
                return a[0] > b[0] ? 1 : -1;
              },
              "right": currySort(true),
              "bottom": currySort(true),
              "left": leftSort
            },
            _sortHelper = function(_array, _fn) {
              return _array.sort(_fn);
            },
            placeAnchors = function(elementId, _anchorLists) {
              var cd = jsPlumbInstance.getCachedData(elementId),
                  sS = cd.s,
                  sO = cd.o,
                  placeSomeAnchors = function(desc, elementDimensions, elementPosition, unsortedConnections, isHorizontal, otherMultiplier, orientation) {
                    if (unsortedConnections.length > 0) {
                      var sc = _sortHelper(unsortedConnections, edgeSortFunctions[desc]),
                          reverse = desc === "right" || desc === "top",
                          anchors = placeAnchorsOnLine(desc, elementDimensions, elementPosition, sc, isHorizontal, otherMultiplier, reverse);
                      var _setAnchorLocation = function(endpoint, anchorPos) {
                        continuousAnchorLocations[endpoint.id] = [anchorPos[0], anchorPos[1], anchorPos[2], anchorPos[3]];
                        continuousAnchorOrientations[endpoint.id] = orientation;
                      };
                      for (var i = 0; i < anchors.length; i++) {
                        var c = anchors[i][4],
                            weAreSource = c.endpoints[0].elementId === elementId,
                            weAreTarget = c.endpoints[1].elementId === elementId;
                        if (weAreSource)
                          _setAnchorLocation(c.endpoints[0], anchors[i]);
                        if (weAreTarget)
                          _setAnchorLocation(c.endpoints[1], anchors[i]);
                      }
                    }
                  };
              placeSomeAnchors("bottom", sS, [sO.left, sO.top], _anchorLists.bottom, true, 1, [0, 1]);
              placeSomeAnchors("top", sS, [sO.left, sO.top], _anchorLists.top, true, 0, [0, -1]);
              placeSomeAnchors("left", sS, [sO.left, sO.top], _anchorLists.left, false, 0, [-1, 0]);
              placeSomeAnchors("right", sS, [sO.left, sO.top], _anchorLists.right, false, 1, [1, 0]);
            };
        this.reset = function() {
          _amEndpoints = {};
          connectionsByElementId = {};
          anchorLists = {};
        };
        this.addFloatingConnection = function(key, conn) {
          floatingConnections[key] = conn;
        };
        this.removeFloatingConnection = function(key) {
          delete floatingConnections[key];
        };
        this.newConnection = function(conn) {
          var sourceId = conn.sourceId,
              targetId = conn.targetId,
              ep = conn.endpoints,
              doRegisterTarget = true,
              registerConnection = function(otherIndex, otherEndpoint, otherAnchor, elId, c) {
                if ((sourceId == targetId) && otherAnchor.isContinuous) {
                  conn._jsPlumb.instance.removeElement(ep[1].canvas);
                  doRegisterTarget = false;
                }
                _ju.addToList(connectionsByElementId, elId, [c, otherEndpoint, otherAnchor.constructor == _jp.DynamicAnchor]);
              };
          registerConnection(0, ep[0], ep[0].anchor, targetId, conn);
          if (doRegisterTarget)
            registerConnection(1, ep[1], ep[1].anchor, sourceId, conn);
        };
        var removeEndpointFromAnchorLists = function(endpoint) {
          (function(list, eId) {
            if (list) {
              var f = function(e) {
                return e[4] == eId;
              };
              _ju.removeWithFunction(list.top, f);
              _ju.removeWithFunction(list.left, f);
              _ju.removeWithFunction(list.bottom, f);
              _ju.removeWithFunction(list.right, f);
            }
          })(anchorLists[endpoint.elementId], endpoint.id);
        };
        this.connectionDetached = function(connInfo, doNotRedraw) {
          var connection = connInfo.connection || connInfo,
              sourceId = connInfo.sourceId,
              targetId = connInfo.targetId,
              ep = connection.endpoints,
              removeConnection = function(otherIndex, otherEndpoint, otherAnchor, elId, c) {
                _ju.removeWithFunction(connectionsByElementId[elId], function(_c) {
                  return _c[0].id == c.id;
                });
              };
          removeConnection(1, ep[1], ep[1].anchor, sourceId, connection);
          removeConnection(0, ep[0], ep[0].anchor, targetId, connection);
          if (connection.floatingId) {
            removeConnection(connection.floatingIndex, connection.floatingEndpoint, connection.floatingEndpoint.anchor, connection.floatingId, connection);
            removeEndpointFromAnchorLists(connection.floatingEndpoint);
          }
          removeEndpointFromAnchorLists(connection.endpoints[0]);
          removeEndpointFromAnchorLists(connection.endpoints[1]);
          if (!doNotRedraw) {
            self.redraw(connection.sourceId);
            if (connection.targetId !== connection.sourceId)
              self.redraw(connection.targetId);
          }
        };
        this.add = function(endpoint, elementId) {
          _ju.addToList(_amEndpoints, elementId, endpoint);
        };
        this.changeId = function(oldId, newId) {
          connectionsByElementId[newId] = connectionsByElementId[oldId];
          _amEndpoints[newId] = _amEndpoints[oldId];
          delete connectionsByElementId[oldId];
          delete _amEndpoints[oldId];
        };
        this.getConnectionsFor = function(elementId) {
          return connectionsByElementId[elementId] || [];
        };
        this.getEndpointsFor = function(elementId) {
          return _amEndpoints[elementId] || [];
        };
        this.deleteEndpoint = function(endpoint) {
          _ju.removeWithFunction(_amEndpoints[endpoint.elementId], function(e) {
            return e.id == endpoint.id;
          });
          removeEndpointFromAnchorLists(endpoint);
        };
        this.clearFor = function(elementId) {
          delete _amEndpoints[elementId];
          _amEndpoints[elementId] = [];
        };
        var _updateAnchorList = function(lists, theta, order, conn, aBoolean, otherElId, idx, reverse, edgeId, elId, connsToPaint, endpointsToPaint) {
          var exactIdx = -1,
              firstMatchingElIdx = -1,
              endpoint = conn.endpoints[idx],
              endpointId = endpoint.id,
              oIdx = [1, 0][idx],
              values = [[theta, order], conn, aBoolean, otherElId, endpointId],
              listToAddTo = lists[edgeId],
              listToRemoveFrom = endpoint._continuousAnchorEdge ? lists[endpoint._continuousAnchorEdge] : null,
              i,
              candidate;
          if (listToRemoveFrom) {
            var rIdx = _ju.findWithFunction(listToRemoveFrom, function(e) {
              return e[4] == endpointId;
            });
            if (rIdx != -1) {
              listToRemoveFrom.splice(rIdx, 1);
              for (i = 0; i < listToRemoveFrom.length; i++) {
                candidate = listToRemoveFrom[i][1];
                _ju.addWithFunction(connsToPaint, candidate, function(c) {
                  return c.id == candidate.id;
                });
                _ju.addWithFunction(endpointsToPaint, listToRemoveFrom[i][1].endpoints[idx], function(e) {
                  return e.id == candidate.endpoints[idx].id;
                });
                _ju.addWithFunction(endpointsToPaint, listToRemoveFrom[i][1].endpoints[oIdx], function(e) {
                  return e.id == candidate.endpoints[oIdx].id;
                });
              }
            }
          }
          for (i = 0; i < listToAddTo.length; i++) {
            candidate = listToAddTo[i][1];
            if (params.idx == 1 && listToAddTo[i][3] === otherElId && firstMatchingElIdx == -1)
              firstMatchingElIdx = i;
            _ju.addWithFunction(connsToPaint, candidate, function(c) {
              return c.id == candidate.id;
            });
            _ju.addWithFunction(endpointsToPaint, listToAddTo[i][1].endpoints[idx], function(e) {
              return e.id == candidate.endpoints[idx].id;
            });
            _ju.addWithFunction(endpointsToPaint, listToAddTo[i][1].endpoints[oIdx], function(e) {
              return e.id == candidate.endpoints[oIdx].id;
            });
          }
          if (exactIdx != -1) {
            listToAddTo[exactIdx] = values;
          } else {
            var insertIdx = reverse ? firstMatchingElIdx != -1 ? firstMatchingElIdx : 0 : listToAddTo.length;
            listToAddTo.splice(insertIdx, 0, values);
          }
          endpoint._continuousAnchorEdge = edgeId;
        };
        this.updateOtherEndpoint = function(elId, oldTargetId, newTargetId, connection) {
          var sIndex = _ju.findWithFunction(connectionsByElementId[elId], function(i) {
            return i[0].id === connection.id;
          }),
              tIndex = _ju.findWithFunction(connectionsByElementId[oldTargetId], function(i) {
                return i[0].id === connection.id;
              });
          if (sIndex != -1) {
            connectionsByElementId[elId][sIndex][0] = connection;
            connectionsByElementId[elId][sIndex][1] = connection.endpoints[1];
            connectionsByElementId[elId][sIndex][2] = connection.endpoints[1].anchor.constructor == _jp.DynamicAnchor;
          }
          if (tIndex > -1) {
            connectionsByElementId[oldTargetId].splice(tIndex, 1);
            _ju.addToList(connectionsByElementId, newTargetId, [connection, connection.endpoints[0], connection.endpoints[0].anchor.constructor == _jp.DynamicAnchor]);
          }
          connection.updateConnectedClass();
        };
        this.sourceChanged = function(originalId, newId, connection) {
          if (originalId !== newId) {
            _ju.removeWithFunction(connectionsByElementId[originalId], function(info) {
              return info[0].id === connection.id;
            });
            var tIdx = _ju.findWithFunction(connectionsByElementId[connection.targetId], function(i) {
              return i[0].id === connection.id;
            });
            if (tIdx > -1) {
              connectionsByElementId[connection.targetId][tIdx][0] = connection;
              connectionsByElementId[connection.targetId][tIdx][1] = connection.endpoints[0];
              connectionsByElementId[connection.targetId][tIdx][2] = connection.endpoints[0].anchor.constructor == _jp.DynamicAnchor;
            }
            _ju.addToList(connectionsByElementId, newId, [connection, connection.endpoints[1], connection.endpoints[1].anchor.constructor == _jp.DynamicAnchor]);
            if (connection.endpoints[1].anchor.isContinuous) {
              if (connection.source === connection.target) {
                connection._jsPlumb.instance.removeElement(connection.endpoints[1].canvas);
              } else {
                if (connection.endpoints[1].canvas.parentNode == null) {
                  connection._jsPlumb.instance.appendElement(connection.endpoints[1].canvas);
                }
              }
            }
            connection.updateConnectedClass();
          }
        };
        this.rehomeEndpoint = function(ep, currentId, element) {
          var eps = _amEndpoints[currentId] || [],
              elementId = jsPlumbInstance.getId(element);
          if (elementId !== currentId) {
            var idx = eps.indexOf(ep);
            if (idx > -1) {
              var _ep = eps.splice(idx, 1)[0];
              self.add(_ep, elementId);
            }
          }
          for (var i = 0; i < ep.connections.length; i++) {
            if (ep.connections[i].sourceId == currentId) {
              ep.connections[i].sourceId = ep.elementId;
              ep.connections[i].source = ep.element;
              self.sourceChanged(currentId, ep.elementId, ep.connections[i]);
            } else if (ep.connections[i].targetId == currentId) {
              ep.connections[i].targetId = ep.elementId;
              ep.connections[i].target = ep.element;
              self.updateOtherEndpoint(ep.connections[i].sourceId, currentId, ep.elementId, ep.connections[i]);
            }
          }
        };
        this.redraw = function(elementId, ui, timestamp, offsetToUI, clearEdits, doNotRecalcEndpoint) {
          if (!jsPlumbInstance.isSuspendDrawing()) {
            var ep = _amEndpoints[elementId] || [],
                endpointConnections = connectionsByElementId[elementId] || [],
                connectionsToPaint = [],
                endpointsToPaint = [],
                anchorsToUpdate = [];
            timestamp = timestamp || jsPlumbInstance.timestamp();
            offsetToUI = offsetToUI || {
              left: 0,
              top: 0
            };
            if (ui) {
              ui = {
                left: ui.left + offsetToUI.left,
                top: ui.top + offsetToUI.top
              };
            }
            var myOffset = jsPlumbInstance.updateOffset({
              elId: elementId,
              offset: ui,
              recalc: false,
              timestamp: timestamp
            }),
                orientationCache = {};
            for (var i = 0; i < endpointConnections.length; i++) {
              var conn = endpointConnections[i][0],
                  sourceId = conn.sourceId,
                  targetId = conn.targetId,
                  sourceContinuous = conn.endpoints[0].anchor.isContinuous,
                  targetContinuous = conn.endpoints[1].anchor.isContinuous;
              if (sourceContinuous || targetContinuous) {
                var oKey = sourceId + "_" + targetId,
                    o = orientationCache[oKey],
                    oIdx = conn.sourceId == elementId ? 1 : 0;
                if (sourceContinuous && !anchorLists[sourceId])
                  anchorLists[sourceId] = {
                    top: [],
                    right: [],
                    bottom: [],
                    left: []
                  };
                if (targetContinuous && !anchorLists[targetId])
                  anchorLists[targetId] = {
                    top: [],
                    right: [],
                    bottom: [],
                    left: []
                  };
                if (elementId != targetId)
                  jsPlumbInstance.updateOffset({
                    elId: targetId,
                    timestamp: timestamp
                  });
                if (elementId != sourceId)
                  jsPlumbInstance.updateOffset({
                    elId: sourceId,
                    timestamp: timestamp
                  });
                var td = jsPlumbInstance.getCachedData(targetId),
                    sd = jsPlumbInstance.getCachedData(sourceId);
                if (targetId == sourceId && (sourceContinuous || targetContinuous)) {
                  _updateAnchorList(anchorLists[sourceId], -Math.PI / 2, 0, conn, false, targetId, 0, false, "top", sourceId, connectionsToPaint, endpointsToPaint);
                  _updateAnchorList(anchorLists[targetId], -Math.PI / 2, 0, conn, false, sourceId, 1, false, "top", targetId, connectionsToPaint, endpointsToPaint);
                } else {
                  if (!o) {
                    o = calculateOrientation(sourceId, targetId, sd.o, td.o, conn.endpoints[0].anchor, conn.endpoints[1].anchor);
                    orientationCache[oKey] = o;
                  }
                  if (sourceContinuous)
                    _updateAnchorList(anchorLists[sourceId], o.theta, 0, conn, false, targetId, 0, false, o.a[0], sourceId, connectionsToPaint, endpointsToPaint);
                  if (targetContinuous)
                    _updateAnchorList(anchorLists[targetId], o.theta2, -1, conn, true, sourceId, 1, true, o.a[1], targetId, connectionsToPaint, endpointsToPaint);
                }
                if (sourceContinuous)
                  _ju.addWithFunction(anchorsToUpdate, sourceId, function(a) {
                    return a === sourceId;
                  });
                if (targetContinuous)
                  _ju.addWithFunction(anchorsToUpdate, targetId, function(a) {
                    return a === targetId;
                  });
                _ju.addWithFunction(connectionsToPaint, conn, function(c) {
                  return c.id == conn.id;
                });
                if ((sourceContinuous && oIdx === 0) || (targetContinuous && oIdx === 1))
                  _ju.addWithFunction(endpointsToPaint, conn.endpoints[oIdx], function(e) {
                    return e.id == conn.endpoints[oIdx].id;
                  });
              }
            }
            for (i = 0; i < ep.length; i++) {
              if (ep[i].connections.length === 0 && ep[i].anchor.isContinuous) {
                if (!anchorLists[elementId])
                  anchorLists[elementId] = {
                    top: [],
                    right: [],
                    bottom: [],
                    left: []
                  };
                _updateAnchorList(anchorLists[elementId], -Math.PI / 2, 0, {
                  endpoints: [ep[i], ep[i]],
                  paint: function() {}
                }, false, elementId, 0, false, ep[i].anchor.getDefaultFace(), elementId, connectionsToPaint, endpointsToPaint);
                _ju.addWithFunction(anchorsToUpdate, elementId, function(a) {
                  return a === elementId;
                });
              }
            }
            for (i = 0; i < anchorsToUpdate.length; i++) {
              placeAnchors(anchorsToUpdate[i], anchorLists[anchorsToUpdate[i]]);
            }
            for (i = 0; i < ep.length; i++) {
              ep[i].paint({
                timestamp: timestamp,
                offset: myOffset,
                dimensions: myOffset.s,
                recalc: doNotRecalcEndpoint !== true
              });
            }
            for (i = 0; i < endpointsToPaint.length; i++) {
              var cd = jsPlumbInstance.getCachedData(endpointsToPaint[i].elementId);
              endpointsToPaint[i].paint({
                timestamp: timestamp,
                offset: cd,
                dimensions: cd.s
              });
            }
            for (i = 0; i < endpointConnections.length; i++) {
              var otherEndpoint = endpointConnections[i][1];
              if (otherEndpoint.anchor.constructor == _jp.DynamicAnchor) {
                otherEndpoint.paint({
                  elementWithPrecedence: elementId,
                  timestamp: timestamp
                });
                _ju.addWithFunction(connectionsToPaint, endpointConnections[i][0], function(c) {
                  return c.id == endpointConnections[i][0].id;
                });
                for (var k = 0; k < otherEndpoint.connections.length; k++) {
                  if (otherEndpoint.connections[k] !== endpointConnections[i][0])
                    _ju.addWithFunction(connectionsToPaint, otherEndpoint.connections[k], function(c) {
                      return c.id == otherEndpoint.connections[k].id;
                    });
                }
              } else if (otherEndpoint.anchor.constructor == _jp.Anchor) {
                _ju.addWithFunction(connectionsToPaint, endpointConnections[i][0], function(c) {
                  return c.id == endpointConnections[i][0].id;
                });
              }
            }
            var fc = floatingConnections[elementId];
            if (fc)
              fc.paint({
                timestamp: timestamp,
                recalc: false,
                elId: elementId
              });
            for (i = 0; i < connectionsToPaint.length; i++) {
              connectionsToPaint[i].paint({
                elId: elementId,
                timestamp: timestamp,
                recalc: false,
                clearEdits: clearEdits
              });
            }
          }
        };
        var ContinuousAnchor = function(anchorParams) {
          _ju.EventGenerator.apply(this);
          this.type = "Continuous";
          this.isDynamic = true;
          this.isContinuous = true;
          var faces = anchorParams.faces || ["top", "right", "bottom", "left"],
              clockwise = !(anchorParams.clockwise === false),
              availableFaces = {},
              opposites = {
                "top": "bottom",
                "right": "left",
                "left": "right",
                "bottom": "top"
              },
              clockwiseOptions = {
                "top": "right",
                "right": "bottom",
                "left": "top",
                "bottom": "left"
              },
              antiClockwiseOptions = {
                "top": "left",
                "right": "top",
                "left": "bottom",
                "bottom": "right"
              },
              secondBest = clockwise ? clockwiseOptions : antiClockwiseOptions,
              lastChoice = clockwise ? antiClockwiseOptions : clockwiseOptions,
              cssClass = anchorParams.cssClass || "";
          for (var i = 0; i < faces.length; i++) {
            availableFaces[faces[i]] = true;
          }
          this.getDefaultFace = function() {
            return faces.length === 0 ? "top" : faces[0];
          };
          this.verifyEdge = function(edge) {
            if (availableFaces[edge])
              return edge;
            else if (availableFaces[opposites[edge]])
              return opposites[edge];
            else if (availableFaces[secondBest[edge]])
              return secondBest[edge];
            else if (availableFaces[lastChoice[edge]])
              return lastChoice[edge];
            return edge;
          };
          this.isEdgeSupported = function(edge) {
            return availableFaces[edge] === true;
          };
          this.compute = function(params) {
            return userDefinedContinuousAnchorLocations[params.element.id] || continuousAnchorLocations[params.element.id] || [0, 0];
          };
          this.getCurrentLocation = function(params) {
            return userDefinedContinuousAnchorLocations[params.element.id] || continuousAnchorLocations[params.element.id] || [0, 0];
          };
          this.getOrientation = function(endpoint) {
            return continuousAnchorOrientations[endpoint.id] || [0, 0];
          };
          this.clearUserDefinedLocation = function() {
            delete userDefinedContinuousAnchorLocations[anchorParams.elementId];
          };
          this.setUserDefinedLocation = function(loc) {
            userDefinedContinuousAnchorLocations[anchorParams.elementId] = loc;
          };
          this.getCssClass = function() {
            return cssClass;
          };
        };
        jsPlumbInstance.continuousAnchorFactory = {
          get: function(params) {
            return new ContinuousAnchor(params);
          },
          clear: function(elementId) {
            delete userDefinedContinuousAnchorLocations[elementId];
            delete continuousAnchorLocations[elementId];
          }
        };
      };
      _jp.Anchor = function(params) {
        this.x = params.x || 0;
        this.y = params.y || 0;
        this.elementId = params.elementId;
        this.cssClass = params.cssClass || "";
        this.userDefinedLocation = null;
        this.orientation = params.orientation || [0, 0];
        this.lastReturnValue = null;
        this.offsets = params.offsets || [0, 0];
        this.timestamp = null;
        _ju.EventGenerator.apply(this);
        this.compute = function(params) {
          var xy = params.xy,
              wh = params.wh,
              timestamp = params.timestamp;
          if (params.clearUserDefinedLocation)
            this.userDefinedLocation = null;
          if (timestamp && timestamp === self.timestamp)
            return this.lastReturnValue;
          if (this.userDefinedLocation != null) {
            this.lastReturnValue = this.userDefinedLocation;
          } else {
            this.lastReturnValue = [xy[0] + (this.x * wh[0]) + this.offsets[0], xy[1] + (this.y * wh[1]) + this.offsets[1]];
          }
          this.timestamp = timestamp;
          return this.lastReturnValue;
        };
        this.getCurrentLocation = function(params) {
          params = params || {};
          return (this.lastReturnValue == null || (params.timestamp != null && this.timestamp != params.timestamp)) ? this.compute(params) : this.lastReturnValue;
        };
      };
      _ju.extend(_jp.Anchor, _ju.EventGenerator, {
        equals: function(anchor) {
          if (!anchor)
            return false;
          var ao = anchor.getOrientation(),
              o = this.getOrientation();
          return this.x == anchor.x && this.y == anchor.y && this.offsets[0] == anchor.offsets[0] && this.offsets[1] == anchor.offsets[1] && o[0] == ao[0] && o[1] == ao[1];
        },
        getUserDefinedLocation: function() {
          return this.userDefinedLocation;
        },
        setUserDefinedLocation: function(l) {
          this.userDefinedLocation = l;
        },
        clearUserDefinedLocation: function() {
          this.userDefinedLocation = null;
        },
        getOrientation: function() {
          return this.orientation;
        },
        getCssClass: function() {
          return this.cssClass;
        }
      });
      _jp.FloatingAnchor = function(params) {
        _jp.Anchor.apply(this, arguments);
        var ref = params.reference,
            refCanvas = params.referenceCanvas,
            size = _jp.getSize(refCanvas),
            xDir = 0,
            yDir = 0,
            orientation = null,
            _lastResult = null;
        this.orientation = null;
        this.x = 0;
        this.y = 0;
        this.isFloating = true;
        this.compute = function(params) {
          var xy = params.xy,
              result = [xy[0] + (size[0] / 2), xy[1] + (size[1] / 2)];
          _lastResult = result;
          return result;
        };
        this.getOrientation = function(_endpoint) {
          if (orientation)
            return orientation;
          else {
            var o = ref.getOrientation(_endpoint);
            return [Math.abs(o[0]) * xDir * -1, Math.abs(o[1]) * yDir * -1];
          }
        };
        this.over = function(anchor, endpoint) {
          orientation = anchor.getOrientation(endpoint);
        };
        this.out = function() {
          orientation = null;
        };
        this.getCurrentLocation = function(params) {
          return _lastResult == null ? this.compute(params) : _lastResult;
        };
      };
      _ju.extend(_jp.FloatingAnchor, _jp.Anchor);
      var _convertAnchor = function(anchor, jsPlumbInstance, elementId) {
        return anchor.constructor == _jp.Anchor ? anchor : jsPlumbInstance.makeAnchor(anchor, elementId, jsPlumbInstance);
      };
      _jp.DynamicAnchor = function(params) {
        _jp.Anchor.apply(this, arguments);
        this.isDynamic = true;
        this.anchors = [];
        this.elementId = params.elementId;
        this.jsPlumbInstance = params.jsPlumbInstance;
        for (var i = 0; i < params.anchors.length; i++)
          this.anchors[i] = _convertAnchor(params.anchors[i], this.jsPlumbInstance, this.elementId);
        this.getAnchors = function() {
          return this.anchors;
        };
        this.locked = false;
        var _curAnchor = this.anchors.length > 0 ? this.anchors[0] : null,
            _lastAnchor = _curAnchor,
            self = this,
            _distance = function(anchor, cx, cy, xy, wh) {
              var ax = xy[0] + (anchor.x * wh[0]),
                  ay = xy[1] + (anchor.y * wh[1]),
                  acx = xy[0] + (wh[0] / 2),
                  acy = xy[1] + (wh[1] / 2);
              return (Math.sqrt(Math.pow(cx - ax, 2) + Math.pow(cy - ay, 2)) + Math.sqrt(Math.pow(acx - ax, 2) + Math.pow(acy - ay, 2)));
            },
            _anchorSelector = params.selector || function(xy, wh, txy, twh, anchors) {
              var cx = txy[0] + (twh[0] / 2),
                  cy = txy[1] + (twh[1] / 2);
              var minIdx = -1,
                  minDist = Infinity;
              for (var i = 0; i < anchors.length; i++) {
                var d = _distance(anchors[i], cx, cy, xy, wh);
                if (d < minDist) {
                  minIdx = i + 0;
                  minDist = d;
                }
              }
              return anchors[minIdx];
            };
        this.compute = function(params) {
          var xy = params.xy,
              wh = params.wh,
              txy = params.txy,
              twh = params.twh;
          this.timestamp = params.timestamp;
          var udl = self.getUserDefinedLocation();
          if (udl != null) {
            return udl;
          }
          if (this.locked || txy == null || twh == null)
            return _curAnchor.compute(params);
          else
            params.timestamp = null;
          _curAnchor = _anchorSelector(xy, wh, txy, twh, this.anchors);
          this.x = _curAnchor.x;
          this.y = _curAnchor.y;
          if (_curAnchor != _lastAnchor)
            this.fire("anchorChanged", _curAnchor);
          _lastAnchor = _curAnchor;
          return _curAnchor.compute(params);
        };
        this.getCurrentLocation = function(params) {
          return this.getUserDefinedLocation() || (_curAnchor != null ? _curAnchor.getCurrentLocation(params) : null);
        };
        this.getOrientation = function(_endpoint) {
          return _curAnchor != null ? _curAnchor.getOrientation(_endpoint) : [0, 0];
        };
        this.over = function(anchor, endpoint) {
          if (_curAnchor != null)
            _curAnchor.over(anchor, endpoint);
        };
        this.out = function() {
          if (_curAnchor != null)
            _curAnchor.out();
        };
        this.getCssClass = function() {
          return (_curAnchor && _curAnchor.getCssClass()) || "";
        };
      };
      _ju.extend(_jp.DynamicAnchor, _jp.Anchor);
      var _curryAnchor = function(x, y, ox, oy, type, fnInit) {
        _jp.Anchors[type] = function(params) {
          var a = params.jsPlumbInstance.makeAnchor([x, y, ox, oy, 0, 0], params.elementId, params.jsPlumbInstance);
          a.type = type;
          if (fnInit)
            fnInit(a, params);
          return a;
        };
      };
      _curryAnchor(0.5, 0, 0, -1, "TopCenter");
      _curryAnchor(0.5, 1, 0, 1, "BottomCenter");
      _curryAnchor(0, 0.5, -1, 0, "LeftMiddle");
      _curryAnchor(1, 0.5, 1, 0, "RightMiddle");
      _curryAnchor(0.5, 0, 0, -1, "Top");
      _curryAnchor(0.5, 1, 0, 1, "Bottom");
      _curryAnchor(0, 0.5, -1, 0, "Left");
      _curryAnchor(1, 0.5, 1, 0, "Right");
      _curryAnchor(0.5, 0.5, 0, 0, "Center");
      _curryAnchor(1, 0, 0, -1, "TopRight");
      _curryAnchor(1, 1, 0, 1, "BottomRight");
      _curryAnchor(0, 0, 0, -1, "TopLeft");
      _curryAnchor(0, 1, 0, 1, "BottomLeft");
      _jp.Defaults.DynamicAnchors = function(params) {
        return params.jsPlumbInstance.makeAnchors(["TopCenter", "RightMiddle", "BottomCenter", "LeftMiddle"], params.elementId, params.jsPlumbInstance);
      };
      _jp.Anchors.AutoDefault = function(params) {
        var a = params.jsPlumbInstance.makeDynamicAnchor(_jp.Defaults.DynamicAnchors(params));
        a.type = "AutoDefault";
        return a;
      };
      var _curryContinuousAnchor = function(type, faces) {
        _jp.Anchors[type] = function(params) {
          var a = params.jsPlumbInstance.makeAnchor(["Continuous", {faces: faces}], params.elementId, params.jsPlumbInstance);
          a.type = type;
          return a;
        };
      };
      _jp.Anchors.Continuous = function(params) {
        return params.jsPlumbInstance.continuousAnchorFactory.get(params);
      };
      _curryContinuousAnchor("ContinuousLeft", ["left"]);
      _curryContinuousAnchor("ContinuousTop", ["top"]);
      _curryContinuousAnchor("ContinuousBottom", ["bottom"]);
      _curryContinuousAnchor("ContinuousRight", ["right"]);
      _curryAnchor(0, 0, 0, 0, "Assign", function(anchor, params) {
        var pf = params.position || "Fixed";
        anchor.positionFinder = pf.constructor == String ? params.jsPlumbInstance.AnchorPositionFinders[pf] : pf;
        anchor.constructorParams = params;
      });
      jsPlumbInstance.prototype.AnchorPositionFinders = {
        "Fixed": function(dp, ep, es) {
          return [(dp.left - ep.left) / es[0], (dp.top - ep.top) / es[1]];
        },
        "Grid": function(dp, ep, es, params) {
          var dx = dp.left - ep.left,
              dy = dp.top - ep.top,
              gx = es[0] / (params.grid[0]),
              gy = es[1] / (params.grid[1]),
              mx = Math.floor(dx / gx),
              my = Math.floor(dy / gy);
          return [((mx * gx) + (gx / 2)) / es[0], ((my * gy) + (gy / 2)) / es[1]];
        }
      };
      _jp.Anchors.Perimeter = function(params) {
        params = params || {};
        var anchorCount = params.anchorCount || 60,
            shape = params.shape;
        if (!shape)
          throw new Error("no shape supplied to Perimeter Anchor type");
        var _circle = function() {
          var r = 0.5,
              step = Math.PI * 2 / anchorCount,
              current = 0,
              a = [];
          for (var i = 0; i < anchorCount; i++) {
            var x = r + (r * Math.sin(current)),
                y = r + (r * Math.cos(current));
            a.push([x, y, 0, 0]);
            current += step;
          }
          return a;
        },
            _path = function(segments) {
              var anchorsPerFace = anchorCount / segments.length,
                  a = [],
                  _computeFace = function(x1, y1, x2, y2, fractionalLength) {
                    anchorsPerFace = anchorCount * fractionalLength;
                    var dx = (x2 - x1) / anchorsPerFace,
                        dy = (y2 - y1) / anchorsPerFace;
                    for (var i = 0; i < anchorsPerFace; i++) {
                      a.push([x1 + (dx * i), y1 + (dy * i), 0, 0]);
                    }
                  };
              for (var i = 0; i < segments.length; i++)
                _computeFace.apply(null, segments[i]);
              return a;
            },
            _shape = function(faces) {
              var s = [];
              for (var i = 0; i < faces.length; i++) {
                s.push([faces[i][0], faces[i][1], faces[i][2], faces[i][3], 1 / faces.length]);
              }
              return _path(s);
            },
            _rectangle = function() {
              return _shape([[0, 0, 1, 0], [1, 0, 1, 1], [1, 1, 0, 1], [0, 1, 0, 0]]);
            };
        var _shapes = {
          "Circle": _circle,
          "Ellipse": _circle,
          "Diamond": function() {
            return _shape([[0.5, 0, 1, 0.5], [1, 0.5, 0.5, 1], [0.5, 1, 0, 0.5], [0, 0.5, 0.5, 0]]);
          },
          "Rectangle": _rectangle,
          "Square": _rectangle,
          "Triangle": function() {
            return _shape([[0.5, 0, 1, 1], [1, 1, 0, 1], [0, 1, 0.5, 0]]);
          },
          "Path": function(params) {
            var points = params.points,
                p = [],
                tl = 0;
            for (var i = 0; i < points.length - 1; i++) {
              var l = Math.sqrt(Math.pow(points[i][2] - points[i][0]) + Math.pow(points[i][3] - points[i][1]));
              tl += l;
              p.push([points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], l]);
            }
            for (var j = 0; j < p.length; j++) {
              p[j][4] = p[j][4] / tl;
            }
            return _path(p);
          }
        },
            _rotate = function(points, amountInDegrees) {
              var o = [],
                  theta = amountInDegrees / 180 * Math.PI;
              for (var i = 0; i < points.length; i++) {
                var _x = points[i][0] - 0.5,
                    _y = points[i][1] - 0.5;
                o.push([0.5 + ((_x * Math.cos(theta)) - (_y * Math.sin(theta))), 0.5 + ((_x * Math.sin(theta)) + (_y * Math.cos(theta))), points[i][2], points[i][3]]);
              }
              return o;
            };
        if (!_shapes[shape])
          throw new Error("Shape [" + shape + "] is unknown by Perimeter Anchor type");
        var da = _shapes[shape](params);
        if (params.rotation)
          da = _rotate(da, params.rotation);
        var a = params.jsPlumbInstance.makeDynamicAnchor(da);
        a.type = "Perimeter";
        return a;
      };
    }).call(this);
    ;
    (function() {
      "use strict";
      var root = this,
          _jp = root.jsPlumb,
          _ju = root.jsPlumbUtil,
          _jg = root.Biltong;
      _jp.Segments = {
        AbstractSegment: function(params) {
          this.params = params;
          this.findClosestPointOnPath = function(x, y) {
            return {
              d: Infinity,
              x: null,
              y: null,
              l: null
            };
          };
          this.getBounds = function() {
            return {
              minX: Math.min(params.x1, params.x2),
              minY: Math.min(params.y1, params.y2),
              maxX: Math.max(params.x1, params.x2),
              maxY: Math.max(params.y1, params.y2)
            };
          };
        },
        Straight: function(params) {
          var _super = _jp.Segments.AbstractSegment.apply(this, arguments),
              length,
              m,
              m2,
              x1,
              x2,
              y1,
              y2,
              _recalc = function() {
                length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                m = _jg.gradient({
                  x: x1,
                  y: y1
                }, {
                  x: x2,
                  y: y2
                });
                m2 = -1 / m;
              };
          this.type = "Straight";
          this.getLength = function() {
            return length;
          };
          this.getGradient = function() {
            return m;
          };
          this.getCoordinates = function() {
            return {
              x1: x1,
              y1: y1,
              x2: x2,
              y2: y2
            };
          };
          this.setCoordinates = function(coords) {
            x1 = coords.x1;
            y1 = coords.y1;
            x2 = coords.x2;
            y2 = coords.y2;
            _recalc();
          };
          this.setCoordinates({
            x1: params.x1,
            y1: params.y1,
            x2: params.x2,
            y2: params.y2
          });
          this.getBounds = function() {
            return {
              minX: Math.min(x1, x2),
              minY: Math.min(y1, y2),
              maxX: Math.max(x1, x2),
              maxY: Math.max(y1, y2)
            };
          };
          this.pointOnPath = function(location, absolute) {
            if (location === 0 && !absolute)
              return {
                x: x1,
                y: y1
              };
            else if (location == 1 && !absolute)
              return {
                x: x2,
                y: y2
              };
            else {
              var l = absolute ? location > 0 ? location : length + location : location * length;
              return _jg.pointOnLine({
                x: x1,
                y: y1
              }, {
                x: x2,
                y: y2
              }, l);
            }
          };
          this.gradientAtPoint = function(_) {
            return m;
          };
          this.pointAlongPathFrom = function(location, distance, absolute) {
            var p = this.pointOnPath(location, absolute),
                farAwayPoint = distance <= 0 ? {
                  x: x1,
                  y: y1
                } : {
                  x: x2,
                  y: y2
                };
            if (distance <= 0 && Math.abs(distance) > 1)
              distance *= -1;
            return _jg.pointOnLine(p, farAwayPoint, distance);
          };
          var within = function(a, b, c) {
            return c >= Math.min(a, b) && c <= Math.max(a, b);
          };
          var closest = function(a, b, c) {
            return Math.abs(c - a) < Math.abs(c - b) ? a : b;
          };
          this.findClosestPointOnPath = function(x, y) {
            var out = {
              d: Infinity,
              x: null,
              y: null,
              l: null,
              x1: x1,
              x2: x2,
              y1: y1,
              y2: y2
            };
            if (m === 0) {
              out.y = y1;
              out.x = within(x1, x2, x) ? x : closest(x1, x2, x);
            } else if (m == Infinity || m == -Infinity) {
              out.x = x1;
              out.y = within(y1, y2, y) ? y : closest(y1, y2, y);
            } else {
              var b = y1 - (m * x1),
                  b2 = y - (m2 * x),
                  _x1 = (b2 - b) / (m - m2),
                  _y1 = (m * _x1) + b;
              out.x = within(x1, x2, _x1) ? _x1 : closest(x1, x2, _x1);
              out.y = within(y1, y2, _y1) ? _y1 : closest(y1, y2, _y1);
            }
            var fractionInSegment = _jg.lineLength([out.x, out.y], [x1, y1]);
            out.d = _jg.lineLength([x, y], [out.x, out.y]);
            out.l = fractionInSegment / length;
            return out;
          };
        },
        Arc: function(params) {
          var _super = _jp.Segments.AbstractSegment.apply(this, arguments),
              _calcAngle = function(_x, _y) {
                return _jg.theta([params.cx, params.cy], [_x, _y]);
              },
              _calcAngleForLocation = function(segment, location) {
                if (segment.anticlockwise) {
                  var sa = segment.startAngle < segment.endAngle ? segment.startAngle + TWO_PI : segment.startAngle,
                      s = Math.abs(sa - segment.endAngle);
                  return sa - (s * location);
                } else {
                  var ea = segment.endAngle < segment.startAngle ? segment.endAngle + TWO_PI : segment.endAngle,
                      ss = Math.abs(ea - segment.startAngle);
                  return segment.startAngle + (ss * location);
                }
              },
              TWO_PI = 2 * Math.PI;
          this.radius = params.r;
          this.anticlockwise = params.ac;
          this.type = "Arc";
          if (params.startAngle && params.endAngle) {
            this.startAngle = params.startAngle;
            this.endAngle = params.endAngle;
            this.x1 = params.cx + (this.radius * Math.cos(params.startAngle));
            this.y1 = params.cy + (this.radius * Math.sin(params.startAngle));
            this.x2 = params.cx + (this.radius * Math.cos(params.endAngle));
            this.y2 = params.cy + (this.radius * Math.sin(params.endAngle));
          } else {
            this.startAngle = _calcAngle(params.x1, params.y1);
            this.endAngle = _calcAngle(params.x2, params.y2);
            this.x1 = params.x1;
            this.y1 = params.y1;
            this.x2 = params.x2;
            this.y2 = params.y2;
          }
          if (this.endAngle < 0)
            this.endAngle += TWO_PI;
          if (this.startAngle < 0)
            this.startAngle += TWO_PI;
          var ea = this.endAngle < this.startAngle ? this.endAngle + TWO_PI : this.endAngle;
          this.sweep = Math.abs(ea - this.startAngle);
          if (this.anticlockwise)
            this.sweep = TWO_PI - this.sweep;
          var circumference = 2 * Math.PI * this.radius,
              frac = this.sweep / TWO_PI,
              length = circumference * frac;
          this.getLength = function() {
            return length;
          };
          this.getBounds = function() {
            return {
              minX: params.cx - params.r,
              maxX: params.cx + params.r,
              minY: params.cy - params.r,
              maxY: params.cy + params.r
            };
          };
          var VERY_SMALL_VALUE = 0.0000000001,
              gentleRound = function(n) {
                var f = Math.floor(n),
                    r = Math.ceil(n);
                if (n - f < VERY_SMALL_VALUE)
                  return f;
                else if (r - n < VERY_SMALL_VALUE)
                  return r;
                return n;
              };
          this.pointOnPath = function(location, absolute) {
            if (location === 0) {
              return {
                x: this.x1,
                y: this.y1,
                theta: this.startAngle
              };
            } else if (location == 1) {
              return {
                x: this.x2,
                y: this.y2,
                theta: this.endAngle
              };
            }
            if (absolute) {
              location = location / length;
            }
            var angle = _calcAngleForLocation(this, location),
                _x = params.cx + (params.r * Math.cos(angle)),
                _y = params.cy + (params.r * Math.sin(angle));
            return {
              x: gentleRound(_x),
              y: gentleRound(_y),
              theta: angle
            };
          };
          this.gradientAtPoint = function(location, absolute) {
            var p = this.pointOnPath(location, absolute);
            var m = _jg.normal([params.cx, params.cy], [p.x, p.y]);
            if (!this.anticlockwise && (m == Infinity || m == -Infinity))
              m *= -1;
            return m;
          };
          this.pointAlongPathFrom = function(location, distance, absolute) {
            var p = this.pointOnPath(location, absolute),
                arcSpan = distance / circumference * 2 * Math.PI,
                dir = this.anticlockwise ? -1 : 1,
                startAngle = p.theta + (dir * arcSpan),
                startX = params.cx + (this.radius * Math.cos(startAngle)),
                startY = params.cy + (this.radius * Math.sin(startAngle));
            return {
              x: startX,
              y: startY
            };
          };
        },
        Bezier: function(params) {
          this.curve = [{
            x: params.x1,
            y: params.y1
          }, {
            x: params.cp1x,
            y: params.cp1y
          }, {
            x: params.cp2x,
            y: params.cp2y
          }, {
            x: params.x2,
            y: params.y2
          }];
          var _super = _jp.Segments.AbstractSegment.apply(this, arguments);
          this.bounds = {
            minX: Math.min(params.x1, params.x2, params.cp1x, params.cp2x),
            minY: Math.min(params.y1, params.y2, params.cp1y, params.cp2y),
            maxX: Math.max(params.x1, params.x2, params.cp1x, params.cp2x),
            maxY: Math.max(params.y1, params.y2, params.cp1y, params.cp2y)
          };
          this.type = "Bezier";
          var _translateLocation = function(_curve, location, absolute) {
            if (absolute)
              location = root.jsBezier.locationAlongCurveFrom(_curve, location > 0 ? 0 : 1, location);
            return location;
          };
          this.pointOnPath = function(location, absolute) {
            location = _translateLocation(this.curve, location, absolute);
            return root.jsBezier.pointOnCurve(this.curve, location);
          };
          this.gradientAtPoint = function(location, absolute) {
            location = _translateLocation(this.curve, location, absolute);
            return root.jsBezier.gradientAtPoint(this.curve, location);
          };
          this.pointAlongPathFrom = function(location, distance, absolute) {
            location = _translateLocation(this.curve, location, absolute);
            return root.jsBezier.pointAlongCurveFrom(this.curve, location, distance);
          };
          this.getLength = function() {
            return root.jsBezier.getLength(this.curve);
          };
          this.getBounds = function() {
            return this.bounds;
          };
        }
      };
      var AbstractComponent = function() {
        this.resetBounds = function() {
          this.bounds = {
            minX: Infinity,
            minY: Infinity,
            maxX: -Infinity,
            maxY: -Infinity
          };
        };
        this.resetBounds();
      };
      _jp.Connectors.AbstractConnector = function(params) {
        AbstractComponent.apply(this, arguments);
        var segments = [],
            totalLength = 0,
            segmentProportions = [],
            segmentProportionalLengths = [],
            stub = params.stub || 0,
            sourceStub = _ju.isArray(stub) ? stub[0] : stub,
            targetStub = _ju.isArray(stub) ? stub[1] : stub,
            gap = params.gap || 0,
            sourceGap = _ju.isArray(gap) ? gap[0] : gap,
            targetGap = _ju.isArray(gap) ? gap[1] : gap,
            userProvidedSegments = null,
            edited = false,
            paintInfo = null,
            geometry = null,
            editable = params.editable !== false && jsPlumb.ConnectorEditors != null && jsPlumb.ConnectorEditors[this.type] != null;
        var _setGeometry = this.setGeometry = function(g, internallyComputed) {
          edited = (!internallyComputed);
          geometry = g;
        };
        var _getGeometry = this.getGeometry = function() {
          return geometry;
        };
        this.hasBeenEdited = function() {
          return edited;
        };
        this.isEditing = function() {
          return this.editor != null && this.editor.isActive();
        };
        this.setEditable = function(e) {
          if (e && jsPlumb.ConnectorEditors != null && jsPlumb.ConnectorEditors[this.type] != null && (this.overrideSetEditable == null || this.overrideSetEditable())) {
            editable = e;
          } else {
            editable = false;
          }
          return editable;
        };
        this.isEditable = function() {
          return editable;
        };
        this.findSegmentForPoint = function(x, y) {
          var out = {
            d: Infinity,
            s: null,
            x: null,
            y: null,
            l: null
          };
          for (var i = 0; i < segments.length; i++) {
            var _s = segments[i].findClosestPointOnPath(x, y);
            if (_s.d < out.d) {
              out.d = _s.d;
              out.l = _s.l;
              out.x = _s.x;
              out.y = _s.y;
              out.s = segments[i];
              out.x1 = _s.x1;
              out.x2 = _s.x2;
              out.y1 = _s.y1;
              out.y2 = _s.y2;
              out.index = i;
            }
          }
          return out;
        };
        var _updateSegmentProportions = function() {
          var curLoc = 0;
          for (var i = 0; i < segments.length; i++) {
            var sl = segments[i].getLength();
            segmentProportionalLengths[i] = sl / totalLength;
            segmentProportions[i] = [curLoc, (curLoc += (sl / totalLength))];
          }
        },
            _findSegmentForLocation = function(location, absolute) {
              if (absolute) {
                location = location > 0 ? location / totalLength : (totalLength + location) / totalLength;
              }
              var idx = segmentProportions.length - 1,
                  inSegmentProportion = 1;
              for (var i = 0; i < segmentProportions.length; i++) {
                if (segmentProportions[i][1] >= location) {
                  idx = i;
                  inSegmentProportion = location == 1 ? 1 : location === 0 ? 0 : (location - segmentProportions[i][0]) / segmentProportionalLengths[i];
                  break;
                }
              }
              return {
                segment: segments[idx],
                proportion: inSegmentProportion,
                index: idx
              };
            },
            _addSegment = function(conn, type, params) {
              if (params.x1 == params.x2 && params.y1 == params.y2)
                return;
              var s = new _jp.Segments[type](params);
              segments.push(s);
              totalLength += s.getLength();
              conn.updateBounds(s);
            },
            _clearSegments = function() {
              totalLength = segments.length = segmentProportions.length = segmentProportionalLengths.length = 0;
            };
        this.setSegments = function(_segs) {
          userProvidedSegments = [];
          totalLength = 0;
          for (var i = 0; i < _segs.length; i++) {
            userProvidedSegments.push(_segs[i]);
            totalLength += _segs[i].getLength();
          }
        };
        this.getLength = function() {
          return totalLength;
        };
        var _prepareCompute = function(params) {
          this.lineWidth = params.lineWidth;
          var segment = _jg.quadrant(params.sourcePos, params.targetPos),
              swapX = params.targetPos[0] < params.sourcePos[0],
              swapY = params.targetPos[1] < params.sourcePos[1],
              lw = params.lineWidth || 1,
              so = params.sourceEndpoint.anchor.getOrientation(params.sourceEndpoint),
              to = params.targetEndpoint.anchor.getOrientation(params.targetEndpoint),
              x = swapX ? params.targetPos[0] : params.sourcePos[0],
              y = swapY ? params.targetPos[1] : params.sourcePos[1],
              w = Math.abs(params.targetPos[0] - params.sourcePos[0]),
              h = Math.abs(params.targetPos[1] - params.sourcePos[1]);
          if (so[0] === 0 && so[1] === 0 || to[0] === 0 && to[1] === 0) {
            var index = w > h ? 0 : 1,
                oIndex = [1, 0][index];
            so = [];
            to = [];
            so[index] = params.sourcePos[index] > params.targetPos[index] ? -1 : 1;
            to[index] = params.sourcePos[index] > params.targetPos[index] ? 1 : -1;
            so[oIndex] = 0;
            to[oIndex] = 0;
          }
          var sx = swapX ? w + (sourceGap * so[0]) : sourceGap * so[0],
              sy = swapY ? h + (sourceGap * so[1]) : sourceGap * so[1],
              tx = swapX ? targetGap * to[0] : w + (targetGap * to[0]),
              ty = swapY ? targetGap * to[1] : h + (targetGap * to[1]),
              oProduct = ((so[0] * to[0]) + (so[1] * to[1]));
          var result = {
            sx: sx,
            sy: sy,
            tx: tx,
            ty: ty,
            lw: lw,
            xSpan: Math.abs(tx - sx),
            ySpan: Math.abs(ty - sy),
            mx: (sx + tx) / 2,
            my: (sy + ty) / 2,
            so: so,
            to: to,
            x: x,
            y: y,
            w: w,
            h: h,
            segment: segment,
            startStubX: sx + (so[0] * sourceStub),
            startStubY: sy + (so[1] * sourceStub),
            endStubX: tx + (to[0] * targetStub),
            endStubY: ty + (to[1] * targetStub),
            isXGreaterThanStubTimes2: Math.abs(sx - tx) > (sourceStub + targetStub),
            isYGreaterThanStubTimes2: Math.abs(sy - ty) > (sourceStub + targetStub),
            opposite: oProduct == -1,
            perpendicular: oProduct === 0,
            orthogonal: oProduct == 1,
            sourceAxis: so[0] === 0 ? "y" : "x",
            points: [x, y, w, h, sx, sy, tx, ty]
          };
          result.anchorOrientation = result.opposite ? "opposite" : result.orthogonal ? "orthogonal" : "perpendicular";
          return result;
        };
        this.getSegments = function() {
          return segments;
        };
        this.updateBounds = function(segment) {
          var segBounds = segment.getBounds();
          this.bounds.minX = Math.min(this.bounds.minX, segBounds.minX);
          this.bounds.maxX = Math.max(this.bounds.maxX, segBounds.maxX);
          this.bounds.minY = Math.min(this.bounds.minY, segBounds.minY);
          this.bounds.maxY = Math.max(this.bounds.maxY, segBounds.maxY);
        };
        var dumpSegmentsToConsole = function() {
          console.log("SEGMENTS:");
          for (var i = 0; i < segments.length; i++) {
            console.log(segments[i].type, segments[i].getLength(), segmentProportions[i]);
          }
        };
        this.pointOnPath = function(location, absolute) {
          var seg = _findSegmentForLocation(location, absolute);
          return seg.segment && seg.segment.pointOnPath(seg.proportion, false) || [0, 0];
        };
        this.gradientAtPoint = function(location, absolute) {
          var seg = _findSegmentForLocation(location, absolute);
          return seg.segment && seg.segment.gradientAtPoint(seg.proportion, false) || 0;
        };
        this.pointAlongPathFrom = function(location, distance, absolute) {
          var seg = _findSegmentForLocation(location, absolute);
          return seg.segment && seg.segment.pointAlongPathFrom(seg.proportion, distance, false) || [0, 0];
        };
        this.compute = function(params) {
          paintInfo = _prepareCompute.call(this, params);
          _clearSegments();
          this._compute(paintInfo, params);
          this.x = paintInfo.points[0];
          this.y = paintInfo.points[1];
          this.w = paintInfo.points[2];
          this.h = paintInfo.points[3];
          this.segment = paintInfo.segment;
          _updateSegmentProportions();
        };
        return {
          addSegment: _addSegment,
          prepareCompute: _prepareCompute,
          sourceStub: sourceStub,
          targetStub: targetStub,
          maxStub: Math.max(sourceStub, targetStub),
          sourceGap: sourceGap,
          targetGap: targetGap,
          maxGap: Math.max(sourceGap, targetGap),
          setGeometry: _setGeometry,
          getGeometry: _getGeometry
        };
      };
      _ju.extend(_jp.Connectors.AbstractConnector, AbstractComponent);
      var Straight = _jp.Connectors.Straight = function() {
        this.type = "Straight";
        var _super = _jp.Connectors.AbstractConnector.apply(this, arguments);
        this._compute = function(paintInfo, _) {
          _super.addSegment(this, "Straight", {
            x1: paintInfo.sx,
            y1: paintInfo.sy,
            x2: paintInfo.startStubX,
            y2: paintInfo.startStubY
          });
          _super.addSegment(this, "Straight", {
            x1: paintInfo.startStubX,
            y1: paintInfo.startStubY,
            x2: paintInfo.endStubX,
            y2: paintInfo.endStubY
          });
          _super.addSegment(this, "Straight", {
            x1: paintInfo.endStubX,
            y1: paintInfo.endStubY,
            x2: paintInfo.tx,
            y2: paintInfo.ty
          });
        };
      };
      _ju.extend(_jp.Connectors.Straight, _jp.Connectors.AbstractConnector);
      _jp.registerConnectorType(Straight, "Straight");
      _jp.Endpoints.AbstractEndpoint = function(params) {
        AbstractComponent.apply(this, arguments);
        var compute = this.compute = function(anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
          var out = this._compute.apply(this, arguments);
          this.x = out[0];
          this.y = out[1];
          this.w = out[2];
          this.h = out[3];
          this.bounds.minX = this.x;
          this.bounds.minY = this.y;
          this.bounds.maxX = this.x + this.w;
          this.bounds.maxY = this.y + this.h;
          return out;
        };
        return {
          compute: compute,
          cssClass: params.cssClass
        };
      };
      _ju.extend(_jp.Endpoints.AbstractEndpoint, AbstractComponent);
      _jp.Endpoints.Dot = function(params) {
        this.type = "Dot";
        var _super = _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        params = params || {};
        this.radius = params.radius || 10;
        this.defaultOffset = 0.5 * this.radius;
        this.defaultInnerRadius = this.radius / 3;
        this._compute = function(anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
          this.radius = endpointStyle.radius || this.radius;
          var x = anchorPoint[0] - this.radius,
              y = anchorPoint[1] - this.radius,
              w = this.radius * 2,
              h = this.radius * 2;
          if (endpointStyle.strokeStyle) {
            var lw = endpointStyle.lineWidth || 1;
            x -= lw;
            y -= lw;
            w += (lw * 2);
            h += (lw * 2);
          }
          return [x, y, w, h, this.radius];
        };
      };
      _ju.extend(_jp.Endpoints.Dot, _jp.Endpoints.AbstractEndpoint);
      _jp.Endpoints.Rectangle = function(params) {
        this.type = "Rectangle";
        var _super = _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        params = params || {};
        this.width = params.width || 20;
        this.height = params.height || 20;
        this._compute = function(anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
          var width = endpointStyle.width || this.width,
              height = endpointStyle.height || this.height,
              x = anchorPoint[0] - (width / 2),
              y = anchorPoint[1] - (height / 2);
          return [x, y, width, height];
        };
      };
      _ju.extend(_jp.Endpoints.Rectangle, _jp.Endpoints.AbstractEndpoint);
      var DOMElementEndpoint = function(params) {
        _jp.jsPlumbUIComponent.apply(this, arguments);
        this._jsPlumb.displayElements = [];
      };
      _ju.extend(DOMElementEndpoint, _jp.jsPlumbUIComponent, {
        getDisplayElements: function() {
          return this._jsPlumb.displayElements;
        },
        appendDisplayElement: function(el) {
          this._jsPlumb.displayElements.push(el);
        }
      });
      _jp.Endpoints.Image = function(params) {
        this.type = "Image";
        DOMElementEndpoint.apply(this, arguments);
        _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        var _onload = params.onload,
            src = params.src || params.url,
            clazz = params.cssClass ? " " + params.cssClass : "";
        this._jsPlumb.img = new Image();
        this._jsPlumb.ready = false;
        this._jsPlumb.initialized = false;
        this._jsPlumb.deleted = false;
        this._jsPlumb.widthToUse = params.width;
        this._jsPlumb.heightToUse = params.height;
        this._jsPlumb.endpoint = params.endpoint;
        this._jsPlumb.img.onload = function() {
          if (this._jsPlumb != null) {
            this._jsPlumb.ready = true;
            this._jsPlumb.widthToUse = this._jsPlumb.widthToUse || this._jsPlumb.img.width;
            this._jsPlumb.heightToUse = this._jsPlumb.heightToUse || this._jsPlumb.img.height;
            if (_onload) {
              _onload(this);
            }
          }
        }.bind(this);
        this._jsPlumb.endpoint.setImage = function(_img, onload) {
          var s = _img.constructor == String ? _img : _img.src;
          _onload = onload;
          this._jsPlumb.img.src = s;
          if (this.canvas != null)
            this.canvas.setAttribute("src", this._jsPlumb.img.src);
        }.bind(this);
        this._jsPlumb.endpoint.setImage(src, _onload);
        this._compute = function(anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
          this.anchorPoint = anchorPoint;
          if (this._jsPlumb.ready)
            return [anchorPoint[0] - this._jsPlumb.widthToUse / 2, anchorPoint[1] - this._jsPlumb.heightToUse / 2, this._jsPlumb.widthToUse, this._jsPlumb.heightToUse];
          else
            return [0, 0, 0, 0];
        };
        this.canvas = jsPlumb.createElement("img", {
          position: "absolute",
          margin: 0,
          padding: 0,
          outline: 0
        }, this._jsPlumb.instance.endpointClass + clazz);
        if (this._jsPlumb.widthToUse)
          this.canvas.setAttribute("width", this._jsPlumb.widthToUse);
        if (this._jsPlumb.heightToUse)
          this.canvas.setAttribute("height", this._jsPlumb.heightToUse);
        this._jsPlumb.instance.appendElement(this.canvas);
        this.actuallyPaint = function(d, style, anchor) {
          if (!this._jsPlumb.deleted) {
            if (!this._jsPlumb.initialized) {
              this.canvas.setAttribute("src", this._jsPlumb.img.src);
              this.appendDisplayElement(this.canvas);
              this._jsPlumb.initialized = true;
            }
            var x = this.anchorPoint[0] - (this._jsPlumb.widthToUse / 2),
                y = this.anchorPoint[1] - (this._jsPlumb.heightToUse / 2);
            _ju.sizeElement(this.canvas, x, y, this._jsPlumb.widthToUse, this._jsPlumb.heightToUse);
          }
        };
        this.paint = function(style, anchor) {
          if (this._jsPlumb != null) {
            if (this._jsPlumb.ready) {
              this.actuallyPaint(style, anchor);
            } else {
              root.setTimeout(function() {
                this.paint(style, anchor);
              }.bind(this), 200);
            }
          }
        };
      };
      _ju.extend(_jp.Endpoints.Image, [DOMElementEndpoint, _jp.Endpoints.AbstractEndpoint], {cleanup: function(force) {
          if (force) {
            this._jsPlumb.deleted = true;
            if (this.canvas)
              this.canvas.parentNode.removeChild(this.canvas);
            this.canvas = null;
          }
        }});
      _jp.Endpoints.Blank = function(params) {
        var _super = _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        this.type = "Blank";
        DOMElementEndpoint.apply(this, arguments);
        this._compute = function(anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
          return [anchorPoint[0], anchorPoint[1], 10, 0];
        };
        var clazz = params.cssClass ? " " + params.cssClass : "";
        this.canvas = jsPlumb.createElement("div", {
          display: "block",
          width: "1px",
          height: "1px",
          background: "transparent",
          position: "absolute"
        }, this._jsPlumb.instance.endpointClass + clazz);
        this._jsPlumb.instance.appendElement(this.canvas);
        this.paint = function(style, anchor) {
          _ju.sizeElement(this.canvas, this.x, this.y, this.w, this.h);
        };
      };
      _ju.extend(_jp.Endpoints.Blank, [_jp.Endpoints.AbstractEndpoint, DOMElementEndpoint], {cleanup: function() {
          if (this.canvas && this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
          }
        }});
      _jp.Endpoints.Triangle = function(params) {
        this.type = "Triangle";
        _jp.Endpoints.AbstractEndpoint.apply(this, arguments);
        params = params || {};
        params.width = params.width || 55;
        params.height = params.height || 55;
        this.width = params.width;
        this.height = params.height;
        this._compute = function(anchorPoint, orientation, endpointStyle, connectorPaintStyle) {
          var width = endpointStyle.width || self.width,
              height = endpointStyle.height || self.height,
              x = anchorPoint[0] - (width / 2),
              y = anchorPoint[1] - (height / 2);
          return [x, y, width, height];
        };
      };
      var AbstractOverlay = _jp.Overlays.AbstractOverlay = function(params) {
        this.visible = true;
        this.isAppendedAtTopLevel = true;
        this.component = params.component;
        this.loc = params.location == null ? 0.5 : params.location;
        this.endpointLoc = params.endpointLocation == null ? [0.5, 0.5] : params.endpointLocation;
        this.visible = params.visible !== false;
      };
      AbstractOverlay.prototype = {
        cleanup: function(force) {
          if (force) {
            this.component = null;
            this.canvas = null;
            this.endpointLoc = null;
          }
        },
        reattach: function(instance) {},
        setVisible: function(val) {
          this.visible = val;
          this.component.repaint();
        },
        isVisible: function() {
          return this.visible;
        },
        hide: function() {
          this.setVisible(false);
        },
        show: function() {
          this.setVisible(true);
        },
        incrementLocation: function(amount) {
          this.loc += amount;
          this.component.repaint();
        },
        setLocation: function(l) {
          this.loc = l;
          this.component.repaint();
        },
        getLocation: function() {
          return this.loc;
        },
        updateFrom: function() {}
      };
      _jp.Overlays.Arrow = function(params) {
        this.type = "Arrow";
        AbstractOverlay.apply(this, arguments);
        this.isAppendedAtTopLevel = false;
        params = params || {};
        this.length = params.length || 20;
        this.width = params.width || 20;
        this.id = params.id;
        var direction = (params.direction || 1) < 0 ? -1 : 1,
            paintStyle = params.paintStyle || {lineWidth: 1},
            foldback = params.foldback || 0.623;
        this.computeMaxSize = function() {
          return self.width * 1.5;
        };
        this.elementCreated = function(p, component) {
          this.path = p;
          if (params.events) {
            for (var i in params.events) {
              jsPlumb.on(p, i, params.events[i]);
            }
          }
        };
        this.draw = function(component, currentConnectionPaintStyle) {
          var hxy,
              mid,
              txy,
              tail,
              cxy;
          if (component.pointAlongPathFrom) {
            if (_ju.isString(this.loc) || this.loc > 1 || this.loc < 0) {
              var l = parseInt(this.loc, 10),
                  fromLoc = this.loc < 0 ? 1 : 0;
              hxy = component.pointAlongPathFrom(fromLoc, l, false);
              mid = component.pointAlongPathFrom(fromLoc, l - (direction * this.length / 2), false);
              txy = _jg.pointOnLine(hxy, mid, this.length);
            } else if (this.loc == 1) {
              hxy = component.pointOnPath(this.loc);
              mid = component.pointAlongPathFrom(this.loc, -(this.length));
              txy = _jg.pointOnLine(hxy, mid, this.length);
              if (direction == -1) {
                var _ = txy;
                txy = hxy;
                hxy = _;
              }
            } else if (this.loc === 0) {
              txy = component.pointOnPath(this.loc);
              mid = component.pointAlongPathFrom(this.loc, this.length);
              hxy = _jg.pointOnLine(txy, mid, this.length);
              if (direction == -1) {
                var __ = txy;
                txy = hxy;
                hxy = __;
              }
            } else {
              hxy = component.pointAlongPathFrom(this.loc, direction * this.length / 2);
              mid = component.pointOnPath(this.loc);
              txy = _jg.pointOnLine(hxy, mid, this.length);
            }
            tail = _jg.perpendicularLineTo(hxy, txy, this.width);
            cxy = _jg.pointOnLine(hxy, txy, foldback * this.length);
            var d = {
              hxy: hxy,
              tail: tail,
              cxy: cxy
            },
                strokeStyle = paintStyle.strokeStyle || currentConnectionPaintStyle.strokeStyle,
                fillStyle = paintStyle.fillStyle || currentConnectionPaintStyle.strokeStyle,
                lineWidth = paintStyle.lineWidth || currentConnectionPaintStyle.lineWidth;
            return {
              component: component,
              d: d,
              lineWidth: lineWidth,
              strokeStyle: strokeStyle,
              fillStyle: fillStyle,
              minX: Math.min(hxy.x, tail[0].x, tail[1].x),
              maxX: Math.max(hxy.x, tail[0].x, tail[1].x),
              minY: Math.min(hxy.y, tail[0].y, tail[1].y),
              maxY: Math.max(hxy.y, tail[0].y, tail[1].y)
            };
          } else
            return {
              component: component,
              minX: 0,
              maxX: 0,
              minY: 0,
              maxY: 0
            };
        };
      };
      _ju.extend(_jp.Overlays.Arrow, AbstractOverlay, {updateFrom: function(d) {
          this.length = d.length || this.length;
          this.width = d.width || this.width;
          this.direction = d.direction != null ? d.direction : this.direction;
          this.foldback = d.foldback || this.foldback;
        }});
      _jp.Overlays.PlainArrow = function(params) {
        params = params || {};
        var p = _jp.extend(params, {foldback: 1});
        _jp.Overlays.Arrow.call(this, p);
        this.type = "PlainArrow";
      };
      _ju.extend(_jp.Overlays.PlainArrow, _jp.Overlays.Arrow);
      _jp.Overlays.Diamond = function(params) {
        params = params || {};
        var l = params.length || 40,
            p = jsPlumb.extend(params, {
              length: l / 2,
              foldback: 2
            });
        _jp.Overlays.Arrow.call(this, p);
        this.type = "Diamond";
      };
      _ju.extend(_jp.Overlays.Diamond, _jp.Overlays.Arrow);
      var _getDimensions = function(component, forceRefresh) {
        if (component._jsPlumb.cachedDimensions == null || forceRefresh)
          component._jsPlumb.cachedDimensions = component.getDimensions();
        return component._jsPlumb.cachedDimensions;
      };
      var AbstractDOMOverlay = function(params) {
        _jp.jsPlumbUIComponent.apply(this, arguments);
        AbstractOverlay.apply(this, arguments);
        var _f = this.fire;
        this.fire = function() {
          _f.apply(this, arguments);
          if (this.component)
            this.component.fire.apply(this.component, arguments);
        };
        this.detached = false;
        this.id = params.id;
        this._jsPlumb.div = null;
        this._jsPlumb.initialised = false;
        this._jsPlumb.component = params.component;
        this._jsPlumb.cachedDimensions = null;
        this._jsPlumb.create = params.create;
        this._jsPlumb.initiallyInvisible = params.visible === false;
        this.getElement = function() {
          if (this._jsPlumb.div == null) {
            var div = this._jsPlumb.div = jsPlumb.getElement(this._jsPlumb.create(this._jsPlumb.component));
            div.style.position = "absolute";
            div.className = this._jsPlumb.instance.overlayClass + " " + (this.cssClass ? this.cssClass : params.cssClass ? params.cssClass : "");
            this._jsPlumb.instance.appendElement(div);
            this._jsPlumb.instance.getId(div);
            this.canvas = div;
            var ts = "translate(-50%, -50%)";
            div.style.webkitTransform = ts;
            div.style.mozTransform = ts;
            div.style.msTransform = ts;
            div.style.oTransform = ts;
            div.style.transform = ts;
            div._jsPlumb = this;
            if (params.visible === false)
              div.style.display = "none";
          }
          return this._jsPlumb.div;
        };
        this.draw = function(component, currentConnectionPaintStyle, absolutePosition) {
          var td = _getDimensions(this);
          if (td != null && td.length == 2) {
            var cxy = {
              x: 0,
              y: 0
            };
            if (absolutePosition) {
              cxy = {
                x: absolutePosition[0],
                y: absolutePosition[1]
              };
            } else if (component.pointOnPath) {
              var loc = this.loc,
                  absolute = false;
              if (_ju.isString(this.loc) || this.loc < 0 || this.loc > 1) {
                loc = parseInt(this.loc, 10);
                absolute = true;
              }
              cxy = component.pointOnPath(loc, absolute);
            } else {
              var locToUse = this.loc.constructor == Array ? this.loc : this.endpointLoc;
              cxy = {
                x: locToUse[0] * component.w,
                y: locToUse[1] * component.h
              };
            }
            var minx = cxy.x - (td[0] / 2),
                miny = cxy.y - (td[1] / 2);
            return {
              component: component,
              d: {
                minx: minx,
                miny: miny,
                td: td,
                cxy: cxy
              },
              minX: minx,
              maxX: minx + td[0],
              minY: miny,
              maxY: miny + td[1]
            };
          } else
            return {
              minX: 0,
              maxX: 0,
              minY: 0,
              maxY: 0
            };
        };
      };
      _ju.extend(AbstractDOMOverlay, [_jp.jsPlumbUIComponent, AbstractOverlay], {
        getDimensions: function() {
          return [1, 1];
        },
        setVisible: function(state) {
          if (this._jsPlumb.div) {
            this._jsPlumb.div.style.display = state ? "block" : "none";
            if (state && this._jsPlumb.initiallyInvisible) {
              _getDimensions(this, true);
              this.component.repaint();
              this._jsPlumb.initiallyInvisible = false;
            }
          }
        },
        clearCachedDimensions: function() {
          this._jsPlumb.cachedDimensions = null;
        },
        cleanup: function(force) {
          if (force) {
            if (this._jsPlumb.div != null) {
              this._jsPlumb.div._jsPlumb = null;
              this._jsPlumb.instance.removeElement(this._jsPlumb.div);
            }
          } else {
            if (this._jsPlumb && this._jsPlumb.div && this._jsPlumb.div.parentNode)
              this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div);
            this.detached = true;
          }
        },
        reattach: function(instance) {
          if (this._jsPlumb.div != null)
            instance.getContainer().appendChild(this._jsPlumb.div);
          this.detached = false;
        },
        computeMaxSize: function() {
          var td = _getDimensions(this);
          return Math.max(td[0], td[1]);
        },
        paint: function(p, containerExtents) {
          if (!this._jsPlumb.initialised) {
            this.getElement();
            p.component.appendDisplayElement(this._jsPlumb.div);
            this._jsPlumb.initialised = true;
            if (this.detached)
              this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div);
          }
          this._jsPlumb.div.style.left = (p.component.x + p.d.minx) + "px";
          this._jsPlumb.div.style.top = (p.component.y + p.d.miny) + "px";
        }
      });
      _jp.Overlays.Custom = function(params) {
        this.type = "Custom";
        AbstractDOMOverlay.apply(this, arguments);
      };
      _ju.extend(_jp.Overlays.Custom, AbstractDOMOverlay);
      _jp.Overlays.GuideLines = function() {
        var self = this;
        self.length = 50;
        self.lineWidth = 5;
        this.type = "GuideLines";
        AbstractOverlay.apply(this, arguments);
        _jp.jsPlumbUIComponent.apply(this, arguments);
        this.draw = function(connector, currentConnectionPaintStyle) {
          var head = connector.pointAlongPathFrom(self.loc, self.length / 2),
              mid = connector.pointOnPath(self.loc),
              tail = _jg.pointOnLine(head, mid, self.length),
              tailLine = _jg.perpendicularLineTo(head, tail, 40),
              headLine = _jg.perpendicularLineTo(tail, head, 20);
          return {
            connector: connector,
            head: head,
            tail: tail,
            headLine: headLine,
            tailLine: tailLine,
            minX: Math.min(head.x, tail.x, headLine[0].x, headLine[1].x),
            minY: Math.min(head.y, tail.y, headLine[0].y, headLine[1].y),
            maxX: Math.max(head.x, tail.x, headLine[0].x, headLine[1].x),
            maxY: Math.max(head.y, tail.y, headLine[0].y, headLine[1].y)
          };
        };
      };
      _jp.Overlays.Label = function(params) {
        this.labelStyle = params.labelStyle;
        var labelWidth = null,
            labelHeight = null,
            labelText = null,
            labelPadding = null;
        this.cssClass = this.labelStyle != null ? this.labelStyle.cssClass : null;
        var p = _jp.extend({create: function() {
            return jsPlumb.createElement("div");
          }}, params);
        _jp.Overlays.Custom.call(this, p);
        this.type = "Label";
        this.label = params.label || "";
        this.labelText = null;
        if (this.labelStyle) {
          var el = this.getElement();
          this.labelStyle.font = this.labelStyle.font || "12px sans-serif";
          el.style.font = this.labelStyle.font;
          el.style.color = this.labelStyle.color || "black";
          if (this.labelStyle.fillStyle)
            el.style.background = this.labelStyle.fillStyle;
          if (this.labelStyle.borderWidth > 0) {
            var dStyle = this.labelStyle.borderStyle ? this.labelStyle.borderStyle : "black";
            el.style.border = this.labelStyle.borderWidth + "px solid " + dStyle;
          }
          if (this.labelStyle.padding)
            el.style.padding = this.labelStyle.padding;
        }
      };
      _ju.extend(_jp.Overlays.Label, _jp.Overlays.Custom, {
        cleanup: function(force) {
          if (force) {
            this.div = null;
            this.label = null;
            this.labelText = null;
            this.cssClass = null;
            this.labelStyle = null;
          }
        },
        getLabel: function() {
          return this.label;
        },
        setLabel: function(l) {
          this.label = l;
          this.labelText = null;
          this.clearCachedDimensions();
          this.update();
          this.component.repaint();
        },
        getDimensions: function() {
          this.update();
          return AbstractDOMOverlay.prototype.getDimensions.apply(this, arguments);
        },
        update: function() {
          if (typeof this.label == "function") {
            var lt = this.label(this);
            this.getElement().innerHTML = lt.replace(/\r\n/g, "<br/>");
          } else {
            if (this.labelText == null) {
              this.labelText = this.label;
              this.getElement().innerHTML = this.labelText.replace(/\r\n/g, "<br/>");
            }
          }
        },
        updateFrom: function(d) {
          if (d.label)
            this.setLabel(d.label);
        }
      });
    }).call(this);
    ;
    (function() {
      "use strict";
      var root = this,
          _jp = root.jsPlumb;
      var _getEventManager = function(instance) {
        var e = instance._mottle;
        if (!e) {
          e = instance._mottle = new root.Mottle();
        }
        return e;
      };
      _jp.extend(root.jsPlumbInstance.prototype, {
        getEventManager: function() {
          return _getEventManager(this);
        },
        on: function(el, event, callback) {
          this.getEventManager().on.apply(this, arguments);
          return this;
        },
        off: function(el, event, callback) {
          this.getEventManager().off.apply(this, arguments);
          return this;
        }
      });
    }).call(this);
    ;
    (function() {
      "use strict";
      var root = this,
          _jp = root.jsPlumb,
          _ju = root.jsPlumbUtil;
      var Flowchart = function(params) {
        this.type = "Flowchart";
        params = params || {};
        params.stub = params.stub == null ? 30 : params.stub;
        var segments,
            _super = _jp.Connectors.AbstractConnector.apply(this, arguments),
            midpoint = params.midpoint == null ? 0.5 : params.midpoint,
            alwaysRespectStubs = params.alwaysRespectStubs === true,
            lastx = null,
            lasty = null,
            lastOrientation,
            cornerRadius = params.cornerRadius != null ? params.cornerRadius : 0,
            loopbackRadius = params.loopbackRadius || 25,
            isLoopbackCurrently = false,
            sgn = function(n) {
              return n < 0 ? -1 : n === 0 ? 0 : 1;
            },
            addSegment = function(segments, x, y, paintInfo) {
              if (lastx == x && lasty == y)
                return;
              var lx = lastx == null ? paintInfo.sx : lastx,
                  ly = lasty == null ? paintInfo.sy : lasty,
                  o = lx == x ? "v" : "h",
                  sgnx = sgn(x - lx),
                  sgny = sgn(y - ly);
              lastx = x;
              lasty = y;
              segments.push([lx, ly, x, y, o, sgnx, sgny]);
            },
            segLength = function(s) {
              return Math.sqrt(Math.pow(s[0] - s[2], 2) + Math.pow(s[1] - s[3], 2));
            },
            _cloneArray = function(a) {
              var _a = [];
              _a.push.apply(_a, a);
              return _a;
            },
            writeSegments = function(conn, segments, paintInfo) {
              var current = null,
                  next;
              for (var i = 0; i < segments.length - 1; i++) {
                current = current || _cloneArray(segments[i]);
                next = _cloneArray(segments[i + 1]);
                if (cornerRadius > 0 && current[4] != next[4]) {
                  var radiusToUse = Math.min(cornerRadius, segLength(current), segLength(next));
                  current[2] -= current[5] * radiusToUse;
                  current[3] -= current[6] * radiusToUse;
                  next[0] += next[5] * radiusToUse;
                  next[1] += next[6] * radiusToUse;
                  var ac = (current[6] == next[5] && next[5] == 1) || ((current[6] == next[5] && next[5] === 0) && current[5] != next[6]) || (current[6] == next[5] && next[5] == -1),
                      sgny = next[1] > current[3] ? 1 : -1,
                      sgnx = next[0] > current[2] ? 1 : -1,
                      sgnEqual = sgny == sgnx,
                      cx = (sgnEqual && ac || (!sgnEqual && !ac)) ? next[0] : current[2],
                      cy = (sgnEqual && ac || (!sgnEqual && !ac)) ? current[3] : next[1];
                  _super.addSegment(conn, "Straight", {
                    x1: current[0],
                    y1: current[1],
                    x2: current[2],
                    y2: current[3]
                  });
                  _super.addSegment(conn, "Arc", {
                    r: radiusToUse,
                    x1: current[2],
                    y1: current[3],
                    x2: next[0],
                    y2: next[1],
                    cx: cx,
                    cy: cy,
                    ac: ac
                  });
                } else {
                  var dx = (current[2] == current[0]) ? 0 : (current[2] > current[0]) ? (paintInfo.lw / 2) : -(paintInfo.lw / 2),
                      dy = (current[3] == current[1]) ? 0 : (current[3] > current[1]) ? (paintInfo.lw / 2) : -(paintInfo.lw / 2);
                  _super.addSegment(conn, "Straight", {
                    x1: current[0] - dx,
                    y1: current[1] - dy,
                    x2: current[2] + dx,
                    y2: current[3] + dy
                  });
                }
                current = next;
              }
              if (next != null) {
                _super.addSegment(conn, "Straight", {
                  x1: next[0],
                  y1: next[1],
                  x2: next[2],
                  y2: next[3]
                });
              }
            };
        this._compute = function(paintInfo, params) {
          segments = [];
          lastx = null;
          lasty = null;
          lastOrientation = null;
          var commonStubCalculator = function() {
            return [paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY];
          },
              stubCalculators = {
                perpendicular: commonStubCalculator,
                orthogonal: commonStubCalculator,
                opposite: function(axis) {
                  var pi = paintInfo,
                      idx = axis == "x" ? 0 : 1,
                      areInProximity = {
                        "x": function() {
                          return ((pi.so[idx] == 1 && (((pi.startStubX > pi.endStubX) && (pi.tx > pi.startStubX)) || ((pi.sx > pi.endStubX) && (pi.tx > pi.sx))))) || ((pi.so[idx] == -1 && (((pi.startStubX < pi.endStubX) && (pi.tx < pi.startStubX)) || ((pi.sx < pi.endStubX) && (pi.tx < pi.sx)))));
                        },
                        "y": function() {
                          return ((pi.so[idx] == 1 && (((pi.startStubY > pi.endStubY) && (pi.ty > pi.startStubY)) || ((pi.sy > pi.endStubY) && (pi.ty > pi.sy))))) || ((pi.so[idx] == -1 && (((pi.startStubY < pi.endStubY) && (pi.ty < pi.startStubY)) || ((pi.sy < pi.endStubY) && (pi.ty < pi.sy)))));
                        }
                      };
                  if (!alwaysRespectStubs && areInProximity[axis]()) {
                    return {
                      "x": [(paintInfo.sx + paintInfo.tx) / 2, paintInfo.startStubY, (paintInfo.sx + paintInfo.tx) / 2, paintInfo.endStubY],
                      "y": [paintInfo.startStubX, (paintInfo.sy + paintInfo.ty) / 2, paintInfo.endStubX, (paintInfo.sy + paintInfo.ty) / 2]
                    }[axis];
                  } else {
                    return [paintInfo.startStubX, paintInfo.startStubY, paintInfo.endStubX, paintInfo.endStubY];
                  }
                }
              };
          var stubs = stubCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis),
              idx = paintInfo.sourceAxis == "x" ? 0 : 1,
              oidx = paintInfo.sourceAxis == "x" ? 1 : 0,
              ss = stubs[idx],
              oss = stubs[oidx],
              es = stubs[idx + 2],
              oes = stubs[oidx + 2];
          addSegment(segments, stubs[0], stubs[1], paintInfo);
          if (false && params.sourcePos[0] == params.targetPos[0] && params.sourcePos[1] == params.targetPos[1]) {
            addSegment(segments, stubs[0] - loopbackRadius, stubs[1], paintInfo);
            addSegment(segments, stubs[0] - loopbackRadius, stubs[1] - (2 * loopbackRadius), paintInfo);
            addSegment(segments, stubs[0] + loopbackRadius, stubs[1] - (2 * loopbackRadius), paintInfo);
            addSegment(segments, stubs[0] + loopbackRadius, stubs[1], paintInfo);
            addSegment(segments, stubs[0], stubs[1], paintInfo);
          } else {
            var midx = paintInfo.startStubX + ((paintInfo.endStubX - paintInfo.startStubX) * midpoint),
                midy = paintInfo.startStubY + ((paintInfo.endStubY - paintInfo.startStubY) * midpoint);
            var orientations = {
              x: [0, 1],
              y: [1, 0]
            },
                lineCalculators = {
                  perpendicular: function(axis) {
                    var pi = paintInfo,
                        sis = {
                          x: [[[1, 2, 3, 4], null, [2, 1, 4, 3]], null, [[4, 3, 2, 1], null, [3, 4, 1, 2]]],
                          y: [[[3, 2, 1, 4], null, [2, 3, 4, 1]], null, [[4, 1, 2, 3], null, [1, 4, 3, 2]]]
                        },
                        stubs = {
                          x: [[pi.startStubX, pi.endStubX], null, [pi.endStubX, pi.startStubX]],
                          y: [[pi.startStubY, pi.endStubY], null, [pi.endStubY, pi.startStubY]]
                        },
                        midLines = {
                          x: [[midx, pi.startStubY], [midx, pi.endStubY]],
                          y: [[pi.startStubX, midy], [pi.endStubX, midy]]
                        },
                        linesToEnd = {
                          x: [[pi.endStubX, pi.startStubY]],
                          y: [[pi.startStubX, pi.endStubY]]
                        },
                        startToEnd = {
                          x: [[pi.startStubX, pi.endStubY], [pi.endStubX, pi.endStubY]],
                          y: [[pi.endStubX, pi.startStubY], [pi.endStubX, pi.endStubY]]
                        },
                        startToMidToEnd = {
                          x: [[pi.startStubX, midy], [pi.endStubX, midy], [pi.endStubX, pi.endStubY]],
                          y: [[midx, pi.startStubY], [midx, pi.endStubY], [pi.endStubX, pi.endStubY]]
                        },
                        otherStubs = {
                          x: [pi.startStubY, pi.endStubY],
                          y: [pi.startStubX, pi.endStubX]
                        },
                        soIdx = orientations[axis][0],
                        toIdx = orientations[axis][1],
                        _so = pi.so[soIdx] + 1,
                        _to = pi.to[toIdx] + 1,
                        otherFlipped = (pi.to[toIdx] == -1 && (otherStubs[axis][1] < otherStubs[axis][0])) || (pi.to[toIdx] == 1 && (otherStubs[axis][1] > otherStubs[axis][0])),
                        stub1 = stubs[axis][_so][0],
                        stub2 = stubs[axis][_so][1],
                        segmentIndexes = sis[axis][_so][_to];
                    if (pi.segment == segmentIndexes[3] || (pi.segment == segmentIndexes[2] && otherFlipped)) {
                      return midLines[axis];
                    } else if (pi.segment == segmentIndexes[2] && stub2 < stub1) {
                      return linesToEnd[axis];
                    } else if ((pi.segment == segmentIndexes[2] && stub2 >= stub1) || (pi.segment == segmentIndexes[1] && !otherFlipped)) {
                      return startToMidToEnd[axis];
                    } else if (pi.segment == segmentIndexes[0] || (pi.segment == segmentIndexes[1] && otherFlipped)) {
                      return startToEnd[axis];
                    }
                  },
                  orthogonal: function(axis, startStub, otherStartStub, endStub, otherEndStub) {
                    var pi = paintInfo,
                        extent = {
                          "x": pi.so[0] == -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub),
                          "y": pi.so[1] == -1 ? Math.min(startStub, endStub) : Math.max(startStub, endStub)
                        }[axis];
                    return {
                      "x": [[extent, otherStartStub], [extent, otherEndStub], [endStub, otherEndStub]],
                      "y": [[otherStartStub, extent], [otherEndStub, extent], [otherEndStub, endStub]]
                    }[axis];
                  },
                  opposite: function(axis, ss, oss, es) {
                    var pi = paintInfo,
                        otherAxis = {
                          "x": "y",
                          "y": "x"
                        }[axis],
                        dim = {
                          "x": "height",
                          "y": "width"
                        }[axis],
                        comparator = pi["is" + axis.toUpperCase() + "GreaterThanStubTimes2"];
                    if (params.sourceEndpoint.elementId == params.targetEndpoint.elementId) {
                      var _val = oss + ((1 - params.sourceEndpoint.anchor[otherAxis]) * params.sourceInfo[dim]) + _super.maxStub;
                      return {
                        "x": [[ss, _val], [es, _val]],
                        "y": [[_val, ss], [_val, es]]
                      }[axis];
                    } else if (!comparator || (pi.so[idx] == 1 && ss > es) || (pi.so[idx] == -1 && ss < es)) {
                      return {
                        "x": [[ss, midy], [es, midy]],
                        "y": [[midx, ss], [midx, es]]
                      }[axis];
                    } else if ((pi.so[idx] == 1 && ss < es) || (pi.so[idx] == -1 && ss > es)) {
                      return {
                        "x": [[midx, pi.sy], [midx, pi.ty]],
                        "y": [[pi.sx, midy], [pi.tx, midy]]
                      }[axis];
                    }
                  }
                };
            var p = lineCalculators[paintInfo.anchorOrientation](paintInfo.sourceAxis, ss, oss, es, oes);
            if (p) {
              for (var i = 0; i < p.length; i++) {
                addSegment(segments, p[i][0], p[i][1], paintInfo);
              }
            }
            addSegment(segments, stubs[2], stubs[3], paintInfo);
          }
          addSegment(segments, paintInfo.tx, paintInfo.ty, paintInfo);
          writeSegments(this, segments, paintInfo);
        };
      };
      _ju.extend(Flowchart, _jp.Connectors.AbstractConnector);
      _jp.registerConnectorType(Flowchart, "Flowchart");
    }).call(this);
    ;
    (function() {
      "use strict";
      var root = this,
          _jp = root.jsPlumb,
          _ju = root.jsPlumbUtil;
      _jp.Connectors.AbstractBezierConnector = function(params) {
        params = params || {};
        var showLoopback = params.showLoopback !== false,
            curviness = params.curviness || 10,
            margin = params.margin || 5,
            proximityLimit = params.proximityLimit || 80,
            clockwise = params.orientation && params.orientation === "clockwise",
            loopbackRadius = params.loopbackRadius || 25,
            isLoopbackCurrently = false,
            _super;
        this.overrideSetEditable = function() {
          return !isLoopbackCurrently;
        };
        this._compute = function(paintInfo, p) {
          var sp = p.sourcePos,
              tp = p.targetPos,
              _w = Math.abs(sp[0] - tp[0]),
              _h = Math.abs(sp[1] - tp[1]);
          if (!showLoopback || (p.sourceEndpoint.elementId !== p.targetEndpoint.elementId)) {
            isLoopbackCurrently = false;
            this._computeBezier(paintInfo, p, sp, tp, _w, _h);
          } else {
            isLoopbackCurrently = true;
            var x1 = p.sourcePos[0],
                y1 = p.sourcePos[1] - margin,
                cx = x1,
                cy = y1 - loopbackRadius,
                _x = cx - loopbackRadius,
                _y = cy - loopbackRadius;
            _w = 2 * loopbackRadius;
            _h = 2 * loopbackRadius;
            paintInfo.points[0] = _x;
            paintInfo.points[1] = _y;
            paintInfo.points[2] = _w;
            paintInfo.points[3] = _h;
            _super.addSegment(this, "Arc", {
              loopback: true,
              x1: (x1 - _x) + 4,
              y1: y1 - _y,
              startAngle: 0,
              endAngle: 2 * Math.PI,
              r: loopbackRadius,
              ac: !clockwise,
              x2: (x1 - _x) - 4,
              y2: y1 - _y,
              cx: cx - _x,
              cy: cy - _y
            });
          }
        };
        _super = _jp.Connectors.AbstractConnector.apply(this, arguments);
        return _super;
      };
      _ju.extend(_jp.Connectors.AbstractBezierConnector, _jp.Connectors.AbstractConnector);
      var Bezier = function(params) {
        params = params || {};
        this.type = "Bezier";
        var _super = _jp.Connectors.AbstractBezierConnector.apply(this, arguments),
            majorAnchor = params.curviness || 150,
            minorAnchor = 10;
        this.getCurviness = function() {
          return majorAnchor;
        };
        this._findControlPoint = function(point, sourceAnchorPosition, targetAnchorPosition, sourceEndpoint, targetEndpoint, soo, too) {
          var perpendicular = soo[0] != too[0] || soo[1] == too[1],
              p = [];
          if (!perpendicular) {
            if (soo[0] === 0)
              p.push(sourceAnchorPosition[0] < targetAnchorPosition[0] ? point[0] + minorAnchor : point[0] - minorAnchor);
            else
              p.push(point[0] - (majorAnchor * soo[0]));
            if (soo[1] === 0)
              p.push(sourceAnchorPosition[1] < targetAnchorPosition[1] ? point[1] + minorAnchor : point[1] - minorAnchor);
            else
              p.push(point[1] + (majorAnchor * too[1]));
          } else {
            if (too[0] === 0)
              p.push(targetAnchorPosition[0] < sourceAnchorPosition[0] ? point[0] + minorAnchor : point[0] - minorAnchor);
            else
              p.push(point[0] + (majorAnchor * too[0]));
            if (too[1] === 0)
              p.push(targetAnchorPosition[1] < sourceAnchorPosition[1] ? point[1] + minorAnchor : point[1] - minorAnchor);
            else
              p.push(point[1] + (majorAnchor * soo[1]));
          }
          return p;
        };
        this._computeBezier = function(paintInfo, p, sp, tp, _w, _h) {
          var geometry = this.getGeometry(),
              _CP,
              _CP2,
              _sx = sp[0] < tp[0] ? _w : 0,
              _sy = sp[1] < tp[1] ? _h : 0,
              _tx = sp[0] < tp[0] ? 0 : _w,
              _ty = sp[1] < tp[1] ? 0 : _h;
          if ((this.hasBeenEdited() || this.isEditing()) && geometry != null && geometry.controlPoints != null && geometry.controlPoints[0] != null && geometry.controlPoints[1] != null) {
            _CP = geometry.controlPoints[0];
            _CP2 = geometry.controlPoints[1];
          } else {
            _CP = this._findControlPoint([_sx, _sy], sp, tp, p.sourceEndpoint, p.targetEndpoint, paintInfo.so, paintInfo.to);
            _CP2 = this._findControlPoint([_tx, _ty], tp, sp, p.targetEndpoint, p.sourceEndpoint, paintInfo.to, paintInfo.so);
          }
          _super.setGeometry({controlPoints: [_CP, _CP2]}, true);
          _super.addSegment(this, "Bezier", {
            x1: _sx,
            y1: _sy,
            x2: _tx,
            y2: _ty,
            cp1x: _CP[0],
            cp1y: _CP[1],
            cp2x: _CP2[0],
            cp2y: _CP2[1]
          });
        };
      };
      _ju.extend(Bezier, _jp.Connectors.AbstractBezierConnector);
      _jp.registerConnectorType(Bezier, "Bezier");
    }).call(this);
    ;
    (function() {
      "use strict";
      var root = this,
          _jp = root.jsPlumb,
          _ju = root.jsPlumbUtil;
      var _segment = function(x1, y1, x2, y2) {
        if (x1 <= x2 && y2 <= y1)
          return 1;
        else if (x1 <= x2 && y1 <= y2)
          return 2;
        else if (x2 <= x1 && y2 >= y1)
          return 3;
        return 4;
      },
          _findControlPoint = function(midx, midy, segment, sourceEdge, targetEdge, dx, dy, distance, proximityLimit) {
            if (distance <= proximityLimit)
              return [midx, midy];
            if (segment === 1) {
              if (sourceEdge[3] <= 0 && targetEdge[3] >= 1)
                return [midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy];
              else if (sourceEdge[2] >= 1 && targetEdge[2] <= 0)
                return [midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy)];
              else
                return [midx + (-1 * dx), midy + (-1 * dy)];
            } else if (segment === 2) {
              if (sourceEdge[3] >= 1 && targetEdge[3] <= 0)
                return [midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy];
              else if (sourceEdge[2] >= 1 && targetEdge[2] <= 0)
                return [midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy)];
              else
                return [midx + dx, midy + (-1 * dy)];
            } else if (segment === 3) {
              if (sourceEdge[3] >= 1 && targetEdge[3] <= 0)
                return [midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy];
              else if (sourceEdge[2] <= 0 && targetEdge[2] >= 1)
                return [midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy)];
              else
                return [midx + (-1 * dx), midy + (-1 * dy)];
            } else if (segment === 4) {
              if (sourceEdge[3] <= 0 && targetEdge[3] >= 1)
                return [midx + (sourceEdge[2] < 0.5 ? -1 * dx : dx), midy];
              else if (sourceEdge[2] <= 0 && targetEdge[2] >= 1)
                return [midx, midy + (sourceEdge[3] < 0.5 ? -1 * dy : dy)];
              else
                return [midx + dx, midy + (-1 * dy)];
            }
          };
      var StateMachine = function(params) {
        params = params || {};
        this.type = "StateMachine";
        var _super = _jp.Connectors.AbstractBezierConnector.apply(this, arguments),
            curviness = params.curviness || 10,
            margin = params.margin || 5,
            proximityLimit = params.proximityLimit || 80,
            clockwise = params.orientation && params.orientation === "clockwise",
            _controlPoint;
        this._computeBezier = function(paintInfo, params, sp, tp, w, h) {
          var _sx = params.sourcePos[0] < params.targetPos[0] ? 0 : w,
              _sy = params.sourcePos[1] < params.targetPos[1] ? 0 : h,
              _tx = params.sourcePos[0] < params.targetPos[0] ? w : 0,
              _ty = params.sourcePos[1] < params.targetPos[1] ? h : 0;
          if (params.sourcePos[2] === 0)
            _sx -= margin;
          if (params.sourcePos[2] === 1)
            _sx += margin;
          if (params.sourcePos[3] === 0)
            _sy -= margin;
          if (params.sourcePos[3] === 1)
            _sy += margin;
          if (params.targetPos[2] === 0)
            _tx -= margin;
          if (params.targetPos[2] === 1)
            _tx += margin;
          if (params.targetPos[3] === 0)
            _ty -= margin;
          if (params.targetPos[3] === 1)
            _ty += margin;
          var _midx = (_sx + _tx) / 2,
              _midy = (_sy + _ty) / 2,
              segment = _segment(_sx, _sy, _tx, _ty),
              distance = Math.sqrt(Math.pow(_tx - _sx, 2) + Math.pow(_ty - _sy, 2)),
              cp1x,
              cp2x,
              cp1y,
              cp2y,
              geometry = _super.getGeometry();
          if ((this.hasBeenEdited() || this.isEditing()) && geometry != null) {
            cp1x = geometry.controlPoints[0][0];
            cp1y = geometry.controlPoints[0][1];
            cp2x = geometry.controlPoints[1][0];
            cp2y = geometry.controlPoints[1][1];
          } else {
            _controlPoint = _findControlPoint(_midx, _midy, segment, params.sourcePos, params.targetPos, curviness, curviness, distance, proximityLimit);
            cp1x = _controlPoint[0];
            cp2x = _controlPoint[0];
            cp1y = _controlPoint[1];
            cp2y = _controlPoint[1];
            _super.setGeometry({controlPoints: [_controlPoint, _controlPoint]}, true);
          }
          _super.addSegment(this, "Bezier", {
            x1: _tx,
            y1: _ty,
            x2: _sx,
            y2: _sy,
            cp1x: cp1x,
            cp1y: cp1y,
            cp2x: cp2x,
            cp2y: cp2y
          });
        };
      };
      _ju.extend(StateMachine, _jp.Connectors.AbstractBezierConnector);
      _jp.registerConnectorType(StateMachine, "StateMachine");
    }).call(this);
    ;
    (function() {
      "use strict";
      var root = this,
          _jp = root.jsPlumb,
          _ju = root.jsPlumbUtil;
      var svgAttributeMap = {
        "stroke-linejoin": "stroke-linejoin",
        "stroke-dashoffset": "stroke-dashoffset",
        "stroke-linecap": "stroke-linecap"
      },
          STROKE_DASHARRAY = "stroke-dasharray",
          DASHSTYLE = "dashstyle",
          LINEAR_GRADIENT = "linearGradient",
          RADIAL_GRADIENT = "radialGradient",
          DEFS = "defs",
          FILL = "fill",
          STOP = "stop",
          STROKE = "stroke",
          STROKE_WIDTH = "stroke-width",
          STYLE = "style",
          NONE = "none",
          JSPLUMB_GRADIENT = "jsplumb_gradient_",
          LINE_WIDTH = "lineWidth",
          ns = {
            svg: "http://www.w3.org/2000/svg",
            xhtml: "http://www.w3.org/1999/xhtml"
          },
          _attr = function(node, attributes) {
            for (var i in attributes)
              node.setAttribute(i, "" + attributes[i]);
          },
          _node = function(name, attributes) {
            attributes = attributes || {};
            attributes.version = "1.1";
            attributes.xmlns = ns.xhtml;
            return jsPlumb.createElementNS(ns.svg, name, null, null, attributes);
          },
          _pos = function(d) {
            return "position:absolute;left:" + d[0] + "px;top:" + d[1] + "px";
          },
          _clearGradient = function(parent) {
            var els = parent.querySelectorAll(" defs,linearGradient,radialGradient");
            for (var i = 0; i < els.length; i++)
              els[i].parentNode.removeChild(els[i]);
          },
          _updateGradient = function(parent, node, style, dimensions, uiComponent) {
            var id = JSPLUMB_GRADIENT + uiComponent._jsPlumb.instance.idstamp();
            _clearGradient(parent);
            var g;
            if (!style.gradient.offset)
              g = _node(LINEAR_GRADIENT, {
                id: id,
                gradientUnits: "userSpaceOnUse"
              });
            else
              g = _node(RADIAL_GRADIENT, {id: id});
            var defs = _node(DEFS);
            parent.appendChild(defs);
            defs.appendChild(g);
            for (var i = 0; i < style.gradient.stops.length; i++) {
              var styleToUse = uiComponent.segment == 1 || uiComponent.segment == 2 ? i : style.gradient.stops.length - 1 - i,
                  stopColor = style.gradient.stops[styleToUse][1],
                  s = _node(STOP, {
                    "offset": Math.floor(style.gradient.stops[i][0] * 100) + "%",
                    "stop-color": stopColor
                  });
              g.appendChild(s);
            }
            var applyGradientTo = style.strokeStyle ? STROKE : FILL;
            node.setAttribute(applyGradientTo, "url(#" + id + ")");
          },
          _applyStyles = function(parent, node, style, dimensions, uiComponent) {
            node.setAttribute(FILL, style.fillStyle ? style.fillStyle : NONE);
            node.setAttribute(STROKE, style.strokeStyle ? style.strokeStyle : NONE);
            if (style.gradient) {
              _updateGradient(parent, node, style, dimensions, uiComponent);
            } else {
              _clearGradient(parent);
              node.setAttribute(STYLE, "");
            }
            if (style.lineWidth) {
              node.setAttribute(STROKE_WIDTH, style.lineWidth);
            }
            if (style[DASHSTYLE] && style[LINE_WIDTH] && !style[STROKE_DASHARRAY]) {
              var sep = style[DASHSTYLE].indexOf(",") == -1 ? " " : ",",
                  parts = style[DASHSTYLE].split(sep),
                  styleToUse = "";
              parts.forEach(function(p) {
                styleToUse += (Math.floor(p * style.lineWidth) + sep);
              });
              node.setAttribute(STROKE_DASHARRAY, styleToUse);
            } else if (style[STROKE_DASHARRAY]) {
              node.setAttribute(STROKE_DASHARRAY, style[STROKE_DASHARRAY]);
            }
            for (var i in svgAttributeMap) {
              if (style[i]) {
                node.setAttribute(svgAttributeMap[i], style[i]);
              }
            }
          },
          _appendAtIndex = function(svg, path, idx) {
            if (svg.childNodes.length > idx) {
              svg.insertBefore(path, svg.childNodes[idx]);
            } else
              svg.appendChild(path);
          };
      _ju.svg = {
        node: _node,
        attr: _attr,
        pos: _pos
      };
      var SvgComponent = function(params) {
        var pointerEventsSpec = params.pointerEventsSpec || "all",
            renderer = {};
        _jp.jsPlumbUIComponent.apply(this, params.originalArgs);
        this.canvas = null;
        this.path = null;
        this.svg = null;
        this.bgCanvas = null;
        var clazz = params.cssClass + " " + (params.originalArgs[0].cssClass || ""),
            svgParams = {
              "style": "",
              "width": 0,
              "height": 0,
              "pointer-events": pointerEventsSpec,
              "position": "absolute"
            };
        this.svg = _node("svg", svgParams);
        if (params.useDivWrapper) {
          this.canvas = jsPlumb.createElement("div", {position: "absolute"});
          _ju.sizeElement(this.canvas, 0, 0, 1, 1);
          this.canvas.className = clazz;
        } else {
          _attr(this.svg, {"class": clazz});
          this.canvas = this.svg;
        }
        params._jsPlumb.appendElement(this.canvas, params.originalArgs[0].parent);
        if (params.useDivWrapper)
          this.canvas.appendChild(this.svg);
        var displayElements = [this.canvas];
        this.getDisplayElements = function() {
          return displayElements;
        };
        this.appendDisplayElement = function(el) {
          displayElements.push(el);
        };
        this.paint = function(style, anchor, extents) {
          if (style != null) {
            var xy = [this.x, this.y],
                wh = [this.w, this.h],
                p;
            if (extents != null) {
              if (extents.xmin < 0)
                xy[0] += extents.xmin;
              if (extents.ymin < 0)
                xy[1] += extents.ymin;
              wh[0] = extents.xmax + ((extents.xmin < 0) ? -extents.xmin : 0);
              wh[1] = extents.ymax + ((extents.ymin < 0) ? -extents.ymin : 0);
            }
            if (params.useDivWrapper) {
              _ju.sizeElement(this.canvas, xy[0], xy[1], wh[0], wh[1]);
              xy[0] = 0;
              xy[1] = 0;
              p = _pos([0, 0]);
            } else
              p = _pos([xy[0], xy[1]]);
            renderer.paint.apply(this, arguments);
            _attr(this.svg, {
              "style": p,
              "width": wh[0] || 0,
              "height": wh[1] || 0
            });
          }
        };
        return {renderer: renderer};
      };
      _ju.extend(SvgComponent, _jp.jsPlumbUIComponent, {
        cleanup: function(force) {
          if (force || this.typeId == null) {
            if (this.canvas)
              this.canvas._jsPlumb = null;
            if (this.svg)
              this.svg._jsPlumb = null;
            if (this.bgCanvas)
              this.bgCanvas._jsPlumb = null;
            if (this.canvas && this.canvas.parentNode)
              this.canvas.parentNode.removeChild(this.canvas);
            if (this.bgCanvas && this.bgCanvas.parentNode)
              this.canvas.parentNode.removeChild(this.canvas);
            this.svg = null;
            this.canvas = null;
            this.path = null;
            this.group = null;
          } else {
            if (this.canvas && this.canvas.parentNode)
              this.canvas.parentNode.removeChild(this.canvas);
            if (this.bgCanvas && this.bgCanvas.parentNode)
              this.bgCanvas.parentNode.removeChild(this.bgCanvas);
          }
        },
        reattach: function(instance) {
          var c = instance.getContainer();
          if (this.canvas && this.canvas.parentNode == null)
            c.appendChild(this.canvas);
          if (this.bgCanvas && this.bgCanvas.parentNode == null)
            c.appendChild(this.bgCanvas);
        },
        setVisible: function(v) {
          if (this.canvas) {
            this.canvas.style.display = v ? "block" : "none";
          }
        }
      });
      _jp.ConnectorRenderers.svg = function(params) {
        var self = this,
            _super = SvgComponent.apply(this, [{
              cssClass: params._jsPlumb.connectorClass + (this.isEditable() ? " " + params._jsPlumb.editableConnectorClass : ""),
              originalArgs: arguments,
              pointerEventsSpec: "none",
              _jsPlumb: params._jsPlumb
            }]);
        var _superSetEditable = this.setEditable;
        this.setEditable = function(e) {
          var result = _superSetEditable.apply(this, [e]);
          jsPlumb[result ? "addClass" : "removeClass"](this.canvas, this._jsPlumb.instance.editableConnectorClass);
        };
        _super.renderer.paint = function(style, anchor, extents) {
          var segments = self.getSegments(),
              p = "",
              offset = [0, 0];
          if (extents.xmin < 0)
            offset[0] = -extents.xmin;
          if (extents.ymin < 0)
            offset[1] = -extents.ymin;
          if (segments.length > 0) {
            for (var i = 0; i < segments.length; i++) {
              p += _jp.Segments.svg.SegmentRenderer.getPath(segments[i]);
              p += " ";
            }
            var a = {
              d: p,
              transform: "translate(" + offset[0] + "," + offset[1] + ")",
              "pointer-events": params["pointer-events"] || "visibleStroke"
            },
                outlineStyle = null,
                d = [self.x, self.y, self.w, self.h];
            if (style.outlineColor) {
              var outlineWidth = style.outlineWidth || 1,
                  outlineStrokeWidth = style.lineWidth + (2 * outlineWidth);
              outlineStyle = _jp.extend({}, style);
              delete outlineStyle.gradient;
              outlineStyle.strokeStyle = style.outlineColor;
              outlineStyle.lineWidth = outlineStrokeWidth;
              if (self.bgPath == null) {
                self.bgPath = _node("path", a);
                _jp.addClass(self.bgPath, _jp.connectorOutlineClass);
                _appendAtIndex(self.svg, self.bgPath, 0);
              } else {
                _attr(self.bgPath, a);
              }
              _applyStyles(self.svg, self.bgPath, outlineStyle, d, self);
            }
            if (self.path == null) {
              self.path = _node("path", a);
              _appendAtIndex(self.svg, self.path, style.outlineColor ? 1 : 0);
            } else {
              _attr(self.path, a);
            }
            _applyStyles(self.svg, self.path, style, d, self);
          }
        };
      };
      _ju.extend(_jp.ConnectorRenderers.svg, SvgComponent);
      _jp.Segments.svg = {SegmentRenderer: {getPath: function(segment) {
            return ({
              "Straight": function() {
                var d = segment.getCoordinates();
                return "M " + d.x1 + " " + d.y1 + " L " + d.x2 + " " + d.y2;
              },
              "Bezier": function() {
                var d = segment.params;
                return "M " + d.x1 + " " + d.y1 + " C " + d.cp1x + " " + d.cp1y + " " + d.cp2x + " " + d.cp2y + " " + d.x2 + " " + d.y2;
              },
              "Arc": function() {
                var d = segment.params,
                    laf = segment.sweep > Math.PI ? 1 : 0,
                    sf = segment.anticlockwise ? 0 : 1;
                return "M" + segment.x1 + " " + segment.y1 + " A " + segment.radius + " " + d.r + " 0 " + laf + "," + sf + " " + segment.x2 + " " + segment.y2;
              }
            })[segment.type]();
          }}};
      var SvgEndpoint = _jp.SvgEndpoint = function(params) {
        var _super = SvgComponent.apply(this, [{
          cssClass: params._jsPlumb.endpointClass,
          originalArgs: arguments,
          pointerEventsSpec: "all",
          useDivWrapper: true,
          _jsPlumb: params._jsPlumb
        }]);
        _super.renderer.paint = function(style) {
          var s = _jp.extend({}, style);
          if (s.outlineColor) {
            s.strokeWidth = s.outlineWidth;
            s.strokeStyle = s.outlineColor;
          }
          if (this.node == null) {
            this.node = this.makeNode(s);
            this.svg.appendChild(this.node);
          } else if (this.updateNode != null) {
            this.updateNode(this.node);
          }
          _applyStyles(this.svg, this.node, s, [this.x, this.y, this.w, this.h], this);
          _pos(this.node, [this.x, this.y]);
        }.bind(this);
      };
      _ju.extend(SvgEndpoint, SvgComponent);
      _jp.Endpoints.svg.Dot = function() {
        _jp.Endpoints.Dot.apply(this, arguments);
        SvgEndpoint.apply(this, arguments);
        this.makeNode = function(style) {
          return _node("circle", {
            "cx": this.w / 2,
            "cy": this.h / 2,
            "r": this.radius
          });
        };
        this.updateNode = function(node) {
          _attr(node, {
            "cx": this.w / 2,
            "cy": this.h / 2,
            "r": this.radius
          });
        };
      };
      _ju.extend(_jp.Endpoints.svg.Dot, [_jp.Endpoints.Dot, SvgEndpoint]);
      _jp.Endpoints.svg.Rectangle = function() {
        _jp.Endpoints.Rectangle.apply(this, arguments);
        SvgEndpoint.apply(this, arguments);
        this.makeNode = function(style) {
          return _node("rect", {
            "width": this.w,
            "height": this.h
          });
        };
        this.updateNode = function(node) {
          _attr(node, {
            "width": this.w,
            "height": this.h
          });
        };
      };
      _ju.extend(_jp.Endpoints.svg.Rectangle, [_jp.Endpoints.Rectangle, SvgEndpoint]);
      _jp.Endpoints.svg.Image = _jp.Endpoints.Image;
      _jp.Endpoints.svg.Blank = _jp.Endpoints.Blank;
      _jp.Overlays.svg.Label = _jp.Overlays.Label;
      _jp.Overlays.svg.Custom = _jp.Overlays.Custom;
      var AbstractSvgArrowOverlay = function(superclass, originalArgs) {
        superclass.apply(this, originalArgs);
        _jp.jsPlumbUIComponent.apply(this, originalArgs);
        this.isAppendedAtTopLevel = false;
        var self = this;
        this.path = null;
        this.paint = function(params, containerExtents) {
          if (params.component.svg && containerExtents) {
            if (this.path == null) {
              this.path = _node("path", {"pointer-events": "all"});
              params.component.svg.appendChild(this.path);
              if (this.elementCreated) {
                this.elementCreated(this.path, params.component);
              }
              this.canvas = params.component.svg;
            }
            var clazz = originalArgs && (originalArgs.length == 1) ? (originalArgs[0].cssClass || "") : "",
                offset = [0, 0];
            if (containerExtents.xmin < 0)
              offset[0] = -containerExtents.xmin;
            if (containerExtents.ymin < 0)
              offset[1] = -containerExtents.ymin;
            _attr(this.path, {
              "d": makePath(params.d),
              "class": clazz,
              stroke: params.strokeStyle ? params.strokeStyle : null,
              fill: params.fillStyle ? params.fillStyle : null,
              transform: "translate(" + offset[0] + "," + offset[1] + ")"
            });
          }
        };
        var makePath = function(d) {
          return (isNaN(d.cxy.x) || isNaN(d.cxy.y)) ? "" : "M" + d.hxy.x + "," + d.hxy.y + " L" + d.tail[0].x + "," + d.tail[0].y + " L" + d.cxy.x + "," + d.cxy.y + " L" + d.tail[1].x + "," + d.tail[1].y + " L" + d.hxy.x + "," + d.hxy.y;
        };
        this.transfer = function(target) {
          if (target.canvas && this.path && this.path.parentNode) {
            this.path.parentNode.removeChild(this.path);
            target.canvas.appendChild(this.path);
          }
        };
      };
      _ju.extend(AbstractSvgArrowOverlay, [_jp.jsPlumbUIComponent, _jp.Overlays.AbstractOverlay], {
        cleanup: function(force) {
          if (this.path != null) {
            if (force)
              this._jsPlumb.instance.removeElement(this.path);
            else if (this.path.parentNode)
              this.path.parentNode.removeChild(this.path);
          }
        },
        reattach: function(instance) {
          if (this.path && this.canvas && this.path.parentNode == null)
            this.canvas.appendChild(this.path);
        },
        setVisible: function(v) {
          if (this.path != null)
            (this.path.style.display = (v ? "block" : "none"));
        }
      });
      _jp.Overlays.svg.Arrow = function() {
        AbstractSvgArrowOverlay.apply(this, [_jp.Overlays.Arrow, arguments]);
      };
      _ju.extend(_jp.Overlays.svg.Arrow, [_jp.Overlays.Arrow, AbstractSvgArrowOverlay]);
      _jp.Overlays.svg.PlainArrow = function() {
        AbstractSvgArrowOverlay.apply(this, [_jp.Overlays.PlainArrow, arguments]);
      };
      _ju.extend(_jp.Overlays.svg.PlainArrow, [_jp.Overlays.PlainArrow, AbstractSvgArrowOverlay]);
      _jp.Overlays.svg.Diamond = function() {
        AbstractSvgArrowOverlay.apply(this, [_jp.Overlays.Diamond, arguments]);
      };
      _ju.extend(_jp.Overlays.svg.Diamond, [_jp.Overlays.Diamond, AbstractSvgArrowOverlay]);
      _jp.Overlays.svg.GuideLines = function() {
        var path = null,
            self = this,
            p1_1,
            p1_2;
        _jp.Overlays.GuideLines.apply(this, arguments);
        this.paint = function(params, containerExtents) {
          if (path == null) {
            path = _node("path");
            params.connector.svg.appendChild(path);
            self.attachListeners(path, params.connector);
            self.attachListeners(path, self);
            p1_1 = _node("path");
            params.connector.svg.appendChild(p1_1);
            self.attachListeners(p1_1, params.connector);
            self.attachListeners(p1_1, self);
            p1_2 = _node("path");
            params.connector.svg.appendChild(p1_2);
            self.attachListeners(p1_2, params.connector);
            self.attachListeners(p1_2, self);
          }
          var offset = [0, 0];
          if (containerExtents.xmin < 0)
            offset[0] = -containerExtents.xmin;
          if (containerExtents.ymin < 0)
            offset[1] = -containerExtents.ymin;
          _attr(path, {
            "d": makePath(params.head, params.tail),
            stroke: "red",
            fill: null,
            transform: "translate(" + offset[0] + "," + offset[1] + ")"
          });
          _attr(p1_1, {
            "d": makePath(params.tailLine[0], params.tailLine[1]),
            stroke: "blue",
            fill: null,
            transform: "translate(" + offset[0] + "," + offset[1] + ")"
          });
          _attr(p1_2, {
            "d": makePath(params.headLine[0], params.headLine[1]),
            stroke: "green",
            fill: null,
            transform: "translate(" + offset[0] + "," + offset[1] + ")"
          });
        };
        var makePath = function(d1, d2) {
          return "M " + d1.x + "," + d1.y + " L" + d2.x + "," + d2.y;
        };
      };
      _ju.extend(_jp.Overlays.svg.GuideLines, _jp.Overlays.GuideLines);
    }).call(this);
    ;
    (function() {
      "use strict";
      var root = this,
          _jp = root.jsPlumb,
          _ju = root.jsPlumbUtil,
          _jk = root.Katavorio,
          _jg = root.Biltong;
      var _getDragManager = function(instance, category) {
        category = category || "main";
        var key = "_katavorio_" + category;
        var k = instance[key],
            e = instance.getEventManager();
        if (!k) {
          k = new _jk({
            bind: e.on,
            unbind: e.off,
            getSize: jsPlumb.getSize,
            getPosition: function(el) {
              var o = instance.getOffset(el, false, el._katavorioDrag ? el.offsetParent : null);
              return [o.left, o.top];
            },
            setPosition: function(el, xy) {
              el.style.left = xy[0] + "px";
              el.style.top = xy[1] + "px";
            },
            addClass: jsPlumb.addClass,
            removeClass: jsPlumb.removeClass,
            intersects: _jg.intersects,
            indexOf: function(l, i) {
              return l.indexOf(i);
            },
            css: {
              noSelect: instance.dragSelectClass,
              droppable: "jsplumb-droppable",
              draggable: "jsplumb-draggable",
              drag: "jsplumb-drag",
              selected: "jsplumb-drag-selected",
              active: "jsplumb-drag-active",
              hover: "jsplumb-drag-hover"
            }
          });
          instance[key] = k;
          instance.bind("zoom", k.setZoom);
        }
        return k;
      };
      var _animProps = function(o, p) {
        var _one = function(pName) {
          if (p[pName] != null) {
            if (_ju.isString(p[pName])) {
              var m = p[pName].match(/-=/) ? -1 : 1,
                  v = p[pName].substring(2);
              return o[pName] + (m * v);
            } else
              return p[pName];
          } else
            return o[pName];
        };
        return [_one("left"), _one("top")];
      };
      _jp.extend(root.jsPlumbInstance.prototype, {
        animationSupported: true,
        getElement: function(el) {
          if (el == null)
            return null;
          el = typeof el === "string" ? el : el.length != null && el.enctype == null ? el[0] : el;
          return typeof el === "string" ? document.getElementById(el) : el;
        },
        removeElement: function(element) {
          _getDragManager(this).elementRemoved(element);
          this.getEventManager().remove(element);
        },
        doAnimate: function(el, properties, options) {
          options = options || {};
          var o = this.getOffset(el),
              ap = _animProps(o, properties),
              ldist = ap[0] - o.left,
              tdist = ap[1] - o.top,
              d = options.duration || 250,
              step = 15,
              steps = d / step,
              linc = (step / d) * ldist,
              tinc = (step / d) * tdist,
              idx = 0,
              int = setInterval(function() {
                jsPlumb.setPosition(el, {
                  left: o.left + (linc * (idx + 1)),
                  top: o.top + (tinc * (idx + 1))
                });
                if (options.step != null)
                  options.step(idx, Math.ceil(steps));
                idx++;
                if (idx >= steps) {
                  window.clearInterval(int);
                  if (options.complete != null)
                    options.complete();
                }
              }, step);
        },
        destroyDraggable: function(el, category) {
          _getDragManager(this, category).destroyDraggable(el);
        },
        destroyDroppable: function(el, category) {
          _getDragManager(this, category).destroyDroppable(el);
        },
        initDraggable: function(el, options, category) {
          _getDragManager(this, category).draggable(el, options);
        },
        initDroppable: function(el, options, category) {
          _getDragManager(this, category).droppable(el, options);
        },
        isAlreadyDraggable: function(el) {
          return el._katavorioDrag != null;
        },
        isDragSupported: function(el, options) {
          return true;
        },
        isDropSupported: function(el, options) {
          return true;
        },
        isElementDraggable: function(el) {
          el = jsPlumb.getElement(el);
          return el._katavorioDrag && el._katavorioDrag.isEnabled();
        },
        getDragObject: function(eventArgs) {
          return eventArgs[0].drag.getDragElement();
        },
        getDragScope: function(el) {
          return el._katavorioDrag && el._katavorioDrag.scopes.join(" ") || "";
        },
        getDropEvent: function(args) {
          return args[0].e;
        },
        getUIPosition: function(eventArgs, zoom) {
          var el = eventArgs[0].el;
          var p = {
            left: eventArgs[0].pos[0],
            top: eventArgs[0].pos[1]
          };
          if (el._katavorioDrag && el.offsetParent !== this.getContainer()) {
            var oc = this.getOffset(el.offsetParent);
            p.left += oc.left;
            p.top += oc.top;
          }
          return p;
        },
        setDragFilter: function(el, filter, _exclude) {
          if (el._katavorioDrag) {
            el._katavorioDrag.setFilter(filter, _exclude);
          }
        },
        setElementDraggable: function(el, draggable) {
          el = jsPlumb.getElement(el);
          if (el._katavorioDrag)
            el._katavorioDrag.setEnabled(draggable);
        },
        setDragScope: function(el, scope) {
          if (el._katavorioDrag)
            el._katavorioDrag.k.setDragScope(el, scope);
        },
        setDropScope: function(el, scope) {
          if (el._katavorioDrop && el._katavorioDrop.length > 0) {
            el._katavorioDrop[0].k.setDropScope(el, scope);
          }
        },
        addToPosse: function(el, spec) {
          var specs = Array.prototype.slice.call(arguments, 1);
          var dm = _getDragManager(this);
          jsPlumb.each(el, function(_el) {
            _el = [jsPlumb.getElement(_el)];
            _el.push.apply(_el, specs);
            dm.addToPosse.apply(dm, _el);
          });
        },
        setPosse: function(el, spec) {
          var specs = Array.prototype.slice.call(arguments, 1);
          var dm = _getDragManager(this);
          jsPlumb.each(el, function(_el) {
            _el = [jsPlumb.getElement(_el)];
            _el.push.apply(_el, specs);
            dm.setPosse.apply(dm, _el);
          });
        },
        removeFromPosse: function(el, posseId) {
          var specs = Array.prototype.slice.call(arguments, 1);
          var dm = _getDragManager(this);
          jsPlumb.each(el, function(_el) {
            _el = [jsPlumb.getElement(_el)];
            _el.push.apply(_el, specs);
            dm.removeFromPosse.apply(dm, _el);
          });
        },
        removeFromAllPosses: function(el) {
          var dm = _getDragManager(this);
          jsPlumb.each(el, function(_el) {
            dm.removeFromAllPosses(jsPlumb.getElement(_el));
          });
        },
        setPosseState: function(el, posseId, state) {
          var dm = _getDragManager(this);
          jsPlumb.each(el, function(_el) {
            dm.setPosseState(jsPlumb.getElement(_el), posseId, state);
          });
        },
        dragEvents: {
          'start': 'start',
          'stop': 'stop',
          'drag': 'drag',
          'step': 'step',
          'over': 'over',
          'out': 'out',
          'drop': 'drop',
          'complete': 'complete',
          'beforeStart': 'beforeStart'
        },
        animEvents: {
          'step': "step",
          'complete': 'complete'
        },
        stopDrag: function(el) {
          if (el._katavorioDrag)
            el._katavorioDrag.abort();
        },
        addToDragSelection: function(spec) {
          _getDragManager(this).select(spec);
        },
        removeFromDragSelection: function(spec) {
          _getDragManager(this).deselect(spec);
        },
        clearDragSelection: function() {
          _getDragManager(this).deselectAll();
        },
        trigger: function(el, event, originalEvent, payload) {
          this.getEventManager().trigger(el, event, originalEvent, payload);
        },
        doReset: function() {
          for (var key in this) {
            if (key.indexOf("_katavorio_") === 0) {
              this[key].reset();
            }
          }
        }
      });
      var ready = function(f) {
        var _do = function() {
          if (/complete|loaded|interactive/.test(document.readyState) && typeof(document.body) != "undefined" && document.body != null)
            f();
          else
            setTimeout(_do, 9);
        };
        _do();
      };
      ready(_jp.init);
    }).call(this);
  })(req('2e'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2f", ["2d"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('2d');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("30", ["2f"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define(['jsplumb'], factory);
    } else if (typeof module === 'object' && module.exports) {
      module.exports = factory(req('2f').jsPlumb);
    } else {
      root.Remapper = factory(root.jsPlumb);
    }
  }(this, function(jsPlumb) {
    function $$(selector, parent) {
      if (typeof parent === 'string') {
        parent = $$(parent);
      }
      parent = parent || document;
      return parent.querySelector(selector);
    }
    function Remapper(id, buttonLabel) {
      if (!buttonLabel) {
        buttonLabel = "Apply mapping";
      }
      this.id = id;
      this._init(buttonLabel);
      this.listeners = new Map();
    }
    Remapper.prototype.on = function(name, fn) {
      if (!this.listeners.has(name)) {
        this.listeners.set(name, new Set());
      }
      this.listeners.get(name).add(fn);
    };
    Remapper.prototype.off = function(name, fn) {
      this.listeners.get(name).delete(fn);
    };
    Remapper.prototype.fire = function(name, obj) {
      if (!this.listeners.has(name))
        return;
      this.listeners.get(name).forEach(function(fn) {
        fn(obj);
      });
    };
    Remapper.prototype._init = function(buttonLabel) {
      this.jsPlumb = jsPlumb.getInstance();
      var self = this;
      if (!$$('#' + self.id).innerHTML) {
        $$('#' + self.id).innerHTML = '<div class="remap-froms"></div><div class="remap-tos"></div><div class="centrecontent"></div><div class="buttonholder"><button class="remap-button">' + buttonLabel + '</button><button class="cancel-remap-button">Cancel</button></div>';
        $$('#' + self.id).style.display = 'none';
        $$('#' + self.id).classList.add('main-remapper');
        $$('.remap-button', '#' + self.id).addEventListener('click', function() {
          var mapping = new Map();
          var connections = self.jsPlumb.select();
          connections.each(function(conn) {
            var fromValue = conn.endpoints[0].element.dataset.categoryId;
            var toValue = conn.endpoints[1].element.dataset.categoryId;
            mapping.set(fromValue, toValue);
          });
          $$('#' + self.id).style.display = 'none';
          self.fire('apply', {mapping: mapping});
        });
        $$('.cancel-remap-button', '#' + self.id).addEventListener('click', function() {
          $$('#' + self.id).style.display = 'none';
          self.fire('cancel');
        });
      }
      this._resize = function() {
        self.jsPlumb.repaintEverything();
      };
      window.addEventListener('resize', this._resize);
    };
    Remapper.prototype.remove = function() {
      this.jsPlumb.cleanupListeners();
      window.removeEventListener('resize', this._resize);
      $$('#' + this.id).classList.remove('main-remapper');
      $$('#' + this.id).innerHTML = '';
    };
    Remapper.prototype.show = function() {
      $$('#' + this.id).style.display = 'block';
      this.jsPlumb.repaintEverything();
    };
    Remapper.prototype.populateFroms = function(fromCategories) {
      var i,
          id;
      var self = this;
      $$('#' + self.id).style.display = 'block';
      $$('.remap-froms', '#' + self.id).innerHTML = '';
      for (i = 0; i < fromCategories.length; i++) {
        id = 'from:' + fromCategories[i].id;
        $$('.remap-froms', '#' + self.id).innerHTML += '<div id="' + id + '" class="map-from" ' + 'data-category-id="' + fromCategories[i].id + '" ' + '>' + fromCategories[i].label + '</div>';
      }
      for (i = 0; i < fromCategories.length; i++) {
        id = 'from:' + fromCategories[i].id;
        self.jsPlumb.addEndpoint(id, {
          container: $$('#' + self.id),
          uuid: id,
          isSource: true,
          isTarget: false,
          endpoint: 'Rectangle',
          paintStyle: {
            fillStyle: fromCategories[i].color,
            outlineColor: 'black',
            outlineWidth: 1
          },
          anchor: 'Right',
          maxConnections: 1,
          connectorOverlays: [['PlainArrow', {
            location: 0.2,
            paintStyle: {
              fillStyle: fromCategories[i].color,
              outlineColor: 'black',
              outlineWidth: 1
            },
            width: 15,
            length: 15
          }]]
        });
      }
      $$('#' + self.id).style.display = 'none';
      self.jsPlumb.bind('click', function(conn) {
        self.jsPlumb.detach(conn);
      });
    };
    Remapper.prototype.populateTos = function(toCategories) {
      var i,
          id;
      var self = this;
      $$('.remap-tos', '#' + this.id).innerHTML = '';
      for (i = 0; i < toCategories.length; i++) {
        id = 'to:' + toCategories[i].id;
        $$('.remap-tos', '#' + this.id).innerHTML += '<div id="' + id + '" class="map-to" ' + 'data-category-id="' + toCategories[i].id + '" ' + '> ' + toCategories[i].label + ' </div>';
      }
      for (i = 0; i < toCategories.length; i++) {
        id = 'to:' + toCategories[i].id;
        this.jsPlumb.addEndpoint(id, {
          uuid: id,
          isSource: false,
          isTarget: true,
          endpoint: 'Dot',
          paintStyle: {
            fillStyle: toCategories[i].color,
            outlineColor: 'black',
            outlineWidth: 1
          },
          anchor: 'Left',
          maxConnections: -1
        });
      }
    };
    Remapper.prototype.linkCategories = function(mapping) {
      var tovals,
          i;
      var self = this;
      mapping.forEach(function(to, from) {
        self.jsPlumb.connect({uuids: ['from:' + from, 'to:' + to]});
      });
    };
    return Remapper;
  }));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("31", ["30"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('30');
  global.define = __define;
  return module.exports;
});

$__System.register('32', ['8', '9', '23', '31', '33', 'c', '2c', '1d', 'b', '1a'], function (_export) {
  'use strict';

  var $, $$, HTML, i18n, withCategories, Remapper, CatRemap, Modal, COVJSON_GRID, Action, VIEW, PROCESS, CoverageData, html, TEMPLATES, CoverageRemapCategories;
  return {
    setters: [function (_) {
      $ = _.$;
      $$ = _.$$;
      HTML = _.HTML;
    }, function (_4) {
      i18n = _4.i18n;
    }, function (_3) {
      withCategories = _3.withCategories;
    }, function (_2) {
      Remapper = _2['default'];
    }, function (_5) {
      CatRemap = _5['default'];
    }, function (_c) {
      Modal = _c['default'];
    }, function (_c2) {}, function (_d) {
      COVJSON_GRID = _d.COVJSON_GRID;
    }, function (_b) {
      Action = _b['default'];
      VIEW = _b.VIEW;
      PROCESS = _b.PROCESS;
    }, function (_a) {
      CoverageData = _a['default'];
    }],
    execute: function () {
      html = '\n<div class="modal fade" id="parameterSelectModal" tabindex="-1" role="dialog" aria-labelledby="paramSelectModalLabel">\n  <div class="modal-dialog" role="document">\n    <div class="modal-content">\n      <div class="modal-header">\n        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>\n        <h4 class="modal-title" id="paramSelectModalLabel">Select a categorical parameter</h4>\n      </div>\n      <div class="modal-body">\n        <span class="remap-is-remapping"></span>\n      \n        <div class="panel panel-primary parameter-select">\n          <div class="panel-body">\n            <p>\n              Which of the following categorical parameters do you like to remap?\n            </p>\n          </div>\n          <ul class="list-group parameter-list"></ul>\n        </div>\n       \n      </div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>\n      </div>\n    </div>\n  </div>\n</div>\n\n<div class="modal fade" id="remapModal" tabindex="-1" role="dialog" aria-labelledby="remapModalLabel">\n  <div class="modal-dialog" role="document">\n    <div class="modal-content">\n      <div class="modal-header">\n        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>\n        <h4 class="modal-title" id="remapModalLabel">Remap <strong class="parameter-label"></strong> Categories</h4>\n      </div>\n      <div class="modal-body">\n        <span class="remap-is-remapping"></span>\n        \n        <div class="panel panel-primary remap-remapping-distributions">\n          <div class="panel-heading">\n            <h4>Option A: Apply ready-made remapping definitions</h4>\n          </div>\n          <div class="panel-body">\n            <p>\n              Using a ready-made remapping definition is the fastest way to apply a remapping.\n              The remapping definition defines both the target categories and their mapping\n              from the source categories.\n            </p>\n            <div class="alert alert-info remapping-distribution-list-empty" role="alert"><strong>None found.</strong></div>\n          </div>\n          <ul class="list-group remapping-distribution-list"></ul>\n        </div>\n        \n        <div class="panel panel-primary remap-categorical-distributions">\n          <div class="panel-heading">\n            <h4>Option B: Remap manually with categories from existing datasets</h4>\n          </div>\n          <div class="panel-body">\n            <p>\n              A manual remapping can be done more quickly by loading the desired\n              target categories from an existing dataset. The connections then have\n              to be created manually via drag and drop.\n            </p>\n            <div class="alert alert-info categorical-distribution-list-empty" role="alert"><strong>None found.</strong></div>\n          </div>\n          \n          <ul class="list-group categorical-distribution-list"></ul>\n        </div>\n        \n        <div class="panel panel-default remap-manual">\n          <div class="panel-heading">\n            <h4>Option C: Fully manual remapping</h4>\n          </div>\n          <div class="panel-body">\n            <p>\n              When the above methods cannot be used then the only option left is\n              to manually create the target categories and connect\n              them to the source categories. NOTE: This is currently not supported.\n            </p>\n          </div>\n        </div>\n       \n      </div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>\n      </div>\n    </div>\n  </div>\n</div>\n<div id="remapper"></div>\n<style>\n/* above sidebar */\n.modal, #remapper {\n  z-index: 3000; \n}\n.modal-backdrop {\n  z-index: 2500;\n}\n.categorical-distribution-list-empty, .remapping-distribution-list-empty {\n  margin-bottom: 0;\n}\n.workspace-dataset-distribution-action .btn {\n  margin-bottom: 5px;\n}\n</style>\n';

      $('body').add(HTML(html));

      TEMPLATES = {
        'is-remapping': '\n  <div class="panel panel-primary">\n    <div class="panel-body">\n      <p>This coverage data is the result of a category remapping operation.</p>\n      <button type="button" class="btn btn-primary btn-modify-remapping" data-dismiss="modal">Modify Remapping</button>\n    </div>\n  </div>\n  ',
        'parameter-item': '\n  <li class="list-group-item">\n    <h4 class="list-group-item-heading parameter-label"></h4>\n    <p>Categories: <span class="parameter-categories"></span></p>\n\n    <button type="button" class="btn btn-primary parameter-select-button" data-dismiss="modal">\n      Select\n    </button>\n  </li>\n  ',
        'categorical-distribution-item': '\n  <li class="list-group-item">\n    <h4 class="list-group-item-heading dataset-title"></h4>\n    <p>Distribution: <span class="distribution-title"></span></p>\n    <span class="distribution-parameters"></span>\n  </li>\n  ',
        // leave the <span> in! otherwise we can't reach the button via minified...
        'categorical-parameter-item': '\n  <span>\n    <p>Target: <span class="parameter-label"></span></p>\n    <p>Categories: <span class="parameter-categories"></span></p>\n  \n    <button type="button" class="btn btn-primary remapping-button" data-dismiss="modal">\n      Use Categories\n    </button>\n  </span>\n  ',
        'remapping-distribution-item': '\n  <li class="list-group-item">\n    <h4 class="list-group-item-heading dataset-title"></h4>\n    <p>Distribution: <span class="distribution-title"></span></p>\n    <p>Target: <span class="target-observedProperty-label"></span></p>\n    <p>Categories: <span class="target-categories"></span></p>\n    \n    <button type="button" class="btn btn-primary remapping-button" data-dismiss="modal">\n      Apply\n    </button>\n  </li>\n  '
      };

      CoverageRemapCategories = (function (_Action) {
        babelHelpers.inherits(CoverageRemapCategories, _Action);

        function CoverageRemapCategories(data, context) {
          babelHelpers.classCallCheck(this, CoverageRemapCategories);

          babelHelpers.get(Object.getPrototypeOf(CoverageRemapCategories.prototype), 'constructor', this).call(this, context);

          if (this._isSingleCoverage(data)) {
            this.cov = this._getSingleCoverage(data);
          } else {
            this.cov = data;
          }

          this.label = 'Remap Categories';
          this.icon = '<span class="glyphicon glyphicon-random"></span>';
        }

        babelHelpers.createClass(CoverageRemapCategories, [{
          key: '_isSingleCoverage',
          value: function _isSingleCoverage(cov) {
            try {
              this._getSingleCoverage(cov);
              return true;
            } catch (e) {
              return false;
            }
          }
        }, {
          key: '_getSingleCoverage',
          value: function _getSingleCoverage(cov) {
            if (!cov.coverages) {
              return cov;
            } else if (cov.coverages.length === 1) {
              return cov.coverages[0];
            } else {
              throw new Error('not a single coverage');
            }
          }
        }, {
          key: '_getCategoricalParams',
          value: function _getCategoricalParams() {
            var params = [].concat(babelHelpers.toConsumableArray(this.cov.parameters.values()));
            return params.filter(function (param) {
              return param.observedProperty.categories;
            });
          }
        }, {
          key: 'run',
          value: function run() {
            // open UI for remapping etc.

            // First modal dialog:
            // Step 0: The user first selects which categorical parameter he wants to remap.
            //         If there is just a single one, then this step is skipped.

            // Second modal dialog:
            // Step 1: search for distributions in workspace that can be used as a mapping or as target categories;
            //         if no distributions found, display message and guide user
            // Step 2: display distributions in a list with "Use" buttons
            // Step 3: after the user presses the "Use" button, a new virtual dataset is created
            //         with a single distribution which is immediately displayed
            //         The virtual distribution has the remapping info attached so that it is possible
            //         to modify the mapping in the same virtual dataset.
            //         This info is stored directly in CovJSON as provenance data (derivedFrom
            // When a remapping is "modified" then this means removing the old virtual distribution and
            // adding a new one.

            var catParams = this._getCategoricalParams();
            if (catParams.length > 1) {
              this._selectParameterModal();
            } else {
              // go directly to the second modal
              this._remapModal(catParams[0]);
            }
          }
        }, {
          key: '_selectParameterModal',
          value: function _selectParameterModal() {
            var _this = this;

            var modalEl = $('#parameterSelectModal');

            this._showModifyRemappingSection(modalEl);

            $('.parameter-list', modalEl).fill();
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              var _loop = function () {
                var param = _step.value;

                var el = $(HTML(TEMPLATES['parameter-item']));
                $('.parameter-label', el).fill(i18n(param.observedProperty.label));

                var categories = param.observedProperty.categories;
                var content = categories.map(function (cat) {
                  return i18n(cat.label);
                }).join(', ');
                $('.parameter-categories', el).fill(content);

                $('.parameter-select-button', el).on('|click', function () {
                  // small timeout otherwise scrolling gets broken
                  // (immediate closing and opening of another modal seems problematic)
                  setTimeout(function () {
                    return _this._remapModal(param, 200);
                  });
                });

                $('.parameter-list', modalEl).add(el);
              };

              for (var _iterator = this._getCategoricalParams()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                _loop();
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            new Modal(modalEl[0]).open();
          }
        }, {
          key: '_modifyRemappingUI',
          value: function _modifyRemappingUI() {
            var _this2 = this;

            var trans = this.cov.transformations[this.cov.transformations.length - 1];
            var sourceCov = trans.source;
            var param = trans.operation.parameter;
            var remapDef = trans.operation.categoryRemappingDefinition;
            var modifyTitle = false;

            this._createVirtualRemappedDataset(sourceCov, param, remapDef, modifyTitle, function () {
              _this2.context.workspace.removeDataset(_this2.context.dataset);
            });
          }
        }, {
          key: '_showModifyRemappingSection',
          value: function _showModifyRemappingSection(modalEl) {
            var _this3 = this;

            // display "Modify Remapping" button when this is a remapped coverage
            if (this._isRemapped()) {
              $('.remap-is-remapping', modalEl).fill(HTML(TEMPLATES['is-remapping']));
              $('.btn-modify-remapping', modalEl).on('click|', function () {
                return _this3._modifyRemappingUI();
              });
            } else {
              $('.remap-is-remapping', modalEl).fill();
            }
          }
        }, {
          key: '_getCategoryMappingDefinition',
          value: function _getCategoryMappingDefinition(sourceObservedProperty, targetObservedProperty) {
            var categoryMappings = [];
            // match up identical categories
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              var _loop2 = function () {
                var category = _step2.value;

                var match = targetObservedProperty.categories.some(function (c) {
                  return c.id === category.id;
                });
                if (match) {
                  categoryMappings.push({
                    sourceCategory: category.id,
                    destinationCategory: category.id
                  });
                }
              };

              for (var _iterator2 = sourceObservedProperty.categories[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                _loop2();
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                  _iterator2['return']();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }

            var remapDef = {
              type: 'CategoryRemappingDefinition',
              label: {
                // TODO do this properly
                en: i18n(sourceObservedProperty.label) + ' / ' + i18n(targetObservedProperty.label) + ' Mapping'
              },
              sourceObservedProperty: sourceObservedProperty,
              destinationObservedProperty: targetObservedProperty,
              categoryMappings: categoryMappings
            };
            return remapDef;
          }
        }, {
          key: '_remapModal',
          value: function _remapModal(sourceParameter) {
            var _this4 = this;

            var modalEl = $('#remapModal');
            $('.parameter-label', modalEl).fill(i18n(sourceParameter.observedProperty.label));

            this._showModifyRemappingSection(modalEl);

            // display categories and remapping specs that can be used
            var catDists = this._findCategoryDistributions();
            var remappingDists = this._findRemappingDistributions(sourceParameter);

            $('.categorical-distribution-list', modalEl).fill();
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = catDists[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var _step3$value = _step3.value;
                var distribution = _step3$value.distribution;
                var dataset = _step3$value.dataset;

                var el = $(HTML(TEMPLATES['categorical-distribution-item']));

                $('.dataset-title', el).fill(i18n(dataset.title));
                $('.distribution-title', el).fill(i18n(distribution.title));

                var cov = distribution.data;
                var covTargetCategories = undefined;
                var _iteratorNormalCompletion5 = true;
                var _didIteratorError5 = false;
                var _iteratorError5 = undefined;

                try {
                  var _loop3 = function () {
                    var param = _step5.value;

                    if (param.observedProperty.categories) {
                      var paramEl = $(HTML(TEMPLATES['categorical-parameter-item']));
                      covTargetCategories = param.observedProperty.categories;
                      var content = covTargetCategories.map(function (cat) {
                        return i18n(cat.label);
                      }).join(', ');
                      $('.parameter-categories', paramEl).fill(content);
                      $('.parameter-label', paramEl).fill(i18n(param.observedProperty.label));
                      $('.distribution-parameters', el).add(paramEl);

                      $('.remapping-button', paramEl).on('|click', function () {
                        var remapDef = _this4._getCategoryMappingDefinition(sourceParameter.observedProperty, param.observedProperty);
                        _this4._createVirtualRemappedDataset(_this4.cov, sourceParameter, remapDef, true);
                      });
                    }
                  };

                  for (var _iterator5 = cov.parameters.values()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                    _loop3();
                  }
                } catch (err) {
                  _didIteratorError5 = true;
                  _iteratorError5 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion5 && _iterator5['return']) {
                      _iterator5['return']();
                    }
                  } finally {
                    if (_didIteratorError5) {
                      throw _iteratorError5;
                    }
                  }
                }

                $('.categorical-distribution-list', modalEl).add(el);
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                  _iterator3['return']();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            $('.remapping-distribution-list', modalEl).fill();
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              var _loop4 = function () {
                var _step4$value = _step4.value;
                var distribution = _step4$value.distribution;
                var dataset = _step4$value.dataset;

                var el = $(HTML(TEMPLATES['remapping-distribution-item']));

                var remapDef = distribution.data;

                $('.dataset-title', el).fill(i18n(dataset.title));
                $('.distribution-title', el).fill(i18n(distribution.title));
                $('.target-observedProperty-label', el).fill(i18n(remapDef.destinationObservedProperty.label));

                var cats = remapDef.destinationObservedProperty.categories;
                var catsStr = cats.map(function (cat) {
                  return i18n(cat.label);
                }).join(', ');
                $('.target-categories', el).fill(catsStr);

                $('.remapping-button', el).on('|click', function () {
                  _this4._createVirtualRemappedDataset(_this4.cov, sourceParameter, remapDef, true);
                });

                $('.remapping-distribution-list', modalEl).add(el);
              };

              for (var _iterator4 = remappingDists[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                _loop4();
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                  _iterator4['return']();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            $$('.categorical-distribution-list-empty', modalEl).style.display = catDists.length > 0 ? 'none' : 'block';
            $$('.remapping-distribution-list-empty', modalEl).style.display = remappingDists.length > 0 ? 'none' : 'block';

            new Modal(modalEl[0]).open();
          }
        }, {
          key: '_createVirtualRemappedDataset',
          value: function _createVirtualRemappedDataset(cov, parameter, remapDef, modifyTitle, oncreate) {
            var _this5 = this;

            var sourceParameter = parameter;
            var targetObservedProp = remapDef.destinationObservedProperty;
            var mapping = new Map(remapDef.categoryMappings.map(function (m) {
              return [m.sourceCategory, m.destinationCategory];
            }));

            var titleAppend = modifyTitle ? ' [remapped to: ' + i18n(targetObservedProp.label) + ']' : '';

            this._showRemapper(sourceParameter.observedProperty, targetObservedProp, mapping, function (data) {
              // use the mapping that was potentially modified by the user
              var mapping = data.mapping;

              var remappedCov = withCategories(cov, sourceParameter.key, targetObservedProp, mapping);

              // update remapDef in case the user dragged around connections
              var newRemapDef = JSON.parse(JSON.stringify(remapDef));
              newRemapDef.categoryMappings = [];
              var _iteratorNormalCompletion6 = true;
              var _didIteratorError6 = false;
              var _iteratorError6 = undefined;

              try {
                for (var _iterator6 = mapping[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                  var _step6$value = babelHelpers.slicedToArray(_step6.value, 2);

                  var sourceCategory = _step6$value[0];
                  var destinationCategory = _step6$value[1];

                  newRemapDef.categoryMappings.push({ sourceCategory: sourceCategory, destinationCategory: destinationCategory });
                }
              } catch (err) {
                _didIteratorError6 = true;
                _iteratorError6 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion6 && _iterator6['return']) {
                    _iterator6['return']();
                  }
                } finally {
                  if (_didIteratorError6) {
                    throw _iteratorError6;
                  }
                }
              }

              if (!remappedCov.transformations) {
                remappedCov.transformations = [];
              }
              remappedCov.transformations.push({
                source: cov,
                operation: {
                  type: 'CategoryRemappingOperation',
                  parameter: sourceParameter,
                  categoryRemappingDefinition: newRemapDef
                }
              });

              var virtualDataset = {
                title: { en: i18n(_this5.context.dataset.title) + titleAppend },
                virtual: true,
                distributions: [{
                  title: { en: i18n(_this5.context.distribution.title) + titleAppend },
                  mediaType: 'coveragedata',
                  data: remappedCov
                }]
              };
              var workspace = _this5.context.workspace;

              // display after loading
              var done = function done(_ref) {
                var dataset = _ref.dataset;

                if (dataset === virtualDataset) {
                  dataset.distributions[0].actions.find(function (a) {
                    return a.type === VIEW;
                  }).run();
                  workspace.off('distributionsLoad', done);
                }
              };
              workspace.on('distributionsLoad', done);

              workspace.addDataset(virtualDataset, _this5.context.dataset);
              workspace.requestFocus(virtualDataset);

              if (oncreate) oncreate();
            });
          }
        }, {
          key: '_showRemapper',
          value: function _showRemapper(sourceObservedProperty, targetObservedProperty, mapping, onapply) {
            var remapper = new Remapper('remapper');

            var sourceCategories = sourceObservedProperty.categories.map(function (cat) {
              // TODO be more clever about colors
              var color = cat.preferredColor || 'grey';
              return {
                id: cat.id,
                label: i18n(cat.label),
                color: color
              };
            });
            var targetCategories = targetObservedProperty.categories.map(function (cat) {
              // TODO be more clever about colors
              var color = cat.preferredColor || 'grey';
              return {
                id: cat.id,
                label: i18n(cat.label),
                color: color
              };
            });

            remapper.populateFroms(sourceCategories);
            remapper.populateTos(targetCategories);
            if (mapping) {
              setTimeout(function () {
                return remapper.linkCategories(mapping);
              }, 100);
            }

            remapper.on('apply', function (data) {
              remapper.remove(); // we create a fresh one each time
              onapply(data);
            });

            remapper.show();
          }

          /**
           * Returns all distributions which have categories, including categories contained in coverage data.
           */
        }, {
          key: '_findCategoryDistributions',
          value: function _findCategoryDistributions() {
            return this.context.workspace.filterDistributions(function (dist) {
              if (dist.formatImpl instanceof CoverageData) {
                var cov = dist.data;
                // check for categorical parameters
                if (cov.parameters) {
                  var _iteratorNormalCompletion7 = true;
                  var _didIteratorError7 = false;
                  var _iteratorError7 = undefined;

                  try {
                    for (var _iterator7 = cov.parameters.values()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                      var param = _step7.value;

                      if (!param.observedProperty.categories) continue;
                      return true;
                    }
                  } catch (err) {
                    _didIteratorError7 = true;
                    _iteratorError7 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion7 && _iterator7['return']) {
                        _iterator7['return']();
                      }
                    } finally {
                      if (_didIteratorError7) {
                        throw _iteratorError7;
                      }
                    }
                  }
                }
              }
            });
          }

          /**
           * Returns all distributions which are a category remapping and are compatible to the source categories.
           */
        }, {
          key: '_findRemappingDistributions',
          value: function _findRemappingDistributions(sourceParameter) {
            var sourceCats = new Set(sourceParameter.observedProperty.categories.map(function (c) {
              return c.id;
            }));
            return this.context.workspace.filterDistributions(function (dist) {
              if (!(dist.formatImpl instanceof CatRemap)) return false;
              return dist.data.categoryMappings.some(function (m) {
                return sourceCats.has(m.sourceCategory);
              });
            });
          }

          /**
           * Returns whether the associated distribution is a result of a remapping.
           */
        }, {
          key: '_isRemapped',
          value: function _isRemapped() {
            // check Coverage data for remapping transformation

            // .transformations contains a record of all transformations that led to the this coverage data
            // The last applied transformation (which then directly resulted into this coverage data) is at the array end.
            if (!this.cov.transformations) return false;
            var trans = this.cov.transformations[this.cov.transformations.length - 1];
            return trans.operation.type === 'CategoryRemappingOperation';
          }
        }, {
          key: 'isSupported',
          get: function get() {
            // Use Case: Category Remapping for grids
            // Current restriction: data is single grid coverage with one or more categorical parameters
            if (this._isSingleCoverage(this.cov) && this.cov.domainType === COVJSON_GRID) {
              if (this._getCategoricalParams().length > 0) {
                return true;
              }
            }
            return false;
          }
        }]);
        return CoverageRemapCategories;
      })(Action);

      _export('default', CoverageRemapCategories);

      CoverageRemapCategories.type = PROCESS;
    }
  };
});

$__System.registerDynamic("27", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.shallowcopy = shallowcopy;
  function shallowcopy(obj) {
    var copy = void 0;
    if (obj instanceof Map) {
      copy = new Map(obj);
    } else {
      copy = Object.create(Object.getPrototypeOf(obj));
      for (var prop in obj) {
        copy[prop] = obj[prop];
      }
    }
    return copy;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2a", ["34", "28", "35", "27", "36", "37"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.withSimpleDerivedParameter = undefined;
  var _slicedToArray = function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  exports.withParameters = withParameters;
  exports.withCategories = withCategories;
  exports.withDomainType = withDomainType;
  exports.asCovJSONDomainType = asCovJSONDomainType;
  exports.renameAxes = renameAxes;
  exports.mapRange = mapRange;
  exports.withDerivedParameter = withDerivedParameter;
  exports.maskByPolygon = maskByPolygon;
  var _ndarray = req('34');
  var _ndarray2 = _interopRequireDefault(_ndarray);
  var _constants = req('28');
  var _validate = req('35');
  var _util = req('27');
  var _polygon = req('36');
  var _create = req('37');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0,
          arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  function withParameters(cov, params) {
    var newcov = {
      type: _constants.COVERAGE,
      domainType: cov.domainType,
      parameters: params,
      loadDomain: function loadDomain() {
        return cov.loadDomain();
      },
      loadRange: function loadRange(key) {
        return cov.loadRange(key);
      },
      loadRanges: function loadRanges(keys) {
        return cov.loadRanges(keys);
      },
      subsetByIndex: function subsetByIndex(constraints) {
        return cov.subsetByIndex(constraints).then(function(sub) {
          return withParameters(sub, params);
        });
      },
      subsetByValue: function subsetByValue(constraints) {
        return cov.subsetByValue(constraints).then(function(sub) {
          return withParameters(sub, params);
        });
      }
    };
    return newcov;
  }
  function withCategories(cov, key, observedProperty, mapping) {
    (0, _validate.checkCoverage)(cov);
    if (observedProperty.categories.some(function(c) {
      return !c.id;
    })) {
      throw new Error('At least one category object is missing the "id" property');
    }
    var newparams = (0, _util.shallowcopy)(cov.parameters);
    var newparam = (0, _util.shallowcopy)(newparams.get(key));
    newparams.set(key, newparam);
    newparams.get(key).observedProperty = observedProperty;
    var fromCatEnc = cov.parameters.get(key).categoryEncoding;
    var catEncoding = new Map();
    var categories = observedProperty.categories;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;
    try {
      for (var _iterator = categories[Symbol.iterator](),
          _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var category = _step.value;
        var vals = [];
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;
        try {
          for (var _iterator2 = mapping[Symbol.iterator](),
              _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _step2$value = _slicedToArray(_step2.value, 2);
            var fromCatId = _step2$value[0];
            var toCatId = _step2$value[1];
            if (toCatId === category.id && fromCatEnc.has(fromCatId)) {
              vals.push.apply(vals, _toConsumableArray(fromCatEnc.get(fromCatId)));
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        if (vals.length > 0) {
          catEncoding.set(category.id, vals);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    newparams.get(key).categoryEncoding = catEncoding;
    var newcov = withParameters(cov, newparams);
    return newcov;
  }
  function withDomainType(cov, domainType) {
    (0, _validate.checkCoverage)(cov);
    var domainWrapper = function domainWrapper(domain) {
      var newdomain = {
        type: _constants.DOMAIN,
        domainType: domainType,
        axes: domain.axes,
        referencing: domain.referencing
      };
      return newdomain;
    };
    var newcov = {
      type: _constants.COVERAGE,
      domainType: domainType,
      parameters: cov.parameters,
      loadDomain: function loadDomain() {
        return cov.loadDomain().then(domainWrapper);
      },
      loadRange: function loadRange(key) {
        return cov.loadRange(key);
      },
      loadRanges: function loadRanges(keys) {
        return cov.loadRanges(keys);
      },
      subsetByIndex: function subsetByIndex(constraints) {
        return cov.subsetByIndex(constraints).then(function(sub) {
          return withDomainType(sub, domainType);
        });
      },
      subsetByValue: function subsetByValue(constraints) {
        return cov.subsetByValue(constraints).then(function(sub) {
          return withDomainType(sub, domainType);
        });
      }
    };
    return newcov;
  }
  function asCovJSONDomainType(cov) {
    return cov.loadDomain().then(function(domain) {});
  }
  function renameAxes(cov, mapping) {
    (0, _validate.checkCoverage)(cov);
    mapping = new Map(mapping);
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;
    try {
      for (var _iterator3 = cov.axes.keys()[Symbol.iterator](),
          _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var axisName = _step3.value;
        if (!mapping.has(axisName)) {
          mapping.set(axisName, axisName);
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
    var domainWrapper = function domainWrapper(domain) {
      var newaxes = new Map();
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;
      try {
        for (var _iterator4 = mapping[Symbol.iterator](),
            _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _step4$value = _slicedToArray(_step4.value, 2);
          var from = _step4$value[0];
          var to = _step4$value[1];
          var _domain$axes$get = domain.axes.get(from);
          var dataType = _domain$axes$get.dataType;
          var components = _domain$axes$get.components;
          var values = _domain$axes$get.values;
          var bounds = _domain$axes$get.bounds;
          var newaxis = {
            key: to,
            dataType: dataType,
            components: components.map(function(c) {
              return mapping.has(c) ? mapping.get(c) : c;
            }),
            values: values,
            bounds: bounds
          };
          newaxes.set(to, newaxis);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
      var newreferencing = domain.referencing.map(function(_ref) {
        var components = _ref.components;
        var system = _ref.system;
        return {
          components: components.map(function(c) {
            return mapping.has(c) ? mapping.get(c) : c;
          }),
          system: system
        };
      });
      var newdomain = {
        type: _constants.DOMAIN,
        domainType: domain.domainType,
        axes: newaxes,
        referencing: newreferencing
      };
      return newdomain;
    };
    var getObjStr = [].concat(_toConsumableArray(mapping)).map(function(_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2);
      var from = _ref3[0];
      var to = _ref3[1];
      return '[\'' + from + '\']:obj[\'' + to + '\']';
    }).join(',');
    var rangeWrapper = function rangeWrapper(range) {
      var newrange = {
        shape: new Map([].concat(_toConsumableArray(range.shape)).map(function(_ref4) {
          var _ref5 = _slicedToArray(_ref4, 2);
          var name = _ref5[0];
          var len = _ref5[1];
          return [mapping.get(name), len];
        })),
        dataType: range.dataType,
        get: new Function('range', 'return function get (obj){return range.get({' + getObjStr + '})}')(range)
      };
      return newrange;
    };
    var loadRange = function loadRange(paramKey) {
      return cov.loadRange(paramKey).then(rangeWrapper);
    };
    var loadRanges = function loadRanges(paramKeys) {
      return cov.loadRanges(paramKeys).then(function(ranges) {
        return new Map([].concat(_toConsumableArray(ranges)).map(function(_ref6) {
          var _ref7 = _slicedToArray(_ref6, 2);
          var paramKey = _ref7[0];
          var range = _ref7[1];
          return [paramKey, rangeWrapper(range)];
        }));
      });
    };
    var newcov = {
      type: _constants.COVERAGE,
      domainType: cov.domainType,
      parameters: cov.parameters,
      loadDomain: function loadDomain() {
        return cov.loadDomain().then(domainWrapper);
      },
      loadRange: loadRange,
      loadRanges: loadRanges,
      subsetByIndex: function subsetByIndex(constraints) {
        return cov.subsetByIndex(constraints).then(function(sub) {
          return renameAxes(sub, mapping);
        });
      },
      subsetByValue: function subsetByValue(constraints) {
        return cov.subsetByValue(constraints).then(function(sub) {
          return renameAxes(sub, mapping);
        });
      }
    };
    return newcov;
  }
  function mapRange(cov, key, fn, dataType) {
    (0, _validate.checkCoverage)(cov);
    var rangeWrapper = function rangeWrapper(range) {
      var newrange = {
        shape: range.shape,
        dataType: dataType || range.dataType,
        get: function get(obj) {
          return fn(obj, range);
        }
      };
      return newrange;
    };
    var loadRange = function loadRange(paramKey) {
      return key === paramKey ? cov.loadRange(paramKey).then(rangeWrapper) : cov.loadRange(paramKey);
    };
    var loadRanges = function loadRanges(paramKeys) {
      return cov.loadRanges(paramKeys).then(function(ranges) {
        return new Map([].concat(_toConsumableArray(ranges)).map(function(_ref8) {
          var _ref9 = _slicedToArray(_ref8, 2);
          var paramKey = _ref9[0];
          var range = _ref9[1];
          return [paramKey, key === paramKey ? rangeWrapper(range) : range];
        }));
      });
    };
    var newcov = {
      type: _constants.COVERAGE,
      domainType: cov.domainType,
      parameters: cov.parameters,
      loadDomain: function loadDomain() {
        return cov.loadDomain();
      },
      loadRange: loadRange,
      loadRanges: loadRanges,
      subsetByIndex: function subsetByIndex(constraints) {
        return cov.subsetByIndex(constraints).then(function(sub) {
          return mapRange(sub, key, fn, dataType);
        });
      },
      subsetByValue: function subsetByValue(constraints) {
        return cov.subsetByValue(constraints).then(function(sub) {
          return mapRange(sub, key, fn, dataType);
        });
      }
    };
    return newcov;
  }
  function withDerivedParameter(cov, options) {
    (0, _validate.checkCoverage)(cov);
    var parameter = options.parameter;
    var inputParameters = options.inputParameters;
    var _options$dataType = options.dataType;
    var dataType = _options$dataType === undefined ? 'float' : _options$dataType;
    var fn = options.fn;
    var parameters = new Map(cov.parameters);
    parameters.set(parameter.key, parameter);
    var loadDerivedRange = function loadDerivedRange() {
      return cov.loadRanges(inputParameters).then(function(inputRanges) {
        var inputRangesArr = inputParameters.map(function(key) {
          return inputRanges.get(key);
        });
        var shape = inputRangesArr[0].shape;
        var range = {
          shape: shape,
          dataType: dataType,
          get: function get(obj) {
            return fn.apply(undefined, [obj].concat(_toConsumableArray(inputRangesArr)));
          }
        };
        return range;
      });
    };
    var loadRange = function loadRange(paramKey) {
      return parameter.key === paramKey ? loadDerivedRange() : cov.loadRange(paramKey);
    };
    var newcov = {
      type: _constants.COVERAGE,
      domainType: cov.domainType,
      parameters: parameters,
      loadDomain: function loadDomain() {
        return cov.loadDomain();
      },
      loadRange: loadRange,
      subsetByIndex: function subsetByIndex(constraints) {
        return cov.subsetByIndex(constraints).then(function(sub) {
          return withDerivedParameter(sub, options);
        });
      },
      subsetByValue: function subsetByValue(constraints) {
        return cov.subsetByValue(constraints).then(function(sub) {
          return withDerivedParameter(sub, options);
        });
      }
    };
    (0, _create.addLoadRangesFunction)(newcov);
    return newcov;
  }
  function withSimpleDerivedParameter(cov, options) {
    var parameter = options.parameter;
    var inputParameters = options.inputParameters;
    var dataType = options.dataType;
    var _fn = options.fn;
    var options_ = {
      parameter: parameter,
      inputParameters: inputParameters,
      dataType: dataType,
      fn: function fn(obj) {
        for (var _len = arguments.length,
            ranges = Array(_len > 1 ? _len - 1 : 0),
            _key = 1; _key < _len; _key++) {
          ranges[_key - 1] = arguments[_key];
        }
        var vals = inputParameters.map(function(_, i) {
          return ranges[i].get(obj);
        });
        if (vals.some(function(val) {
          return val === null;
        })) {
          return null;
        }
        return _fn.apply(undefined, _toConsumableArray(vals));
      }
    };
    return withDerivedParameter(cov, options_);
  }
  exports.withSimpleDerivedParameter = withSimpleDerivedParameter;
  function maskByPolygon(cov, polygon) {
    var axes = arguments.length <= 2 || arguments[2] === undefined ? ['x', 'y'] : arguments[2];
    (0, _validate.checkCoverage)(cov);
    if (polygon.type === 'Polygon') {
      polygon = {
        type: 'MultiPolygon',
        coordinates: [polygon.coordinates]
      };
    }
    var polygons = polygon.coordinates;
    polygons.forEach(function(p) {
      return (0, _polygon.ensureClockwisePolygon)(p);
    });
    var pip = (0, _polygon.getPointInPolygonsFn)(polygons);
    var _axes = _slicedToArray(axes, 2);
    var X = _axes[0];
    var Y = _axes[1];
    return cov.loadDomain().then(function(domain) {
      var x = domain.axes.get(X).values;
      var y = domain.axes.get(Y).values;
      var pnpolyCache = (0, _ndarray2.default)(new Uint8Array(x.length * y.length), [x.length, y.length]);
      for (var i = 0; i < x.length; i++) {
        for (var j = 0; j < y.length; j++) {
          var inside = pip([x[i], y[j]]) >= 0;
          pnpolyCache.set(i, j, inside);
        }
      }
      var fn = function fn(obj, range) {
        if (pnpolyCache.get(obj[X] || 0, obj[Y] || 0)) {
          return range.get(obj);
        } else {
          return null;
        }
      };
      var newcov = cov;
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;
      try {
        for (var _iterator5 = cov.parameters.keys()[Symbol.iterator](),
            _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var key = _step5.value;
          newcov = mapRange(newcov, key, fn);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
      return newcov;
    });
  }
  global.define = __define;
  return module.exports;
});

$__System.register('38', ['8', '9', 'c', '2a', 'b'], function (_export) {
  'use strict';

  var $, $$, HTML, i18n, Modal, withSimpleDerivedParameter, Action, PROCESS, html, TEMPLATES, CoverageDeriveParameter;
  return {
    setters: [function (_) {
      $ = _.$;
      $$ = _.$$;
      HTML = _.HTML;
    }, function (_2) {
      i18n = _2.i18n;
    }, function (_c) {
      Modal = _c['default'];
    }, function (_a) {
      withSimpleDerivedParameter = _a.withSimpleDerivedParameter;
    }, function (_b) {
      Action = _b['default'];
      PROCESS = _b.PROCESS;
    }],
    execute: function () {
      html = '\n<div class="modal fade" id="deriveParameterModal" tabindex="-1" role="dialog" aria-labelledby="deriveParameterModalLabel">\n  <div class="modal-dialog" role="document">\n    <div class="modal-content">\n      <div class="modal-header">\n        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>\n        <h4 class="modal-title" id="deriveParameterModalLabel">Derive a Parameter</h4>\n      </div>\n      <div class="modal-body">\n        <div class="panel panel-primary derive-input-parameters">\n          <div class="panel-heading">\n            <h4>Select input parameters</h4>\n          </div>\n          <div class="panel-body input-parameters">\n          </div>\n        </div>\n        \n        <div class="panel panel-primary derive-ouput-parameter">\n          <div class="panel-heading">\n            <h4>Define derived parameter</h4>\n          </div>\n          <div class="panel-body">\n            \n            <div class="form-horizontal">\n              <div class="form-group">\n                <label for="inputParameterKey" class="col-sm-2 control-label">ID</label>\n                <div class="col-sm-10">\n                  <input type="text" class="form-control" id="inputParameterKey" placeholder="salinity">\n                </div>\n              </div>\n              <div class="form-group">\n                <label for="inputObservedPropertyLabel" class="col-sm-2 control-label">Observed Property</label>\n                <div class="col-sm-10">\n                  <input type="text" class="form-control" id="inputObservedPropertyLabel" placeholder="Sea Water Salinity">\n                </div>\n              </div>\n              <div class="form-group">\n                <label for="inputParameterUnits" class="col-sm-2 control-label">Units</label>\n                <div class="col-sm-10">\n                  <input type="text" class="form-control" id="inputParameterUnits">\n                </div>\n              </div>\n              <div class="form-group">\n                <label for="inputParameterFormula" class="col-sm-2 control-label">Formula</label>\n                <div class="col-sm-10">\n                  <input type="text" class="form-control" id="inputParameterFormula">\n                </div>\n              </div>\n              <div class="form-group">\n                <div class="col-sm-offset-2 col-sm-10 submit-button-container">\n                </div>\n              </div>\n            </div>\n  \n          </div>\n        </div>\n               \n      </div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>\n      </div>\n    </div>\n  </div>\n</div>\n';

      $('body').add(HTML(html));

      TEMPLATES = {
        'input-parameter': '\n  <div class="checkbox">\n    <label>\n      <input type="checkbox" class="input-parameter-key">\n      <code class="parameter-key"></code> - <span class="observedProperty-label"></span>\n    </label>\n  </div>\n  ',
        'submit-button': '\n  <button type="submit" class="btn btn-primary submit-button" data-dismiss="modal">Confirm</button>\n  '
      };

      CoverageDeriveParameter = (function (_Action) {
        babelHelpers.inherits(CoverageDeriveParameter, _Action);

        function CoverageDeriveParameter(data, context) {
          babelHelpers.classCallCheck(this, CoverageDeriveParameter);

          babelHelpers.get(Object.getPrototypeOf(CoverageDeriveParameter.prototype), 'constructor', this).call(this, context);

          if (this._isSingleCoverage(data)) {
            this.cov = this._getSingleCoverage(data);
          } else {
            this.cov = data;
          }

          this.label = 'Derive';
          this.icon = '<span class="glyphicon glyphicon-plus"></span>';
        }

        // TODO code duplication with CoverageRemapCategories.js
        babelHelpers.createClass(CoverageDeriveParameter, [{
          key: '_isSingleCoverage',
          value: function _isSingleCoverage(cov) {
            try {
              this._getSingleCoverage(cov);
              return true;
            } catch (e) {
              return false;
            }
          }
        }, {
          key: '_getSingleCoverage',
          value: function _getSingleCoverage(cov) {
            if (!cov.coverages) {
              return cov;
            } else if (cov.coverages.length === 1) {
              return cov.coverages[0];
            } else {
              throw new Error('not a single coverage');
            }
          }
        }, {
          key: 'run',
          value: function run() {
            var _this = this;

            // Step 1: Display modal with fields for parameter key, label, unit, input parameters, formula
            // Step 2: Save

            var cov = this.cov;

            var modalEl = $('#deriveParameterModal');

            // clean old inputs
            $('.input-parameters', modalEl).fill();
            $$('#inputParameterKey', modalEl).value = '';
            $$('#inputObservedPropertyLabel', modalEl).value = '';
            $$('#inputParameterUnits', modalEl).value = '';
            $$('#inputParameterFormula', modalEl).value = '';

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = cov.parameters.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var parameter = _step.value;

                var _el = $(HTML(TEMPLATES['input-parameter']));

                $$('.input-parameter-key', _el).value = parameter.key;
                $('.parameter-key', _el).fill(parameter.key);
                $('.observedProperty-label', _el).fill(i18n(parameter.observedProperty.label));

                $('input', _el).on('|click', function () {
                  var formulaInput = $$('#inputParameterFormula', modalEl);
                  if (formulaInput.value) return;
                  // update formula placeholder to provide some guidance
                  var keys = _this._getCheckedParameterKeys(modalEl);
                  formulaInput.placeholder = keys.join(' + ');
                });

                $('.input-parameters', modalEl).add(_el);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            var el = $(HTML(TEMPLATES['submit-button']));
            $('.submit-button-container', modalEl).fill().add(el);

            $('.submit-button', modalEl).on('?click', function () {
              var inputKeys = _this._getCheckedParameterKeys(modalEl);
              var key = $$('#inputParameterKey', modalEl).value;
              var propLabel = $$('#inputObservedPropertyLabel', modalEl).value;
              var units = $$('#inputParameterUnits', modalEl).value;
              var formula = $$('#inputParameterFormula', modalEl).value;

              if (!inputKeys.length || !key || !propLabel || !formula) {
                alert('Input parameters, ID, observed property, and formula are required');
                return;
              }

              var fn = new (babelHelpers.bind.apply(Function, [null].concat(babelHelpers.toConsumableArray(inputKeys), ['return ' + formula])))();
              try {
                var testVals = inputKeys.map(function () {
                  return Math.random();
                });
                fn.apply(undefined, babelHelpers.toConsumableArray(testVals));
              } catch (e) {
                alert('Invalid formula: ' + e);
                return;
              }
              console.log(fn.toString());

              _this._createVirtualDataset(inputKeys, key, propLabel, units, fn);

              return true;
            });

            new Modal(modalEl[0]).open();
          }
        }, {
          key: '_createVirtualDataset',
          value: function _createVirtualDataset(inputKeys, key, propLabel, units, fn) {
            var parameter = {
              key: key,
              observedProperty: {
                label: { en: propLabel }
              }
            };
            if (units) {
              parameter.unit = {
                symbol: units
              };
            }

            var derivedCov = withSimpleDerivedParameter(this.cov, {
              parameter: parameter,
              inputParameters: inputKeys,
              fn: fn
            });

            var appendTitle = ' [derived: ' + key + ']';

            var virtualDataset = {
              title: { en: i18n(this.context.dataset.title) + appendTitle },
              virtual: true,
              distributions: [{
                title: { en: i18n(this.context.distribution.title) + appendTitle },
                mediaType: 'coveragedata',
                data: derivedCov
              }]
            };
            var workspace = this.context.workspace;

            workspace.addDataset(virtualDataset, this.context.dataset);
            workspace.requestFocus(virtualDataset);
          }
        }, {
          key: '_getCheckedParameterKeys',
          value: function _getCheckedParameterKeys(modalEl) {
            var inputs = $('.input-parameter-key', modalEl).array();
            var checked = inputs.filter(function (el) {
              return el.checked;
            });
            return checked.map(function (el) {
              return el.value;
            });
          }
        }, {
          key: 'isSupported',
          get: function get() {
            if (this._isSingleCoverage(this.cov)) {
              return true;
            }
            return false;
          }
        }]);
        return CoverageDeriveParameter;
      })(Action);

      _export('default', CoverageDeriveParameter);

      CoverageDeriveParameter.type = PROCESS;
    }
  };
});

$__System.register("39", [], function() { return { setters: [], execute: function() {} } });

$__System.registerDynamic("3a", ["3b"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(window) {
    'use strict';
    var c3 = {version: "0.4.11-rc4"};
    var c3_chart_fn,
        c3_chart_internal_fn,
        c3_chart_internal_axis_fn;
    function API(owner) {
      this.owner = owner;
    }
    function inherit(base, derived) {
      if (Object.create) {
        derived.prototype = Object.create(base.prototype);
      } else {
        var f = function f() {};
        f.prototype = base.prototype;
        derived.prototype = new f();
      }
      derived.prototype.constructor = derived;
      return derived;
    }
    function Chart(config) {
      var $$ = this.internal = new ChartInternal(this);
      $$.loadConfig(config);
      $$.beforeInit(config);
      $$.init();
      $$.afterInit(config);
      (function bindThis(fn, target, argThis) {
        Object.keys(fn).forEach(function(key) {
          target[key] = fn[key].bind(argThis);
          if (Object.keys(fn[key]).length > 0) {
            bindThis(fn[key], target[key], argThis);
          }
        });
      })(c3_chart_fn, this, this);
    }
    function ChartInternal(api) {
      var $$ = this;
      $$.d3 = window.d3 ? window.d3 : typeof req !== 'undefined' ? req('3b') : undefined;
      $$.api = api;
      $$.config = $$.getDefaultConfig();
      $$.data = {};
      $$.cache = {};
      $$.axes = {};
    }
    c3.generate = function(config) {
      return new Chart(config);
    };
    c3.chart = {
      fn: Chart.prototype,
      internal: {
        fn: ChartInternal.prototype,
        axis: {fn: Axis.prototype}
      }
    };
    c3_chart_fn = c3.chart.fn;
    c3_chart_internal_fn = c3.chart.internal.fn;
    c3_chart_internal_axis_fn = c3.chart.internal.axis.fn;
    c3_chart_internal_fn.beforeInit = function() {};
    c3_chart_internal_fn.afterInit = function() {};
    c3_chart_internal_fn.init = function() {
      var $$ = this,
          config = $$.config;
      $$.initParams();
      if (config.data_url) {
        $$.convertUrlToData(config.data_url, config.data_mimeType, config.data_keys, $$.initWithData);
      } else if (config.data_json) {
        $$.initWithData($$.convertJsonToData(config.data_json, config.data_keys));
      } else if (config.data_rows) {
        $$.initWithData($$.convertRowsToData(config.data_rows));
      } else if (config.data_columns) {
        $$.initWithData($$.convertColumnsToData(config.data_columns));
      } else {
        throw Error('url or json or rows or columns is required.');
      }
    };
    c3_chart_internal_fn.initParams = function() {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config;
      $$.clipId = "c3-" + (+new Date()) + '-clip', $$.clipIdForXAxis = $$.clipId + '-xaxis', $$.clipIdForYAxis = $$.clipId + '-yaxis', $$.clipIdForGrid = $$.clipId + '-grid', $$.clipIdForSubchart = $$.clipId + '-subchart', $$.clipPath = $$.getClipPath($$.clipId), $$.clipPathForXAxis = $$.getClipPath($$.clipIdForXAxis), $$.clipPathForYAxis = $$.getClipPath($$.clipIdForYAxis);
      $$.clipPathForGrid = $$.getClipPath($$.clipIdForGrid), $$.clipPathForSubchart = $$.getClipPath($$.clipIdForSubchart), $$.dragStart = null;
      $$.dragging = false;
      $$.flowing = false;
      $$.cancelClick = false;
      $$.mouseover = false;
      $$.transiting = false;
      $$.color = $$.generateColor();
      $$.levelColor = $$.generateLevelColor();
      $$.dataTimeFormat = config.data_xLocaltime ? d3.time.format : d3.time.format.utc;
      $$.axisTimeFormat = config.axis_x_localtime ? d3.time.format : d3.time.format.utc;
      $$.defaultAxisTimeFormat = $$.axisTimeFormat.multi([[".%L", function(d) {
        return d.getMilliseconds();
      }], [":%S", function(d) {
        return d.getSeconds();
      }], ["%I:%M", function(d) {
        return d.getMinutes();
      }], ["%I %p", function(d) {
        return d.getHours();
      }], ["%-m/%-d", function(d) {
        return d.getDay() && d.getDate() !== 1;
      }], ["%-m/%-d", function(d) {
        return d.getDate() !== 1;
      }], ["%-m/%-d", function(d) {
        return d.getMonth();
      }], ["%Y/%-m/%-d", function() {
        return true;
      }]]);
      $$.hiddenTargetIds = [];
      $$.hiddenLegendIds = [];
      $$.focusedTargetIds = [];
      $$.defocusedTargetIds = [];
      $$.xOrient = config.axis_rotated ? "left" : "bottom";
      $$.yOrient = config.axis_rotated ? (config.axis_y_inner ? "top" : "bottom") : (config.axis_y_inner ? "right" : "left");
      $$.y2Orient = config.axis_rotated ? (config.axis_y2_inner ? "bottom" : "top") : (config.axis_y2_inner ? "left" : "right");
      $$.subXOrient = config.axis_rotated ? "left" : "bottom";
      $$.isLegendRight = config.legend_position === 'right';
      $$.isLegendInset = config.legend_position === 'inset';
      $$.isLegendTop = config.legend_inset_anchor === 'top-left' || config.legend_inset_anchor === 'top-right';
      $$.isLegendLeft = config.legend_inset_anchor === 'top-left' || config.legend_inset_anchor === 'bottom-left';
      $$.legendStep = 0;
      $$.legendItemWidth = 0;
      $$.legendItemHeight = 0;
      $$.currentMaxTickWidths = {
        x: 0,
        y: 0,
        y2: 0
      };
      $$.rotated_padding_left = 30;
      $$.rotated_padding_right = config.axis_rotated && !config.axis_x_show ? 0 : 30;
      $$.rotated_padding_top = 5;
      $$.withoutFadeIn = {};
      $$.intervalForObserveInserted = undefined;
      $$.axes.subx = d3.selectAll([]);
    };
    c3_chart_internal_fn.initChartElements = function() {
      if (this.initBar) {
        this.initBar();
      }
      if (this.initLine) {
        this.initLine();
      }
      if (this.initArc) {
        this.initArc();
      }
      if (this.initGauge) {
        this.initGauge();
      }
      if (this.initText) {
        this.initText();
      }
    };
    c3_chart_internal_fn.initWithData = function(data) {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config;
      var defs,
          main,
          binding = true;
      $$.axis = new Axis($$);
      if ($$.initPie) {
        $$.initPie();
      }
      if ($$.initBrush) {
        $$.initBrush();
      }
      if ($$.initZoom) {
        $$.initZoom();
      }
      if (!config.bindto) {
        $$.selectChart = d3.selectAll([]);
      } else if (typeof config.bindto.node === 'function') {
        $$.selectChart = config.bindto;
      } else {
        $$.selectChart = d3.select(config.bindto);
      }
      if ($$.selectChart.empty()) {
        $$.selectChart = d3.select(document.createElement('div')).style('opacity', 0);
        $$.observeInserted($$.selectChart);
        binding = false;
      }
      $$.selectChart.html("").classed("c3", true);
      $$.data.xs = {};
      $$.data.targets = $$.convertDataToTargets(data);
      if (config.data_filter) {
        $$.data.targets = $$.data.targets.filter(config.data_filter);
      }
      if (config.data_hide) {
        $$.addHiddenTargetIds(config.data_hide === true ? $$.mapToIds($$.data.targets) : config.data_hide);
      }
      if (config.legend_hide) {
        $$.addHiddenLegendIds(config.legend_hide === true ? $$.mapToIds($$.data.targets) : config.legend_hide);
      }
      if ($$.hasType('gauge')) {
        config.legend_show = false;
      }
      $$.updateSizes();
      $$.updateScales();
      $$.x.domain(d3.extent($$.getXDomain($$.data.targets)));
      $$.y.domain($$.getYDomain($$.data.targets, 'y'));
      $$.y2.domain($$.getYDomain($$.data.targets, 'y2'));
      $$.subX.domain($$.x.domain());
      $$.subY.domain($$.y.domain());
      $$.subY2.domain($$.y2.domain());
      $$.orgXDomain = $$.x.domain();
      if ($$.brush) {
        $$.brush.scale($$.subX);
      }
      if (config.zoom_enabled) {
        $$.zoom.scale($$.x);
      }
      $$.svg = $$.selectChart.append("svg").style("overflow", "hidden").on('mouseenter', function() {
        return config.onmouseover.call($$);
      }).on('mouseleave', function() {
        return config.onmouseout.call($$);
      });
      defs = $$.svg.append("defs");
      $$.clipChart = $$.appendClip(defs, $$.clipId);
      $$.clipXAxis = $$.appendClip(defs, $$.clipIdForXAxis);
      $$.clipYAxis = $$.appendClip(defs, $$.clipIdForYAxis);
      $$.clipGrid = $$.appendClip(defs, $$.clipIdForGrid);
      $$.clipSubchart = $$.appendClip(defs, $$.clipIdForSubchart);
      $$.updateSvgSize();
      main = $$.main = $$.svg.append("g").attr("transform", $$.getTranslate('main'));
      if ($$.initSubchart) {
        $$.initSubchart();
      }
      if ($$.initTooltip) {
        $$.initTooltip();
      }
      if ($$.initLegend) {
        $$.initLegend();
      }
      if ($$.initTitle) {
        $$.initTitle();
      }
      main.append("text").attr("class", CLASS.text + ' ' + CLASS.empty).attr("text-anchor", "middle").attr("dominant-baseline", "middle");
      $$.initRegion();
      $$.initGrid();
      main.append('g').attr("clip-path", $$.clipPath).attr('class', CLASS.chart);
      if (config.grid_lines_front) {
        $$.initGridLines();
      }
      $$.initEventRect();
      $$.initChartElements();
      main.insert('rect', config.zoom_privileged ? null : 'g.' + CLASS.regions).attr('class', CLASS.zoomRect).attr('width', $$.width).attr('height', $$.height).style('opacity', 0).on("dblclick.zoom", null);
      if (config.axis_x_extent) {
        $$.brush.extent($$.getDefaultExtent());
      }
      $$.axis.init();
      $$.updateTargets($$.data.targets);
      if (binding) {
        $$.updateDimension();
        $$.config.oninit.call($$);
        $$.redraw({
          withTransition: false,
          withTransform: true,
          withUpdateXDomain: true,
          withUpdateOrgXDomain: true,
          withTransitionForAxis: false
        });
      }
      $$.bindResize();
      $$.api.element = $$.selectChart.node();
    };
    c3_chart_internal_fn.smoothLines = function(el, type) {
      var $$ = this;
      if (type === 'grid') {
        el.each(function() {
          var g = $$.d3.select(this),
              x1 = g.attr('x1'),
              x2 = g.attr('x2'),
              y1 = g.attr('y1'),
              y2 = g.attr('y2');
          g.attr({
            'x1': Math.ceil(x1),
            'x2': Math.ceil(x2),
            'y1': Math.ceil(y1),
            'y2': Math.ceil(y2)
          });
        });
      }
    };
    c3_chart_internal_fn.updateSizes = function() {
      var $$ = this,
          config = $$.config;
      var legendHeight = $$.legend ? $$.getLegendHeight() : 0,
          legendWidth = $$.legend ? $$.getLegendWidth() : 0,
          legendHeightForBottom = $$.isLegendRight || $$.isLegendInset ? 0 : legendHeight,
          hasArc = $$.hasArcType(),
          xAxisHeight = config.axis_rotated || hasArc ? 0 : $$.getHorizontalAxisHeight('x'),
          subchartHeight = config.subchart_show && !hasArc ? (config.subchart_size_height + xAxisHeight) : 0;
      $$.currentWidth = $$.getCurrentWidth();
      $$.currentHeight = $$.getCurrentHeight();
      $$.margin = config.axis_rotated ? {
        top: $$.getHorizontalAxisHeight('y2') + $$.getCurrentPaddingTop(),
        right: hasArc ? 0 : $$.getCurrentPaddingRight(),
        bottom: $$.getHorizontalAxisHeight('y') + legendHeightForBottom + $$.getCurrentPaddingBottom(),
        left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
      } : {
        top: 4 + $$.getCurrentPaddingTop(),
        right: hasArc ? 0 : $$.getCurrentPaddingRight(),
        bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),
        left: hasArc ? 0 : $$.getCurrentPaddingLeft()
      };
      $$.margin2 = config.axis_rotated ? {
        top: $$.margin.top,
        right: NaN,
        bottom: 20 + legendHeightForBottom,
        left: $$.rotated_padding_left
      } : {
        top: $$.currentHeight - subchartHeight - legendHeightForBottom,
        right: NaN,
        bottom: xAxisHeight + legendHeightForBottom,
        left: $$.margin.left
      };
      $$.margin3 = {
        top: 0,
        right: NaN,
        bottom: 0,
        left: 0
      };
      if ($$.updateSizeForLegend) {
        $$.updateSizeForLegend(legendHeight, legendWidth);
      }
      $$.width = $$.currentWidth - $$.margin.left - $$.margin.right;
      $$.height = $$.currentHeight - $$.margin.top - $$.margin.bottom;
      if ($$.width < 0) {
        $$.width = 0;
      }
      if ($$.height < 0) {
        $$.height = 0;
      }
      $$.width2 = config.axis_rotated ? $$.margin.left - $$.rotated_padding_left - $$.rotated_padding_right : $$.width;
      $$.height2 = config.axis_rotated ? $$.height : $$.currentHeight - $$.margin2.top - $$.margin2.bottom;
      if ($$.width2 < 0) {
        $$.width2 = 0;
      }
      if ($$.height2 < 0) {
        $$.height2 = 0;
      }
      $$.arcWidth = $$.width - ($$.isLegendRight ? legendWidth + 10 : 0);
      $$.arcHeight = $$.height - ($$.isLegendRight ? 0 : 10);
      if ($$.hasType('gauge')) {
        $$.arcHeight += $$.height - $$.getGaugeLabelHeight();
      }
      if ($$.updateRadius) {
        $$.updateRadius();
      }
      if ($$.isLegendRight && hasArc) {
        $$.margin3.left = $$.arcWidth / 2 + $$.radiusExpanded * 1.1;
      }
    };
    c3_chart_internal_fn.updateTargets = function(targets) {
      var $$ = this;
      $$.updateTargetsForText(targets);
      $$.updateTargetsForBar(targets);
      $$.updateTargetsForLine(targets);
      if ($$.hasArcType() && $$.updateTargetsForArc) {
        $$.updateTargetsForArc(targets);
      }
      if ($$.updateTargetsForSubchart) {
        $$.updateTargetsForSubchart(targets);
      }
      $$.showTargets();
    };
    c3_chart_internal_fn.showTargets = function() {
      var $$ = this;
      $$.svg.selectAll('.' + CLASS.target).filter(function(d) {
        return $$.isTargetToShow(d.id);
      }).transition().duration($$.config.transition_duration).style("opacity", 1);
    };
    c3_chart_internal_fn.redraw = function(options, transitions) {
      var $$ = this,
          main = $$.main,
          d3 = $$.d3,
          config = $$.config;
      var areaIndices = $$.getShapeIndices($$.isAreaType),
          barIndices = $$.getShapeIndices($$.isBarType),
          lineIndices = $$.getShapeIndices($$.isLineType);
      var withY,
          withSubchart,
          withTransition,
          withTransitionForExit,
          withTransitionForAxis,
          withTransform,
          withUpdateXDomain,
          withUpdateOrgXDomain,
          withTrimXDomain,
          withLegend,
          withEventRect,
          withDimension,
          withUpdateXAxis;
      var hideAxis = $$.hasArcType();
      var drawArea,
          drawBar,
          drawLine,
          xForText,
          yForText;
      var duration,
          durationForExit,
          durationForAxis;
      var waitForDraw,
          flow;
      var targetsToShow = $$.filterTargetsToShow($$.data.targets),
          tickValues,
          i,
          intervalForCulling,
          xDomainForZoom;
      var xv = $$.xv.bind($$),
          cx,
          cy;
      options = options || {};
      withY = getOption(options, "withY", true);
      withSubchart = getOption(options, "withSubchart", true);
      withTransition = getOption(options, "withTransition", true);
      withTransform = getOption(options, "withTransform", false);
      withUpdateXDomain = getOption(options, "withUpdateXDomain", false);
      withUpdateOrgXDomain = getOption(options, "withUpdateOrgXDomain", false);
      withTrimXDomain = getOption(options, "withTrimXDomain", true);
      withUpdateXAxis = getOption(options, "withUpdateXAxis", withUpdateXDomain);
      withLegend = getOption(options, "withLegend", false);
      withEventRect = getOption(options, "withEventRect", true);
      withDimension = getOption(options, "withDimension", true);
      withTransitionForExit = getOption(options, "withTransitionForExit", withTransition);
      withTransitionForAxis = getOption(options, "withTransitionForAxis", withTransition);
      duration = withTransition ? config.transition_duration : 0;
      durationForExit = withTransitionForExit ? duration : 0;
      durationForAxis = withTransitionForAxis ? duration : 0;
      transitions = transitions || $$.axis.generateTransitions(durationForAxis);
      if (withLegend && config.legend_show) {
        $$.updateLegend($$.mapToIds($$.data.targets), options, transitions);
      } else if (withDimension) {
        $$.updateDimension(true);
      }
      if ($$.isCategorized() && targetsToShow.length === 0) {
        $$.x.domain([0, $$.axes.x.selectAll('.tick').size()]);
      }
      if (targetsToShow.length) {
        $$.updateXDomain(targetsToShow, withUpdateXDomain, withUpdateOrgXDomain, withTrimXDomain);
        if (!config.axis_x_tick_values) {
          tickValues = $$.axis.updateXAxisTickValues(targetsToShow);
        }
      } else {
        $$.xAxis.tickValues([]);
        $$.subXAxis.tickValues([]);
      }
      if (config.zoom_rescale && !options.flow) {
        xDomainForZoom = $$.x.orgDomain();
      }
      $$.y.domain($$.getYDomain(targetsToShow, 'y', xDomainForZoom));
      $$.y2.domain($$.getYDomain(targetsToShow, 'y2', xDomainForZoom));
      if (!config.axis_y_tick_values && config.axis_y_tick_count) {
        $$.yAxis.tickValues($$.axis.generateTickValues($$.y.domain(), config.axis_y_tick_count));
      }
      if (!config.axis_y2_tick_values && config.axis_y2_tick_count) {
        $$.y2Axis.tickValues($$.axis.generateTickValues($$.y2.domain(), config.axis_y2_tick_count));
      }
      $$.axis.redraw(transitions, hideAxis);
      $$.axis.updateLabels(withTransition);
      if ((withUpdateXDomain || withUpdateXAxis) && targetsToShow.length) {
        if (config.axis_x_tick_culling && tickValues) {
          for (i = 1; i < tickValues.length; i++) {
            if (tickValues.length / i < config.axis_x_tick_culling_max) {
              intervalForCulling = i;
              break;
            }
          }
          $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').each(function(e) {
            var index = tickValues.indexOf(e);
            if (index >= 0) {
              d3.select(this).style('display', index % intervalForCulling ? 'none' : 'block');
            }
          });
        } else {
          $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').style('display', 'block');
        }
      }
      drawArea = $$.generateDrawArea ? $$.generateDrawArea(areaIndices, false) : undefined;
      drawBar = $$.generateDrawBar ? $$.generateDrawBar(barIndices) : undefined;
      drawLine = $$.generateDrawLine ? $$.generateDrawLine(lineIndices, false) : undefined;
      xForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, true);
      yForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, false);
      if (withY) {
        $$.subY.domain($$.getYDomain(targetsToShow, 'y'));
        $$.subY2.domain($$.getYDomain(targetsToShow, 'y2'));
      }
      $$.updateXgridFocus();
      main.select("text." + CLASS.text + '.' + CLASS.empty).attr("x", $$.width / 2).attr("y", $$.height / 2).text(config.data_empty_label_text).transition().style('opacity', targetsToShow.length ? 0 : 1);
      $$.updateGrid(duration);
      $$.updateRegion(duration);
      $$.updateBar(durationForExit);
      $$.updateLine(durationForExit);
      $$.updateArea(durationForExit);
      $$.updateCircle();
      if ($$.hasDataLabel()) {
        $$.updateText(durationForExit);
      }
      if ($$.redrawTitle) {
        $$.redrawTitle();
      }
      if ($$.redrawArc) {
        $$.redrawArc(duration, durationForExit, withTransform);
      }
      if ($$.redrawSubchart) {
        $$.redrawSubchart(withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices);
      }
      main.selectAll('.' + CLASS.selectedCircles).filter($$.isBarType.bind($$)).selectAll('circle').remove();
      if (config.interaction_enabled && !options.flow && withEventRect) {
        $$.redrawEventRect();
        if ($$.updateZoom) {
          $$.updateZoom();
        }
      }
      $$.updateCircleY();
      cx = ($$.config.axis_rotated ? $$.circleY : $$.circleX).bind($$);
      cy = ($$.config.axis_rotated ? $$.circleX : $$.circleY).bind($$);
      if (options.flow) {
        flow = $$.generateFlow({
          targets: targetsToShow,
          flow: options.flow,
          duration: options.flow.duration,
          drawBar: drawBar,
          drawLine: drawLine,
          drawArea: drawArea,
          cx: cx,
          cy: cy,
          xv: xv,
          xForText: xForText,
          yForText: yForText
        });
      }
      if ((duration || flow) && $$.isTabVisible()) {
        d3.transition().duration(duration).each(function() {
          var transitionsToWait = [];
          [$$.redrawBar(drawBar, true), $$.redrawLine(drawLine, true), $$.redrawArea(drawArea, true), $$.redrawCircle(cx, cy, true), $$.redrawText(xForText, yForText, options.flow, true), $$.redrawRegion(true), $$.redrawGrid(true)].forEach(function(transitions) {
            transitions.forEach(function(transition) {
              transitionsToWait.push(transition);
            });
          });
          waitForDraw = $$.generateWait();
          transitionsToWait.forEach(function(t) {
            waitForDraw.add(t);
          });
        }).call(waitForDraw, function() {
          if (flow) {
            flow();
          }
          if (config.onrendered) {
            config.onrendered.call($$);
          }
        });
      } else {
        $$.redrawBar(drawBar);
        $$.redrawLine(drawLine);
        $$.redrawArea(drawArea);
        $$.redrawCircle(cx, cy);
        $$.redrawText(xForText, yForText, options.flow);
        $$.redrawRegion();
        $$.redrawGrid();
        if (config.onrendered) {
          config.onrendered.call($$);
        }
      }
      $$.mapToIds($$.data.targets).forEach(function(id) {
        $$.withoutFadeIn[id] = true;
      });
    };
    c3_chart_internal_fn.updateAndRedraw = function(options) {
      var $$ = this,
          config = $$.config,
          transitions;
      options = options || {};
      options.withTransition = getOption(options, "withTransition", true);
      options.withTransform = getOption(options, "withTransform", false);
      options.withLegend = getOption(options, "withLegend", false);
      options.withUpdateXDomain = true;
      options.withUpdateOrgXDomain = true;
      options.withTransitionForExit = false;
      options.withTransitionForTransform = getOption(options, "withTransitionForTransform", options.withTransition);
      $$.updateSizes();
      if (!(options.withLegend && config.legend_show)) {
        transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0);
        $$.updateScales();
        $$.updateSvgSize();
        $$.transformAll(options.withTransitionForTransform, transitions);
      }
      $$.redraw(options, transitions);
    };
    c3_chart_internal_fn.redrawWithoutRescale = function() {
      this.redraw({
        withY: false,
        withSubchart: false,
        withEventRect: false,
        withTransitionForAxis: false
      });
    };
    c3_chart_internal_fn.isTimeSeries = function() {
      return this.config.axis_x_type === 'timeseries';
    };
    c3_chart_internal_fn.isCategorized = function() {
      return this.config.axis_x_type.indexOf('categor') >= 0;
    };
    c3_chart_internal_fn.isCustomX = function() {
      var $$ = this,
          config = $$.config;
      return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
    };
    c3_chart_internal_fn.isTimeSeriesY = function() {
      return this.config.axis_y_type === 'timeseries';
    };
    c3_chart_internal_fn.getTranslate = function(target) {
      var $$ = this,
          config = $$.config,
          x,
          y;
      if (target === 'main') {
        x = asHalfPixel($$.margin.left);
        y = asHalfPixel($$.margin.top);
      } else if (target === 'context') {
        x = asHalfPixel($$.margin2.left);
        y = asHalfPixel($$.margin2.top);
      } else if (target === 'legend') {
        x = $$.margin3.left;
        y = $$.margin3.top;
      } else if (target === 'x') {
        x = 0;
        y = config.axis_rotated ? 0 : $$.height;
      } else if (target === 'y') {
        x = 0;
        y = config.axis_rotated ? $$.height : 0;
      } else if (target === 'y2') {
        x = config.axis_rotated ? 0 : $$.width;
        y = config.axis_rotated ? 1 : 0;
      } else if (target === 'subx') {
        x = 0;
        y = config.axis_rotated ? 0 : $$.height2;
      } else if (target === 'arc') {
        x = $$.arcWidth / 2;
        y = $$.arcHeight / 2;
      }
      return "translate(" + x + "," + y + ")";
    };
    c3_chart_internal_fn.initialOpacity = function(d) {
      return d.value !== null && this.withoutFadeIn[d.id] ? 1 : 0;
    };
    c3_chart_internal_fn.initialOpacityForCircle = function(d) {
      return d.value !== null && this.withoutFadeIn[d.id] ? this.opacityForCircle(d) : 0;
    };
    c3_chart_internal_fn.opacityForCircle = function(d) {
      var opacity = this.config.point_show ? 1 : 0;
      return isValue(d.value) ? (this.isScatterType(d) ? 0.5 : opacity) : 0;
    };
    c3_chart_internal_fn.opacityForText = function() {
      return this.hasDataLabel() ? 1 : 0;
    };
    c3_chart_internal_fn.xx = function(d) {
      return d ? this.x(d.x) : null;
    };
    c3_chart_internal_fn.xv = function(d) {
      var $$ = this,
          value = d.value;
      if ($$.isTimeSeries()) {
        value = $$.parseDate(d.value);
      } else if ($$.isCategorized() && typeof d.value === 'string') {
        value = $$.config.axis_x_categories.indexOf(d.value);
      }
      return Math.ceil($$.x(value));
    };
    c3_chart_internal_fn.yv = function(d) {
      var $$ = this,
          yScale = d.axis && d.axis === 'y2' ? $$.y2 : $$.y;
      return Math.ceil(yScale(d.value));
    };
    c3_chart_internal_fn.subxx = function(d) {
      return d ? this.subX(d.x) : null;
    };
    c3_chart_internal_fn.transformMain = function(withTransition, transitions) {
      var $$ = this,
          xAxis,
          yAxis,
          y2Axis;
      if (transitions && transitions.axisX) {
        xAxis = transitions.axisX;
      } else {
        xAxis = $$.main.select('.' + CLASS.axisX);
        if (withTransition) {
          xAxis = xAxis.transition();
        }
      }
      if (transitions && transitions.axisY) {
        yAxis = transitions.axisY;
      } else {
        yAxis = $$.main.select('.' + CLASS.axisY);
        if (withTransition) {
          yAxis = yAxis.transition();
        }
      }
      if (transitions && transitions.axisY2) {
        y2Axis = transitions.axisY2;
      } else {
        y2Axis = $$.main.select('.' + CLASS.axisY2);
        if (withTransition) {
          y2Axis = y2Axis.transition();
        }
      }
      (withTransition ? $$.main.transition() : $$.main).attr("transform", $$.getTranslate('main'));
      xAxis.attr("transform", $$.getTranslate('x'));
      yAxis.attr("transform", $$.getTranslate('y'));
      y2Axis.attr("transform", $$.getTranslate('y2'));
      $$.main.select('.' + CLASS.chartArcs).attr("transform", $$.getTranslate('arc'));
    };
    c3_chart_internal_fn.transformAll = function(withTransition, transitions) {
      var $$ = this;
      $$.transformMain(withTransition, transitions);
      if ($$.config.subchart_show) {
        $$.transformContext(withTransition, transitions);
      }
      if ($$.legend) {
        $$.transformLegend(withTransition);
      }
    };
    c3_chart_internal_fn.updateSvgSize = function() {
      var $$ = this,
          brush = $$.svg.select(".c3-brush .background");
      $$.svg.attr('width', $$.currentWidth).attr('height', $$.currentHeight);
      $$.svg.selectAll(['#' + $$.clipId, '#' + $$.clipIdForGrid]).select('rect').attr('width', $$.width).attr('height', $$.height);
      $$.svg.select('#' + $$.clipIdForXAxis).select('rect').attr('x', $$.getXAxisClipX.bind($$)).attr('y', $$.getXAxisClipY.bind($$)).attr('width', $$.getXAxisClipWidth.bind($$)).attr('height', $$.getXAxisClipHeight.bind($$));
      $$.svg.select('#' + $$.clipIdForYAxis).select('rect').attr('x', $$.getYAxisClipX.bind($$)).attr('y', $$.getYAxisClipY.bind($$)).attr('width', $$.getYAxisClipWidth.bind($$)).attr('height', $$.getYAxisClipHeight.bind($$));
      $$.svg.select('#' + $$.clipIdForSubchart).select('rect').attr('width', $$.width).attr('height', brush.size() ? brush.attr('height') : 0);
      $$.svg.select('.' + CLASS.zoomRect).attr('width', $$.width).attr('height', $$.height);
      $$.selectChart.style('max-height', $$.currentHeight + "px");
    };
    c3_chart_internal_fn.updateDimension = function(withoutAxis) {
      var $$ = this;
      if (!withoutAxis) {
        if ($$.config.axis_rotated) {
          $$.axes.x.call($$.xAxis);
          $$.axes.subx.call($$.subXAxis);
        } else {
          $$.axes.y.call($$.yAxis);
          $$.axes.y2.call($$.y2Axis);
        }
      }
      $$.updateSizes();
      $$.updateScales();
      $$.updateSvgSize();
      $$.transformAll(false);
    };
    c3_chart_internal_fn.observeInserted = function(selection) {
      var $$ = this,
          observer;
      if (typeof MutationObserver === 'undefined') {
        window.console.error("MutationObserver not defined.");
        return;
      }
      observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          if (mutation.type === 'childList' && mutation.previousSibling) {
            observer.disconnect();
            $$.intervalForObserveInserted = window.setInterval(function() {
              if (selection.node().parentNode) {
                window.clearInterval($$.intervalForObserveInserted);
                $$.updateDimension();
                if ($$.brush) {
                  $$.brush.update();
                }
                $$.config.oninit.call($$);
                $$.redraw({
                  withTransform: true,
                  withUpdateXDomain: true,
                  withUpdateOrgXDomain: true,
                  withTransition: false,
                  withTransitionForTransform: false,
                  withLegend: true
                });
                selection.transition().style('opacity', 1);
              }
            }, 10);
          }
        });
      });
      observer.observe(selection.node(), {
        attributes: true,
        childList: true,
        characterData: true
      });
    };
    c3_chart_internal_fn.bindResize = function() {
      var $$ = this,
          config = $$.config;
      $$.resizeFunction = $$.generateResize();
      $$.resizeFunction.add(function() {
        config.onresize.call($$);
      });
      if (config.resize_auto) {
        $$.resizeFunction.add(function() {
          if ($$.resizeTimeout !== undefined) {
            window.clearTimeout($$.resizeTimeout);
          }
          $$.resizeTimeout = window.setTimeout(function() {
            delete $$.resizeTimeout;
            $$.api.flush();
          }, 100);
        });
      }
      $$.resizeFunction.add(function() {
        config.onresized.call($$);
      });
      if (window.attachEvent) {
        window.attachEvent('onresize', $$.resizeFunction);
      } else if (window.addEventListener) {
        window.addEventListener('resize', $$.resizeFunction, false);
      } else {
        var wrapper = window.onresize;
        if (!wrapper) {
          wrapper = $$.generateResize();
        } else if (!wrapper.add || !wrapper.remove) {
          wrapper = $$.generateResize();
          wrapper.add(window.onresize);
        }
        wrapper.add($$.resizeFunction);
        window.onresize = wrapper;
      }
    };
    c3_chart_internal_fn.generateResize = function() {
      var resizeFunctions = [];
      function callResizeFunctions() {
        resizeFunctions.forEach(function(f) {
          f();
        });
      }
      callResizeFunctions.add = function(f) {
        resizeFunctions.push(f);
      };
      callResizeFunctions.remove = function(f) {
        for (var i = 0; i < resizeFunctions.length; i++) {
          if (resizeFunctions[i] === f) {
            resizeFunctions.splice(i, 1);
            break;
          }
        }
      };
      return callResizeFunctions;
    };
    c3_chart_internal_fn.endall = function(transition, callback) {
      var n = 0;
      transition.each(function() {
        ++n;
      }).each("end", function() {
        if (!--n) {
          callback.apply(this, arguments);
        }
      });
    };
    c3_chart_internal_fn.generateWait = function() {
      var transitionsToWait = [],
          f = function(transition, callback) {
            var timer = setInterval(function() {
              var done = 0;
              transitionsToWait.forEach(function(t) {
                if (t.empty()) {
                  done += 1;
                  return;
                }
                try {
                  t.transition();
                } catch (e) {
                  done += 1;
                }
              });
              if (done === transitionsToWait.length) {
                clearInterval(timer);
                if (callback) {
                  callback();
                }
              }
            }, 10);
          };
      f.add = function(transition) {
        transitionsToWait.push(transition);
      };
      return f;
    };
    c3_chart_internal_fn.parseDate = function(date) {
      var $$ = this,
          parsedDate;
      if (date instanceof Date) {
        parsedDate = date;
      } else if (typeof date === 'string') {
        parsedDate = $$.dataTimeFormat($$.config.data_xFormat).parse(date);
      } else if (typeof date === 'number' && !isNaN(date)) {
        parsedDate = new Date(+date);
      }
      if (!parsedDate || isNaN(+parsedDate)) {
        window.console.error("Failed to parse x '" + date + "' to Date object");
      }
      return parsedDate;
    };
    c3_chart_internal_fn.isTabVisible = function() {
      var hidden;
      if (typeof document.hidden !== "undefined") {
        hidden = "hidden";
      } else if (typeof document.mozHidden !== "undefined") {
        hidden = "mozHidden";
      } else if (typeof document.msHidden !== "undefined") {
        hidden = "msHidden";
      } else if (typeof document.webkitHidden !== "undefined") {
        hidden = "webkitHidden";
      }
      return document[hidden] ? false : true;
    };
    c3_chart_internal_fn.getDefaultConfig = function() {
      var config = {
        bindto: '#chart',
        size_width: undefined,
        size_height: undefined,
        padding_left: undefined,
        padding_right: undefined,
        padding_top: undefined,
        padding_bottom: undefined,
        resize_auto: true,
        zoom_enabled: false,
        zoom_extent: undefined,
        zoom_privileged: false,
        zoom_rescale: false,
        zoom_onzoom: function() {},
        zoom_onzoomstart: function() {},
        zoom_onzoomend: function() {},
        zoom_x_min: undefined,
        zoom_x_max: undefined,
        interaction_enabled: true,
        onmouseover: function() {},
        onmouseout: function() {},
        onresize: function() {},
        onresized: function() {},
        oninit: function() {},
        onrendered: function() {},
        transition_duration: 350,
        data_x: undefined,
        data_xs: {},
        data_xFormat: '%Y-%m-%d',
        data_xLocaltime: true,
        data_xSort: true,
        data_idConverter: function(id) {
          return id;
        },
        data_names: {},
        data_classes: {},
        data_groups: [],
        data_axes: {},
        data_type: undefined,
        data_types: {},
        data_labels: {},
        data_order: 'desc',
        data_regions: {},
        data_color: undefined,
        data_colors: {},
        data_hide: false,
        data_filter: undefined,
        data_selection_enabled: false,
        data_selection_grouped: false,
        data_selection_isselectable: function() {
          return true;
        },
        data_selection_multiple: true,
        data_selection_draggable: false,
        data_onclick: function() {},
        data_onmouseover: function() {},
        data_onmouseout: function() {},
        data_onselected: function() {},
        data_onunselected: function() {},
        data_url: undefined,
        data_json: undefined,
        data_rows: undefined,
        data_columns: undefined,
        data_mimeType: undefined,
        data_keys: undefined,
        data_empty_label_text: "",
        subchart_show: false,
        subchart_size_height: 60,
        subchart_axis_x_show: true,
        subchart_onbrush: function() {},
        color_pattern: [],
        color_threshold: {},
        legend_show: true,
        legend_hide: false,
        legend_position: 'bottom',
        legend_inset_anchor: 'top-left',
        legend_inset_x: 10,
        legend_inset_y: 0,
        legend_inset_step: undefined,
        legend_item_onclick: undefined,
        legend_item_onmouseover: undefined,
        legend_item_onmouseout: undefined,
        legend_equally: false,
        legend_padding: 0,
        legend_item_tile_width: 10,
        legend_item_tile_height: 10,
        axis_rotated: false,
        axis_x_show: true,
        axis_x_type: 'indexed',
        axis_x_localtime: true,
        axis_x_categories: [],
        axis_x_tick_centered: false,
        axis_x_tick_format: undefined,
        axis_x_tick_culling: {},
        axis_x_tick_culling_max: 10,
        axis_x_tick_count: undefined,
        axis_x_tick_fit: true,
        axis_x_tick_values: null,
        axis_x_tick_rotate: 0,
        axis_x_tick_outer: true,
        axis_x_tick_multiline: true,
        axis_x_tick_width: null,
        axis_x_max: undefined,
        axis_x_min: undefined,
        axis_x_padding: {},
        axis_x_height: undefined,
        axis_x_extent: undefined,
        axis_x_label: {},
        axis_y_show: true,
        axis_y_type: undefined,
        axis_y_max: undefined,
        axis_y_min: undefined,
        axis_y_inverted: false,
        axis_y_center: undefined,
        axis_y_inner: undefined,
        axis_y_label: {},
        axis_y_tick_format: undefined,
        axis_y_tick_outer: true,
        axis_y_tick_values: null,
        axis_y_tick_count: undefined,
        axis_y_tick_time_value: undefined,
        axis_y_tick_time_interval: undefined,
        axis_y_padding: {},
        axis_y_default: undefined,
        axis_y2_show: false,
        axis_y2_max: undefined,
        axis_y2_min: undefined,
        axis_y2_inverted: false,
        axis_y2_center: undefined,
        axis_y2_inner: undefined,
        axis_y2_label: {},
        axis_y2_tick_format: undefined,
        axis_y2_tick_outer: true,
        axis_y2_tick_values: null,
        axis_y2_tick_count: undefined,
        axis_y2_padding: {},
        axis_y2_default: undefined,
        grid_x_show: false,
        grid_x_type: 'tick',
        grid_x_lines: [],
        grid_y_show: false,
        grid_y_lines: [],
        grid_y_ticks: 10,
        grid_focus_show: true,
        grid_lines_front: true,
        point_show: true,
        point_r: 2.5,
        point_sensitivity: 10,
        point_focus_expand_enabled: true,
        point_focus_expand_r: undefined,
        point_select_r: undefined,
        line_connectNull: false,
        line_step_type: 'step',
        bar_width: undefined,
        bar_width_ratio: 0.6,
        bar_width_max: undefined,
        bar_zerobased: true,
        area_zerobased: true,
        pie_label_show: true,
        pie_label_format: undefined,
        pie_label_threshold: 0.05,
        pie_expand: {},
        pie_expand_duration: 50,
        gauge_label_show: true,
        gauge_label_format: undefined,
        gauge_min: 0,
        gauge_max: 100,
        gauge_units: undefined,
        gauge_width: undefined,
        gauge_expand: {},
        gauge_expand_duration: 50,
        donut_label_show: true,
        donut_label_format: undefined,
        donut_label_threshold: 0.05,
        donut_width: undefined,
        donut_title: "",
        donut_expand: {},
        donut_expand_duration: 50,
        spline_interpolation_type: 'cardinal',
        regions: [],
        tooltip_show: true,
        tooltip_grouped: true,
        tooltip_format_title: undefined,
        tooltip_format_name: undefined,
        tooltip_format_value: undefined,
        tooltip_position: undefined,
        tooltip_contents: function(d, defaultTitleFormat, defaultValueFormat, color) {
          return this.getTooltipContent ? this.getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) : '';
        },
        tooltip_init_show: false,
        tooltip_init_x: 0,
        tooltip_init_position: {
          top: '0px',
          left: '50px'
        },
        tooltip_onshow: function() {},
        tooltip_onhide: function() {},
        title_text: undefined,
        title_padding: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        },
        title_position: 'top-center'
      };
      Object.keys(this.additionalConfig).forEach(function(key) {
        config[key] = this.additionalConfig[key];
      }, this);
      return config;
    };
    c3_chart_internal_fn.additionalConfig = {};
    c3_chart_internal_fn.loadConfig = function(config) {
      var this_config = this.config,
          target,
          keys,
          read;
      function find() {
        var key = keys.shift();
        if (key && target && typeof target === 'object' && key in target) {
          target = target[key];
          return find();
        } else if (!key) {
          return target;
        } else {
          return undefined;
        }
      }
      Object.keys(this_config).forEach(function(key) {
        target = config;
        keys = key.split('_');
        read = find();
        if (isDefined(read)) {
          this_config[key] = read;
        }
      });
    };
    c3_chart_internal_fn.getScale = function(min, max, forTimeseries) {
      return (forTimeseries ? this.d3.time.scale() : this.d3.scale.linear()).range([min, max]);
    };
    c3_chart_internal_fn.getX = function(min, max, domain, offset) {
      var $$ = this,
          scale = $$.getScale(min, max, $$.isTimeSeries()),
          _scale = domain ? scale.domain(domain) : scale,
          key;
      if ($$.isCategorized()) {
        offset = offset || function() {
          return 0;
        };
        scale = function(d, raw) {
          var v = _scale(d) + offset(d);
          return raw ? v : Math.ceil(v);
        };
      } else {
        scale = function(d, raw) {
          var v = _scale(d);
          return raw ? v : Math.ceil(v);
        };
      }
      for (key in _scale) {
        scale[key] = _scale[key];
      }
      scale.orgDomain = function() {
        return _scale.domain();
      };
      if ($$.isCategorized()) {
        scale.domain = function(domain) {
          if (!arguments.length) {
            domain = this.orgDomain();
            return [domain[0], domain[1] + 1];
          }
          _scale.domain(domain);
          return scale;
        };
      }
      return scale;
    };
    c3_chart_internal_fn.getY = function(min, max, domain) {
      var scale = this.getScale(min, max, this.isTimeSeriesY());
      if (domain) {
        scale.domain(domain);
      }
      return scale;
    };
    c3_chart_internal_fn.getYScale = function(id) {
      return this.axis.getId(id) === 'y2' ? this.y2 : this.y;
    };
    c3_chart_internal_fn.getSubYScale = function(id) {
      return this.axis.getId(id) === 'y2' ? this.subY2 : this.subY;
    };
    c3_chart_internal_fn.updateScales = function() {
      var $$ = this,
          config = $$.config,
          forInit = !$$.x;
      $$.xMin = config.axis_rotated ? 1 : 0;
      $$.xMax = config.axis_rotated ? $$.height : $$.width;
      $$.yMin = config.axis_rotated ? 0 : $$.height;
      $$.yMax = config.axis_rotated ? $$.width : 1;
      $$.subXMin = $$.xMin;
      $$.subXMax = $$.xMax;
      $$.subYMin = config.axis_rotated ? 0 : $$.height2;
      $$.subYMax = config.axis_rotated ? $$.width2 : 1;
      $$.x = $$.getX($$.xMin, $$.xMax, forInit ? undefined : $$.x.orgDomain(), function() {
        return $$.xAxis.tickOffset();
      });
      $$.y = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y_default : $$.y.domain());
      $$.y2 = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y2_default : $$.y2.domain());
      $$.subX = $$.getX($$.xMin, $$.xMax, $$.orgXDomain, function(d) {
        return d % 1 ? 0 : $$.subXAxis.tickOffset();
      });
      $$.subY = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y_default : $$.subY.domain());
      $$.subY2 = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y2_default : $$.subY2.domain());
      $$.xAxisTickFormat = $$.axis.getXAxisTickFormat();
      $$.xAxisTickValues = $$.axis.getXAxisTickValues();
      $$.yAxisTickValues = $$.axis.getYAxisTickValues();
      $$.y2AxisTickValues = $$.axis.getY2AxisTickValues();
      $$.xAxis = $$.axis.getXAxis($$.x, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer);
      $$.subXAxis = $$.axis.getXAxis($$.subX, $$.subXOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer);
      $$.yAxis = $$.axis.getYAxis($$.y, $$.yOrient, config.axis_y_tick_format, $$.yAxisTickValues, config.axis_y_tick_outer);
      $$.y2Axis = $$.axis.getYAxis($$.y2, $$.y2Orient, config.axis_y2_tick_format, $$.y2AxisTickValues, config.axis_y2_tick_outer);
      if (!forInit) {
        if ($$.brush) {
          $$.brush.scale($$.subX);
        }
        if (config.zoom_enabled) {
          $$.zoom.scale($$.x);
        }
      }
      if ($$.updateArc) {
        $$.updateArc();
      }
    };
    c3_chart_internal_fn.getYDomainMin = function(targets) {
      var $$ = this,
          config = $$.config,
          ids = $$.mapToIds(targets),
          ys = $$.getValuesAsIdKeyed(targets),
          j,
          k,
          baseId,
          idsInGroup,
          id,
          hasNegativeValue;
      if (config.data_groups.length > 0) {
        hasNegativeValue = $$.hasNegativeValueInTargets(targets);
        for (j = 0; j < config.data_groups.length; j++) {
          idsInGroup = config.data_groups[j].filter(function(id) {
            return ids.indexOf(id) >= 0;
          });
          if (idsInGroup.length === 0) {
            continue;
          }
          baseId = idsInGroup[0];
          if (hasNegativeValue && ys[baseId]) {
            ys[baseId].forEach(function(v, i) {
              ys[baseId][i] = v < 0 ? v : 0;
            });
          }
          for (k = 1; k < idsInGroup.length; k++) {
            id = idsInGroup[k];
            if (!ys[id]) {
              continue;
            }
            ys[id].forEach(function(v, i) {
              if ($$.axis.getId(id) === $$.axis.getId(baseId) && ys[baseId] && !(hasNegativeValue && +v > 0)) {
                ys[baseId][i] += +v;
              }
            });
          }
        }
      }
      return $$.d3.min(Object.keys(ys).map(function(key) {
        return $$.d3.min(ys[key]);
      }));
    };
    c3_chart_internal_fn.getYDomainMax = function(targets) {
      var $$ = this,
          config = $$.config,
          ids = $$.mapToIds(targets),
          ys = $$.getValuesAsIdKeyed(targets),
          j,
          k,
          baseId,
          idsInGroup,
          id,
          hasPositiveValue;
      if (config.data_groups.length > 0) {
        hasPositiveValue = $$.hasPositiveValueInTargets(targets);
        for (j = 0; j < config.data_groups.length; j++) {
          idsInGroup = config.data_groups[j].filter(function(id) {
            return ids.indexOf(id) >= 0;
          });
          if (idsInGroup.length === 0) {
            continue;
          }
          baseId = idsInGroup[0];
          if (hasPositiveValue && ys[baseId]) {
            ys[baseId].forEach(function(v, i) {
              ys[baseId][i] = v > 0 ? v : 0;
            });
          }
          for (k = 1; k < idsInGroup.length; k++) {
            id = idsInGroup[k];
            if (!ys[id]) {
              continue;
            }
            ys[id].forEach(function(v, i) {
              if ($$.axis.getId(id) === $$.axis.getId(baseId) && ys[baseId] && !(hasPositiveValue && +v < 0)) {
                ys[baseId][i] += +v;
              }
            });
          }
        }
      }
      return $$.d3.max(Object.keys(ys).map(function(key) {
        return $$.d3.max(ys[key]);
      }));
    };
    c3_chart_internal_fn.getYDomain = function(targets, axisId, xDomain) {
      var $$ = this,
          config = $$.config,
          targetsByAxisId = targets.filter(function(t) {
            return $$.axis.getId(t.id) === axisId;
          }),
          yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId,
          yMin = axisId === 'y2' ? config.axis_y2_min : config.axis_y_min,
          yMax = axisId === 'y2' ? config.axis_y2_max : config.axis_y_max,
          yDomainMin = $$.getYDomainMin(yTargets),
          yDomainMax = $$.getYDomainMax(yTargets),
          domain,
          domainLength,
          padding,
          padding_top,
          padding_bottom,
          center = axisId === 'y2' ? config.axis_y2_center : config.axis_y_center,
          yDomainAbs,
          lengths,
          diff,
          ratio,
          isAllPositive,
          isAllNegative,
          isZeroBased = ($$.hasType('bar', yTargets) && config.bar_zerobased) || ($$.hasType('area', yTargets) && config.area_zerobased),
          isInverted = axisId === 'y2' ? config.axis_y2_inverted : config.axis_y_inverted,
          showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,
          showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;
      yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? (yDomainMin < yMax ? yDomainMin : yMax - 10) : yDomainMin;
      yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? (yMin < yDomainMax ? yDomainMax : yMin + 10) : yDomainMax;
      if (yTargets.length === 0) {
        return axisId === 'y2' ? $$.y2.domain() : $$.y.domain();
      }
      if (isNaN(yDomainMin)) {
        yDomainMin = 0;
      }
      if (isNaN(yDomainMax)) {
        yDomainMax = yDomainMin;
      }
      if (yDomainMin === yDomainMax) {
        yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0;
      }
      isAllPositive = yDomainMin >= 0 && yDomainMax >= 0;
      isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;
      if ((isValue(yMin) && isAllPositive) || (isValue(yMax) && isAllNegative)) {
        isZeroBased = false;
      }
      if (isZeroBased) {
        if (isAllPositive) {
          yDomainMin = 0;
        }
        if (isAllNegative) {
          yDomainMax = 0;
        }
      }
      domainLength = Math.abs(yDomainMax - yDomainMin);
      padding = padding_top = padding_bottom = domainLength * 0.1;
      if (typeof center !== 'undefined') {
        yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
        yDomainMax = center + yDomainAbs;
        yDomainMin = center - yDomainAbs;
      }
      if (showHorizontalDataLabel) {
        lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'width');
        diff = diffDomain($$.y.range());
        ratio = [lengths[0] / diff, lengths[1] / diff];
        padding_top += domainLength * (ratio[1] / (1 - ratio[0] - ratio[1]));
        padding_bottom += domainLength * (ratio[0] / (1 - ratio[0] - ratio[1]));
      } else if (showVerticalDataLabel) {
        lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'height');
        padding_top += $$.axis.convertPixelsToAxisPadding(lengths[1], domainLength);
        padding_bottom += $$.axis.convertPixelsToAxisPadding(lengths[0], domainLength);
      }
      if (axisId === 'y' && notEmpty(config.axis_y_padding)) {
        padding_top = $$.axis.getPadding(config.axis_y_padding, 'top', padding_top, domainLength);
        padding_bottom = $$.axis.getPadding(config.axis_y_padding, 'bottom', padding_bottom, domainLength);
      }
      if (axisId === 'y2' && notEmpty(config.axis_y2_padding)) {
        padding_top = $$.axis.getPadding(config.axis_y2_padding, 'top', padding_top, domainLength);
        padding_bottom = $$.axis.getPadding(config.axis_y2_padding, 'bottom', padding_bottom, domainLength);
      }
      if (isZeroBased) {
        if (isAllPositive) {
          padding_bottom = yDomainMin;
        }
        if (isAllNegative) {
          padding_top = -yDomainMax;
        }
      }
      domain = [yDomainMin - padding_bottom, yDomainMax + padding_top];
      return isInverted ? domain.reverse() : domain;
    };
    c3_chart_internal_fn.getXDomainMin = function(targets) {
      var $$ = this,
          config = $$.config;
      return isDefined(config.axis_x_min) ? ($$.isTimeSeries() ? this.parseDate(config.axis_x_min) : config.axis_x_min) : $$.d3.min(targets, function(t) {
        return $$.d3.min(t.values, function(v) {
          return v.x;
        });
      });
    };
    c3_chart_internal_fn.getXDomainMax = function(targets) {
      var $$ = this,
          config = $$.config;
      return isDefined(config.axis_x_max) ? ($$.isTimeSeries() ? this.parseDate(config.axis_x_max) : config.axis_x_max) : $$.d3.max(targets, function(t) {
        return $$.d3.max(t.values, function(v) {
          return v.x;
        });
      });
    };
    c3_chart_internal_fn.getXDomainPadding = function(domain) {
      var $$ = this,
          config = $$.config,
          diff = domain[1] - domain[0],
          maxDataCount,
          padding,
          paddingLeft,
          paddingRight;
      if ($$.isCategorized()) {
        padding = 0;
      } else if ($$.hasType('bar')) {
        maxDataCount = $$.getMaxDataCount();
        padding = maxDataCount > 1 ? (diff / (maxDataCount - 1)) / 2 : 0.5;
      } else {
        padding = diff * 0.01;
      }
      if (typeof config.axis_x_padding === 'object' && notEmpty(config.axis_x_padding)) {
        paddingLeft = isValue(config.axis_x_padding.left) ? config.axis_x_padding.left : padding;
        paddingRight = isValue(config.axis_x_padding.right) ? config.axis_x_padding.right : padding;
      } else if (typeof config.axis_x_padding === 'number') {
        paddingLeft = paddingRight = config.axis_x_padding;
      } else {
        paddingLeft = paddingRight = padding;
      }
      return {
        left: paddingLeft,
        right: paddingRight
      };
    };
    c3_chart_internal_fn.getXDomain = function(targets) {
      var $$ = this,
          xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],
          firstX = xDomain[0],
          lastX = xDomain[1],
          padding = $$.getXDomainPadding(xDomain),
          min = 0,
          max = 0;
      if ((firstX - lastX) === 0 && !$$.isCategorized()) {
        if ($$.isTimeSeries()) {
          firstX = new Date(firstX.getTime() * 0.5);
          lastX = new Date(lastX.getTime() * 1.5);
        } else {
          firstX = firstX === 0 ? 1 : (firstX * 0.5);
          lastX = lastX === 0 ? -1 : (lastX * 1.5);
        }
      }
      if (firstX || firstX === 0) {
        min = $$.isTimeSeries() ? new Date(firstX.getTime() - padding.left) : firstX - padding.left;
      }
      if (lastX || lastX === 0) {
        max = $$.isTimeSeries() ? new Date(lastX.getTime() + padding.right) : lastX + padding.right;
      }
      return [min, max];
    };
    c3_chart_internal_fn.updateXDomain = function(targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
      var $$ = this,
          config = $$.config;
      if (withUpdateOrgXDomain) {
        $$.x.domain(domain ? domain : $$.d3.extent($$.getXDomain(targets)));
        $$.orgXDomain = $$.x.domain();
        if (config.zoom_enabled) {
          $$.zoom.scale($$.x).updateScaleExtent();
        }
        $$.subX.domain($$.x.domain());
        if ($$.brush) {
          $$.brush.scale($$.subX);
        }
      }
      if (withUpdateXDomain) {
        $$.x.domain(domain ? domain : (!$$.brush || $$.brush.empty()) ? $$.orgXDomain : $$.brush.extent());
        if (config.zoom_enabled) {
          $$.zoom.scale($$.x).updateScaleExtent();
        }
      }
      if (withTrim) {
        $$.x.domain($$.trimXDomain($$.x.orgDomain()));
      }
      return $$.x.domain();
    };
    c3_chart_internal_fn.trimXDomain = function(domain) {
      var zoomDomain = this.getZoomDomain(),
          min = zoomDomain[0],
          max = zoomDomain[1];
      if (domain[0] <= min) {
        domain[1] = +domain[1] + (min - domain[0]);
        domain[0] = min;
      }
      if (max <= domain[1]) {
        domain[0] = +domain[0] - (domain[1] - max);
        domain[1] = max;
      }
      return domain;
    };
    c3_chart_internal_fn.isX = function(key) {
      var $$ = this,
          config = $$.config;
      return (config.data_x && key === config.data_x) || (notEmpty(config.data_xs) && hasValue(config.data_xs, key));
    };
    c3_chart_internal_fn.isNotX = function(key) {
      return !this.isX(key);
    };
    c3_chart_internal_fn.getXKey = function(id) {
      var $$ = this,
          config = $$.config;
      return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null;
    };
    c3_chart_internal_fn.getXValuesOfXKey = function(key, targets) {
      var $$ = this,
          xValues,
          ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
      ids.forEach(function(id) {
        if ($$.getXKey(id) === key) {
          xValues = $$.data.xs[id];
        }
      });
      return xValues;
    };
    c3_chart_internal_fn.getIndexByX = function(x) {
      var $$ = this,
          data = $$.filterByX($$.data.targets, x);
      return data.length ? data[0].index : null;
    };
    c3_chart_internal_fn.getXValue = function(id, i) {
      var $$ = this;
      return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;
    };
    c3_chart_internal_fn.getOtherTargetXs = function() {
      var $$ = this,
          idsForX = Object.keys($$.data.xs);
      return idsForX.length ? $$.data.xs[idsForX[0]] : null;
    };
    c3_chart_internal_fn.getOtherTargetX = function(index) {
      var xs = this.getOtherTargetXs();
      return xs && index < xs.length ? xs[index] : null;
    };
    c3_chart_internal_fn.addXs = function(xs) {
      var $$ = this;
      Object.keys(xs).forEach(function(id) {
        $$.config.data_xs[id] = xs[id];
      });
    };
    c3_chart_internal_fn.hasMultipleX = function(xs) {
      return this.d3.set(Object.keys(xs).map(function(id) {
        return xs[id];
      })).size() > 1;
    };
    c3_chart_internal_fn.isMultipleX = function() {
      return notEmpty(this.config.data_xs) || !this.config.data_xSort || this.hasType('scatter');
    };
    c3_chart_internal_fn.addName = function(data) {
      var $$ = this,
          name;
      if (data) {
        name = $$.config.data_names[data.id];
        data.name = name !== undefined ? name : data.id;
      }
      return data;
    };
    c3_chart_internal_fn.getValueOnIndex = function(values, index) {
      var valueOnIndex = values.filter(function(v) {
        return v.index === index;
      });
      return valueOnIndex.length ? valueOnIndex[0] : null;
    };
    c3_chart_internal_fn.updateTargetX = function(targets, x) {
      var $$ = this;
      targets.forEach(function(t) {
        t.values.forEach(function(v, i) {
          v.x = $$.generateTargetX(x[i], t.id, i);
        });
        $$.data.xs[t.id] = x;
      });
    };
    c3_chart_internal_fn.updateTargetXs = function(targets, xs) {
      var $$ = this;
      targets.forEach(function(t) {
        if (xs[t.id]) {
          $$.updateTargetX([t], xs[t.id]);
        }
      });
    };
    c3_chart_internal_fn.generateTargetX = function(rawX, id, index) {
      var $$ = this,
          x;
      if ($$.isTimeSeries()) {
        x = rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index));
      } else if ($$.isCustomX() && !$$.isCategorized()) {
        x = isValue(rawX) ? +rawX : $$.getXValue(id, index);
      } else {
        x = index;
      }
      return x;
    };
    c3_chart_internal_fn.cloneTarget = function(target) {
      return {
        id: target.id,
        id_org: target.id_org,
        values: target.values.map(function(d) {
          return {
            x: d.x,
            value: d.value,
            id: d.id
          };
        })
      };
    };
    c3_chart_internal_fn.updateXs = function() {
      var $$ = this;
      if ($$.data.targets.length) {
        $$.xs = [];
        $$.data.targets[0].values.forEach(function(v) {
          $$.xs[v.index] = v.x;
        });
      }
    };
    c3_chart_internal_fn.getPrevX = function(i) {
      var x = this.xs[i - 1];
      return typeof x !== 'undefined' ? x : null;
    };
    c3_chart_internal_fn.getNextX = function(i) {
      var x = this.xs[i + 1];
      return typeof x !== 'undefined' ? x : null;
    };
    c3_chart_internal_fn.getMaxDataCount = function() {
      var $$ = this;
      return $$.d3.max($$.data.targets, function(t) {
        return t.values.length;
      });
    };
    c3_chart_internal_fn.getMaxDataCountTarget = function(targets) {
      var length = targets.length,
          max = 0,
          maxTarget;
      if (length > 1) {
        targets.forEach(function(t) {
          if (t.values.length > max) {
            maxTarget = t;
            max = t.values.length;
          }
        });
      } else {
        maxTarget = length ? targets[0] : null;
      }
      return maxTarget;
    };
    c3_chart_internal_fn.getEdgeX = function(targets) {
      var $$ = this;
      return !targets.length ? [0, 0] : [$$.d3.min(targets, function(t) {
        return t.values[0].x;
      }), $$.d3.max(targets, function(t) {
        return t.values[t.values.length - 1].x;
      })];
    };
    c3_chart_internal_fn.mapToIds = function(targets) {
      return targets.map(function(d) {
        return d.id;
      });
    };
    c3_chart_internal_fn.mapToTargetIds = function(ids) {
      var $$ = this;
      return ids ? [].concat(ids) : $$.mapToIds($$.data.targets);
    };
    c3_chart_internal_fn.hasTarget = function(targets, id) {
      var ids = this.mapToIds(targets),
          i;
      for (i = 0; i < ids.length; i++) {
        if (ids[i] === id) {
          return true;
        }
      }
      return false;
    };
    c3_chart_internal_fn.isTargetToShow = function(targetId) {
      return this.hiddenTargetIds.indexOf(targetId) < 0;
    };
    c3_chart_internal_fn.isLegendToShow = function(targetId) {
      return this.hiddenLegendIds.indexOf(targetId) < 0;
    };
    c3_chart_internal_fn.filterTargetsToShow = function(targets) {
      var $$ = this;
      return targets.filter(function(t) {
        return $$.isTargetToShow(t.id);
      });
    };
    c3_chart_internal_fn.mapTargetsToUniqueXs = function(targets) {
      var $$ = this;
      var xs = $$.d3.set($$.d3.merge(targets.map(function(t) {
        return t.values.map(function(v) {
          return +v.x;
        });
      }))).values();
      xs = $$.isTimeSeries() ? xs.map(function(x) {
        return new Date(+x);
      }) : xs.map(function(x) {
        return +x;
      });
      return xs.sort(function(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
      });
    };
    c3_chart_internal_fn.addHiddenTargetIds = function(targetIds) {
      this.hiddenTargetIds = this.hiddenTargetIds.concat(targetIds);
    };
    c3_chart_internal_fn.removeHiddenTargetIds = function(targetIds) {
      this.hiddenTargetIds = this.hiddenTargetIds.filter(function(id) {
        return targetIds.indexOf(id) < 0;
      });
    };
    c3_chart_internal_fn.addHiddenLegendIds = function(targetIds) {
      this.hiddenLegendIds = this.hiddenLegendIds.concat(targetIds);
    };
    c3_chart_internal_fn.removeHiddenLegendIds = function(targetIds) {
      this.hiddenLegendIds = this.hiddenLegendIds.filter(function(id) {
        return targetIds.indexOf(id) < 0;
      });
    };
    c3_chart_internal_fn.getValuesAsIdKeyed = function(targets) {
      var ys = {};
      targets.forEach(function(t) {
        ys[t.id] = [];
        t.values.forEach(function(v) {
          ys[t.id].push(v.value);
        });
      });
      return ys;
    };
    c3_chart_internal_fn.checkValueInTargets = function(targets, checker) {
      var ids = Object.keys(targets),
          i,
          j,
          values;
      for (i = 0; i < ids.length; i++) {
        values = targets[ids[i]].values;
        for (j = 0; j < values.length; j++) {
          if (checker(values[j].value)) {
            return true;
          }
        }
      }
      return false;
    };
    c3_chart_internal_fn.hasNegativeValueInTargets = function(targets) {
      return this.checkValueInTargets(targets, function(v) {
        return v < 0;
      });
    };
    c3_chart_internal_fn.hasPositiveValueInTargets = function(targets) {
      return this.checkValueInTargets(targets, function(v) {
        return v > 0;
      });
    };
    c3_chart_internal_fn.isOrderDesc = function() {
      var config = this.config;
      return typeof(config.data_order) === 'string' && config.data_order.toLowerCase() === 'desc';
    };
    c3_chart_internal_fn.isOrderAsc = function() {
      var config = this.config;
      return typeof(config.data_order) === 'string' && config.data_order.toLowerCase() === 'asc';
    };
    c3_chart_internal_fn.orderTargets = function(targets) {
      var $$ = this,
          config = $$.config,
          orderAsc = $$.isOrderAsc(),
          orderDesc = $$.isOrderDesc();
      if (orderAsc || orderDesc) {
        targets.sort(function(t1, t2) {
          var reducer = function(p, c) {
            return p + Math.abs(c.value);
          };
          var t1Sum = t1.values.reduce(reducer, 0),
              t2Sum = t2.values.reduce(reducer, 0);
          return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
        });
      } else if (isFunction(config.data_order)) {
        targets.sort(config.data_order);
      }
      return targets;
    };
    c3_chart_internal_fn.filterByX = function(targets, x) {
      return this.d3.merge(targets.map(function(t) {
        return t.values;
      })).filter(function(v) {
        return v.x - x === 0;
      });
    };
    c3_chart_internal_fn.filterRemoveNull = function(data) {
      return data.filter(function(d) {
        return isValue(d.value);
      });
    };
    c3_chart_internal_fn.filterByXDomain = function(targets, xDomain) {
      return targets.map(function(t) {
        return {
          id: t.id,
          id_org: t.id_org,
          values: t.values.filter(function(v) {
            return xDomain[0] <= v.x && v.x <= xDomain[1];
          })
        };
      });
    };
    c3_chart_internal_fn.hasDataLabel = function() {
      var config = this.config;
      if (typeof config.data_labels === 'boolean' && config.data_labels) {
        return true;
      } else if (typeof config.data_labels === 'object' && notEmpty(config.data_labels)) {
        return true;
      }
      return false;
    };
    c3_chart_internal_fn.getDataLabelLength = function(min, max, key) {
      var $$ = this,
          lengths = [0, 0],
          paddingCoef = 1.3;
      $$.selectChart.select('svg').selectAll('.dummy').data([min, max]).enter().append('text').text(function(d) {
        return $$.dataLabelFormat(d.id)(d);
      }).each(function(d, i) {
        lengths[i] = this.getBoundingClientRect()[key] * paddingCoef;
      }).remove();
      return lengths;
    };
    c3_chart_internal_fn.isNoneArc = function(d) {
      return this.hasTarget(this.data.targets, d.id);
    }, c3_chart_internal_fn.isArc = function(d) {
      return 'data' in d && this.hasTarget(this.data.targets, d.data.id);
    };
    c3_chart_internal_fn.findSameXOfValues = function(values, index) {
      var i,
          targetX = values[index].x,
          sames = [];
      for (i = index - 1; i >= 0; i--) {
        if (targetX !== values[i].x) {
          break;
        }
        sames.push(values[i]);
      }
      for (i = index; i < values.length; i++) {
        if (targetX !== values[i].x) {
          break;
        }
        sames.push(values[i]);
      }
      return sames;
    };
    c3_chart_internal_fn.findClosestFromTargets = function(targets, pos) {
      var $$ = this,
          candidates;
      candidates = targets.map(function(target) {
        return $$.findClosest(target.values, pos);
      });
      return $$.findClosest(candidates, pos);
    };
    c3_chart_internal_fn.findClosest = function(values, pos) {
      var $$ = this,
          minDist = $$.config.point_sensitivity,
          closest;
      values.filter(function(v) {
        return v && $$.isBarType(v.id);
      }).forEach(function(v) {
        var shape = $$.main.select('.' + CLASS.bars + $$.getTargetSelectorSuffix(v.id) + ' .' + CLASS.bar + '-' + v.index).node();
        if (!closest && $$.isWithinBar(shape)) {
          closest = v;
        }
      });
      values.filter(function(v) {
        return v && !$$.isBarType(v.id);
      }).forEach(function(v) {
        var d = $$.dist(v, pos);
        if (d < minDist) {
          minDist = d;
          closest = v;
        }
      });
      return closest;
    };
    c3_chart_internal_fn.dist = function(data, pos) {
      var $$ = this,
          config = $$.config,
          xIndex = config.axis_rotated ? 1 : 0,
          yIndex = config.axis_rotated ? 0 : 1,
          y = $$.circleY(data, data.index),
          x = $$.x(data.x);
      return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
    };
    c3_chart_internal_fn.convertValuesToStep = function(values) {
      var converted = [].concat(values),
          i;
      if (!this.isCategorized()) {
        return values;
      }
      for (i = values.length + 1; 0 < i; i--) {
        converted[i] = converted[i - 1];
      }
      converted[0] = {
        x: converted[0].x - 1,
        value: converted[0].value,
        id: converted[0].id
      };
      converted[values.length + 1] = {
        x: converted[values.length].x + 1,
        value: converted[values.length].value,
        id: converted[values.length].id
      };
      return converted;
    };
    c3_chart_internal_fn.updateDataAttributes = function(name, attrs) {
      var $$ = this,
          config = $$.config,
          current = config['data_' + name];
      if (typeof attrs === 'undefined') {
        return current;
      }
      Object.keys(attrs).forEach(function(id) {
        current[id] = attrs[id];
      });
      $$.redraw({withLegend: true});
      return current;
    };
    c3_chart_internal_fn.convertUrlToData = function(url, mimeType, keys, done) {
      var $$ = this,
          type = mimeType ? mimeType : 'csv';
      $$.d3.xhr(url, function(error, data) {
        var d;
        if (!data) {
          throw new Error(error.responseURL + ' ' + error.status + ' (' + error.statusText + ')');
        }
        if (type === 'json') {
          d = $$.convertJsonToData(JSON.parse(data.response), keys);
        } else if (type === 'tsv') {
          d = $$.convertTsvToData(data.response);
        } else {
          d = $$.convertCsvToData(data.response);
        }
        done.call($$, d);
      });
    };
    c3_chart_internal_fn.convertXsvToData = function(xsv, parser) {
      var rows = parser.parseRows(xsv),
          d;
      if (rows.length === 1) {
        d = [{}];
        rows[0].forEach(function(id) {
          d[0][id] = null;
        });
      } else {
        d = parser.parse(xsv);
      }
      return d;
    };
    c3_chart_internal_fn.convertCsvToData = function(csv) {
      return this.convertXsvToData(csv, this.d3.csv);
    };
    c3_chart_internal_fn.convertTsvToData = function(tsv) {
      return this.convertXsvToData(tsv, this.d3.tsv);
    };
    c3_chart_internal_fn.convertJsonToData = function(json, keys) {
      var $$ = this,
          new_rows = [],
          targetKeys,
          data;
      if (keys) {
        if (keys.x) {
          targetKeys = keys.value.concat(keys.x);
          $$.config.data_x = keys.x;
        } else {
          targetKeys = keys.value;
        }
        new_rows.push(targetKeys);
        json.forEach(function(o) {
          var new_row = [];
          targetKeys.forEach(function(key) {
            var v = isUndefined(o[key]) ? null : o[key];
            new_row.push(v);
          });
          new_rows.push(new_row);
        });
        data = $$.convertRowsToData(new_rows);
      } else {
        Object.keys(json).forEach(function(key) {
          new_rows.push([key].concat(json[key]));
        });
        data = $$.convertColumnsToData(new_rows);
      }
      return data;
    };
    c3_chart_internal_fn.convertRowsToData = function(rows) {
      var keys = rows[0],
          new_row = {},
          new_rows = [],
          i,
          j;
      for (i = 1; i < rows.length; i++) {
        new_row = {};
        for (j = 0; j < rows[i].length; j++) {
          if (isUndefined(rows[i][j])) {
            throw new Error("Source data is missing a component at (" + i + "," + j + ")!");
          }
          new_row[keys[j]] = rows[i][j];
        }
        new_rows.push(new_row);
      }
      return new_rows;
    };
    c3_chart_internal_fn.convertColumnsToData = function(columns) {
      var new_rows = [],
          i,
          j,
          key;
      for (i = 0; i < columns.length; i++) {
        key = columns[i][0];
        for (j = 1; j < columns[i].length; j++) {
          if (isUndefined(new_rows[j - 1])) {
            new_rows[j - 1] = {};
          }
          if (isUndefined(columns[i][j])) {
            throw new Error("Source data is missing a component at (" + i + "," + j + ")!");
          }
          new_rows[j - 1][key] = columns[i][j];
        }
      }
      return new_rows;
    };
    c3_chart_internal_fn.convertDataToTargets = function(data, appendXs) {
      var $$ = this,
          config = $$.config,
          ids = $$.d3.keys(data[0]).filter($$.isNotX, $$),
          xs = $$.d3.keys(data[0]).filter($$.isX, $$),
          targets;
      ids.forEach(function(id) {
        var xKey = $$.getXKey(id);
        if ($$.isCustomX() || $$.isTimeSeries()) {
          if (xs.indexOf(xKey) >= 0) {
            $$.data.xs[id] = (appendXs && $$.data.xs[id] ? $$.data.xs[id] : []).concat(data.map(function(d) {
              return d[xKey];
            }).filter(isValue).map(function(rawX, i) {
              return $$.generateTargetX(rawX, id, i);
            }));
          } else if (config.data_x) {
            $$.data.xs[id] = $$.getOtherTargetXs();
          } else if (notEmpty(config.data_xs)) {
            $$.data.xs[id] = $$.getXValuesOfXKey(xKey, $$.data.targets);
          }
        } else {
          $$.data.xs[id] = data.map(function(d, i) {
            return i;
          });
        }
      });
      ids.forEach(function(id) {
        if (!$$.data.xs[id]) {
          throw new Error('x is not defined for id = "' + id + '".');
        }
      });
      targets = ids.map(function(id, index) {
        var convertedId = config.data_idConverter(id);
        return {
          id: convertedId,
          id_org: id,
          values: data.map(function(d, i) {
            var xKey = $$.getXKey(id),
                rawX = d[xKey],
                x = $$.generateTargetX(rawX, id, i),
                value = d[id] !== null && !isNaN(d[id]) ? +d[id] : null;
            if ($$.isCustomX() && $$.isCategorized() && index === 0 && rawX) {
              if (i === 0) {
                config.axis_x_categories = [];
              }
              config.axis_x_categories.push(rawX);
            }
            if (isUndefined(d[id]) || $$.data.xs[id].length <= i) {
              x = undefined;
            }
            return {
              x: x,
              value: value,
              id: convertedId
            };
          }).filter(function(v) {
            return isDefined(v.x);
          })
        };
      });
      targets.forEach(function(t) {
        var i;
        if (config.data_xSort) {
          t.values = t.values.sort(function(v1, v2) {
            var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,
                x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
            return x1 - x2;
          });
        }
        i = 0;
        t.values.forEach(function(v) {
          v.index = i++;
        });
        $$.data.xs[t.id].sort(function(v1, v2) {
          return v1 - v2;
        });
      });
      $$.hasNegativeValue = $$.hasNegativeValueInTargets(targets);
      $$.hasPositiveValue = $$.hasPositiveValueInTargets(targets);
      if (config.data_type) {
        $$.setTargetType($$.mapToIds(targets).filter(function(id) {
          return !(id in config.data_types);
        }), config.data_type);
      }
      targets.forEach(function(d) {
        $$.addCache(d.id_org, d);
      });
      return targets;
    };
    c3_chart_internal_fn.load = function(targets, args) {
      var $$ = this;
      if (targets) {
        if (args.filter) {
          targets = targets.filter(args.filter);
        }
        if (args.type || args.types) {
          targets.forEach(function(t) {
            var type = args.types && args.types[t.id] ? args.types[t.id] : args.type;
            $$.setTargetType(t.id, type);
          });
        }
        $$.data.targets.forEach(function(d) {
          for (var i = 0; i < targets.length; i++) {
            if (d.id === targets[i].id) {
              d.values = targets[i].values;
              targets.splice(i, 1);
              break;
            }
          }
        });
        $$.data.targets = $$.data.targets.concat(targets);
      }
      $$.updateTargets($$.data.targets);
      $$.redraw({
        withUpdateOrgXDomain: true,
        withUpdateXDomain: true,
        withLegend: true
      });
      if (args.done) {
        args.done();
      }
    };
    c3_chart_internal_fn.loadFromArgs = function(args) {
      var $$ = this;
      if (args.data) {
        $$.load($$.convertDataToTargets(args.data), args);
      } else if (args.url) {
        $$.convertUrlToData(args.url, args.mimeType, args.keys, function(data) {
          $$.load($$.convertDataToTargets(data), args);
        });
      } else if (args.json) {
        $$.load($$.convertDataToTargets($$.convertJsonToData(args.json, args.keys)), args);
      } else if (args.rows) {
        $$.load($$.convertDataToTargets($$.convertRowsToData(args.rows)), args);
      } else if (args.columns) {
        $$.load($$.convertDataToTargets($$.convertColumnsToData(args.columns)), args);
      } else {
        $$.load(null, args);
      }
    };
    c3_chart_internal_fn.unload = function(targetIds, done) {
      var $$ = this;
      if (!done) {
        done = function() {};
      }
      targetIds = targetIds.filter(function(id) {
        return $$.hasTarget($$.data.targets, id);
      });
      if (!targetIds || targetIds.length === 0) {
        done();
        return;
      }
      $$.svg.selectAll(targetIds.map(function(id) {
        return $$.selectorTarget(id);
      })).transition().style('opacity', 0).remove().call($$.endall, done);
      targetIds.forEach(function(id) {
        $$.withoutFadeIn[id] = false;
        if ($$.legend) {
          $$.legend.selectAll('.' + CLASS.legendItem + $$.getTargetSelectorSuffix(id)).remove();
        }
        $$.data.targets = $$.data.targets.filter(function(t) {
          return t.id !== id;
        });
      });
    };
    c3_chart_internal_fn.categoryName = function(i) {
      var config = this.config;
      return i < config.axis_x_categories.length ? config.axis_x_categories[i] : i;
    };
    c3_chart_internal_fn.initEventRect = function() {
      var $$ = this;
      $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.eventRects).style('fill-opacity', 0);
    };
    c3_chart_internal_fn.redrawEventRect = function() {
      var $$ = this,
          config = $$.config,
          eventRectUpdate,
          maxDataCountTarget,
          isMultipleX = $$.isMultipleX();
      var eventRects = $$.main.select('.' + CLASS.eventRects).style('cursor', config.zoom_enabled ? config.axis_rotated ? 'ns-resize' : 'ew-resize' : null).classed(CLASS.eventRectsMultiple, isMultipleX).classed(CLASS.eventRectsSingle, !isMultipleX);
      eventRects.selectAll('.' + CLASS.eventRect).remove();
      $$.eventRect = eventRects.selectAll('.' + CLASS.eventRect);
      if (isMultipleX) {
        eventRectUpdate = $$.eventRect.data([0]);
        $$.generateEventRectsForMultipleXs(eventRectUpdate.enter());
        $$.updateEventRect(eventRectUpdate);
      } else {
        maxDataCountTarget = $$.getMaxDataCountTarget($$.data.targets);
        eventRects.datum(maxDataCountTarget ? maxDataCountTarget.values : []);
        $$.eventRect = eventRects.selectAll('.' + CLASS.eventRect);
        eventRectUpdate = $$.eventRect.data(function(d) {
          return d;
        });
        $$.generateEventRectsForSingleX(eventRectUpdate.enter());
        $$.updateEventRect(eventRectUpdate);
        eventRectUpdate.exit().remove();
      }
    };
    c3_chart_internal_fn.updateEventRect = function(eventRectUpdate) {
      var $$ = this,
          config = $$.config,
          x,
          y,
          w,
          h,
          rectW,
          rectX;
      eventRectUpdate = eventRectUpdate || $$.eventRect.data(function(d) {
        return d;
      });
      if ($$.isMultipleX()) {
        x = 0;
        y = 0;
        w = $$.width;
        h = $$.height;
      } else {
        if (($$.isCustomX() || $$.isTimeSeries()) && !$$.isCategorized()) {
          $$.updateXs();
          rectW = function(d) {
            var prevX = $$.getPrevX(d.index),
                nextX = $$.getNextX(d.index);
            if (prevX === null && nextX === null) {
              return config.axis_rotated ? $$.height : $$.width;
            }
            if (prevX === null) {
              prevX = $$.x.domain()[0];
            }
            if (nextX === null) {
              nextX = $$.x.domain()[1];
            }
            return Math.max(0, ($$.x(nextX) - $$.x(prevX)) / 2);
          };
          rectX = function(d) {
            var prevX = $$.getPrevX(d.index),
                nextX = $$.getNextX(d.index),
                thisX = $$.data.xs[d.id][d.index];
            if (prevX === null && nextX === null) {
              return 0;
            }
            if (prevX === null) {
              prevX = $$.x.domain()[0];
            }
            return ($$.x(thisX) + $$.x(prevX)) / 2;
          };
        } else {
          rectW = $$.getEventRectWidth();
          rectX = function(d) {
            return $$.x(d.x) - (rectW / 2);
          };
        }
        x = config.axis_rotated ? 0 : rectX;
        y = config.axis_rotated ? rectX : 0;
        w = config.axis_rotated ? $$.width : rectW;
        h = config.axis_rotated ? rectW : $$.height;
      }
      eventRectUpdate.attr('class', $$.classEvent.bind($$)).attr("x", x).attr("y", y).attr("width", w).attr("height", h);
    };
    c3_chart_internal_fn.generateEventRectsForSingleX = function(eventRectEnter) {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config;
      eventRectEnter.append("rect").attr("class", $$.classEvent.bind($$)).style("cursor", config.data_selection_enabled && config.data_selection_grouped ? "pointer" : null).on('mouseover', function(d) {
        var index = d.index;
        if ($$.dragging || $$.flowing) {
          return;
        }
        if ($$.hasArcType()) {
          return;
        }
        if (config.point_focus_expand_enabled) {
          $$.expandCircles(index, null, true);
        }
        $$.expandBars(index, null, true);
        $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function(d) {
          config.data_onmouseover.call($$.api, d);
        });
      }).on('mouseout', function(d) {
        var index = d.index;
        if (!$$.config) {
          return;
        }
        if ($$.hasArcType()) {
          return;
        }
        $$.hideXGridFocus();
        $$.hideTooltip();
        $$.unexpandCircles();
        $$.unexpandBars();
        $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function(d) {
          config.data_onmouseout.call($$.api, d);
        });
      }).on('mousemove', function(d) {
        var selectedData,
            index = d.index,
            eventRect = $$.svg.select('.' + CLASS.eventRect + '-' + index);
        if ($$.dragging || $$.flowing) {
          return;
        }
        if ($$.hasArcType()) {
          return;
        }
        if ($$.isStepType(d) && $$.config.line_step_type === 'step-after' && d3.mouse(this)[0] < $$.x($$.getXValue(d.id, index))) {
          index -= 1;
        }
        selectedData = $$.filterTargetsToShow($$.data.targets).map(function(t) {
          return $$.addName($$.getValueOnIndex(t.values, index));
        });
        if (config.tooltip_grouped) {
          $$.showTooltip(selectedData, this);
          $$.showXGridFocus(selectedData);
        }
        if (config.tooltip_grouped && (!config.data_selection_enabled || config.data_selection_grouped)) {
          return;
        }
        $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function() {
          d3.select(this).classed(CLASS.EXPANDED, true);
          if (config.data_selection_enabled) {
            eventRect.style('cursor', config.data_selection_grouped ? 'pointer' : null);
          }
          if (!config.tooltip_grouped) {
            $$.hideXGridFocus();
            $$.hideTooltip();
            if (!config.data_selection_grouped) {
              $$.unexpandCircles(index);
              $$.unexpandBars(index);
            }
          }
        }).filter(function(d) {
          return $$.isWithinShape(this, d);
        }).each(function(d) {
          if (config.data_selection_enabled && (config.data_selection_grouped || config.data_selection_isselectable(d))) {
            eventRect.style('cursor', 'pointer');
          }
          if (!config.tooltip_grouped) {
            $$.showTooltip([d], this);
            $$.showXGridFocus([d]);
            if (config.point_focus_expand_enabled) {
              $$.expandCircles(index, d.id, true);
            }
            $$.expandBars(index, d.id, true);
          }
        });
      }).on('click', function(d) {
        var index = d.index;
        if ($$.hasArcType() || !$$.toggleShape) {
          return;
        }
        if ($$.cancelClick) {
          $$.cancelClick = false;
          return;
        }
        if ($$.isStepType(d) && config.line_step_type === 'step-after' && d3.mouse(this)[0] < $$.x($$.getXValue(d.id, index))) {
          index -= 1;
        }
        $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function(d) {
          if (config.data_selection_grouped || $$.isWithinShape(this, d)) {
            $$.toggleShape(this, d, index);
            $$.config.data_onclick.call($$.api, d, this);
          }
        });
      }).call(config.data_selection_draggable && $$.drag ? (d3.behavior.drag().origin(Object).on('drag', function() {
        $$.drag(d3.mouse(this));
      }).on('dragstart', function() {
        $$.dragstart(d3.mouse(this));
      }).on('dragend', function() {
        $$.dragend();
      })) : function() {});
    };
    c3_chart_internal_fn.generateEventRectsForMultipleXs = function(eventRectEnter) {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config;
      function mouseout() {
        $$.svg.select('.' + CLASS.eventRect).style('cursor', null);
        $$.hideXGridFocus();
        $$.hideTooltip();
        $$.unexpandCircles();
        $$.unexpandBars();
      }
      eventRectEnter.append('rect').attr('x', 0).attr('y', 0).attr('width', $$.width).attr('height', $$.height).attr('class', CLASS.eventRect).on('mouseout', function() {
        if (!$$.config) {
          return;
        }
        if ($$.hasArcType()) {
          return;
        }
        mouseout();
      }).on('mousemove', function() {
        var targetsToShow = $$.filterTargetsToShow($$.data.targets);
        var mouse,
            closest,
            sameXData,
            selectedData;
        if ($$.dragging) {
          return;
        }
        if ($$.hasArcType(targetsToShow)) {
          return;
        }
        mouse = d3.mouse(this);
        closest = $$.findClosestFromTargets(targetsToShow, mouse);
        if ($$.mouseover && (!closest || closest.id !== $$.mouseover.id)) {
          config.data_onmouseout.call($$.api, $$.mouseover);
          $$.mouseover = undefined;
        }
        if (!closest) {
          mouseout();
          return;
        }
        if ($$.isScatterType(closest) || !config.tooltip_grouped) {
          sameXData = [closest];
        } else {
          sameXData = $$.filterByX(targetsToShow, closest.x);
        }
        selectedData = sameXData.map(function(d) {
          return $$.addName(d);
        });
        $$.showTooltip(selectedData, this);
        if (config.point_focus_expand_enabled) {
          $$.expandCircles(closest.index, closest.id, true);
        }
        $$.expandBars(closest.index, closest.id, true);
        $$.showXGridFocus(selectedData);
        if ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) {
          $$.svg.select('.' + CLASS.eventRect).style('cursor', 'pointer');
          if (!$$.mouseover) {
            config.data_onmouseover.call($$.api, closest);
            $$.mouseover = closest;
          }
        }
      }).on('click', function() {
        var targetsToShow = $$.filterTargetsToShow($$.data.targets);
        var mouse,
            closest;
        if ($$.hasArcType(targetsToShow)) {
          return;
        }
        mouse = d3.mouse(this);
        closest = $$.findClosestFromTargets(targetsToShow, mouse);
        if (!closest) {
          return;
        }
        if ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) {
          $$.main.selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(closest.id)).selectAll('.' + CLASS.shape + '-' + closest.index).each(function() {
            if (config.data_selection_grouped || $$.isWithinShape(this, closest)) {
              $$.toggleShape(this, closest, closest.index);
              $$.config.data_onclick.call($$.api, closest, this);
            }
          });
        }
      }).call(config.data_selection_draggable && $$.drag ? (d3.behavior.drag().origin(Object).on('drag', function() {
        $$.drag(d3.mouse(this));
      }).on('dragstart', function() {
        $$.dragstart(d3.mouse(this));
      }).on('dragend', function() {
        $$.dragend();
      })) : function() {});
    };
    c3_chart_internal_fn.dispatchEvent = function(type, index, mouse) {
      var $$ = this,
          selector = '.' + CLASS.eventRect + (!$$.isMultipleX() ? '-' + index : ''),
          eventRect = $$.main.select(selector).node(),
          box = eventRect.getBoundingClientRect(),
          x = box.left + (mouse ? mouse[0] : 0),
          y = box.top + (mouse ? mouse[1] : 0),
          event = document.createEvent("MouseEvents");
      event.initMouseEvent(type, true, true, window, 0, x, y, x, y, false, false, false, false, 0, null);
      eventRect.dispatchEvent(event);
    };
    c3_chart_internal_fn.getCurrentWidth = function() {
      var $$ = this,
          config = $$.config;
      return config.size_width ? config.size_width : $$.getParentWidth();
    };
    c3_chart_internal_fn.getCurrentHeight = function() {
      var $$ = this,
          config = $$.config,
          h = config.size_height ? config.size_height : $$.getParentHeight();
      return h > 0 ? h : 320 / ($$.hasType('gauge') ? 2 : 1);
    };
    c3_chart_internal_fn.getCurrentPaddingTop = function() {
      var $$ = this,
          config = $$.config,
          padding = isValue(config.padding_top) ? config.padding_top : 0;
      if ($$.title && $$.title.node()) {
        padding += $$.getTitlePadding();
      }
      return padding;
    };
    c3_chart_internal_fn.getCurrentPaddingBottom = function() {
      var config = this.config;
      return isValue(config.padding_bottom) ? config.padding_bottom : 0;
    };
    c3_chart_internal_fn.getCurrentPaddingLeft = function(withoutRecompute) {
      var $$ = this,
          config = $$.config;
      if (isValue(config.padding_left)) {
        return config.padding_left;
      } else if (config.axis_rotated) {
        return !config.axis_x_show ? 1 : Math.max(ceil10($$.getAxisWidthByAxisId('x', withoutRecompute)), 40);
      } else if (!config.axis_y_show || config.axis_y_inner) {
        return $$.axis.getYAxisLabelPosition().isOuter ? 30 : 1;
      } else {
        return ceil10($$.getAxisWidthByAxisId('y', withoutRecompute));
      }
    };
    c3_chart_internal_fn.getCurrentPaddingRight = function() {
      var $$ = this,
          config = $$.config,
          defaultPadding = 10,
          legendWidthOnRight = $$.isLegendRight ? $$.getLegendWidth() + 20 : 0;
      if (isValue(config.padding_right)) {
        return config.padding_right + 1;
      } else if (config.axis_rotated) {
        return defaultPadding + legendWidthOnRight;
      } else if (!config.axis_y2_show || config.axis_y2_inner) {
        return 2 + legendWidthOnRight + ($$.axis.getY2AxisLabelPosition().isOuter ? 20 : 0);
      } else {
        return ceil10($$.getAxisWidthByAxisId('y2')) + legendWidthOnRight;
      }
    };
    c3_chart_internal_fn.getParentRectValue = function(key) {
      var parent = this.selectChart.node(),
          v;
      while (parent && parent.tagName !== 'BODY') {
        try {
          v = parent.getBoundingClientRect()[key];
        } catch (e) {
          if (key === 'width') {
            v = parent.offsetWidth;
          }
        }
        if (v) {
          break;
        }
        parent = parent.parentNode;
      }
      return v;
    };
    c3_chart_internal_fn.getParentWidth = function() {
      return this.getParentRectValue('width');
    };
    c3_chart_internal_fn.getParentHeight = function() {
      var h = this.selectChart.style('height');
      return h.indexOf('px') > 0 ? +h.replace('px', '') : 0;
    };
    c3_chart_internal_fn.getSvgLeft = function(withoutRecompute) {
      var $$ = this,
          config = $$.config,
          hasLeftAxisRect = config.axis_rotated || (!config.axis_rotated && !config.axis_y_inner),
          leftAxisClass = config.axis_rotated ? CLASS.axisX : CLASS.axisY,
          leftAxis = $$.main.select('.' + leftAxisClass).node(),
          svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : {right: 0},
          chartRect = $$.selectChart.node().getBoundingClientRect(),
          hasArc = $$.hasArcType(),
          svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
      return svgLeft > 0 ? svgLeft : 0;
    };
    c3_chart_internal_fn.getAxisWidthByAxisId = function(id, withoutRecompute) {
      var $$ = this,
          position = $$.axis.getLabelPositionById(id);
      return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);
    };
    c3_chart_internal_fn.getHorizontalAxisHeight = function(axisId) {
      var $$ = this,
          config = $$.config,
          h = 30;
      if (axisId === 'x' && !config.axis_x_show) {
        return 8;
      }
      if (axisId === 'x' && config.axis_x_height) {
        return config.axis_x_height;
      }
      if (axisId === 'y' && !config.axis_y_show) {
        return config.legend_show && !$$.isLegendRight && !$$.isLegendInset ? 10 : 1;
      }
      if (axisId === 'y2' && !config.axis_y2_show) {
        return $$.rotated_padding_top;
      }
      if (axisId === 'x' && !config.axis_rotated && config.axis_x_tick_rotate) {
        h = 30 + $$.axis.getMaxTickWidth(axisId) * Math.cos(Math.PI * (90 - config.axis_x_tick_rotate) / 180);
      }
      return h + ($$.axis.getLabelPositionById(axisId).isInner ? 0 : 10) + (axisId === 'y2' ? -10 : 0);
    };
    c3_chart_internal_fn.getEventRectWidth = function() {
      return Math.max(0, this.xAxis.tickInterval());
    };
    c3_chart_internal_fn.getShapeIndices = function(typeFilter) {
      var $$ = this,
          config = $$.config,
          indices = {},
          i = 0,
          j,
          k;
      $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function(d) {
        for (j = 0; j < config.data_groups.length; j++) {
          if (config.data_groups[j].indexOf(d.id) < 0) {
            continue;
          }
          for (k = 0; k < config.data_groups[j].length; k++) {
            if (config.data_groups[j][k] in indices) {
              indices[d.id] = indices[config.data_groups[j][k]];
              break;
            }
          }
        }
        if (isUndefined(indices[d.id])) {
          indices[d.id] = i++;
        }
      });
      indices.__max__ = i - 1;
      return indices;
    };
    c3_chart_internal_fn.getShapeX = function(offset, targetsNum, indices, isSub) {
      var $$ = this,
          scale = isSub ? $$.subX : $$.x;
      return function(d) {
        var index = d.id in indices ? indices[d.id] : 0;
        return d.x || d.x === 0 ? scale(d.x) - offset * (targetsNum / 2 - index) : 0;
      };
    };
    c3_chart_internal_fn.getShapeY = function(isSub) {
      var $$ = this;
      return function(d) {
        var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id);
        return scale(d.value);
      };
    };
    c3_chart_internal_fn.getShapeOffset = function(typeFilter, indices, isSub) {
      var $$ = this,
          targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),
          targetIds = targets.map(function(t) {
            return t.id;
          });
      return function(d, i) {
        var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id),
            y0 = scale(0),
            offset = y0;
        targets.forEach(function(t) {
          var values = $$.isStepType(d) ? $$.convertValuesToStep(t.values) : t.values;
          if (t.id === d.id || indices[t.id] !== indices[d.id]) {
            return;
          }
          if (targetIds.indexOf(t.id) < targetIds.indexOf(d.id)) {
            if (typeof values[i] === 'undefined' || +values[i].x !== +d.x) {
              i = -1;
              values.forEach(function(v, j) {
                if (v.x === d.x) {
                  i = j;
                }
              });
            }
            if (i in values && values[i].value * d.value >= 0) {
              offset += scale(values[i].value) - y0;
            }
          }
        });
        return offset;
      };
    };
    c3_chart_internal_fn.isWithinShape = function(that, d) {
      var $$ = this,
          shape = $$.d3.select(that),
          isWithin;
      if (!$$.isTargetToShow(d.id)) {
        isWithin = false;
      } else if (that.nodeName === 'circle') {
        isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value)) : $$.isWithinCircle(that, $$.pointSelectR(d) * 1.5);
      } else if (that.nodeName === 'path') {
        isWithin = shape.classed(CLASS.bar) ? $$.isWithinBar(that) : true;
      }
      return isWithin;
    };
    c3_chart_internal_fn.getInterpolate = function(d) {
      var $$ = this,
          interpolation = $$.isInterpolationType($$.config.spline_interpolation_type) ? $$.config.spline_interpolation_type : 'cardinal';
      return $$.isSplineType(d) ? interpolation : $$.isStepType(d) ? $$.config.line_step_type : "linear";
    };
    c3_chart_internal_fn.initLine = function() {
      var $$ = this;
      $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartLines);
    };
    c3_chart_internal_fn.updateTargetsForLine = function(targets) {
      var $$ = this,
          config = $$.config,
          mainLineUpdate,
          mainLineEnter,
          classChartLine = $$.classChartLine.bind($$),
          classLines = $$.classLines.bind($$),
          classAreas = $$.classAreas.bind($$),
          classCircles = $$.classCircles.bind($$),
          classFocus = $$.classFocus.bind($$);
      mainLineUpdate = $$.main.select('.' + CLASS.chartLines).selectAll('.' + CLASS.chartLine).data(targets).attr('class', function(d) {
        return classChartLine(d) + classFocus(d);
      });
      mainLineEnter = mainLineUpdate.enter().append('g').attr('class', classChartLine).style('opacity', 0).style("pointer-events", "none");
      mainLineEnter.append('g').attr("class", classLines);
      mainLineEnter.append('g').attr('class', classAreas);
      mainLineEnter.append('g').attr("class", function(d) {
        return $$.generateClass(CLASS.selectedCircles, d.id);
      });
      mainLineEnter.append('g').attr("class", classCircles).style("cursor", function(d) {
        return config.data_selection_isselectable(d) ? "pointer" : null;
      });
      targets.forEach(function(t) {
        $$.main.selectAll('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(t.id)).selectAll('.' + CLASS.selectedCircle).each(function(d) {
          d.value = t.values[d.index].value;
        });
      });
    };
    c3_chart_internal_fn.updateLine = function(durationForExit) {
      var $$ = this;
      $$.mainLine = $$.main.selectAll('.' + CLASS.lines).selectAll('.' + CLASS.line).data($$.lineData.bind($$));
      $$.mainLine.enter().append('path').attr('class', $$.classLine.bind($$)).style("stroke", $$.color);
      $$.mainLine.style("opacity", $$.initialOpacity.bind($$)).style('shape-rendering', function(d) {
        return $$.isStepType(d) ? 'crispEdges' : '';
      }).attr('transform', null);
      $$.mainLine.exit().transition().duration(durationForExit).style('opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawLine = function(drawLine, withTransition) {
      return [(withTransition ? this.mainLine.transition() : this.mainLine).attr("d", drawLine).style("stroke", this.color).style("opacity", 1)];
    };
    c3_chart_internal_fn.generateDrawLine = function(lineIndices, isSub) {
      var $$ = this,
          config = $$.config,
          line = $$.d3.svg.line(),
          getPoints = $$.generateGetLinePoints(lineIndices, isSub),
          yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
          xValue = function(d) {
            return (isSub ? $$.subxx : $$.xx).call($$, d);
          },
          yValue = function(d, i) {
            return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)(d.value);
          };
      line = config.axis_rotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue);
      if (!config.line_connectNull) {
        line = line.defined(function(d) {
          return d.value != null;
        });
      }
      return function(d) {
        var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,
            x = isSub ? $$.x : $$.subX,
            y = yScaleGetter.call($$, d.id),
            x0 = 0,
            y0 = 0,
            path;
        if ($$.isLineType(d)) {
          if (config.data_regions[d.id]) {
            path = $$.lineWithRegions(values, x, y, config.data_regions[d.id]);
          } else {
            if ($$.isStepType(d)) {
              values = $$.convertValuesToStep(values);
            }
            path = line.interpolate($$.getInterpolate(d))(values);
          }
        } else {
          if (values[0]) {
            x0 = x(values[0].x);
            y0 = y(values[0].value);
          }
          path = config.axis_rotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;
        }
        return path ? path : "M 0 0";
      };
    };
    c3_chart_internal_fn.generateGetLinePoints = function(lineIndices, isSub) {
      var $$ = this,
          config = $$.config,
          lineTargetsNum = lineIndices.__max__ + 1,
          x = $$.getShapeX(0, lineTargetsNum, lineIndices, !!isSub),
          y = $$.getShapeY(!!isSub),
          lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, !!isSub),
          yScale = isSub ? $$.getSubYScale : $$.getYScale;
      return function(d, i) {
        var y0 = yScale.call($$, d.id)(0),
            offset = lineOffset(d, i) || y0,
            posX = x(d),
            posY = y(d);
        if (config.axis_rotated) {
          if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {
            posY = y0;
          }
        }
        return [[posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)]];
      };
    };
    c3_chart_internal_fn.lineWithRegions = function(d, x, y, _regions) {
      var $$ = this,
          config = $$.config,
          prev = -1,
          i,
          j,
          s = "M",
          sWithRegion,
          xp,
          yp,
          dx,
          dy,
          dd,
          diff,
          diffx2,
          xOffset = $$.isCategorized() ? 0.5 : 0,
          xValue,
          yValue,
          regions = [];
      function isWithinRegions(x, regions) {
        var i;
        for (i = 0; i < regions.length; i++) {
          if (regions[i].start < x && x <= regions[i].end) {
            return true;
          }
        }
        return false;
      }
      if (isDefined(_regions)) {
        for (i = 0; i < _regions.length; i++) {
          regions[i] = {};
          if (isUndefined(_regions[i].start)) {
            regions[i].start = d[0].x;
          } else {
            regions[i].start = $$.isTimeSeries() ? $$.parseDate(_regions[i].start) : _regions[i].start;
          }
          if (isUndefined(_regions[i].end)) {
            regions[i].end = d[d.length - 1].x;
          } else {
            regions[i].end = $$.isTimeSeries() ? $$.parseDate(_regions[i].end) : _regions[i].end;
          }
        }
      }
      xValue = config.axis_rotated ? function(d) {
        return y(d.value);
      } : function(d) {
        return x(d.x);
      };
      yValue = config.axis_rotated ? function(d) {
        return x(d.x);
      } : function(d) {
        return y(d.value);
      };
      function generateM(points) {
        return 'M' + points[0][0] + ' ' + points[0][1] + ' ' + points[1][0] + ' ' + points[1][1];
      }
      if ($$.isTimeSeries()) {
        sWithRegion = function(d0, d1, j, diff) {
          var x0 = d0.x.getTime(),
              x_diff = d1.x - d0.x,
              xv0 = new Date(x0 + x_diff * j),
              xv1 = new Date(x0 + x_diff * (j + diff)),
              points;
          if (config.axis_rotated) {
            points = [[y(yp(j)), x(xv0)], [y(yp(j + diff)), x(xv1)]];
          } else {
            points = [[x(xv0), y(yp(j))], [x(xv1), y(yp(j + diff))]];
          }
          return generateM(points);
        };
      } else {
        sWithRegion = function(d0, d1, j, diff) {
          var points;
          if (config.axis_rotated) {
            points = [[y(yp(j), true), x(xp(j))], [y(yp(j + diff), true), x(xp(j + diff))]];
          } else {
            points = [[x(xp(j), true), y(yp(j))], [x(xp(j + diff), true), y(yp(j + diff))]];
          }
          return generateM(points);
        };
      }
      for (i = 0; i < d.length; i++) {
        if (isUndefined(regions) || !isWithinRegions(d[i].x, regions)) {
          s += " " + xValue(d[i]) + " " + yValue(d[i]);
        } else {
          xp = $$.getScale(d[i - 1].x + xOffset, d[i].x + xOffset, $$.isTimeSeries());
          yp = $$.getScale(d[i - 1].value, d[i].value);
          dx = x(d[i].x) - x(d[i - 1].x);
          dy = y(d[i].value) - y(d[i - 1].value);
          dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          diff = 2 / dd;
          diffx2 = diff * 2;
          for (j = diff; j <= 1; j += diffx2) {
            s += sWithRegion(d[i - 1], d[i], j, diff);
          }
        }
        prev = d[i].x;
      }
      return s;
    };
    c3_chart_internal_fn.updateArea = function(durationForExit) {
      var $$ = this,
          d3 = $$.d3;
      $$.mainArea = $$.main.selectAll('.' + CLASS.areas).selectAll('.' + CLASS.area).data($$.lineData.bind($$));
      $$.mainArea.enter().append('path').attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function() {
        $$.orgAreaOpacity = +d3.select(this).style('opacity');
        return 0;
      });
      $$.mainArea.style("opacity", $$.orgAreaOpacity);
      $$.mainArea.exit().transition().duration(durationForExit).style('opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawArea = function(drawArea, withTransition) {
      return [(withTransition ? this.mainArea.transition() : this.mainArea).attr("d", drawArea).style("fill", this.color).style("opacity", this.orgAreaOpacity)];
    };
    c3_chart_internal_fn.generateDrawArea = function(areaIndices, isSub) {
      var $$ = this,
          config = $$.config,
          area = $$.d3.svg.area(),
          getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
          yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
          xValue = function(d) {
            return (isSub ? $$.subxx : $$.xx).call($$, d);
          },
          value0 = function(d, i) {
            return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.getAreaBaseValue(d.id));
          },
          value1 = function(d, i) {
            return config.data_groups.length > 0 ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)(d.value);
          };
      area = config.axis_rotated ? area.x0(value0).x1(value1).y(xValue) : area.x(xValue).y0(value0).y1(value1);
      if (!config.line_connectNull) {
        area = area.defined(function(d) {
          return d.value !== null;
        });
      }
      return function(d) {
        var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,
            x0 = 0,
            y0 = 0,
            path;
        if ($$.isAreaType(d)) {
          if ($$.isStepType(d)) {
            values = $$.convertValuesToStep(values);
          }
          path = area.interpolate($$.getInterpolate(d))(values);
        } else {
          if (values[0]) {
            x0 = $$.x(values[0].x);
            y0 = $$.getYScale(d.id)(values[0].value);
          }
          path = config.axis_rotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;
        }
        return path ? path : "M 0 0";
      };
    };
    c3_chart_internal_fn.getAreaBaseValue = function() {
      return 0;
    };
    c3_chart_internal_fn.generateGetAreaPoints = function(areaIndices, isSub) {
      var $$ = this,
          config = $$.config,
          areaTargetsNum = areaIndices.__max__ + 1,
          x = $$.getShapeX(0, areaTargetsNum, areaIndices, !!isSub),
          y = $$.getShapeY(!!isSub),
          areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
          yScale = isSub ? $$.getSubYScale : $$.getYScale;
      return function(d, i) {
        var y0 = yScale.call($$, d.id)(0),
            offset = areaOffset(d, i) || y0,
            posX = x(d),
            posY = y(d);
        if (config.axis_rotated) {
          if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {
            posY = y0;
          }
        }
        return [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], [posX, offset]];
      };
    };
    c3_chart_internal_fn.updateCircle = function() {
      var $$ = this;
      $$.mainCircle = $$.main.selectAll('.' + CLASS.circles).selectAll('.' + CLASS.circle).data($$.lineOrScatterData.bind($$));
      $$.mainCircle.enter().append("circle").attr("class", $$.classCircle.bind($$)).attr("r", $$.pointR.bind($$)).style("fill", $$.color);
      $$.mainCircle.style("opacity", $$.initialOpacityForCircle.bind($$));
      $$.mainCircle.exit().remove();
    };
    c3_chart_internal_fn.redrawCircle = function(cx, cy, withTransition) {
      var selectedCircles = this.main.selectAll('.' + CLASS.selectedCircle);
      return [(withTransition ? this.mainCircle.transition() : this.mainCircle).style('opacity', this.opacityForCircle.bind(this)).style("fill", this.color).attr("cx", cx).attr("cy", cy), (withTransition ? selectedCircles.transition() : selectedCircles).attr("cx", cx).attr("cy", cy)];
    };
    c3_chart_internal_fn.circleX = function(d) {
      return d.x || d.x === 0 ? this.x(d.x) : null;
    };
    c3_chart_internal_fn.updateCircleY = function() {
      var $$ = this,
          lineIndices,
          getPoints;
      if ($$.config.data_groups.length > 0) {
        lineIndices = $$.getShapeIndices($$.isLineType), getPoints = $$.generateGetLinePoints(lineIndices);
        $$.circleY = function(d, i) {
          return getPoints(d, i)[0][1];
        };
      } else {
        $$.circleY = function(d) {
          return $$.getYScale(d.id)(d.value);
        };
      }
    };
    c3_chart_internal_fn.getCircles = function(i, id) {
      var $$ = this;
      return (id ? $$.main.selectAll('.' + CLASS.circles + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll('.' + CLASS.circle + (isValue(i) ? '-' + i : ''));
    };
    c3_chart_internal_fn.expandCircles = function(i, id, reset) {
      var $$ = this,
          r = $$.pointExpandedR.bind($$);
      if (reset) {
        $$.unexpandCircles();
      }
      $$.getCircles(i, id).classed(CLASS.EXPANDED, true).attr('r', r);
    };
    c3_chart_internal_fn.unexpandCircles = function(i) {
      var $$ = this,
          r = $$.pointR.bind($$);
      $$.getCircles(i).filter(function() {
        return $$.d3.select(this).classed(CLASS.EXPANDED);
      }).classed(CLASS.EXPANDED, false).attr('r', r);
    };
    c3_chart_internal_fn.pointR = function(d) {
      var $$ = this,
          config = $$.config;
      return $$.isStepType(d) ? 0 : (isFunction(config.point_r) ? config.point_r(d) : config.point_r);
    };
    c3_chart_internal_fn.pointExpandedR = function(d) {
      var $$ = this,
          config = $$.config;
      return config.point_focus_expand_enabled ? (config.point_focus_expand_r ? config.point_focus_expand_r : $$.pointR(d) * 1.75) : $$.pointR(d);
    };
    c3_chart_internal_fn.pointSelectR = function(d) {
      var $$ = this,
          config = $$.config;
      return config.point_select_r ? config.point_select_r : $$.pointR(d) * 4;
    };
    c3_chart_internal_fn.isWithinCircle = function(that, r) {
      var d3 = this.d3,
          mouse = d3.mouse(that),
          d3_this = d3.select(that),
          cx = +d3_this.attr("cx"),
          cy = +d3_this.attr("cy");
      return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < r;
    };
    c3_chart_internal_fn.isWithinStep = function(that, y) {
      return Math.abs(y - this.d3.mouse(that)[1]) < 30;
    };
    c3_chart_internal_fn.initBar = function() {
      var $$ = this;
      $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartBars);
    };
    c3_chart_internal_fn.updateTargetsForBar = function(targets) {
      var $$ = this,
          config = $$.config,
          mainBarUpdate,
          mainBarEnter,
          classChartBar = $$.classChartBar.bind($$),
          classBars = $$.classBars.bind($$),
          classFocus = $$.classFocus.bind($$);
      mainBarUpdate = $$.main.select('.' + CLASS.chartBars).selectAll('.' + CLASS.chartBar).data(targets).attr('class', function(d) {
        return classChartBar(d) + classFocus(d);
      });
      mainBarEnter = mainBarUpdate.enter().append('g').attr('class', classChartBar).style('opacity', 0).style("pointer-events", "none");
      mainBarEnter.append('g').attr("class", classBars).style("cursor", function(d) {
        return config.data_selection_isselectable(d) ? "pointer" : null;
      });
    };
    c3_chart_internal_fn.updateBar = function(durationForExit) {
      var $$ = this,
          barData = $$.barData.bind($$),
          classBar = $$.classBar.bind($$),
          initialOpacity = $$.initialOpacity.bind($$),
          color = function(d) {
            return $$.color(d.id);
          };
      $$.mainBar = $$.main.selectAll('.' + CLASS.bars).selectAll('.' + CLASS.bar).data(barData);
      $$.mainBar.enter().append('path').attr("class", classBar).style("stroke", color).style("fill", color);
      $$.mainBar.style("opacity", initialOpacity);
      $$.mainBar.exit().transition().duration(durationForExit).style('opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawBar = function(drawBar, withTransition) {
      return [(withTransition ? this.mainBar.transition() : this.mainBar).attr('d', drawBar).style("fill", this.color).style("opacity", 1)];
    };
    c3_chart_internal_fn.getBarW = function(axis, barTargetsNum) {
      var $$ = this,
          config = $$.config,
          w = typeof config.bar_width === 'number' ? config.bar_width : barTargetsNum ? (axis.tickInterval() * config.bar_width_ratio) / barTargetsNum : 0;
      return config.bar_width_max && w > config.bar_width_max ? config.bar_width_max : w;
    };
    c3_chart_internal_fn.getBars = function(i, id) {
      var $$ = this;
      return (id ? $$.main.selectAll('.' + CLASS.bars + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll('.' + CLASS.bar + (isValue(i) ? '-' + i : ''));
    };
    c3_chart_internal_fn.expandBars = function(i, id, reset) {
      var $$ = this;
      if (reset) {
        $$.unexpandBars();
      }
      $$.getBars(i, id).classed(CLASS.EXPANDED, true);
    };
    c3_chart_internal_fn.unexpandBars = function(i) {
      var $$ = this;
      $$.getBars(i).classed(CLASS.EXPANDED, false);
    };
    c3_chart_internal_fn.generateDrawBar = function(barIndices, isSub) {
      var $$ = this,
          config = $$.config,
          getPoints = $$.generateGetBarPoints(barIndices, isSub);
      return function(d, i) {
        var points = getPoints(d, i);
        var indexX = config.axis_rotated ? 1 : 0;
        var indexY = config.axis_rotated ? 0 : 1;
        var path = 'M ' + points[0][indexX] + ',' + points[0][indexY] + ' ' + 'L' + points[1][indexX] + ',' + points[1][indexY] + ' ' + 'L' + points[2][indexX] + ',' + points[2][indexY] + ' ' + 'L' + points[3][indexX] + ',' + points[3][indexY] + ' ' + 'z';
        return path;
      };
    };
    c3_chart_internal_fn.generateGetBarPoints = function(barIndices, isSub) {
      var $$ = this,
          axis = isSub ? $$.subXAxis : $$.xAxis,
          barTargetsNum = barIndices.__max__ + 1,
          barW = $$.getBarW(axis, barTargetsNum),
          barX = $$.getShapeX(barW, barTargetsNum, barIndices, !!isSub),
          barY = $$.getShapeY(!!isSub),
          barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),
          yScale = isSub ? $$.getSubYScale : $$.getYScale;
      return function(d, i) {
        var y0 = yScale.call($$, d.id)(0),
            offset = barOffset(d, i) || y0,
            posX = barX(d),
            posY = barY(d);
        if ($$.config.axis_rotated) {
          if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {
            posY = y0;
          }
        }
        return [[posX, offset], [posX, posY - (y0 - offset)], [posX + barW, posY - (y0 - offset)], [posX + barW, offset]];
      };
    };
    c3_chart_internal_fn.isWithinBar = function(that) {
      var mouse = this.d3.mouse(that),
          box = that.getBoundingClientRect(),
          seg0 = that.pathSegList.getItem(0),
          seg1 = that.pathSegList.getItem(1),
          x = Math.min(seg0.x, seg1.x),
          y = Math.min(seg0.y, seg1.y),
          w = box.width,
          h = box.height,
          offset = 2,
          sx = x - offset,
          ex = x + w + offset,
          sy = y + h + offset,
          ey = y - offset;
      return sx < mouse[0] && mouse[0] < ex && ey < mouse[1] && mouse[1] < sy;
    };
    c3_chart_internal_fn.initText = function() {
      var $$ = this;
      $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartTexts);
      $$.mainText = $$.d3.selectAll([]);
    };
    c3_chart_internal_fn.updateTargetsForText = function(targets) {
      var $$ = this,
          mainTextUpdate,
          mainTextEnter,
          classChartText = $$.classChartText.bind($$),
          classTexts = $$.classTexts.bind($$),
          classFocus = $$.classFocus.bind($$);
      mainTextUpdate = $$.main.select('.' + CLASS.chartTexts).selectAll('.' + CLASS.chartText).data(targets).attr('class', function(d) {
        return classChartText(d) + classFocus(d);
      });
      mainTextEnter = mainTextUpdate.enter().append('g').attr('class', classChartText).style('opacity', 0).style("pointer-events", "none");
      mainTextEnter.append('g').attr('class', classTexts);
    };
    c3_chart_internal_fn.updateText = function(durationForExit) {
      var $$ = this,
          config = $$.config,
          barOrLineData = $$.barOrLineData.bind($$),
          classText = $$.classText.bind($$);
      $$.mainText = $$.main.selectAll('.' + CLASS.texts).selectAll('.' + CLASS.text).data(barOrLineData);
      $$.mainText.enter().append('text').attr("class", classText).attr('text-anchor', function(d) {
        return config.axis_rotated ? (d.value < 0 ? 'end' : 'start') : 'middle';
      }).style("stroke", 'none').style("fill", function(d) {
        return $$.color(d);
      }).style("fill-opacity", 0);
      $$.mainText.text(function(d, i, j) {
        return $$.dataLabelFormat(d.id)(d.value, d.id, i, j);
      });
      $$.mainText.exit().transition().duration(durationForExit).style('fill-opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawText = function(xForText, yForText, forFlow, withTransition) {
      return [(withTransition ? this.mainText.transition() : this.mainText).attr('x', xForText).attr('y', yForText).style("fill", this.color).style("fill-opacity", forFlow ? 0 : this.opacityForText.bind(this))];
    };
    c3_chart_internal_fn.getTextRect = function(text, cls, element) {
      var dummy = this.d3.select('body').append('div').classed('c3', true),
          svg = dummy.append("svg").style('visibility', 'hidden').style('position', 'fixed').style('top', 0).style('left', 0),
          font = this.d3.select(element).style('font'),
          rect;
      svg.selectAll('.dummy').data([text]).enter().append('text').classed(cls ? cls : "", true).style('font', font).text(text).each(function() {
        rect = this.getBoundingClientRect();
      });
      dummy.remove();
      return rect;
    };
    c3_chart_internal_fn.generateXYForText = function(areaIndices, barIndices, lineIndices, forX) {
      var $$ = this,
          getAreaPoints = $$.generateGetAreaPoints(areaIndices, false),
          getBarPoints = $$.generateGetBarPoints(barIndices, false),
          getLinePoints = $$.generateGetLinePoints(lineIndices, false),
          getter = forX ? $$.getXForText : $$.getYForText;
      return function(d, i) {
        var getPoints = $$.isAreaType(d) ? getAreaPoints : $$.isBarType(d) ? getBarPoints : getLinePoints;
        return getter.call($$, getPoints(d, i), d, this);
      };
    };
    c3_chart_internal_fn.getXForText = function(points, d, textElement) {
      var $$ = this,
          box = textElement.getBoundingClientRect(),
          xPos,
          padding;
      if ($$.config.axis_rotated) {
        padding = $$.isBarType(d) ? 4 : 6;
        xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1);
      } else {
        xPos = $$.hasType('bar') ? (points[2][0] + points[0][0]) / 2 : points[0][0];
      }
      if (d.value === null) {
        if (xPos > $$.width) {
          xPos = $$.width - box.width;
        } else if (xPos < 0) {
          xPos = 4;
        }
      }
      return xPos;
    };
    c3_chart_internal_fn.getYForText = function(points, d, textElement) {
      var $$ = this,
          box = textElement.getBoundingClientRect(),
          yPos;
      if ($$.config.axis_rotated) {
        yPos = (points[0][0] + points[2][0] + box.height * 0.6) / 2;
      } else {
        yPos = points[2][1];
        if (d.value < 0 || (d.value === 0 && !$$.hasPositiveValue)) {
          yPos += box.height;
          if ($$.isBarType(d) && $$.isSafari()) {
            yPos -= 3;
          } else if (!$$.isBarType(d) && $$.isChrome()) {
            yPos += 3;
          }
        } else {
          yPos += $$.isBarType(d) ? -3 : -6;
        }
      }
      if (d.value === null && !$$.config.axis_rotated) {
        if (yPos < box.height) {
          yPos = box.height;
        } else if (yPos > this.height) {
          yPos = this.height - 4;
        }
      }
      return yPos;
    };
    c3_chart_internal_fn.setTargetType = function(targetIds, type) {
      var $$ = this,
          config = $$.config;
      $$.mapToTargetIds(targetIds).forEach(function(id) {
        $$.withoutFadeIn[id] = (type === config.data_types[id]);
        config.data_types[id] = type;
      });
      if (!targetIds) {
        config.data_type = type;
      }
    };
    c3_chart_internal_fn.hasType = function(type, targets) {
      var $$ = this,
          types = $$.config.data_types,
          has = false;
      targets = targets || $$.data.targets;
      if (targets && targets.length) {
        targets.forEach(function(target) {
          var t = types[target.id];
          if ((t && t.indexOf(type) >= 0) || (!t && type === 'line')) {
            has = true;
          }
        });
      } else if (Object.keys(types).length) {
        Object.keys(types).forEach(function(id) {
          if (types[id] === type) {
            has = true;
          }
        });
      } else {
        has = $$.config.data_type === type;
      }
      return has;
    };
    c3_chart_internal_fn.hasArcType = function(targets) {
      return this.hasType('pie', targets) || this.hasType('donut', targets) || this.hasType('gauge', targets);
    };
    c3_chart_internal_fn.isLineType = function(d) {
      var config = this.config,
          id = isString(d) ? d : d.id;
      return !config.data_types[id] || ['line', 'spline', 'area', 'area-spline', 'step', 'area-step'].indexOf(config.data_types[id]) >= 0;
    };
    c3_chart_internal_fn.isStepType = function(d) {
      var id = isString(d) ? d : d.id;
      return ['step', 'area-step'].indexOf(this.config.data_types[id]) >= 0;
    };
    c3_chart_internal_fn.isSplineType = function(d) {
      var id = isString(d) ? d : d.id;
      return ['spline', 'area-spline'].indexOf(this.config.data_types[id]) >= 0;
    };
    c3_chart_internal_fn.isAreaType = function(d) {
      var id = isString(d) ? d : d.id;
      return ['area', 'area-spline', 'area-step'].indexOf(this.config.data_types[id]) >= 0;
    };
    c3_chart_internal_fn.isBarType = function(d) {
      var id = isString(d) ? d : d.id;
      return this.config.data_types[id] === 'bar';
    };
    c3_chart_internal_fn.isScatterType = function(d) {
      var id = isString(d) ? d : d.id;
      return this.config.data_types[id] === 'scatter';
    };
    c3_chart_internal_fn.isPieType = function(d) {
      var id = isString(d) ? d : d.id;
      return this.config.data_types[id] === 'pie';
    };
    c3_chart_internal_fn.isGaugeType = function(d) {
      var id = isString(d) ? d : d.id;
      return this.config.data_types[id] === 'gauge';
    };
    c3_chart_internal_fn.isDonutType = function(d) {
      var id = isString(d) ? d : d.id;
      return this.config.data_types[id] === 'donut';
    };
    c3_chart_internal_fn.isArcType = function(d) {
      return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d);
    };
    c3_chart_internal_fn.lineData = function(d) {
      return this.isLineType(d) ? [d] : [];
    };
    c3_chart_internal_fn.arcData = function(d) {
      return this.isArcType(d.data) ? [d] : [];
    };
    c3_chart_internal_fn.barData = function(d) {
      return this.isBarType(d) ? d.values : [];
    };
    c3_chart_internal_fn.lineOrScatterData = function(d) {
      return this.isLineType(d) || this.isScatterType(d) ? d.values : [];
    };
    c3_chart_internal_fn.barOrLineData = function(d) {
      return this.isBarType(d) || this.isLineType(d) ? d.values : [];
    };
    c3_chart_internal_fn.isInterpolationType = function(type) {
      return ['linear', 'linear-closed', 'basis', 'basis-open', 'basis-closed', 'bundle', 'cardinal', 'cardinal-open', 'cardinal-closed', 'monotone'].indexOf(type) >= 0;
    };
    c3_chart_internal_fn.initGrid = function() {
      var $$ = this,
          config = $$.config,
          d3 = $$.d3;
      $$.grid = $$.main.append('g').attr("clip-path", $$.clipPathForGrid).attr('class', CLASS.grid);
      if (config.grid_x_show) {
        $$.grid.append("g").attr("class", CLASS.xgrids);
      }
      if (config.grid_y_show) {
        $$.grid.append('g').attr('class', CLASS.ygrids);
      }
      if (config.grid_focus_show) {
        $$.grid.append('g').attr("class", CLASS.xgridFocus).append('line').attr('class', CLASS.xgridFocus);
      }
      $$.xgrid = d3.selectAll([]);
      if (!config.grid_lines_front) {
        $$.initGridLines();
      }
    };
    c3_chart_internal_fn.initGridLines = function() {
      var $$ = this,
          d3 = $$.d3;
      $$.gridLines = $$.main.append('g').attr("clip-path", $$.clipPathForGrid).attr('class', CLASS.grid + ' ' + CLASS.gridLines);
      $$.gridLines.append('g').attr("class", CLASS.xgridLines);
      $$.gridLines.append('g').attr('class', CLASS.ygridLines);
      $$.xgridLines = d3.selectAll([]);
    };
    c3_chart_internal_fn.updateXGrid = function(withoutUpdate) {
      var $$ = this,
          config = $$.config,
          d3 = $$.d3,
          xgridData = $$.generateGridData(config.grid_x_type, $$.x),
          tickOffset = $$.isCategorized() ? $$.xAxis.tickOffset() : 0;
      $$.xgridAttr = config.axis_rotated ? {
        'x1': 0,
        'x2': $$.width,
        'y1': function(d) {
          return $$.x(d) - tickOffset;
        },
        'y2': function(d) {
          return $$.x(d) - tickOffset;
        }
      } : {
        'x1': function(d) {
          return $$.x(d) + tickOffset;
        },
        'x2': function(d) {
          return $$.x(d) + tickOffset;
        },
        'y1': 0,
        'y2': $$.height
      };
      $$.xgrid = $$.main.select('.' + CLASS.xgrids).selectAll('.' + CLASS.xgrid).data(xgridData);
      $$.xgrid.enter().append('line').attr("class", CLASS.xgrid);
      if (!withoutUpdate) {
        $$.xgrid.attr($$.xgridAttr).style("opacity", function() {
          return +d3.select(this).attr(config.axis_rotated ? 'y1' : 'x1') === (config.axis_rotated ? $$.height : 0) ? 0 : 1;
        });
      }
      $$.xgrid.exit().remove();
    };
    c3_chart_internal_fn.updateYGrid = function() {
      var $$ = this,
          config = $$.config,
          gridValues = $$.yAxis.tickValues() || $$.y.ticks(config.grid_y_ticks);
      $$.ygrid = $$.main.select('.' + CLASS.ygrids).selectAll('.' + CLASS.ygrid).data(gridValues);
      $$.ygrid.enter().append('line').attr('class', CLASS.ygrid);
      $$.ygrid.attr("x1", config.axis_rotated ? $$.y : 0).attr("x2", config.axis_rotated ? $$.y : $$.width).attr("y1", config.axis_rotated ? 0 : $$.y).attr("y2", config.axis_rotated ? $$.height : $$.y);
      $$.ygrid.exit().remove();
      $$.smoothLines($$.ygrid, 'grid');
    };
    c3_chart_internal_fn.gridTextAnchor = function(d) {
      return d.position ? d.position : "end";
    };
    c3_chart_internal_fn.gridTextDx = function(d) {
      return d.position === 'start' ? 4 : d.position === 'middle' ? 0 : -4;
    };
    c3_chart_internal_fn.xGridTextX = function(d) {
      return d.position === 'start' ? -this.height : d.position === 'middle' ? -this.height / 2 : 0;
    };
    c3_chart_internal_fn.yGridTextX = function(d) {
      return d.position === 'start' ? 0 : d.position === 'middle' ? this.width / 2 : this.width;
    };
    c3_chart_internal_fn.updateGrid = function(duration) {
      var $$ = this,
          main = $$.main,
          config = $$.config,
          xgridLine,
          ygridLine,
          yv;
      $$.grid.style('visibility', $$.hasArcType() ? 'hidden' : 'visible');
      main.select('line.' + CLASS.xgridFocus).style("visibility", "hidden");
      if (config.grid_x_show) {
        $$.updateXGrid();
      }
      $$.xgridLines = main.select('.' + CLASS.xgridLines).selectAll('.' + CLASS.xgridLine).data(config.grid_x_lines);
      xgridLine = $$.xgridLines.enter().append('g').attr("class", function(d) {
        return CLASS.xgridLine + (d['class'] ? ' ' + d['class'] : '');
      });
      xgridLine.append('line').style("opacity", 0);
      xgridLine.append('text').attr("text-anchor", $$.gridTextAnchor).attr("transform", config.axis_rotated ? "" : "rotate(-90)").attr('dx', $$.gridTextDx).attr('dy', -5).style("opacity", 0);
      $$.xgridLines.exit().transition().duration(duration).style("opacity", 0).remove();
      if (config.grid_y_show) {
        $$.updateYGrid();
      }
      $$.ygridLines = main.select('.' + CLASS.ygridLines).selectAll('.' + CLASS.ygridLine).data(config.grid_y_lines);
      ygridLine = $$.ygridLines.enter().append('g').attr("class", function(d) {
        return CLASS.ygridLine + (d['class'] ? ' ' + d['class'] : '');
      });
      ygridLine.append('line').style("opacity", 0);
      ygridLine.append('text').attr("text-anchor", $$.gridTextAnchor).attr("transform", config.axis_rotated ? "rotate(-90)" : "").attr('dx', $$.gridTextDx).attr('dy', -5).style("opacity", 0);
      yv = $$.yv.bind($$);
      $$.ygridLines.select('line').transition().duration(duration).attr("x1", config.axis_rotated ? yv : 0).attr("x2", config.axis_rotated ? yv : $$.width).attr("y1", config.axis_rotated ? 0 : yv).attr("y2", config.axis_rotated ? $$.height : yv).style("opacity", 1);
      $$.ygridLines.select('text').transition().duration(duration).attr("x", config.axis_rotated ? $$.xGridTextX.bind($$) : $$.yGridTextX.bind($$)).attr("y", yv).text(function(d) {
        return d.text;
      }).style("opacity", 1);
      $$.ygridLines.exit().transition().duration(duration).style("opacity", 0).remove();
    };
    c3_chart_internal_fn.redrawGrid = function(withTransition) {
      var $$ = this,
          config = $$.config,
          xv = $$.xv.bind($$),
          lines = $$.xgridLines.select('line'),
          texts = $$.xgridLines.select('text');
      return [(withTransition ? lines.transition() : lines).attr("x1", config.axis_rotated ? 0 : xv).attr("x2", config.axis_rotated ? $$.width : xv).attr("y1", config.axis_rotated ? xv : 0).attr("y2", config.axis_rotated ? xv : $$.height).style("opacity", 1), (withTransition ? texts.transition() : texts).attr("x", config.axis_rotated ? $$.yGridTextX.bind($$) : $$.xGridTextX.bind($$)).attr("y", xv).text(function(d) {
        return d.text;
      }).style("opacity", 1)];
    };
    c3_chart_internal_fn.showXGridFocus = function(selectedData) {
      var $$ = this,
          config = $$.config,
          dataToShow = selectedData.filter(function(d) {
            return d && isValue(d.value);
          }),
          focusEl = $$.main.selectAll('line.' + CLASS.xgridFocus),
          xx = $$.xx.bind($$);
      if (!config.tooltip_show) {
        return;
      }
      if ($$.hasType('scatter') || $$.hasArcType()) {
        return;
      }
      focusEl.style("visibility", "visible").data([dataToShow[0]]).attr(config.axis_rotated ? 'y1' : 'x1', xx).attr(config.axis_rotated ? 'y2' : 'x2', xx);
      $$.smoothLines(focusEl, 'grid');
    };
    c3_chart_internal_fn.hideXGridFocus = function() {
      this.main.select('line.' + CLASS.xgridFocus).style("visibility", "hidden");
    };
    c3_chart_internal_fn.updateXgridFocus = function() {
      var $$ = this,
          config = $$.config;
      $$.main.select('line.' + CLASS.xgridFocus).attr("x1", config.axis_rotated ? 0 : -10).attr("x2", config.axis_rotated ? $$.width : -10).attr("y1", config.axis_rotated ? -10 : 0).attr("y2", config.axis_rotated ? -10 : $$.height);
    };
    c3_chart_internal_fn.generateGridData = function(type, scale) {
      var $$ = this,
          gridData = [],
          xDomain,
          firstYear,
          lastYear,
          i,
          tickNum = $$.main.select("." + CLASS.axisX).selectAll('.tick').size();
      if (type === 'year') {
        xDomain = $$.getXDomain();
        firstYear = xDomain[0].getFullYear();
        lastYear = xDomain[1].getFullYear();
        for (i = firstYear; i <= lastYear; i++) {
          gridData.push(new Date(i + '-01-01 00:00:00'));
        }
      } else {
        gridData = scale.ticks(10);
        if (gridData.length > tickNum) {
          gridData = gridData.filter(function(d) {
            return ("" + d).indexOf('.') < 0;
          });
        }
      }
      return gridData;
    };
    c3_chart_internal_fn.getGridFilterToRemove = function(params) {
      return params ? function(line) {
        var found = false;
        [].concat(params).forEach(function(param) {
          if ((('value' in param && line.value === param.value) || ('class' in param && line['class'] === param['class']))) {
            found = true;
          }
        });
        return found;
      } : function() {
        return true;
      };
    };
    c3_chart_internal_fn.removeGridLines = function(params, forX) {
      var $$ = this,
          config = $$.config,
          toRemove = $$.getGridFilterToRemove(params),
          toShow = function(line) {
            return !toRemove(line);
          },
          classLines = forX ? CLASS.xgridLines : CLASS.ygridLines,
          classLine = forX ? CLASS.xgridLine : CLASS.ygridLine;
      $$.main.select('.' + classLines).selectAll('.' + classLine).filter(toRemove).transition().duration(config.transition_duration).style('opacity', 0).remove();
      if (forX) {
        config.grid_x_lines = config.grid_x_lines.filter(toShow);
      } else {
        config.grid_y_lines = config.grid_y_lines.filter(toShow);
      }
    };
    c3_chart_internal_fn.initTooltip = function() {
      var $$ = this,
          config = $$.config,
          i;
      $$.tooltip = $$.selectChart.style("position", "relative").append("div").attr('class', CLASS.tooltipContainer).style("position", "absolute").style("pointer-events", "none").style("display", "none");
      if (config.tooltip_init_show) {
        if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {
          config.tooltip_init_x = $$.parseDate(config.tooltip_init_x);
          for (i = 0; i < $$.data.targets[0].values.length; i++) {
            if (($$.data.targets[0].values[i].x - config.tooltip_init_x) === 0) {
              break;
            }
          }
          config.tooltip_init_x = i;
        }
        $$.tooltip.html(config.tooltip_contents.call($$, $$.data.targets.map(function(d) {
          return $$.addName(d.values[config.tooltip_init_x]);
        }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType()), $$.color));
        $$.tooltip.style("top", config.tooltip_init_position.top).style("left", config.tooltip_init_position.left).style("display", "block");
      }
    };
    c3_chart_internal_fn.getTooltipContent = function(d, defaultTitleFormat, defaultValueFormat, color) {
      var $$ = this,
          config = $$.config,
          titleFormat = config.tooltip_format_title || defaultTitleFormat,
          nameFormat = config.tooltip_format_name || function(name) {
            return name;
          },
          valueFormat = config.tooltip_format_value || defaultValueFormat,
          text,
          i,
          title,
          value,
          name,
          bgcolor,
          orderAsc = $$.isOrderAsc();
      if (config.data_groups.length === 0) {
        d.sort(function(a, b) {
          return orderAsc ? a.value - b.value : b.value - a.value;
        });
      } else {
        var ids = $$.orderTargets($$.data.targets).map(function(i) {
          return i.id;
        });
        d.sort(function(a, b) {
          if (a.value > 0 && b.value > 0) {
            return orderAsc ? ids.indexOf(a.id) - ids.indexOf(b.id) : ids.indexOf(b.id) - ids.indexOf(a.id);
          } else {
            return orderAsc ? a.value - b.value : b.value - a.value;
          }
        });
      }
      for (i = 0; i < d.length; i++) {
        if (!(d[i] && (d[i].value || d[i].value === 0))) {
          continue;
        }
        if (!text) {
          title = titleFormat ? titleFormat(d[i].x) : d[i].x;
          text = "<table class='" + $$.CLASS.tooltip + "'>" + (title || title === 0 ? "<tr><th colspan='2'>" + title + "</th></tr>" : "");
        }
        value = valueFormat(d[i].value, d[i].ratio, d[i].id, d[i].index);
        if (value !== undefined) {
          if (d[i].name === null) {
            continue;
          }
          name = nameFormat(d[i].name, d[i].ratio, d[i].id, d[i].index);
          bgcolor = $$.levelColor ? $$.levelColor(d[i].value) : color(d[i].id);
          text += "<tr class='" + $$.CLASS.tooltipName + "-" + $$.getTargetSelectorSuffix(d[i].id) + "'>";
          text += "<td class='name'><span style='background-color:" + bgcolor + "'></span>" + name + "</td>";
          text += "<td class='value'>" + value + "</td>";
          text += "</tr>";
        }
      }
      return text + "</table>";
    };
    c3_chart_internal_fn.tooltipPosition = function(dataToShow, tWidth, tHeight, element) {
      var $$ = this,
          config = $$.config,
          d3 = $$.d3;
      var svgLeft,
          tooltipLeft,
          tooltipRight,
          tooltipTop,
          chartRight;
      var forArc = $$.hasArcType(),
          mouse = d3.mouse(element);
      if (forArc) {
        tooltipLeft = (($$.width - ($$.isLegendRight ? $$.getLegendWidth() : 0)) / 2) + mouse[0];
        tooltipTop = ($$.height / 2) + mouse[1] + 20;
      } else {
        svgLeft = $$.getSvgLeft(true);
        if (config.axis_rotated) {
          tooltipLeft = svgLeft + mouse[0] + 100;
          tooltipRight = tooltipLeft + tWidth;
          chartRight = $$.currentWidth - $$.getCurrentPaddingRight();
          tooltipTop = $$.x(dataToShow[0].x) + 20;
        } else {
          tooltipLeft = svgLeft + $$.getCurrentPaddingLeft(true) + $$.x(dataToShow[0].x) + 20;
          tooltipRight = tooltipLeft + tWidth;
          chartRight = svgLeft + $$.currentWidth - $$.getCurrentPaddingRight();
          tooltipTop = mouse[1] + 15;
        }
        if (tooltipRight > chartRight) {
          tooltipLeft -= tooltipRight - chartRight + 20;
        }
        if (tooltipTop + tHeight > $$.currentHeight) {
          tooltipTop -= tHeight + 30;
        }
      }
      if (tooltipTop < 0) {
        tooltipTop = 0;
      }
      return {
        top: tooltipTop,
        left: tooltipLeft
      };
    };
    c3_chart_internal_fn.showTooltip = function(selectedData, element) {
      var $$ = this,
          config = $$.config;
      var tWidth,
          tHeight,
          position;
      var forArc = $$.hasArcType(),
          dataToShow = selectedData.filter(function(d) {
            return d && isValue(d.value);
          }),
          positionFunction = config.tooltip_position || c3_chart_internal_fn.tooltipPosition;
      if (dataToShow.length === 0 || !config.tooltip_show) {
        return;
      }
      $$.tooltip.html(config.tooltip_contents.call($$, selectedData, $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color)).style("display", "block");
      tWidth = $$.tooltip.property('offsetWidth');
      tHeight = $$.tooltip.property('offsetHeight');
      position = positionFunction.call(this, dataToShow, tWidth, tHeight, element);
      $$.tooltip.style("top", position.top + "px").style("left", position.left + 'px');
    };
    c3_chart_internal_fn.hideTooltip = function() {
      this.tooltip.style("display", "none");
    };
    c3_chart_internal_fn.initLegend = function() {
      var $$ = this;
      $$.legendItemTextBox = {};
      $$.legendHasRendered = false;
      $$.legend = $$.svg.append("g").attr("transform", $$.getTranslate('legend'));
      if (!$$.config.legend_show) {
        $$.legend.style('visibility', 'hidden');
        $$.hiddenLegendIds = $$.mapToIds($$.data.targets);
        return;
      }
      $$.updateLegendWithDefaults();
    };
    c3_chart_internal_fn.updateLegendWithDefaults = function() {
      var $$ = this;
      $$.updateLegend($$.mapToIds($$.data.targets), {
        withTransform: false,
        withTransitionForTransform: false,
        withTransition: false
      });
    };
    c3_chart_internal_fn.updateSizeForLegend = function(legendHeight, legendWidth) {
      var $$ = this,
          config = $$.config,
          insetLegendPosition = {
            top: $$.isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : $$.currentHeight - legendHeight - $$.getCurrentPaddingBottom() - config.legend_inset_y,
            left: $$.isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + 0.5 : $$.currentWidth - legendWidth - $$.getCurrentPaddingRight() - config.legend_inset_x + 0.5
          };
      $$.margin3 = {
        top: $$.isLegendRight ? 0 : $$.isLegendInset ? insetLegendPosition.top : $$.currentHeight - legendHeight,
        right: NaN,
        bottom: 0,
        left: $$.isLegendRight ? $$.currentWidth - legendWidth : $$.isLegendInset ? insetLegendPosition.left : 0
      };
    };
    c3_chart_internal_fn.transformLegend = function(withTransition) {
      var $$ = this;
      (withTransition ? $$.legend.transition() : $$.legend).attr("transform", $$.getTranslate('legend'));
    };
    c3_chart_internal_fn.updateLegendStep = function(step) {
      this.legendStep = step;
    };
    c3_chart_internal_fn.updateLegendItemWidth = function(w) {
      this.legendItemWidth = w;
    };
    c3_chart_internal_fn.updateLegendItemHeight = function(h) {
      this.legendItemHeight = h;
    };
    c3_chart_internal_fn.getLegendWidth = function() {
      var $$ = this;
      return $$.config.legend_show ? $$.isLegendRight || $$.isLegendInset ? $$.legendItemWidth * ($$.legendStep + 1) : $$.currentWidth : 0;
    };
    c3_chart_internal_fn.getLegendHeight = function() {
      var $$ = this,
          h = 0;
      if ($$.config.legend_show) {
        if ($$.isLegendRight) {
          h = $$.currentHeight;
        } else {
          h = Math.max(20, $$.legendItemHeight) * ($$.legendStep + 1);
        }
      }
      return h;
    };
    c3_chart_internal_fn.opacityForLegend = function(legendItem) {
      return legendItem.classed(CLASS.legendItemHidden) ? null : 1;
    };
    c3_chart_internal_fn.opacityForUnfocusedLegend = function(legendItem) {
      return legendItem.classed(CLASS.legendItemHidden) ? null : 0.3;
    };
    c3_chart_internal_fn.toggleFocusLegend = function(targetIds, focus) {
      var $$ = this;
      targetIds = $$.mapToTargetIds(targetIds);
      $$.legend.selectAll('.' + CLASS.legendItem).filter(function(id) {
        return targetIds.indexOf(id) >= 0;
      }).classed(CLASS.legendItemFocused, focus).transition().duration(100).style('opacity', function() {
        var opacity = focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend;
        return opacity.call($$, $$.d3.select(this));
      });
    };
    c3_chart_internal_fn.revertLegend = function() {
      var $$ = this,
          d3 = $$.d3;
      $$.legend.selectAll('.' + CLASS.legendItem).classed(CLASS.legendItemFocused, false).transition().duration(100).style('opacity', function() {
        return $$.opacityForLegend(d3.select(this));
      });
    };
    c3_chart_internal_fn.showLegend = function(targetIds) {
      var $$ = this,
          config = $$.config;
      if (!config.legend_show) {
        config.legend_show = true;
        $$.legend.style('visibility', 'visible');
        if (!$$.legendHasRendered) {
          $$.updateLegendWithDefaults();
        }
      }
      $$.removeHiddenLegendIds(targetIds);
      $$.legend.selectAll($$.selectorLegends(targetIds)).style('visibility', 'visible').transition().style('opacity', function() {
        return $$.opacityForLegend($$.d3.select(this));
      });
    };
    c3_chart_internal_fn.hideLegend = function(targetIds) {
      var $$ = this,
          config = $$.config;
      if (config.legend_show && isEmpty(targetIds)) {
        config.legend_show = false;
        $$.legend.style('visibility', 'hidden');
      }
      $$.addHiddenLegendIds(targetIds);
      $$.legend.selectAll($$.selectorLegends(targetIds)).style('opacity', 0).style('visibility', 'hidden');
    };
    c3_chart_internal_fn.clearLegendItemTextBoxCache = function() {
      this.legendItemTextBox = {};
    };
    c3_chart_internal_fn.updateLegend = function(targetIds, options, transitions) {
      var $$ = this,
          config = $$.config;
      var xForLegend,
          xForLegendText,
          xForLegendRect,
          yForLegend,
          yForLegendText,
          yForLegendRect,
          x1ForLegendTile,
          x2ForLegendTile,
          yForLegendTile;
      var paddingTop = 4,
          paddingRight = 10,
          maxWidth = 0,
          maxHeight = 0,
          posMin = 10,
          tileWidth = config.legend_item_tile_width + 5;
      var l,
          totalLength = 0,
          offsets = {},
          widths = {},
          heights = {},
          margins = [0],
          steps = {},
          step = 0;
      var withTransition,
          withTransitionForTransform;
      var texts,
          rects,
          tiles,
          background;
      targetIds = targetIds.filter(function(id) {
        return !isDefined(config.data_names[id]) || config.data_names[id] !== null;
      });
      options = options || {};
      withTransition = getOption(options, "withTransition", true);
      withTransitionForTransform = getOption(options, "withTransitionForTransform", true);
      function getTextBox(textElement, id) {
        if (!$$.legendItemTextBox[id]) {
          $$.legendItemTextBox[id] = $$.getTextRect(textElement.textContent, CLASS.legendItem, textElement);
        }
        return $$.legendItemTextBox[id];
      }
      function updatePositions(textElement, id, index) {
        var reset = index === 0,
            isLast = index === targetIds.length - 1,
            box = getTextBox(textElement, id),
            itemWidth = box.width + tileWidth + (isLast && !($$.isLegendRight || $$.isLegendInset) ? 0 : paddingRight) + config.legend_padding,
            itemHeight = box.height + paddingTop,
            itemLength = $$.isLegendRight || $$.isLegendInset ? itemHeight : itemWidth,
            areaLength = $$.isLegendRight || $$.isLegendInset ? $$.getLegendHeight() : $$.getLegendWidth(),
            margin,
            maxLength;
        function updateValues(id, withoutStep) {
          if (!withoutStep) {
            margin = (areaLength - totalLength - itemLength) / 2;
            if (margin < posMin) {
              margin = (areaLength - itemLength) / 2;
              totalLength = 0;
              step++;
            }
          }
          steps[id] = step;
          margins[step] = $$.isLegendInset ? 10 : margin;
          offsets[id] = totalLength;
          totalLength += itemLength;
        }
        if (reset) {
          totalLength = 0;
          step = 0;
          maxWidth = 0;
          maxHeight = 0;
        }
        if (config.legend_show && !$$.isLegendToShow(id)) {
          widths[id] = heights[id] = steps[id] = offsets[id] = 0;
          return;
        }
        widths[id] = itemWidth;
        heights[id] = itemHeight;
        if (!maxWidth || itemWidth >= maxWidth) {
          maxWidth = itemWidth;
        }
        if (!maxHeight || itemHeight >= maxHeight) {
          maxHeight = itemHeight;
        }
        maxLength = $$.isLegendRight || $$.isLegendInset ? maxHeight : maxWidth;
        if (config.legend_equally) {
          Object.keys(widths).forEach(function(id) {
            widths[id] = maxWidth;
          });
          Object.keys(heights).forEach(function(id) {
            heights[id] = maxHeight;
          });
          margin = (areaLength - maxLength * targetIds.length) / 2;
          if (margin < posMin) {
            totalLength = 0;
            step = 0;
            targetIds.forEach(function(id) {
              updateValues(id);
            });
          } else {
            updateValues(id, true);
          }
        } else {
          updateValues(id);
        }
      }
      if ($$.isLegendInset) {
        step = config.legend_inset_step ? config.legend_inset_step : targetIds.length;
        $$.updateLegendStep(step);
      }
      if ($$.isLegendRight) {
        xForLegend = function(id) {
          return maxWidth * steps[id];
        };
        yForLegend = function(id) {
          return margins[steps[id]] + offsets[id];
        };
      } else if ($$.isLegendInset) {
        xForLegend = function(id) {
          return maxWidth * steps[id] + 10;
        };
        yForLegend = function(id) {
          return margins[steps[id]] + offsets[id];
        };
      } else {
        xForLegend = function(id) {
          return margins[steps[id]] + offsets[id];
        };
        yForLegend = function(id) {
          return maxHeight * steps[id];
        };
      }
      xForLegendText = function(id, i) {
        return xForLegend(id, i) + 4 + config.legend_item_tile_width;
      };
      yForLegendText = function(id, i) {
        return yForLegend(id, i) + 9;
      };
      xForLegendRect = function(id, i) {
        return xForLegend(id, i);
      };
      yForLegendRect = function(id, i) {
        return yForLegend(id, i) - 5;
      };
      x1ForLegendTile = function(id, i) {
        return xForLegend(id, i) - 2;
      };
      x2ForLegendTile = function(id, i) {
        return xForLegend(id, i) - 2 + config.legend_item_tile_width;
      };
      yForLegendTile = function(id, i) {
        return yForLegend(id, i) + 4;
      };
      l = $$.legend.selectAll('.' + CLASS.legendItem).data(targetIds).enter().append('g').attr('class', function(id) {
        return $$.generateClass(CLASS.legendItem, id);
      }).style('visibility', function(id) {
        return $$.isLegendToShow(id) ? 'visible' : 'hidden';
      }).style('cursor', 'pointer').on('click', function(id) {
        if (config.legend_item_onclick) {
          config.legend_item_onclick.call($$, id);
        } else {
          if ($$.d3.event.altKey) {
            $$.api.hide();
            $$.api.show(id);
          } else {
            $$.api.toggle(id);
            $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert();
          }
        }
      }).on('mouseover', function(id) {
        if (config.legend_item_onmouseover) {
          config.legend_item_onmouseover.call($$, id);
        } else {
          $$.d3.select(this).classed(CLASS.legendItemFocused, true);
          if (!$$.transiting && $$.isTargetToShow(id)) {
            $$.api.focus(id);
          }
        }
      }).on('mouseout', function(id) {
        if (config.legend_item_onmouseout) {
          config.legend_item_onmouseout.call($$, id);
        } else {
          $$.d3.select(this).classed(CLASS.legendItemFocused, false);
          $$.api.revert();
        }
      });
      l.append('text').text(function(id) {
        return isDefined(config.data_names[id]) ? config.data_names[id] : id;
      }).each(function(id, i) {
        updatePositions(this, id, i);
      }).style("pointer-events", "none").attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendText : -200).attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendText);
      l.append('rect').attr("class", CLASS.legendItemEvent).style('fill-opacity', 0).attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendRect : -200).attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendRect);
      l.append('line').attr('class', CLASS.legendItemTile).style('stroke', $$.color).style("pointer-events", "none").attr('x1', $$.isLegendRight || $$.isLegendInset ? x1ForLegendTile : -200).attr('y1', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile).attr('x2', $$.isLegendRight || $$.isLegendInset ? x2ForLegendTile : -200).attr('y2', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile).attr('stroke-width', config.legend_item_tile_height);
      background = $$.legend.select('.' + CLASS.legendBackground + ' rect');
      if ($$.isLegendInset && maxWidth > 0 && background.size() === 0) {
        background = $$.legend.insert('g', '.' + CLASS.legendItem).attr("class", CLASS.legendBackground).append('rect');
      }
      texts = $$.legend.selectAll('text').data(targetIds).text(function(id) {
        return isDefined(config.data_names[id]) ? config.data_names[id] : id;
      }).each(function(id, i) {
        updatePositions(this, id, i);
      });
      (withTransition ? texts.transition() : texts).attr('x', xForLegendText).attr('y', yForLegendText);
      rects = $$.legend.selectAll('rect.' + CLASS.legendItemEvent).data(targetIds);
      (withTransition ? rects.transition() : rects).attr('width', function(id) {
        return widths[id];
      }).attr('height', function(id) {
        return heights[id];
      }).attr('x', xForLegendRect).attr('y', yForLegendRect);
      tiles = $$.legend.selectAll('line.' + CLASS.legendItemTile).data(targetIds);
      (withTransition ? tiles.transition() : tiles).style('stroke', $$.color).attr('x1', x1ForLegendTile).attr('y1', yForLegendTile).attr('x2', x2ForLegendTile).attr('y2', yForLegendTile);
      if (background) {
        (withTransition ? background.transition() : background).attr('height', $$.getLegendHeight() - 12).attr('width', maxWidth * (step + 1) + 10);
      }
      $$.legend.selectAll('.' + CLASS.legendItem).classed(CLASS.legendItemHidden, function(id) {
        return !$$.isTargetToShow(id);
      });
      $$.updateLegendItemWidth(maxWidth);
      $$.updateLegendItemHeight(maxHeight);
      $$.updateLegendStep(step);
      $$.updateSizes();
      $$.updateScales();
      $$.updateSvgSize();
      $$.transformAll(withTransitionForTransform, transitions);
      $$.legendHasRendered = true;
    };
    c3_chart_internal_fn.initTitle = function() {
      var $$ = this;
      $$.title = $$.svg.append("text").text($$.config.title_text).attr("class", $$.CLASS.title);
    };
    c3_chart_internal_fn.redrawTitle = function() {
      var $$ = this;
      $$.title.attr("x", $$.xForTitle.bind($$)).attr("y", $$.yForTitle.bind($$));
    };
    c3_chart_internal_fn.xForTitle = function() {
      var $$ = this,
          config = $$.config,
          position = config.title_position || 'left',
          x;
      if (position.indexOf('right') >= 0) {
        x = $$.currentWidth - $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width - config.title_padding.right;
      } else if (position.indexOf('center') >= 0) {
        x = ($$.currentWidth - $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width) / 2;
      } else {
        x = config.title_padding.left;
      }
      return x;
    };
    c3_chart_internal_fn.yForTitle = function() {
      var $$ = this;
      return $$.config.title_padding.top + $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).height;
    };
    c3_chart_internal_fn.getTitlePadding = function() {
      var $$ = this;
      return $$.yForTitle() + $$.config.title_padding.bottom;
    };
    function Axis(owner) {
      API.call(this, owner);
    }
    inherit(API, Axis);
    Axis.prototype.init = function init() {
      var $$ = this.owner,
          config = $$.config,
          main = $$.main;
      $$.axes.x = main.append("g").attr("class", CLASS.axis + ' ' + CLASS.axisX).attr("clip-path", $$.clipPathForXAxis).attr("transform", $$.getTranslate('x')).style("visibility", config.axis_x_show ? 'visible' : 'hidden');
      $$.axes.x.append("text").attr("class", CLASS.axisXLabel).attr("transform", config.axis_rotated ? "rotate(-90)" : "").style("text-anchor", this.textAnchorForXAxisLabel.bind(this));
      $$.axes.y = main.append("g").attr("class", CLASS.axis + ' ' + CLASS.axisY).attr("clip-path", config.axis_y_inner ? "" : $$.clipPathForYAxis).attr("transform", $$.getTranslate('y')).style("visibility", config.axis_y_show ? 'visible' : 'hidden');
      $$.axes.y.append("text").attr("class", CLASS.axisYLabel).attr("transform", config.axis_rotated ? "" : "rotate(-90)").style("text-anchor", this.textAnchorForYAxisLabel.bind(this));
      $$.axes.y2 = main.append("g").attr("class", CLASS.axis + ' ' + CLASS.axisY2).attr("transform", $$.getTranslate('y2')).style("visibility", config.axis_y2_show ? 'visible' : 'hidden');
      $$.axes.y2.append("text").attr("class", CLASS.axisY2Label).attr("transform", config.axis_rotated ? "" : "rotate(-90)").style("text-anchor", this.textAnchorForY2AxisLabel.bind(this));
    };
    Axis.prototype.getXAxis = function getXAxis(scale, orient, tickFormat, tickValues, withOuterTick, withoutTransition, withoutRotateTickText) {
      var $$ = this.owner,
          config = $$.config,
          axisParams = {
            isCategory: $$.isCategorized(),
            withOuterTick: withOuterTick,
            tickMultiline: config.axis_x_tick_multiline,
            tickWidth: config.axis_x_tick_width,
            tickTextRotate: withoutRotateTickText ? 0 : config.axis_x_tick_rotate,
            withoutTransition: withoutTransition
          },
          axis = c3_axis($$.d3, axisParams).scale(scale).orient(orient);
      if ($$.isTimeSeries() && tickValues && typeof tickValues !== "function") {
        tickValues = tickValues.map(function(v) {
          return $$.parseDate(v);
        });
      }
      axis.tickFormat(tickFormat).tickValues(tickValues);
      if ($$.isCategorized()) {
        axis.tickCentered(config.axis_x_tick_centered);
        if (isEmpty(config.axis_x_tick_culling)) {
          config.axis_x_tick_culling = false;
        }
      }
      return axis;
    };
    Axis.prototype.updateXAxisTickValues = function updateXAxisTickValues(targets, axis) {
      var $$ = this.owner,
          config = $$.config,
          tickValues;
      if (config.axis_x_tick_fit || config.axis_x_tick_count) {
        tickValues = this.generateTickValues($$.mapTargetsToUniqueXs(targets), config.axis_x_tick_count, $$.isTimeSeries());
      }
      if (axis) {
        axis.tickValues(tickValues);
      } else {
        $$.xAxis.tickValues(tickValues);
        $$.subXAxis.tickValues(tickValues);
      }
      return tickValues;
    };
    Axis.prototype.getYAxis = function getYAxis(scale, orient, tickFormat, tickValues, withOuterTick, withoutTransition) {
      var axisParams = {
        withOuterTick: withOuterTick,
        withoutTransition: withoutTransition
      },
          $$ = this.owner,
          d3 = $$.d3,
          config = $$.config,
          axis = c3_axis(d3, axisParams).scale(scale).orient(orient).tickFormat(tickFormat);
      if ($$.isTimeSeriesY()) {
        axis.ticks(d3.time[config.axis_y_tick_time_value], config.axis_y_tick_time_interval);
      } else {
        axis.tickValues(tickValues);
      }
      return axis;
    };
    Axis.prototype.getId = function getId(id) {
      var config = this.owner.config;
      return id in config.data_axes ? config.data_axes[id] : 'y';
    };
    Axis.prototype.getXAxisTickFormat = function getXAxisTickFormat() {
      var $$ = this.owner,
          config = $$.config,
          format = $$.isTimeSeries() ? $$.defaultAxisTimeFormat : $$.isCategorized() ? $$.categoryName : function(v) {
            return v < 0 ? v.toFixed(0) : v;
          };
      if (config.axis_x_tick_format) {
        if (isFunction(config.axis_x_tick_format)) {
          format = config.axis_x_tick_format;
        } else if ($$.isTimeSeries()) {
          format = function(date) {
            return date ? $$.axisTimeFormat(config.axis_x_tick_format)(date) : "";
          };
        }
      }
      return isFunction(format) ? function(v) {
        return format.call($$, v);
      } : format;
    };
    Axis.prototype.getTickValues = function getTickValues(tickValues, axis) {
      return tickValues ? tickValues : axis ? axis.tickValues() : undefined;
    };
    Axis.prototype.getXAxisTickValues = function getXAxisTickValues() {
      return this.getTickValues(this.owner.config.axis_x_tick_values, this.owner.xAxis);
    };
    Axis.prototype.getYAxisTickValues = function getYAxisTickValues() {
      return this.getTickValues(this.owner.config.axis_y_tick_values, this.owner.yAxis);
    };
    Axis.prototype.getY2AxisTickValues = function getY2AxisTickValues() {
      return this.getTickValues(this.owner.config.axis_y2_tick_values, this.owner.y2Axis);
    };
    Axis.prototype.getLabelOptionByAxisId = function getLabelOptionByAxisId(axisId) {
      var $$ = this.owner,
          config = $$.config,
          option;
      if (axisId === 'y') {
        option = config.axis_y_label;
      } else if (axisId === 'y2') {
        option = config.axis_y2_label;
      } else if (axisId === 'x') {
        option = config.axis_x_label;
      }
      return option;
    };
    Axis.prototype.getLabelText = function getLabelText(axisId) {
      var option = this.getLabelOptionByAxisId(axisId);
      return isString(option) ? option : option ? option.text : null;
    };
    Axis.prototype.setLabelText = function setLabelText(axisId, text) {
      var $$ = this.owner,
          config = $$.config,
          option = this.getLabelOptionByAxisId(axisId);
      if (isString(option)) {
        if (axisId === 'y') {
          config.axis_y_label = text;
        } else if (axisId === 'y2') {
          config.axis_y2_label = text;
        } else if (axisId === 'x') {
          config.axis_x_label = text;
        }
      } else if (option) {
        option.text = text;
      }
    };
    Axis.prototype.getLabelPosition = function getLabelPosition(axisId, defaultPosition) {
      var option = this.getLabelOptionByAxisId(axisId),
          position = (option && typeof option === 'object' && option.position) ? option.position : defaultPosition;
      return {
        isInner: position.indexOf('inner') >= 0,
        isOuter: position.indexOf('outer') >= 0,
        isLeft: position.indexOf('left') >= 0,
        isCenter: position.indexOf('center') >= 0,
        isRight: position.indexOf('right') >= 0,
        isTop: position.indexOf('top') >= 0,
        isMiddle: position.indexOf('middle') >= 0,
        isBottom: position.indexOf('bottom') >= 0
      };
    };
    Axis.prototype.getXAxisLabelPosition = function getXAxisLabelPosition() {
      return this.getLabelPosition('x', this.owner.config.axis_rotated ? 'inner-top' : 'inner-right');
    };
    Axis.prototype.getYAxisLabelPosition = function getYAxisLabelPosition() {
      return this.getLabelPosition('y', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top');
    };
    Axis.prototype.getY2AxisLabelPosition = function getY2AxisLabelPosition() {
      return this.getLabelPosition('y2', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top');
    };
    Axis.prototype.getLabelPositionById = function getLabelPositionById(id) {
      return id === 'y2' ? this.getY2AxisLabelPosition() : id === 'y' ? this.getYAxisLabelPosition() : this.getXAxisLabelPosition();
    };
    Axis.prototype.textForXAxisLabel = function textForXAxisLabel() {
      return this.getLabelText('x');
    };
    Axis.prototype.textForYAxisLabel = function textForYAxisLabel() {
      return this.getLabelText('y');
    };
    Axis.prototype.textForY2AxisLabel = function textForY2AxisLabel() {
      return this.getLabelText('y2');
    };
    Axis.prototype.xForAxisLabel = function xForAxisLabel(forHorizontal, position) {
      var $$ = this.owner;
      if (forHorizontal) {
        return position.isLeft ? 0 : position.isCenter ? $$.width / 2 : $$.width;
      } else {
        return position.isBottom ? -$$.height : position.isMiddle ? -$$.height / 2 : 0;
      }
    };
    Axis.prototype.dxForAxisLabel = function dxForAxisLabel(forHorizontal, position) {
      if (forHorizontal) {
        return position.isLeft ? "0.5em" : position.isRight ? "-0.5em" : "0";
      } else {
        return position.isTop ? "-0.5em" : position.isBottom ? "0.5em" : "0";
      }
    };
    Axis.prototype.textAnchorForAxisLabel = function textAnchorForAxisLabel(forHorizontal, position) {
      if (forHorizontal) {
        return position.isLeft ? 'start' : position.isCenter ? 'middle' : 'end';
      } else {
        return position.isBottom ? 'start' : position.isMiddle ? 'middle' : 'end';
      }
    };
    Axis.prototype.xForXAxisLabel = function xForXAxisLabel() {
      return this.xForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());
    };
    Axis.prototype.xForYAxisLabel = function xForYAxisLabel() {
      return this.xForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());
    };
    Axis.prototype.xForY2AxisLabel = function xForY2AxisLabel() {
      return this.xForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());
    };
    Axis.prototype.dxForXAxisLabel = function dxForXAxisLabel() {
      return this.dxForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());
    };
    Axis.prototype.dxForYAxisLabel = function dxForYAxisLabel() {
      return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());
    };
    Axis.prototype.dxForY2AxisLabel = function dxForY2AxisLabel() {
      return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());
    };
    Axis.prototype.dyForXAxisLabel = function dyForXAxisLabel() {
      var $$ = this.owner,
          config = $$.config,
          position = this.getXAxisLabelPosition();
      if (config.axis_rotated) {
        return position.isInner ? "1.2em" : -25 - this.getMaxTickWidth('x');
      } else {
        return position.isInner ? "-0.5em" : config.axis_x_height ? config.axis_x_height - 10 : "3em";
      }
    };
    Axis.prototype.dyForYAxisLabel = function dyForYAxisLabel() {
      var $$ = this.owner,
          position = this.getYAxisLabelPosition();
      if ($$.config.axis_rotated) {
        return position.isInner ? "-0.5em" : "3em";
      } else {
        return position.isInner ? "1.2em" : -10 - ($$.config.axis_y_inner ? 0 : (this.getMaxTickWidth('y') + 10));
      }
    };
    Axis.prototype.dyForY2AxisLabel = function dyForY2AxisLabel() {
      var $$ = this.owner,
          position = this.getY2AxisLabelPosition();
      if ($$.config.axis_rotated) {
        return position.isInner ? "1.2em" : "-2.2em";
      } else {
        return position.isInner ? "-0.5em" : 15 + ($$.config.axis_y2_inner ? 0 : (this.getMaxTickWidth('y2') + 15));
      }
    };
    Axis.prototype.textAnchorForXAxisLabel = function textAnchorForXAxisLabel() {
      var $$ = this.owner;
      return this.textAnchorForAxisLabel(!$$.config.axis_rotated, this.getXAxisLabelPosition());
    };
    Axis.prototype.textAnchorForYAxisLabel = function textAnchorForYAxisLabel() {
      var $$ = this.owner;
      return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getYAxisLabelPosition());
    };
    Axis.prototype.textAnchorForY2AxisLabel = function textAnchorForY2AxisLabel() {
      var $$ = this.owner;
      return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getY2AxisLabelPosition());
    };
    Axis.prototype.getMaxTickWidth = function getMaxTickWidth(id, withoutRecompute) {
      var $$ = this.owner,
          config = $$.config,
          maxWidth = 0,
          targetsToShow,
          scale,
          axis,
          dummy,
          svg;
      if (withoutRecompute && $$.currentMaxTickWidths[id]) {
        return $$.currentMaxTickWidths[id];
      }
      if ($$.svg) {
        targetsToShow = $$.filterTargetsToShow($$.data.targets);
        if (id === 'y') {
          scale = $$.y.copy().domain($$.getYDomain(targetsToShow, 'y'));
          axis = this.getYAxis(scale, $$.yOrient, config.axis_y_tick_format, $$.yAxisTickValues, false, true);
        } else if (id === 'y2') {
          scale = $$.y2.copy().domain($$.getYDomain(targetsToShow, 'y2'));
          axis = this.getYAxis(scale, $$.y2Orient, config.axis_y2_tick_format, $$.y2AxisTickValues, false, true);
        } else {
          scale = $$.x.copy().domain($$.getXDomain(targetsToShow));
          axis = this.getXAxis(scale, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, false, true, true);
          this.updateXAxisTickValues(targetsToShow, axis);
        }
        dummy = $$.d3.select('body').append('div').classed('c3', true);
        svg = dummy.append("svg").style('visibility', 'hidden').style('position', 'fixed').style('top', 0).style('left', 0), svg.append('g').call(axis).each(function() {
          $$.d3.select(this).selectAll('text').each(function() {
            var box = this.getBoundingClientRect();
            if (maxWidth < box.width) {
              maxWidth = box.width;
            }
          });
          dummy.remove();
        });
      }
      $$.currentMaxTickWidths[id] = maxWidth <= 0 ? $$.currentMaxTickWidths[id] : maxWidth;
      return $$.currentMaxTickWidths[id];
    };
    Axis.prototype.updateLabels = function updateLabels(withTransition) {
      var $$ = this.owner;
      var axisXLabel = $$.main.select('.' + CLASS.axisX + ' .' + CLASS.axisXLabel),
          axisYLabel = $$.main.select('.' + CLASS.axisY + ' .' + CLASS.axisYLabel),
          axisY2Label = $$.main.select('.' + CLASS.axisY2 + ' .' + CLASS.axisY2Label);
      (withTransition ? axisXLabel.transition() : axisXLabel).attr("x", this.xForXAxisLabel.bind(this)).attr("dx", this.dxForXAxisLabel.bind(this)).attr("dy", this.dyForXAxisLabel.bind(this)).text(this.textForXAxisLabel.bind(this));
      (withTransition ? axisYLabel.transition() : axisYLabel).attr("x", this.xForYAxisLabel.bind(this)).attr("dx", this.dxForYAxisLabel.bind(this)).attr("dy", this.dyForYAxisLabel.bind(this)).text(this.textForYAxisLabel.bind(this));
      (withTransition ? axisY2Label.transition() : axisY2Label).attr("x", this.xForY2AxisLabel.bind(this)).attr("dx", this.dxForY2AxisLabel.bind(this)).attr("dy", this.dyForY2AxisLabel.bind(this)).text(this.textForY2AxisLabel.bind(this));
    };
    Axis.prototype.getPadding = function getPadding(padding, key, defaultValue, domainLength) {
      var p = typeof padding === 'number' ? padding : padding[key];
      if (!isValue(p)) {
        return defaultValue;
      }
      if (padding.unit === 'ratio') {
        return padding[key] * domainLength;
      }
      return this.convertPixelsToAxisPadding(p, domainLength);
    };
    Axis.prototype.convertPixelsToAxisPadding = function convertPixelsToAxisPadding(pixels, domainLength) {
      var $$ = this.owner,
          length = $$.config.axis_rotated ? $$.width : $$.height;
      return domainLength * (pixels / length);
    };
    Axis.prototype.generateTickValues = function generateTickValues(values, tickCount, forTimeSeries) {
      var tickValues = values,
          targetCount,
          start,
          end,
          count,
          interval,
          i,
          tickValue;
      if (tickCount) {
        targetCount = isFunction(tickCount) ? tickCount() : tickCount;
        if (targetCount === 1) {
          tickValues = [values[0]];
        } else if (targetCount === 2) {
          tickValues = [values[0], values[values.length - 1]];
        } else if (targetCount > 2) {
          count = targetCount - 2;
          start = values[0];
          end = values[values.length - 1];
          interval = (end - start) / (count + 1);
          tickValues = [start];
          for (i = 0; i < count; i++) {
            tickValue = +start + interval * (i + 1);
            tickValues.push(forTimeSeries ? new Date(tickValue) : tickValue);
          }
          tickValues.push(end);
        }
      }
      if (!forTimeSeries) {
        tickValues = tickValues.sort(function(a, b) {
          return a - b;
        });
      }
      return tickValues;
    };
    Axis.prototype.generateTransitions = function generateTransitions(duration) {
      var $$ = this.owner,
          axes = $$.axes;
      return {
        axisX: duration ? axes.x.transition().duration(duration) : axes.x,
        axisY: duration ? axes.y.transition().duration(duration) : axes.y,
        axisY2: duration ? axes.y2.transition().duration(duration) : axes.y2,
        axisSubX: duration ? axes.subx.transition().duration(duration) : axes.subx
      };
    };
    Axis.prototype.redraw = function redraw(transitions, isHidden) {
      var $$ = this.owner;
      $$.axes.x.style("opacity", isHidden ? 0 : 1);
      $$.axes.y.style("opacity", isHidden ? 0 : 1);
      $$.axes.y2.style("opacity", isHidden ? 0 : 1);
      $$.axes.subx.style("opacity", isHidden ? 0 : 1);
      transitions.axisX.call($$.xAxis);
      transitions.axisY.call($$.yAxis);
      transitions.axisY2.call($$.y2Axis);
      transitions.axisSubX.call($$.subXAxis);
    };
    c3_chart_internal_fn.getClipPath = function(id) {
      var isIE9 = window.navigator.appVersion.toLowerCase().indexOf("msie 9.") >= 0;
      return "url(" + (isIE9 ? "" : document.URL.split('#')[0]) + "#" + id + ")";
    };
    c3_chart_internal_fn.appendClip = function(parent, id) {
      return parent.append("clipPath").attr("id", id).append("rect");
    };
    c3_chart_internal_fn.getAxisClipX = function(forHorizontal) {
      var left = Math.max(30, this.margin.left);
      return forHorizontal ? -(1 + left) : -(left - 1);
    };
    c3_chart_internal_fn.getAxisClipY = function(forHorizontal) {
      return forHorizontal ? -20 : -this.margin.top;
    };
    c3_chart_internal_fn.getXAxisClipX = function() {
      var $$ = this;
      return $$.getAxisClipX(!$$.config.axis_rotated);
    };
    c3_chart_internal_fn.getXAxisClipY = function() {
      var $$ = this;
      return $$.getAxisClipY(!$$.config.axis_rotated);
    };
    c3_chart_internal_fn.getYAxisClipX = function() {
      var $$ = this;
      return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
    };
    c3_chart_internal_fn.getYAxisClipY = function() {
      var $$ = this;
      return $$.getAxisClipY($$.config.axis_rotated);
    };
    c3_chart_internal_fn.getAxisClipWidth = function(forHorizontal) {
      var $$ = this,
          left = Math.max(30, $$.margin.left),
          right = Math.max(30, $$.margin.right);
      return forHorizontal ? $$.width + 2 + left + right : $$.margin.left + 20;
    };
    c3_chart_internal_fn.getAxisClipHeight = function(forHorizontal) {
      return (forHorizontal ? this.margin.bottom : (this.margin.top + this.height)) + 20;
    };
    c3_chart_internal_fn.getXAxisClipWidth = function() {
      var $$ = this;
      return $$.getAxisClipWidth(!$$.config.axis_rotated);
    };
    c3_chart_internal_fn.getXAxisClipHeight = function() {
      var $$ = this;
      return $$.getAxisClipHeight(!$$.config.axis_rotated);
    };
    c3_chart_internal_fn.getYAxisClipWidth = function() {
      var $$ = this;
      return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);
    };
    c3_chart_internal_fn.getYAxisClipHeight = function() {
      var $$ = this;
      return $$.getAxisClipHeight($$.config.axis_rotated);
    };
    c3_chart_internal_fn.initPie = function() {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config;
      $$.pie = d3.layout.pie().value(function(d) {
        return d.values.reduce(function(a, b) {
          return a + b.value;
        }, 0);
      });
      if (!config.data_order) {
        $$.pie.sort(null);
      }
    };
    c3_chart_internal_fn.updateRadius = function() {
      var $$ = this,
          config = $$.config,
          w = config.gauge_width || config.donut_width;
      $$.radiusExpanded = Math.min($$.arcWidth, $$.arcHeight) / 2;
      $$.radius = $$.radiusExpanded * 0.95;
      $$.innerRadiusRatio = w ? ($$.radius - w) / $$.radius : 0.6;
      $$.innerRadius = $$.hasType('donut') || $$.hasType('gauge') ? $$.radius * $$.innerRadiusRatio : 0;
    };
    c3_chart_internal_fn.updateArc = function() {
      var $$ = this;
      $$.svgArc = $$.getSvgArc();
      $$.svgArcExpanded = $$.getSvgArcExpanded();
      $$.svgArcExpandedSub = $$.getSvgArcExpanded(0.98);
    };
    c3_chart_internal_fn.updateAngle = function(d) {
      var $$ = this,
          config = $$.config,
          found = false,
          index = 0,
          gMin = config.gauge_min,
          gMax = config.gauge_max,
          gTic,
          gValue;
      $$.pie($$.filterTargetsToShow($$.data.targets)).forEach(function(t) {
        if (!found && t.data.id === d.data.id) {
          found = true;
          d = t;
          d.index = index;
        }
        index++;
      });
      if (isNaN(d.startAngle)) {
        d.startAngle = 0;
      }
      if (isNaN(d.endAngle)) {
        d.endAngle = d.startAngle;
      }
      if ($$.isGaugeType(d.data)) {
        gTic = (Math.PI) / (gMax - gMin);
        gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : (gMax - gMin);
        d.startAngle = -1 * (Math.PI / 2);
        d.endAngle = d.startAngle + gTic * gValue;
      }
      return found ? d : null;
    };
    c3_chart_internal_fn.getSvgArc = function() {
      var $$ = this,
          arc = $$.d3.svg.arc().outerRadius($$.radius).innerRadius($$.innerRadius),
          newArc = function(d, withoutUpdate) {
            var updated;
            if (withoutUpdate) {
              return arc(d);
            }
            updated = $$.updateAngle(d);
            return updated ? arc(updated) : "M 0 0";
          };
      newArc.centroid = arc.centroid;
      return newArc;
    };
    c3_chart_internal_fn.getSvgArcExpanded = function(rate) {
      var $$ = this,
          arc = $$.d3.svg.arc().outerRadius($$.radiusExpanded * (rate ? rate : 1)).innerRadius($$.innerRadius);
      return function(d) {
        var updated = $$.updateAngle(d);
        return updated ? arc(updated) : "M 0 0";
      };
    };
    c3_chart_internal_fn.getArc = function(d, withoutUpdate, force) {
      return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : "M 0 0";
    };
    c3_chart_internal_fn.transformForArcLabel = function(d) {
      var $$ = this,
          updated = $$.updateAngle(d),
          c,
          x,
          y,
          h,
          ratio,
          translate = "";
      if (updated && !$$.hasType('gauge')) {
        c = this.svgArc.centroid(updated);
        x = isNaN(c[0]) ? 0 : c[0];
        y = isNaN(c[1]) ? 0 : c[1];
        h = Math.sqrt(x * x + y * y);
        ratio = $$.radius && h ? (36 / $$.radius > 0.375 ? 1.175 - 36 / $$.radius : 0.8) * $$.radius / h : 0;
        translate = "translate(" + (x * ratio) + ',' + (y * ratio) + ")";
      }
      return translate;
    };
    c3_chart_internal_fn.getArcRatio = function(d) {
      var $$ = this,
          whole = $$.hasType('gauge') ? Math.PI : (Math.PI * 2);
      return d ? (d.endAngle - d.startAngle) / whole : null;
    };
    c3_chart_internal_fn.convertToArcData = function(d) {
      return this.addName({
        id: d.data.id,
        value: d.value,
        ratio: this.getArcRatio(d),
        index: d.index
      });
    };
    c3_chart_internal_fn.textForArcLabel = function(d) {
      var $$ = this,
          updated,
          value,
          ratio,
          id,
          format;
      if (!$$.shouldShowArcLabel()) {
        return "";
      }
      updated = $$.updateAngle(d);
      value = updated ? updated.value : null;
      ratio = $$.getArcRatio(updated);
      id = d.data.id;
      if (!$$.hasType('gauge') && !$$.meetsArcLabelThreshold(ratio)) {
        return "";
      }
      format = $$.getArcLabelFormat();
      return format ? format(value, ratio, id) : $$.defaultArcValueFormat(value, ratio);
    };
    c3_chart_internal_fn.expandArc = function(targetIds) {
      var $$ = this,
          interval;
      if ($$.transiting) {
        interval = window.setInterval(function() {
          if (!$$.transiting) {
            window.clearInterval(interval);
            if ($$.legend.selectAll('.c3-legend-item-focused').size() > 0) {
              $$.expandArc(targetIds);
            }
          }
        }, 10);
        return;
      }
      targetIds = $$.mapToTargetIds(targetIds);
      $$.svg.selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc)).each(function(d) {
        if (!$$.shouldExpand(d.data.id)) {
          return;
        }
        $$.d3.select(this).selectAll('path').transition().duration($$.expandDuration(d.data.id)).attr("d", $$.svgArcExpanded).transition().duration($$.expandDuration(d.data.id) * 2).attr("d", $$.svgArcExpandedSub).each(function(d) {
          if ($$.isDonutType(d.data)) {}
        });
      });
    };
    c3_chart_internal_fn.unexpandArc = function(targetIds) {
      var $$ = this;
      if ($$.transiting) {
        return;
      }
      targetIds = $$.mapToTargetIds(targetIds);
      $$.svg.selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc)).selectAll('path').transition().duration(function(d) {
        return $$.expandDuration(d.data.id);
      }).attr("d", $$.svgArc);
      $$.svg.selectAll('.' + CLASS.arc).style("opacity", 1);
    };
    c3_chart_internal_fn.expandDuration = function(id) {
      var $$ = this,
          config = $$.config;
      if ($$.isDonutType(id)) {
        return config.donut_expand_duration;
      } else if ($$.isGaugeType(id)) {
        return config.gauge_expand_duration;
      } else if ($$.isPieType(id)) {
        return config.pie_expand_duration;
      } else {
        return 50;
      }
    };
    c3_chart_internal_fn.shouldExpand = function(id) {
      var $$ = this,
          config = $$.config;
      return ($$.isDonutType(id) && config.donut_expand) || ($$.isGaugeType(id) && config.gauge_expand) || ($$.isPieType(id) && config.pie_expand);
    };
    c3_chart_internal_fn.shouldShowArcLabel = function() {
      var $$ = this,
          config = $$.config,
          shouldShow = true;
      if ($$.hasType('donut')) {
        shouldShow = config.donut_label_show;
      } else if ($$.hasType('pie')) {
        shouldShow = config.pie_label_show;
      }
      return shouldShow;
    };
    c3_chart_internal_fn.meetsArcLabelThreshold = function(ratio) {
      var $$ = this,
          config = $$.config,
          threshold = $$.hasType('donut') ? config.donut_label_threshold : config.pie_label_threshold;
      return ratio >= threshold;
    };
    c3_chart_internal_fn.getArcLabelFormat = function() {
      var $$ = this,
          config = $$.config,
          format = config.pie_label_format;
      if ($$.hasType('gauge')) {
        format = config.gauge_label_format;
      } else if ($$.hasType('donut')) {
        format = config.donut_label_format;
      }
      return format;
    };
    c3_chart_internal_fn.getArcTitle = function() {
      var $$ = this;
      return $$.hasType('donut') ? $$.config.donut_title : "";
    };
    c3_chart_internal_fn.updateTargetsForArc = function(targets) {
      var $$ = this,
          main = $$.main,
          mainPieUpdate,
          mainPieEnter,
          classChartArc = $$.classChartArc.bind($$),
          classArcs = $$.classArcs.bind($$),
          classFocus = $$.classFocus.bind($$);
      mainPieUpdate = main.select('.' + CLASS.chartArcs).selectAll('.' + CLASS.chartArc).data($$.pie(targets)).attr("class", function(d) {
        return classChartArc(d) + classFocus(d.data);
      });
      mainPieEnter = mainPieUpdate.enter().append("g").attr("class", classChartArc);
      mainPieEnter.append('g').attr('class', classArcs);
      mainPieEnter.append("text").attr("dy", $$.hasType('gauge') ? "-.1em" : ".35em").style("opacity", 0).style("text-anchor", "middle").style("pointer-events", "none");
    };
    c3_chart_internal_fn.initArc = function() {
      var $$ = this;
      $$.arcs = $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartArcs).attr("transform", $$.getTranslate('arc'));
      $$.arcs.append('text').attr('class', CLASS.chartArcsTitle).style("text-anchor", "middle").text($$.getArcTitle());
    };
    c3_chart_internal_fn.redrawArc = function(duration, durationForExit, withTransform) {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config,
          main = $$.main,
          mainArc;
      mainArc = main.selectAll('.' + CLASS.arcs).selectAll('.' + CLASS.arc).data($$.arcData.bind($$));
      mainArc.enter().append('path').attr("class", $$.classArc.bind($$)).style("fill", function(d) {
        return $$.color(d.data);
      }).style("cursor", function(d) {
        return config.interaction_enabled && config.data_selection_isselectable(d) ? "pointer" : null;
      }).style("opacity", 0).each(function(d) {
        if ($$.isGaugeType(d.data)) {
          d.startAngle = d.endAngle = -1 * (Math.PI / 2);
        }
        this._current = d;
      });
      mainArc.attr("transform", function(d) {
        return !$$.isGaugeType(d.data) && withTransform ? "scale(0)" : "";
      }).style("opacity", function(d) {
        return d === this._current ? 0 : 1;
      }).on('mouseover', config.interaction_enabled ? function(d) {
        var updated,
            arcData;
        if ($$.transiting) {
          return;
        }
        updated = $$.updateAngle(d);
        if (updated) {
          arcData = $$.convertToArcData(updated);
          $$.expandArc(updated.data.id);
          $$.api.focus(updated.data.id);
          $$.toggleFocusLegend(updated.data.id, true);
          $$.config.data_onmouseover(arcData, this);
        }
      } : null).on('mousemove', config.interaction_enabled ? function(d) {
        var updated = $$.updateAngle(d),
            arcData,
            selectedData;
        if (updated) {
          arcData = $$.convertToArcData(updated), selectedData = [arcData];
          $$.showTooltip(selectedData, this);
        }
      } : null).on('mouseout', config.interaction_enabled ? function(d) {
        var updated,
            arcData;
        if ($$.transiting) {
          return;
        }
        updated = $$.updateAngle(d);
        if (updated) {
          arcData = $$.convertToArcData(updated);
          $$.unexpandArc(updated.data.id);
          $$.api.revert();
          $$.revertLegend();
          $$.hideTooltip();
          $$.config.data_onmouseout(arcData, this);
        }
      } : null).on('click', config.interaction_enabled ? function(d, i) {
        var updated = $$.updateAngle(d),
            arcData;
        if (updated) {
          arcData = $$.convertToArcData(updated);
          if ($$.toggleShape) {
            $$.toggleShape(this, arcData, i);
          }
          $$.config.data_onclick.call($$.api, arcData, this);
        }
      } : null).each(function() {
        $$.transiting = true;
      }).transition().duration(duration).attrTween("d", function(d) {
        var updated = $$.updateAngle(d),
            interpolate;
        if (!updated) {
          return function() {
            return "M 0 0";
          };
        }
        if (isNaN(this._current.startAngle)) {
          this._current.startAngle = 0;
        }
        if (isNaN(this._current.endAngle)) {
          this._current.endAngle = this._current.startAngle;
        }
        interpolate = d3.interpolate(this._current, updated);
        this._current = interpolate(0);
        return function(t) {
          var interpolated = interpolate(t);
          interpolated.data = d.data;
          return $$.getArc(interpolated, true);
        };
      }).attr("transform", withTransform ? "scale(1)" : "").style("fill", function(d) {
        return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data.id);
      }).style("opacity", 1).call($$.endall, function() {
        $$.transiting = false;
      });
      mainArc.exit().transition().duration(durationForExit).style('opacity', 0).remove();
      main.selectAll('.' + CLASS.chartArc).select('text').style("opacity", 0).attr('class', function(d) {
        return $$.isGaugeType(d.data) ? CLASS.gaugeValue : '';
      }).text($$.textForArcLabel.bind($$)).attr("transform", $$.transformForArcLabel.bind($$)).style('font-size', function(d) {
        return $$.isGaugeType(d.data) ? Math.round($$.radius / 5) + 'px' : '';
      }).transition().duration(duration).style("opacity", function(d) {
        return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? 1 : 0;
      });
      main.select('.' + CLASS.chartArcsTitle).style("opacity", $$.hasType('donut') || $$.hasType('gauge') ? 1 : 0);
      if ($$.hasType('gauge')) {
        $$.arcs.select('.' + CLASS.chartArcsBackground).attr("d", function() {
          var d = {
            data: [{value: config.gauge_max}],
            startAngle: -1 * (Math.PI / 2),
            endAngle: Math.PI / 2
          };
          return $$.getArc(d, true, true);
        });
        $$.arcs.select('.' + CLASS.chartArcsGaugeUnit).attr("dy", ".75em").text(config.gauge_label_show ? config.gauge_units : '');
        $$.arcs.select('.' + CLASS.chartArcsGaugeMin).attr("dx", -1 * ($$.innerRadius + (($$.radius - $$.innerRadius) / 2)) + "px").attr("dy", "1.2em").text(config.gauge_label_show ? config.gauge_min : '');
        $$.arcs.select('.' + CLASS.chartArcsGaugeMax).attr("dx", $$.innerRadius + (($$.radius - $$.innerRadius) / 2) + "px").attr("dy", "1.2em").text(config.gauge_label_show ? config.gauge_max : '');
      }
    };
    c3_chart_internal_fn.initGauge = function() {
      var arcs = this.arcs;
      if (this.hasType('gauge')) {
        arcs.append('path').attr("class", CLASS.chartArcsBackground);
        arcs.append("text").attr("class", CLASS.chartArcsGaugeUnit).style("text-anchor", "middle").style("pointer-events", "none");
        arcs.append("text").attr("class", CLASS.chartArcsGaugeMin).style("text-anchor", "middle").style("pointer-events", "none");
        arcs.append("text").attr("class", CLASS.chartArcsGaugeMax).style("text-anchor", "middle").style("pointer-events", "none");
      }
    };
    c3_chart_internal_fn.getGaugeLabelHeight = function() {
      return this.config.gauge_label_show ? 20 : 0;
    };
    c3_chart_internal_fn.initRegion = function() {
      var $$ = this;
      $$.region = $$.main.append('g').attr("clip-path", $$.clipPath).attr("class", CLASS.regions);
    };
    c3_chart_internal_fn.updateRegion = function(duration) {
      var $$ = this,
          config = $$.config;
      $$.region.style('visibility', $$.hasArcType() ? 'hidden' : 'visible');
      $$.mainRegion = $$.main.select('.' + CLASS.regions).selectAll('.' + CLASS.region).data(config.regions);
      $$.mainRegion.enter().append('g').attr('class', $$.classRegion.bind($$)).append('rect').style("fill-opacity", 0);
      $$.mainRegion.exit().transition().duration(duration).style("opacity", 0).remove();
    };
    c3_chart_internal_fn.redrawRegion = function(withTransition) {
      var $$ = this,
          regions = $$.mainRegion.selectAll('rect'),
          x = $$.regionX.bind($$),
          y = $$.regionY.bind($$),
          w = $$.regionWidth.bind($$),
          h = $$.regionHeight.bind($$);
      return [(withTransition ? regions.transition() : regions).attr("x", x).attr("y", y).attr("width", w).attr("height", h).style("fill-opacity", function(d) {
        return isValue(d.opacity) ? d.opacity : 0.1;
      })];
    };
    c3_chart_internal_fn.regionX = function(d) {
      var $$ = this,
          config = $$.config,
          xPos,
          yScale = d.axis === 'y' ? $$.y : $$.y2;
      if (d.axis === 'y' || d.axis === 'y2') {
        xPos = config.axis_rotated ? ('start' in d ? yScale(d.start) : 0) : 0;
      } else {
        xPos = config.axis_rotated ? 0 : ('start' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0);
      }
      return xPos;
    };
    c3_chart_internal_fn.regionY = function(d) {
      var $$ = this,
          config = $$.config,
          yPos,
          yScale = d.axis === 'y' ? $$.y : $$.y2;
      if (d.axis === 'y' || d.axis === 'y2') {
        yPos = config.axis_rotated ? 0 : ('end' in d ? yScale(d.end) : 0);
      } else {
        yPos = config.axis_rotated ? ('start' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0) : 0;
      }
      return yPos;
    };
    c3_chart_internal_fn.regionWidth = function(d) {
      var $$ = this,
          config = $$.config,
          start = $$.regionX(d),
          end,
          yScale = d.axis === 'y' ? $$.y : $$.y2;
      if (d.axis === 'y' || d.axis === 'y2') {
        end = config.axis_rotated ? ('end' in d ? yScale(d.end) : $$.width) : $$.width;
      } else {
        end = config.axis_rotated ? $$.width : ('end' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end) : $$.width);
      }
      return end < start ? 0 : end - start;
    };
    c3_chart_internal_fn.regionHeight = function(d) {
      var $$ = this,
          config = $$.config,
          start = this.regionY(d),
          end,
          yScale = d.axis === 'y' ? $$.y : $$.y2;
      if (d.axis === 'y' || d.axis === 'y2') {
        end = config.axis_rotated ? $$.height : ('start' in d ? yScale(d.start) : $$.height);
      } else {
        end = config.axis_rotated ? ('end' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end) : $$.height) : $$.height;
      }
      return end < start ? 0 : end - start;
    };
    c3_chart_internal_fn.isRegionOnX = function(d) {
      return !d.axis || d.axis === 'x';
    };
    c3_chart_internal_fn.drag = function(mouse) {
      var $$ = this,
          config = $$.config,
          main = $$.main,
          d3 = $$.d3;
      var sx,
          sy,
          mx,
          my,
          minX,
          maxX,
          minY,
          maxY;
      if ($$.hasArcType()) {
        return;
      }
      if (!config.data_selection_enabled) {
        return;
      }
      if (config.zoom_enabled && !$$.zoom.altDomain) {
        return;
      }
      if (!config.data_selection_multiple) {
        return;
      }
      sx = $$.dragStart[0];
      sy = $$.dragStart[1];
      mx = mouse[0];
      my = mouse[1];
      minX = Math.min(sx, mx);
      maxX = Math.max(sx, mx);
      minY = (config.data_selection_grouped) ? $$.margin.top : Math.min(sy, my);
      maxY = (config.data_selection_grouped) ? $$.height : Math.max(sy, my);
      main.select('.' + CLASS.dragarea).attr('x', minX).attr('y', minY).attr('width', maxX - minX).attr('height', maxY - minY);
      main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).filter(function(d) {
        return config.data_selection_isselectable(d);
      }).each(function(d, i) {
        var shape = d3.select(this),
            isSelected = shape.classed(CLASS.SELECTED),
            isIncluded = shape.classed(CLASS.INCLUDED),
            _x,
            _y,
            _w,
            _h,
            toggle,
            isWithin = false,
            box;
        if (shape.classed(CLASS.circle)) {
          _x = shape.attr("cx") * 1;
          _y = shape.attr("cy") * 1;
          toggle = $$.togglePoint;
          isWithin = minX < _x && _x < maxX && minY < _y && _y < maxY;
        } else if (shape.classed(CLASS.bar)) {
          box = getPathBox(this);
          _x = box.x;
          _y = box.y;
          _w = box.width;
          _h = box.height;
          toggle = $$.togglePath;
          isWithin = !(maxX < _x || _x + _w < minX) && !(maxY < _y || _y + _h < minY);
        } else {
          return;
        }
        if (isWithin ^ isIncluded) {
          shape.classed(CLASS.INCLUDED, !isIncluded);
          shape.classed(CLASS.SELECTED, !isSelected);
          toggle.call($$, !isSelected, shape, d, i);
        }
      });
    };
    c3_chart_internal_fn.dragstart = function(mouse) {
      var $$ = this,
          config = $$.config;
      if ($$.hasArcType()) {
        return;
      }
      if (!config.data_selection_enabled) {
        return;
      }
      $$.dragStart = mouse;
      $$.main.select('.' + CLASS.chart).append('rect').attr('class', CLASS.dragarea).style('opacity', 0.1);
      $$.dragging = true;
    };
    c3_chart_internal_fn.dragend = function() {
      var $$ = this,
          config = $$.config;
      if ($$.hasArcType()) {
        return;
      }
      if (!config.data_selection_enabled) {
        return;
      }
      $$.main.select('.' + CLASS.dragarea).transition().duration(100).style('opacity', 0).remove();
      $$.main.selectAll('.' + CLASS.shape).classed(CLASS.INCLUDED, false);
      $$.dragging = false;
    };
    c3_chart_internal_fn.selectPoint = function(target, d, i) {
      var $$ = this,
          config = $$.config,
          cx = (config.axis_rotated ? $$.circleY : $$.circleX).bind($$),
          cy = (config.axis_rotated ? $$.circleX : $$.circleY).bind($$),
          r = $$.pointSelectR.bind($$);
      config.data_onselected.call($$.api, d, target.node());
      $$.main.select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll('.' + CLASS.selectedCircle + '-' + i).data([d]).enter().append('circle').attr("class", function() {
        return $$.generateClass(CLASS.selectedCircle, i);
      }).attr("cx", cx).attr("cy", cy).attr("stroke", function() {
        return $$.color(d);
      }).attr("r", function(d) {
        return $$.pointSelectR(d) * 1.4;
      }).transition().duration(100).attr("r", r);
    };
    c3_chart_internal_fn.unselectPoint = function(target, d, i) {
      var $$ = this;
      $$.config.data_onunselected.call($$.api, d, target.node());
      $$.main.select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll('.' + CLASS.selectedCircle + '-' + i).transition().duration(100).attr('r', 0).remove();
    };
    c3_chart_internal_fn.togglePoint = function(selected, target, d, i) {
      selected ? this.selectPoint(target, d, i) : this.unselectPoint(target, d, i);
    };
    c3_chart_internal_fn.selectPath = function(target, d) {
      var $$ = this;
      $$.config.data_onselected.call($$, d, target.node());
      target.transition().duration(100).style("fill", function() {
        return $$.d3.rgb($$.color(d)).brighter(0.75);
      });
    };
    c3_chart_internal_fn.unselectPath = function(target, d) {
      var $$ = this;
      $$.config.data_onunselected.call($$, d, target.node());
      target.transition().duration(100).style("fill", function() {
        return $$.color(d);
      });
    };
    c3_chart_internal_fn.togglePath = function(selected, target, d, i) {
      selected ? this.selectPath(target, d, i) : this.unselectPath(target, d, i);
    };
    c3_chart_internal_fn.getToggle = function(that, d) {
      var $$ = this,
          toggle;
      if (that.nodeName === 'circle') {
        if ($$.isStepType(d)) {
          toggle = function() {};
        } else {
          toggle = $$.togglePoint;
        }
      } else if (that.nodeName === 'path') {
        toggle = $$.togglePath;
      }
      return toggle;
    };
    c3_chart_internal_fn.toggleShape = function(that, d, i) {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config,
          shape = d3.select(that),
          isSelected = shape.classed(CLASS.SELECTED),
          toggle = $$.getToggle(that, d).bind($$);
      if (config.data_selection_enabled && config.data_selection_isselectable(d)) {
        if (!config.data_selection_multiple) {
          $$.main.selectAll('.' + CLASS.shapes + (config.data_selection_grouped ? $$.getTargetSelectorSuffix(d.id) : "")).selectAll('.' + CLASS.shape).each(function(d, i) {
            var shape = d3.select(this);
            if (shape.classed(CLASS.SELECTED)) {
              toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
            }
          });
        }
        shape.classed(CLASS.SELECTED, !isSelected);
        toggle(!isSelected, shape, d, i);
      }
    };
    c3_chart_internal_fn.initBrush = function() {
      var $$ = this,
          d3 = $$.d3;
      $$.brush = d3.svg.brush().on("brush", function() {
        $$.redrawForBrush();
      });
      $$.brush.update = function() {
        if ($$.context) {
          $$.context.select('.' + CLASS.brush).call(this);
        }
        return this;
      };
      $$.brush.scale = function(scale) {
        return $$.config.axis_rotated ? this.y(scale) : this.x(scale);
      };
    };
    c3_chart_internal_fn.initSubchart = function() {
      var $$ = this,
          config = $$.config,
          context = $$.context = $$.svg.append("g").attr("transform", $$.getTranslate('context')),
          visibility = config.subchart_show ? 'visible' : 'hidden';
      context.style('visibility', visibility);
      context.append('g').attr("clip-path", $$.clipPathForSubchart).attr('class', CLASS.chart);
      context.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartBars);
      context.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartLines);
      context.append("g").attr("clip-path", $$.clipPath).attr("class", CLASS.brush).call($$.brush);
      $$.axes.subx = context.append("g").attr("class", CLASS.axisX).attr("transform", $$.getTranslate('subx')).attr("clip-path", config.axis_rotated ? "" : $$.clipPathForXAxis).style("visibility", config.subchart_axis_x_show ? visibility : 'hidden');
    };
    c3_chart_internal_fn.updateTargetsForSubchart = function(targets) {
      var $$ = this,
          context = $$.context,
          config = $$.config,
          contextLineEnter,
          contextLineUpdate,
          contextBarEnter,
          contextBarUpdate,
          classChartBar = $$.classChartBar.bind($$),
          classBars = $$.classBars.bind($$),
          classChartLine = $$.classChartLine.bind($$),
          classLines = $$.classLines.bind($$),
          classAreas = $$.classAreas.bind($$);
      if (config.subchart_show) {
        contextBarUpdate = context.select('.' + CLASS.chartBars).selectAll('.' + CLASS.chartBar).data(targets).attr('class', classChartBar);
        contextBarEnter = contextBarUpdate.enter().append('g').style('opacity', 0).attr('class', classChartBar);
        contextBarEnter.append('g').attr("class", classBars);
        contextLineUpdate = context.select('.' + CLASS.chartLines).selectAll('.' + CLASS.chartLine).data(targets).attr('class', classChartLine);
        contextLineEnter = contextLineUpdate.enter().append('g').style('opacity', 0).attr('class', classChartLine);
        contextLineEnter.append("g").attr("class", classLines);
        contextLineEnter.append("g").attr("class", classAreas);
        context.selectAll('.' + CLASS.brush + ' rect').attr(config.axis_rotated ? "width" : "height", config.axis_rotated ? $$.width2 : $$.height2);
      }
    };
    c3_chart_internal_fn.updateBarForSubchart = function(durationForExit) {
      var $$ = this;
      $$.contextBar = $$.context.selectAll('.' + CLASS.bars).selectAll('.' + CLASS.bar).data($$.barData.bind($$));
      $$.contextBar.enter().append('path').attr("class", $$.classBar.bind($$)).style("stroke", 'none').style("fill", $$.color);
      $$.contextBar.style("opacity", $$.initialOpacity.bind($$));
      $$.contextBar.exit().transition().duration(durationForExit).style('opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawBarForSubchart = function(drawBarOnSub, withTransition, duration) {
      (withTransition ? this.contextBar.transition().duration(duration) : this.contextBar).attr('d', drawBarOnSub).style('opacity', 1);
    };
    c3_chart_internal_fn.updateLineForSubchart = function(durationForExit) {
      var $$ = this;
      $$.contextLine = $$.context.selectAll('.' + CLASS.lines).selectAll('.' + CLASS.line).data($$.lineData.bind($$));
      $$.contextLine.enter().append('path').attr('class', $$.classLine.bind($$)).style('stroke', $$.color);
      $$.contextLine.style("opacity", $$.initialOpacity.bind($$));
      $$.contextLine.exit().transition().duration(durationForExit).style('opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawLineForSubchart = function(drawLineOnSub, withTransition, duration) {
      (withTransition ? this.contextLine.transition().duration(duration) : this.contextLine).attr("d", drawLineOnSub).style('opacity', 1);
    };
    c3_chart_internal_fn.updateAreaForSubchart = function(durationForExit) {
      var $$ = this,
          d3 = $$.d3;
      $$.contextArea = $$.context.selectAll('.' + CLASS.areas).selectAll('.' + CLASS.area).data($$.lineData.bind($$));
      $$.contextArea.enter().append('path').attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function() {
        $$.orgAreaOpacity = +d3.select(this).style('opacity');
        return 0;
      });
      $$.contextArea.style("opacity", 0);
      $$.contextArea.exit().transition().duration(durationForExit).style('opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawAreaForSubchart = function(drawAreaOnSub, withTransition, duration) {
      (withTransition ? this.contextArea.transition().duration(duration) : this.contextArea).attr("d", drawAreaOnSub).style("fill", this.color).style("opacity", this.orgAreaOpacity);
    };
    c3_chart_internal_fn.redrawSubchart = function(withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices) {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config,
          drawAreaOnSub,
          drawBarOnSub,
          drawLineOnSub;
      $$.context.style('visibility', config.subchart_show ? 'visible' : 'hidden');
      if (config.subchart_show) {
        if (d3.event && d3.event.type === 'zoom') {
          $$.brush.extent($$.x.orgDomain()).update();
        }
        if (withSubchart) {
          if (!$$.brush.empty()) {
            $$.brush.extent($$.x.orgDomain()).update();
          }
          drawAreaOnSub = $$.generateDrawArea(areaIndices, true);
          drawBarOnSub = $$.generateDrawBar(barIndices, true);
          drawLineOnSub = $$.generateDrawLine(lineIndices, true);
          $$.updateBarForSubchart(duration);
          $$.updateLineForSubchart(duration);
          $$.updateAreaForSubchart(duration);
          $$.redrawBarForSubchart(drawBarOnSub, duration, duration);
          $$.redrawLineForSubchart(drawLineOnSub, duration, duration);
          $$.redrawAreaForSubchart(drawAreaOnSub, duration, duration);
        }
      }
    };
    c3_chart_internal_fn.redrawForBrush = function() {
      var $$ = this,
          x = $$.x;
      $$.redraw({
        withTransition: false,
        withY: $$.config.zoom_rescale,
        withSubchart: false,
        withUpdateXDomain: true,
        withDimension: false
      });
      $$.config.subchart_onbrush.call($$.api, x.orgDomain());
    };
    c3_chart_internal_fn.transformContext = function(withTransition, transitions) {
      var $$ = this,
          subXAxis;
      if (transitions && transitions.axisSubX) {
        subXAxis = transitions.axisSubX;
      } else {
        subXAxis = $$.context.select('.' + CLASS.axisX);
        if (withTransition) {
          subXAxis = subXAxis.transition();
        }
      }
      $$.context.attr("transform", $$.getTranslate('context'));
      subXAxis.attr("transform", $$.getTranslate('subx'));
    };
    c3_chart_internal_fn.getDefaultExtent = function() {
      var $$ = this,
          config = $$.config,
          extent = isFunction(config.axis_x_extent) ? config.axis_x_extent($$.getXDomain($$.data.targets)) : config.axis_x_extent;
      if ($$.isTimeSeries()) {
        extent = [$$.parseDate(extent[0]), $$.parseDate(extent[1])];
      }
      return extent;
    };
    c3_chart_internal_fn.initZoom = function() {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config,
          startEvent;
      $$.zoom = d3.behavior.zoom().on("zoomstart", function() {
        startEvent = d3.event.sourceEvent;
        $$.zoom.altDomain = d3.event.sourceEvent.altKey ? $$.x.orgDomain() : null;
        config.zoom_onzoomstart.call($$.api, d3.event.sourceEvent);
      }).on("zoom", function() {
        $$.redrawForZoom.call($$);
      }).on('zoomend', function() {
        var event = d3.event.sourceEvent;
        if (event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY) {
          return;
        }
        $$.redrawEventRect();
        $$.updateZoom();
        config.zoom_onzoomend.call($$.api, $$.x.orgDomain());
      });
      $$.zoom.scale = function(scale) {
        return config.axis_rotated ? this.y(scale) : this.x(scale);
      };
      $$.zoom.orgScaleExtent = function() {
        var extent = config.zoom_extent ? config.zoom_extent : [1, 10];
        return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];
      };
      $$.zoom.updateScaleExtent = function() {
        var ratio = diffDomain($$.x.orgDomain()) / diffDomain($$.getZoomDomain()),
            extent = this.orgScaleExtent();
        this.scaleExtent([extent[0] * ratio, extent[1] * ratio]);
        return this;
      };
    };
    c3_chart_internal_fn.getZoomDomain = function() {
      var $$ = this,
          config = $$.config,
          d3 = $$.d3,
          min = d3.min([$$.orgXDomain[0], config.zoom_x_min]),
          max = d3.max([$$.orgXDomain[1], config.zoom_x_max]);
      return [min, max];
    };
    c3_chart_internal_fn.updateZoom = function() {
      var $$ = this,
          z = $$.config.zoom_enabled ? $$.zoom : function() {};
      $$.main.select('.' + CLASS.zoomRect).call(z).on("dblclick.zoom", null);
      $$.main.selectAll('.' + CLASS.eventRect).call(z).on("dblclick.zoom", null);
    };
    c3_chart_internal_fn.redrawForZoom = function() {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config,
          zoom = $$.zoom,
          x = $$.x;
      if (!config.zoom_enabled) {
        return;
      }
      if ($$.filterTargetsToShow($$.data.targets).length === 0) {
        return;
      }
      if (d3.event.sourceEvent.type === 'mousemove' && zoom.altDomain) {
        x.domain(zoom.altDomain);
        zoom.scale(x).updateScaleExtent();
        return;
      }
      if ($$.isCategorized() && x.orgDomain()[0] === $$.orgXDomain[0]) {
        x.domain([$$.orgXDomain[0] - 1e-10, x.orgDomain()[1]]);
      }
      $$.redraw({
        withTransition: false,
        withY: config.zoom_rescale,
        withSubchart: false,
        withEventRect: false,
        withDimension: false
      });
      if (d3.event.sourceEvent.type === 'mousemove') {
        $$.cancelClick = true;
      }
      config.zoom_onzoom.call($$.api, x.orgDomain());
    };
    c3_chart_internal_fn.generateColor = function() {
      var $$ = this,
          config = $$.config,
          d3 = $$.d3,
          colors = config.data_colors,
          pattern = notEmpty(config.color_pattern) ? config.color_pattern : d3.scale.category10().range(),
          callback = config.data_color,
          ids = [];
      return function(d) {
        var id = d.id || (d.data && d.data.id) || d,
            color;
        if (colors[id] instanceof Function) {
          color = colors[id](d);
        } else if (colors[id]) {
          color = colors[id];
        } else {
          if (ids.indexOf(id) < 0) {
            ids.push(id);
          }
          color = pattern[ids.indexOf(id) % pattern.length];
          colors[id] = color;
        }
        return callback instanceof Function ? callback(color, d) : color;
      };
    };
    c3_chart_internal_fn.generateLevelColor = function() {
      var $$ = this,
          config = $$.config,
          colors = config.color_pattern,
          threshold = config.color_threshold,
          asValue = threshold.unit === 'value',
          values = threshold.values && threshold.values.length ? threshold.values : [],
          max = threshold.max || 100;
      return notEmpty(config.color_threshold) ? function(value) {
        var i,
            v,
            color = colors[colors.length - 1];
        for (i = 0; i < values.length; i++) {
          v = asValue ? value : (value * 100 / max);
          if (v < values[i]) {
            color = colors[i];
            break;
          }
        }
        return color;
      } : null;
    };
    c3_chart_internal_fn.getYFormat = function(forArc) {
      var $$ = this,
          formatForY = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.yFormat,
          formatForY2 = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.y2Format;
      return function(v, ratio, id) {
        var format = $$.axis.getId(id) === 'y2' ? formatForY2 : formatForY;
        return format.call($$, v, ratio);
      };
    };
    c3_chart_internal_fn.yFormat = function(v) {
      var $$ = this,
          config = $$.config,
          format = config.axis_y_tick_format ? config.axis_y_tick_format : $$.defaultValueFormat;
      return format(v);
    };
    c3_chart_internal_fn.y2Format = function(v) {
      var $$ = this,
          config = $$.config,
          format = config.axis_y2_tick_format ? config.axis_y2_tick_format : $$.defaultValueFormat;
      return format(v);
    };
    c3_chart_internal_fn.defaultValueFormat = function(v) {
      return isValue(v) ? +v : "";
    };
    c3_chart_internal_fn.defaultArcValueFormat = function(v, ratio) {
      return (ratio * 100).toFixed(1) + '%';
    };
    c3_chart_internal_fn.dataLabelFormat = function(targetId) {
      var $$ = this,
          data_labels = $$.config.data_labels,
          format,
          defaultFormat = function(v) {
            return isValue(v) ? +v : "";
          };
      if (typeof data_labels.format === 'function') {
        format = data_labels.format;
      } else if (typeof data_labels.format === 'object') {
        if (data_labels.format[targetId]) {
          format = data_labels.format[targetId] === true ? defaultFormat : data_labels.format[targetId];
        } else {
          format = function() {
            return '';
          };
        }
      } else {
        format = defaultFormat;
      }
      return format;
    };
    c3_chart_internal_fn.hasCaches = function(ids) {
      for (var i = 0; i < ids.length; i++) {
        if (!(ids[i] in this.cache)) {
          return false;
        }
      }
      return true;
    };
    c3_chart_internal_fn.addCache = function(id, target) {
      this.cache[id] = this.cloneTarget(target);
    };
    c3_chart_internal_fn.getCaches = function(ids) {
      var targets = [],
          i;
      for (i = 0; i < ids.length; i++) {
        if (ids[i] in this.cache) {
          targets.push(this.cloneTarget(this.cache[ids[i]]));
        }
      }
      return targets;
    };
    var CLASS = c3_chart_internal_fn.CLASS = {
      target: 'c3-target',
      chart: 'c3-chart',
      chartLine: 'c3-chart-line',
      chartLines: 'c3-chart-lines',
      chartBar: 'c3-chart-bar',
      chartBars: 'c3-chart-bars',
      chartText: 'c3-chart-text',
      chartTexts: 'c3-chart-texts',
      chartArc: 'c3-chart-arc',
      chartArcs: 'c3-chart-arcs',
      chartArcsTitle: 'c3-chart-arcs-title',
      chartArcsBackground: 'c3-chart-arcs-background',
      chartArcsGaugeUnit: 'c3-chart-arcs-gauge-unit',
      chartArcsGaugeMax: 'c3-chart-arcs-gauge-max',
      chartArcsGaugeMin: 'c3-chart-arcs-gauge-min',
      selectedCircle: 'c3-selected-circle',
      selectedCircles: 'c3-selected-circles',
      eventRect: 'c3-event-rect',
      eventRects: 'c3-event-rects',
      eventRectsSingle: 'c3-event-rects-single',
      eventRectsMultiple: 'c3-event-rects-multiple',
      zoomRect: 'c3-zoom-rect',
      brush: 'c3-brush',
      focused: 'c3-focused',
      defocused: 'c3-defocused',
      region: 'c3-region',
      regions: 'c3-regions',
      title: 'c3-title',
      tooltipContainer: 'c3-tooltip-container',
      tooltip: 'c3-tooltip',
      tooltipName: 'c3-tooltip-name',
      shape: 'c3-shape',
      shapes: 'c3-shapes',
      line: 'c3-line',
      lines: 'c3-lines',
      bar: 'c3-bar',
      bars: 'c3-bars',
      circle: 'c3-circle',
      circles: 'c3-circles',
      arc: 'c3-arc',
      arcs: 'c3-arcs',
      area: 'c3-area',
      areas: 'c3-areas',
      empty: 'c3-empty',
      text: 'c3-text',
      texts: 'c3-texts',
      gaugeValue: 'c3-gauge-value',
      grid: 'c3-grid',
      gridLines: 'c3-grid-lines',
      xgrid: 'c3-xgrid',
      xgrids: 'c3-xgrids',
      xgridLine: 'c3-xgrid-line',
      xgridLines: 'c3-xgrid-lines',
      xgridFocus: 'c3-xgrid-focus',
      ygrid: 'c3-ygrid',
      ygrids: 'c3-ygrids',
      ygridLine: 'c3-ygrid-line',
      ygridLines: 'c3-ygrid-lines',
      axis: 'c3-axis',
      axisX: 'c3-axis-x',
      axisXLabel: 'c3-axis-x-label',
      axisY: 'c3-axis-y',
      axisYLabel: 'c3-axis-y-label',
      axisY2: 'c3-axis-y2',
      axisY2Label: 'c3-axis-y2-label',
      legendBackground: 'c3-legend-background',
      legendItem: 'c3-legend-item',
      legendItemEvent: 'c3-legend-item-event',
      legendItemTile: 'c3-legend-item-tile',
      legendItemHidden: 'c3-legend-item-hidden',
      legendItemFocused: 'c3-legend-item-focused',
      dragarea: 'c3-dragarea',
      EXPANDED: '_expanded_',
      SELECTED: '_selected_',
      INCLUDED: '_included_'
    };
    c3_chart_internal_fn.generateClass = function(prefix, targetId) {
      return " " + prefix + " " + prefix + this.getTargetSelectorSuffix(targetId);
    };
    c3_chart_internal_fn.classText = function(d) {
      return this.generateClass(CLASS.text, d.index);
    };
    c3_chart_internal_fn.classTexts = function(d) {
      return this.generateClass(CLASS.texts, d.id);
    };
    c3_chart_internal_fn.classShape = function(d) {
      return this.generateClass(CLASS.shape, d.index);
    };
    c3_chart_internal_fn.classShapes = function(d) {
      return this.generateClass(CLASS.shapes, d.id);
    };
    c3_chart_internal_fn.classLine = function(d) {
      return this.classShape(d) + this.generateClass(CLASS.line, d.id);
    };
    c3_chart_internal_fn.classLines = function(d) {
      return this.classShapes(d) + this.generateClass(CLASS.lines, d.id);
    };
    c3_chart_internal_fn.classCircle = function(d) {
      return this.classShape(d) + this.generateClass(CLASS.circle, d.index);
    };
    c3_chart_internal_fn.classCircles = function(d) {
      return this.classShapes(d) + this.generateClass(CLASS.circles, d.id);
    };
    c3_chart_internal_fn.classBar = function(d) {
      return this.classShape(d) + this.generateClass(CLASS.bar, d.index);
    };
    c3_chart_internal_fn.classBars = function(d) {
      return this.classShapes(d) + this.generateClass(CLASS.bars, d.id);
    };
    c3_chart_internal_fn.classArc = function(d) {
      return this.classShape(d.data) + this.generateClass(CLASS.arc, d.data.id);
    };
    c3_chart_internal_fn.classArcs = function(d) {
      return this.classShapes(d.data) + this.generateClass(CLASS.arcs, d.data.id);
    };
    c3_chart_internal_fn.classArea = function(d) {
      return this.classShape(d) + this.generateClass(CLASS.area, d.id);
    };
    c3_chart_internal_fn.classAreas = function(d) {
      return this.classShapes(d) + this.generateClass(CLASS.areas, d.id);
    };
    c3_chart_internal_fn.classRegion = function(d, i) {
      return this.generateClass(CLASS.region, i) + ' ' + ('class' in d ? d['class'] : '');
    };
    c3_chart_internal_fn.classEvent = function(d) {
      return this.generateClass(CLASS.eventRect, d.index);
    };
    c3_chart_internal_fn.classTarget = function(id) {
      var $$ = this;
      var additionalClassSuffix = $$.config.data_classes[id],
          additionalClass = '';
      if (additionalClassSuffix) {
        additionalClass = ' ' + CLASS.target + '-' + additionalClassSuffix;
      }
      return $$.generateClass(CLASS.target, id) + additionalClass;
    };
    c3_chart_internal_fn.classFocus = function(d) {
      return this.classFocused(d) + this.classDefocused(d);
    };
    c3_chart_internal_fn.classFocused = function(d) {
      return ' ' + (this.focusedTargetIds.indexOf(d.id) >= 0 ? CLASS.focused : '');
    };
    c3_chart_internal_fn.classDefocused = function(d) {
      return ' ' + (this.defocusedTargetIds.indexOf(d.id) >= 0 ? CLASS.defocused : '');
    };
    c3_chart_internal_fn.classChartText = function(d) {
      return CLASS.chartText + this.classTarget(d.id);
    };
    c3_chart_internal_fn.classChartLine = function(d) {
      return CLASS.chartLine + this.classTarget(d.id);
    };
    c3_chart_internal_fn.classChartBar = function(d) {
      return CLASS.chartBar + this.classTarget(d.id);
    };
    c3_chart_internal_fn.classChartArc = function(d) {
      return CLASS.chartArc + this.classTarget(d.data.id);
    };
    c3_chart_internal_fn.getTargetSelectorSuffix = function(targetId) {
      return targetId || targetId === 0 ? ('-' + targetId).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, '-') : '';
    };
    c3_chart_internal_fn.selectorTarget = function(id, prefix) {
      return (prefix || '') + '.' + CLASS.target + this.getTargetSelectorSuffix(id);
    };
    c3_chart_internal_fn.selectorTargets = function(ids, prefix) {
      var $$ = this;
      ids = ids || [];
      return ids.length ? ids.map(function(id) {
        return $$.selectorTarget(id, prefix);
      }) : null;
    };
    c3_chart_internal_fn.selectorLegend = function(id) {
      return '.' + CLASS.legendItem + this.getTargetSelectorSuffix(id);
    };
    c3_chart_internal_fn.selectorLegends = function(ids) {
      var $$ = this;
      return ids && ids.length ? ids.map(function(id) {
        return $$.selectorLegend(id);
      }) : null;
    };
    var isValue = c3_chart_internal_fn.isValue = function(v) {
      return v || v === 0;
    },
        isFunction = c3_chart_internal_fn.isFunction = function(o) {
          return typeof o === 'function';
        },
        isString = c3_chart_internal_fn.isString = function(o) {
          return typeof o === 'string';
        },
        isUndefined = c3_chart_internal_fn.isUndefined = function(v) {
          return typeof v === 'undefined';
        },
        isDefined = c3_chart_internal_fn.isDefined = function(v) {
          return typeof v !== 'undefined';
        },
        ceil10 = c3_chart_internal_fn.ceil10 = function(v) {
          return Math.ceil(v / 10) * 10;
        },
        asHalfPixel = c3_chart_internal_fn.asHalfPixel = function(n) {
          return Math.ceil(n) + 0.5;
        },
        diffDomain = c3_chart_internal_fn.diffDomain = function(d) {
          return d[1] - d[0];
        },
        isEmpty = c3_chart_internal_fn.isEmpty = function(o) {
          return typeof o === 'undefined' || o === null || (isString(o) && o.length === 0) || (typeof o === 'object' && Object.keys(o).length === 0);
        },
        notEmpty = c3_chart_internal_fn.notEmpty = function(o) {
          return !c3_chart_internal_fn.isEmpty(o);
        },
        getOption = c3_chart_internal_fn.getOption = function(options, key, defaultValue) {
          return isDefined(options[key]) ? options[key] : defaultValue;
        },
        hasValue = c3_chart_internal_fn.hasValue = function(dict, value) {
          var found = false;
          Object.keys(dict).forEach(function(key) {
            if (dict[key] === value) {
              found = true;
            }
          });
          return found;
        },
        getPathBox = c3_chart_internal_fn.getPathBox = function(path) {
          var box = path.getBoundingClientRect(),
              items = [path.pathSegList.getItem(0), path.pathSegList.getItem(1)],
              minX = items[0].x,
              minY = Math.min(items[0].y, items[1].y);
          return {
            x: minX,
            y: minY,
            width: box.width,
            height: box.height
          };
        };
    c3_chart_fn.focus = function(targetIds) {
      var $$ = this.internal,
          candidates;
      targetIds = $$.mapToTargetIds(targetIds);
      candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$))), this.revert();
      this.defocus();
      candidates.classed(CLASS.focused, true).classed(CLASS.defocused, false);
      if ($$.hasArcType()) {
        $$.expandArc(targetIds);
      }
      $$.toggleFocusLegend(targetIds, true);
      $$.focusedTargetIds = targetIds;
      $$.defocusedTargetIds = $$.defocusedTargetIds.filter(function(id) {
        return targetIds.indexOf(id) < 0;
      });
    };
    c3_chart_fn.defocus = function(targetIds) {
      var $$ = this.internal,
          candidates;
      targetIds = $$.mapToTargetIds(targetIds);
      candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$))), candidates.classed(CLASS.focused, false).classed(CLASS.defocused, true);
      if ($$.hasArcType()) {
        $$.unexpandArc(targetIds);
      }
      $$.toggleFocusLegend(targetIds, false);
      $$.focusedTargetIds = $$.focusedTargetIds.filter(function(id) {
        return targetIds.indexOf(id) < 0;
      });
      $$.defocusedTargetIds = targetIds;
    };
    c3_chart_fn.revert = function(targetIds) {
      var $$ = this.internal,
          candidates;
      targetIds = $$.mapToTargetIds(targetIds);
      candidates = $$.svg.selectAll($$.selectorTargets(targetIds));
      candidates.classed(CLASS.focused, false).classed(CLASS.defocused, false);
      if ($$.hasArcType()) {
        $$.unexpandArc(targetIds);
      }
      if ($$.config.legend_show) {
        $$.showLegend(targetIds.filter($$.isLegendToShow.bind($$)));
        $$.legend.selectAll($$.selectorLegends(targetIds)).filter(function() {
          return $$.d3.select(this).classed(CLASS.legendItemFocused);
        }).classed(CLASS.legendItemFocused, false);
      }
      $$.focusedTargetIds = [];
      $$.defocusedTargetIds = [];
    };
    c3_chart_fn.show = function(targetIds, options) {
      var $$ = this.internal,
          targets;
      targetIds = $$.mapToTargetIds(targetIds);
      options = options || {};
      $$.removeHiddenTargetIds(targetIds);
      targets = $$.svg.selectAll($$.selectorTargets(targetIds));
      targets.transition().style('opacity', 1, 'important').call($$.endall, function() {
        targets.style('opacity', null).style('opacity', 1);
      });
      if (options.withLegend) {
        $$.showLegend(targetIds);
      }
      $$.redraw({
        withUpdateOrgXDomain: true,
        withUpdateXDomain: true,
        withLegend: true
      });
    };
    c3_chart_fn.hide = function(targetIds, options) {
      var $$ = this.internal,
          targets;
      targetIds = $$.mapToTargetIds(targetIds);
      options = options || {};
      $$.addHiddenTargetIds(targetIds);
      targets = $$.svg.selectAll($$.selectorTargets(targetIds));
      targets.transition().style('opacity', 0, 'important').call($$.endall, function() {
        targets.style('opacity', null).style('opacity', 0);
      });
      if (options.withLegend) {
        $$.hideLegend(targetIds);
      }
      $$.redraw({
        withUpdateOrgXDomain: true,
        withUpdateXDomain: true,
        withLegend: true
      });
    };
    c3_chart_fn.toggle = function(targetIds, options) {
      var that = this,
          $$ = this.internal;
      $$.mapToTargetIds(targetIds).forEach(function(targetId) {
        $$.isTargetToShow(targetId) ? that.hide(targetId, options) : that.show(targetId, options);
      });
    };
    c3_chart_fn.zoom = function(domain) {
      var $$ = this.internal;
      if (domain) {
        if ($$.isTimeSeries()) {
          domain = domain.map(function(x) {
            return $$.parseDate(x);
          });
        }
        $$.brush.extent(domain);
        $$.redraw({
          withUpdateXDomain: true,
          withY: $$.config.zoom_rescale
        });
        $$.config.zoom_onzoom.call(this, $$.x.orgDomain());
      }
      return $$.brush.extent();
    };
    c3_chart_fn.zoom.enable = function(enabled) {
      var $$ = this.internal;
      $$.config.zoom_enabled = enabled;
      $$.updateAndRedraw();
    };
    c3_chart_fn.unzoom = function() {
      var $$ = this.internal;
      $$.brush.clear().update();
      $$.redraw({withUpdateXDomain: true});
    };
    c3_chart_fn.zoom.max = function(max) {
      var $$ = this.internal,
          config = $$.config,
          d3 = $$.d3;
      if (max === 0 || max) {
        config.zoom_x_max = d3.max([$$.orgXDomain[1], max]);
      } else {
        return config.zoom_x_max;
      }
    };
    c3_chart_fn.zoom.min = function(min) {
      var $$ = this.internal,
          config = $$.config,
          d3 = $$.d3;
      if (min === 0 || min) {
        config.zoom_x_min = d3.min([$$.orgXDomain[0], min]);
      } else {
        return config.zoom_x_min;
      }
    };
    c3_chart_fn.zoom.range = function(range) {
      if (arguments.length) {
        if (isDefined(range.max)) {
          this.domain.max(range.max);
        }
        if (isDefined(range.min)) {
          this.domain.min(range.min);
        }
      } else {
        return {
          max: this.domain.max(),
          min: this.domain.min()
        };
      }
    };
    c3_chart_fn.load = function(args) {
      var $$ = this.internal,
          config = $$.config;
      if (args.xs) {
        $$.addXs(args.xs);
      }
      if ('classes' in args) {
        Object.keys(args.classes).forEach(function(id) {
          config.data_classes[id] = args.classes[id];
        });
      }
      if ('categories' in args && $$.isCategorized()) {
        config.axis_x_categories = args.categories;
      }
      if ('axes' in args) {
        Object.keys(args.axes).forEach(function(id) {
          config.data_axes[id] = args.axes[id];
        });
      }
      if ('colors' in args) {
        Object.keys(args.colors).forEach(function(id) {
          config.data_colors[id] = args.colors[id];
        });
      }
      if ('cacheIds' in args && $$.hasCaches(args.cacheIds)) {
        $$.load($$.getCaches(args.cacheIds), args.done);
        return;
      }
      if ('unload' in args) {
        $$.unload($$.mapToTargetIds((typeof args.unload === 'boolean' && args.unload) ? null : args.unload), function() {
          $$.loadFromArgs(args);
        });
      } else {
        $$.loadFromArgs(args);
      }
    };
    c3_chart_fn.unload = function(args) {
      var $$ = this.internal;
      args = args || {};
      if (args instanceof Array) {
        args = {ids: args};
      } else if (typeof args === 'string') {
        args = {ids: [args]};
      }
      $$.unload($$.mapToTargetIds(args.ids), function() {
        $$.redraw({
          withUpdateOrgXDomain: true,
          withUpdateXDomain: true,
          withLegend: true
        });
        if (args.done) {
          args.done();
        }
      });
    };
    c3_chart_fn.flow = function(args) {
      var $$ = this.internal,
          targets,
          data,
          notfoundIds = [],
          orgDataCount = $$.getMaxDataCount(),
          dataCount,
          domain,
          baseTarget,
          baseValue,
          length = 0,
          tail = 0,
          diff,
          to;
      if (args.json) {
        data = $$.convertJsonToData(args.json, args.keys);
      } else if (args.rows) {
        data = $$.convertRowsToData(args.rows);
      } else if (args.columns) {
        data = $$.convertColumnsToData(args.columns);
      } else {
        return;
      }
      targets = $$.convertDataToTargets(data, true);
      $$.data.targets.forEach(function(t) {
        var found = false,
            i,
            j;
        for (i = 0; i < targets.length; i++) {
          if (t.id === targets[i].id) {
            found = true;
            if (t.values[t.values.length - 1]) {
              tail = t.values[t.values.length - 1].index + 1;
            }
            length = targets[i].values.length;
            for (j = 0; j < length; j++) {
              targets[i].values[j].index = tail + j;
              if (!$$.isTimeSeries()) {
                targets[i].values[j].x = tail + j;
              }
            }
            t.values = t.values.concat(targets[i].values);
            targets.splice(i, 1);
            break;
          }
        }
        if (!found) {
          notfoundIds.push(t.id);
        }
      });
      $$.data.targets.forEach(function(t) {
        var i,
            j;
        for (i = 0; i < notfoundIds.length; i++) {
          if (t.id === notfoundIds[i]) {
            tail = t.values[t.values.length - 1].index + 1;
            for (j = 0; j < length; j++) {
              t.values.push({
                id: t.id,
                index: tail + j,
                x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + j) : tail + j,
                value: null
              });
            }
          }
        }
      });
      if ($$.data.targets.length) {
        targets.forEach(function(t) {
          var i,
              missing = [];
          for (i = $$.data.targets[0].values[0].index; i < tail; i++) {
            missing.push({
              id: t.id,
              index: i,
              x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,
              value: null
            });
          }
          t.values.forEach(function(v) {
            v.index += tail;
            if (!$$.isTimeSeries()) {
              v.x += tail;
            }
          });
          t.values = missing.concat(t.values);
        });
      }
      $$.data.targets = $$.data.targets.concat(targets);
      dataCount = $$.getMaxDataCount();
      baseTarget = $$.data.targets[0];
      baseValue = baseTarget.values[0];
      if (isDefined(args.to)) {
        length = 0;
        to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to;
        baseTarget.values.forEach(function(v) {
          if (v.x < to) {
            length++;
          }
        });
      } else if (isDefined(args.length)) {
        length = args.length;
      }
      if (!orgDataCount) {
        if ($$.isTimeSeries()) {
          if (baseTarget.values.length > 1) {
            diff = baseTarget.values[baseTarget.values.length - 1].x - baseValue.x;
          } else {
            diff = baseValue.x - $$.getXDomain($$.data.targets)[0];
          }
        } else {
          diff = 1;
        }
        domain = [baseValue.x - diff, baseValue.x];
        $$.updateXDomain(null, true, true, false, domain);
      } else if (orgDataCount === 1) {
        if ($$.isTimeSeries()) {
          diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2;
          domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)];
          $$.updateXDomain(null, true, true, false, domain);
        }
      }
      $$.updateTargets($$.data.targets);
      $$.redraw({
        flow: {
          index: baseValue.index,
          length: length,
          duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,
          done: args.done,
          orgDataCount: orgDataCount
        },
        withLegend: true,
        withTransition: orgDataCount > 1,
        withTrimXDomain: false,
        withUpdateXAxis: true
      });
    };
    c3_chart_internal_fn.generateFlow = function(args) {
      var $$ = this,
          config = $$.config,
          d3 = $$.d3;
      return function() {
        var targets = args.targets,
            flow = args.flow,
            drawBar = args.drawBar,
            drawLine = args.drawLine,
            drawArea = args.drawArea,
            cx = args.cx,
            cy = args.cy,
            xv = args.xv,
            xForText = args.xForText,
            yForText = args.yForText,
            duration = args.duration;
        var translateX,
            scaleX = 1,
            transform,
            flowIndex = flow.index,
            flowLength = flow.length,
            flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex),
            flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength),
            orgDomain = $$.x.domain(),
            domain,
            durationForFlow = flow.duration || duration,
            done = flow.done || function() {},
            wait = $$.generateWait();
        var xgrid = $$.xgrid || d3.selectAll([]),
            xgridLines = $$.xgridLines || d3.selectAll([]),
            mainRegion = $$.mainRegion || d3.selectAll([]),
            mainText = $$.mainText || d3.selectAll([]),
            mainBar = $$.mainBar || d3.selectAll([]),
            mainLine = $$.mainLine || d3.selectAll([]),
            mainArea = $$.mainArea || d3.selectAll([]),
            mainCircle = $$.mainCircle || d3.selectAll([]);
        $$.flowing = true;
        $$.data.targets.forEach(function(d) {
          d.values.splice(0, flowLength);
        });
        domain = $$.updateXDomain(targets, true, true);
        if ($$.updateXGrid) {
          $$.updateXGrid(true);
        }
        if (!flow.orgDataCount) {
          if ($$.data.targets[0].values.length !== 1) {
            translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
          } else {
            if ($$.isTimeSeries()) {
              flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0);
              flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1);
              translateX = $$.x(flowStart.x) - $$.x(flowEnd.x);
            } else {
              translateX = diffDomain(domain) / 2;
            }
          }
        } else if (flow.orgDataCount === 1 || flowStart.x === flowEnd.x) {
          translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
        } else {
          if ($$.isTimeSeries()) {
            translateX = ($$.x(orgDomain[0]) - $$.x(domain[0]));
          } else {
            translateX = ($$.x(flowStart.x) - $$.x(flowEnd.x));
          }
        }
        scaleX = (diffDomain(orgDomain) / diffDomain(domain));
        transform = 'translate(' + translateX + ',0) scale(' + scaleX + ',1)';
        $$.hideXGridFocus();
        d3.transition().ease('linear').duration(durationForFlow).each(function() {
          wait.add($$.axes.x.transition().call($$.xAxis));
          wait.add(mainBar.transition().attr('transform', transform));
          wait.add(mainLine.transition().attr('transform', transform));
          wait.add(mainArea.transition().attr('transform', transform));
          wait.add(mainCircle.transition().attr('transform', transform));
          wait.add(mainText.transition().attr('transform', transform));
          wait.add(mainRegion.filter($$.isRegionOnX).transition().attr('transform', transform));
          wait.add(xgrid.transition().attr('transform', transform));
          wait.add(xgridLines.transition().attr('transform', transform));
        }).call(wait, function() {
          var i,
              shapes = [],
              texts = [],
              eventRects = [];
          if (flowLength) {
            for (i = 0; i < flowLength; i++) {
              shapes.push('.' + CLASS.shape + '-' + (flowIndex + i));
              texts.push('.' + CLASS.text + '-' + (flowIndex + i));
              eventRects.push('.' + CLASS.eventRect + '-' + (flowIndex + i));
            }
            $$.svg.selectAll('.' + CLASS.shapes).selectAll(shapes).remove();
            $$.svg.selectAll('.' + CLASS.texts).selectAll(texts).remove();
            $$.svg.selectAll('.' + CLASS.eventRects).selectAll(eventRects).remove();
            $$.svg.select('.' + CLASS.xgrid).remove();
          }
          xgrid.attr('transform', null).attr($$.xgridAttr);
          xgridLines.attr('transform', null);
          xgridLines.select('line').attr("x1", config.axis_rotated ? 0 : xv).attr("x2", config.axis_rotated ? $$.width : xv);
          xgridLines.select('text').attr("x", config.axis_rotated ? $$.width : 0).attr("y", xv);
          mainBar.attr('transform', null).attr("d", drawBar);
          mainLine.attr('transform', null).attr("d", drawLine);
          mainArea.attr('transform', null).attr("d", drawArea);
          mainCircle.attr('transform', null).attr("cx", cx).attr("cy", cy);
          mainText.attr('transform', null).attr('x', xForText).attr('y', yForText).style('fill-opacity', $$.opacityForText.bind($$));
          mainRegion.attr('transform', null);
          mainRegion.select('rect').filter($$.isRegionOnX).attr("x", $$.regionX.bind($$)).attr("width", $$.regionWidth.bind($$));
          if (config.interaction_enabled) {
            $$.redrawEventRect();
          }
          done();
          $$.flowing = false;
        });
      };
    };
    c3_chart_fn.selected = function(targetId) {
      var $$ = this.internal,
          d3 = $$.d3;
      return d3.merge($$.main.selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(targetId)).selectAll('.' + CLASS.shape).filter(function() {
        return d3.select(this).classed(CLASS.SELECTED);
      }).map(function(d) {
        return d.map(function(d) {
          var data = d.__data__;
          return data.data ? data.data : data;
        });
      }));
    };
    c3_chart_fn.select = function(ids, indices, resetOther) {
      var $$ = this.internal,
          d3 = $$.d3,
          config = $$.config;
      if (!config.data_selection_enabled) {
        return;
      }
      $$.main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).each(function(d, i) {
        var shape = d3.select(this),
            id = d.data ? d.data.id : d.id,
            toggle = $$.getToggle(this, d).bind($$),
            isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
            isTargetIndex = !indices || indices.indexOf(i) >= 0,
            isSelected = shape.classed(CLASS.SELECTED);
        if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {
          return;
        }
        if (isTargetId && isTargetIndex) {
          if (config.data_selection_isselectable(d) && !isSelected) {
            toggle(true, shape.classed(CLASS.SELECTED, true), d, i);
          }
        } else if (isDefined(resetOther) && resetOther) {
          if (isSelected) {
            toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
          }
        }
      });
    };
    c3_chart_fn.unselect = function(ids, indices) {
      var $$ = this.internal,
          d3 = $$.d3,
          config = $$.config;
      if (!config.data_selection_enabled) {
        return;
      }
      $$.main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).each(function(d, i) {
        var shape = d3.select(this),
            id = d.data ? d.data.id : d.id,
            toggle = $$.getToggle(this, d).bind($$),
            isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
            isTargetIndex = !indices || indices.indexOf(i) >= 0,
            isSelected = shape.classed(CLASS.SELECTED);
        if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {
          return;
        }
        if (isTargetId && isTargetIndex) {
          if (config.data_selection_isselectable(d)) {
            if (isSelected) {
              toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
            }
          }
        }
      });
    };
    c3_chart_fn.transform = function(type, targetIds) {
      var $$ = this.internal,
          options = ['pie', 'donut'].indexOf(type) >= 0 ? {withTransform: true} : null;
      $$.transformTo(targetIds, type, options);
    };
    c3_chart_internal_fn.transformTo = function(targetIds, type, optionsForRedraw) {
      var $$ = this,
          withTransitionForAxis = !$$.hasArcType(),
          options = optionsForRedraw || {withTransitionForAxis: withTransitionForAxis};
      options.withTransitionForTransform = false;
      $$.transiting = false;
      $$.setTargetType(targetIds, type);
      $$.updateTargets($$.data.targets);
      $$.updateAndRedraw(options);
    };
    c3_chart_fn.groups = function(groups) {
      var $$ = this.internal,
          config = $$.config;
      if (isUndefined(groups)) {
        return config.data_groups;
      }
      config.data_groups = groups;
      $$.redraw();
      return config.data_groups;
    };
    c3_chart_fn.xgrids = function(grids) {
      var $$ = this.internal,
          config = $$.config;
      if (!grids) {
        return config.grid_x_lines;
      }
      config.grid_x_lines = grids;
      $$.redrawWithoutRescale();
      return config.grid_x_lines;
    };
    c3_chart_fn.xgrids.add = function(grids) {
      var $$ = this.internal;
      return this.xgrids($$.config.grid_x_lines.concat(grids ? grids : []));
    };
    c3_chart_fn.xgrids.remove = function(params) {
      var $$ = this.internal;
      $$.removeGridLines(params, true);
    };
    c3_chart_fn.ygrids = function(grids) {
      var $$ = this.internal,
          config = $$.config;
      if (!grids) {
        return config.grid_y_lines;
      }
      config.grid_y_lines = grids;
      $$.redrawWithoutRescale();
      return config.grid_y_lines;
    };
    c3_chart_fn.ygrids.add = function(grids) {
      var $$ = this.internal;
      return this.ygrids($$.config.grid_y_lines.concat(grids ? grids : []));
    };
    c3_chart_fn.ygrids.remove = function(params) {
      var $$ = this.internal;
      $$.removeGridLines(params, false);
    };
    c3_chart_fn.regions = function(regions) {
      var $$ = this.internal,
          config = $$.config;
      if (!regions) {
        return config.regions;
      }
      config.regions = regions;
      $$.redrawWithoutRescale();
      return config.regions;
    };
    c3_chart_fn.regions.add = function(regions) {
      var $$ = this.internal,
          config = $$.config;
      if (!regions) {
        return config.regions;
      }
      config.regions = config.regions.concat(regions);
      $$.redrawWithoutRescale();
      return config.regions;
    };
    c3_chart_fn.regions.remove = function(options) {
      var $$ = this.internal,
          config = $$.config,
          duration,
          classes,
          regions;
      options = options || {};
      duration = $$.getOption(options, "duration", config.transition_duration);
      classes = $$.getOption(options, "classes", [CLASS.region]);
      regions = $$.main.select('.' + CLASS.regions).selectAll(classes.map(function(c) {
        return '.' + c;
      }));
      (duration ? regions.transition().duration(duration) : regions).style('opacity', 0).remove();
      config.regions = config.regions.filter(function(region) {
        var found = false;
        if (!region['class']) {
          return true;
        }
        region['class'].split(' ').forEach(function(c) {
          if (classes.indexOf(c) >= 0) {
            found = true;
          }
        });
        return !found;
      });
      return config.regions;
    };
    c3_chart_fn.data = function(targetIds) {
      var targets = this.internal.data.targets;
      return typeof targetIds === 'undefined' ? targets : targets.filter(function(t) {
        return [].concat(targetIds).indexOf(t.id) >= 0;
      });
    };
    c3_chart_fn.data.shown = function(targetIds) {
      return this.internal.filterTargetsToShow(this.data(targetIds));
    };
    c3_chart_fn.data.values = function(targetId) {
      var targets,
          values = null;
      if (targetId) {
        targets = this.data(targetId);
        values = targets[0] ? targets[0].values.map(function(d) {
          return d.value;
        }) : null;
      }
      return values;
    };
    c3_chart_fn.data.names = function(names) {
      this.internal.clearLegendItemTextBoxCache();
      return this.internal.updateDataAttributes('names', names);
    };
    c3_chart_fn.data.colors = function(colors) {
      return this.internal.updateDataAttributes('colors', colors);
    };
    c3_chart_fn.data.axes = function(axes) {
      return this.internal.updateDataAttributes('axes', axes);
    };
    c3_chart_fn.category = function(i, category) {
      var $$ = this.internal,
          config = $$.config;
      if (arguments.length > 1) {
        config.axis_x_categories[i] = category;
        $$.redraw();
      }
      return config.axis_x_categories[i];
    };
    c3_chart_fn.categories = function(categories) {
      var $$ = this.internal,
          config = $$.config;
      if (!arguments.length) {
        return config.axis_x_categories;
      }
      config.axis_x_categories = categories;
      $$.redraw();
      return config.axis_x_categories;
    };
    c3_chart_fn.color = function(id) {
      var $$ = this.internal;
      return $$.color(id);
    };
    c3_chart_fn.x = function(x) {
      var $$ = this.internal;
      if (arguments.length) {
        $$.updateTargetX($$.data.targets, x);
        $$.redraw({
          withUpdateOrgXDomain: true,
          withUpdateXDomain: true
        });
      }
      return $$.data.xs;
    };
    c3_chart_fn.xs = function(xs) {
      var $$ = this.internal;
      if (arguments.length) {
        $$.updateTargetXs($$.data.targets, xs);
        $$.redraw({
          withUpdateOrgXDomain: true,
          withUpdateXDomain: true
        });
      }
      return $$.data.xs;
    };
    c3_chart_fn.axis = function() {};
    c3_chart_fn.axis.labels = function(labels) {
      var $$ = this.internal;
      if (arguments.length) {
        Object.keys(labels).forEach(function(axisId) {
          $$.axis.setLabelText(axisId, labels[axisId]);
        });
        $$.axis.updateLabels();
      }
    };
    c3_chart_fn.axis.max = function(max) {
      var $$ = this.internal,
          config = $$.config;
      if (arguments.length) {
        if (typeof max === 'object') {
          if (isValue(max.x)) {
            config.axis_x_max = max.x;
          }
          if (isValue(max.y)) {
            config.axis_y_max = max.y;
          }
          if (isValue(max.y2)) {
            config.axis_y2_max = max.y2;
          }
        } else {
          config.axis_y_max = config.axis_y2_max = max;
        }
        $$.redraw({
          withUpdateOrgXDomain: true,
          withUpdateXDomain: true
        });
      } else {
        return {
          x: config.axis_x_max,
          y: config.axis_y_max,
          y2: config.axis_y2_max
        };
      }
    };
    c3_chart_fn.axis.min = function(min) {
      var $$ = this.internal,
          config = $$.config;
      if (arguments.length) {
        if (typeof min === 'object') {
          if (isValue(min.x)) {
            config.axis_x_min = min.x;
          }
          if (isValue(min.y)) {
            config.axis_y_min = min.y;
          }
          if (isValue(min.y2)) {
            config.axis_y2_min = min.y2;
          }
        } else {
          config.axis_y_min = config.axis_y2_min = min;
        }
        $$.redraw({
          withUpdateOrgXDomain: true,
          withUpdateXDomain: true
        });
      } else {
        return {
          x: config.axis_x_min,
          y: config.axis_y_min,
          y2: config.axis_y2_min
        };
      }
    };
    c3_chart_fn.axis.range = function(range) {
      if (arguments.length) {
        if (isDefined(range.max)) {
          this.axis.max(range.max);
        }
        if (isDefined(range.min)) {
          this.axis.min(range.min);
        }
      } else {
        return {
          max: this.axis.max(),
          min: this.axis.min()
        };
      }
    };
    c3_chart_fn.legend = function() {};
    c3_chart_fn.legend.show = function(targetIds) {
      var $$ = this.internal;
      $$.showLegend($$.mapToTargetIds(targetIds));
      $$.updateAndRedraw({withLegend: true});
    };
    c3_chart_fn.legend.hide = function(targetIds) {
      var $$ = this.internal;
      $$.hideLegend($$.mapToTargetIds(targetIds));
      $$.updateAndRedraw({withLegend: true});
    };
    c3_chart_fn.resize = function(size) {
      var $$ = this.internal,
          config = $$.config;
      config.size_width = size ? size.width : null;
      config.size_height = size ? size.height : null;
      this.flush();
    };
    c3_chart_fn.flush = function() {
      var $$ = this.internal;
      $$.updateAndRedraw({
        withLegend: true,
        withTransition: false,
        withTransitionForTransform: false
      });
    };
    c3_chart_fn.destroy = function() {
      var $$ = this.internal;
      window.clearInterval($$.intervalForObserveInserted);
      if ($$.resizeTimeout !== undefined) {
        window.clearTimeout($$.resizeTimeout);
      }
      if (window.detachEvent) {
        window.detachEvent('onresize', $$.resizeFunction);
      } else if (window.removeEventListener) {
        window.removeEventListener('resize', $$.resizeFunction);
      } else {
        var wrapper = window.onresize;
        if (wrapper && wrapper.add && wrapper.remove) {
          wrapper.remove($$.resizeFunction);
        }
      }
      $$.selectChart.classed('c3', false).html("");
      Object.keys($$).forEach(function(key) {
        $$[key] = null;
      });
      return null;
    };
    c3_chart_fn.tooltip = function() {};
    c3_chart_fn.tooltip.show = function(args) {
      var $$ = this.internal,
          index,
          mouse;
      if (args.mouse) {
        mouse = args.mouse;
      }
      if (args.data) {
        if ($$.isMultipleX()) {
          mouse = [$$.x(args.data.x), $$.getYScale(args.data.id)(args.data.value)];
          index = null;
        } else {
          index = isValue(args.data.index) ? args.data.index : $$.getIndexByX(args.data.x);
        }
      } else if (typeof args.x !== 'undefined') {
        index = $$.getIndexByX(args.x);
      } else if (typeof args.index !== 'undefined') {
        index = args.index;
      }
      $$.dispatchEvent('mouseover', index, mouse);
      $$.dispatchEvent('mousemove', index, mouse);
      $$.config.tooltip_onshow.call($$, args.data);
    };
    c3_chart_fn.tooltip.hide = function() {
      this.internal.dispatchEvent('mouseout', 0);
      this.internal.config.tooltip_onhide.call(this);
    };
    var tickTextCharSize;
    function c3_axis(d3, params) {
      var scale = d3.scale.linear(),
          orient = "bottom",
          innerTickSize = 6,
          outerTickSize,
          tickPadding = 3,
          tickValues = null,
          tickFormat,
          tickArguments;
      var tickOffset = 0,
          tickCulling = true,
          tickCentered;
      params = params || {};
      outerTickSize = params.withOuterTick ? 6 : 0;
      function axisX(selection, x) {
        selection.attr("transform", function(d) {
          return "translate(" + Math.ceil(x(d) + tickOffset) + ", 0)";
        });
      }
      function axisY(selection, y) {
        selection.attr("transform", function(d) {
          return "translate(0," + Math.ceil(y(d)) + ")";
        });
      }
      function scaleExtent(domain) {
        var start = domain[0],
            stop = domain[domain.length - 1];
        return start < stop ? [start, stop] : [stop, start];
      }
      function generateTicks(scale) {
        var i,
            domain,
            ticks = [];
        if (scale.ticks) {
          return scale.ticks.apply(scale, tickArguments);
        }
        domain = scale.domain();
        for (i = Math.ceil(domain[0]); i < domain[1]; i++) {
          ticks.push(i);
        }
        if (ticks.length > 0 && ticks[0] > 0) {
          ticks.unshift(ticks[0] - (ticks[1] - ticks[0]));
        }
        return ticks;
      }
      function copyScale() {
        var newScale = scale.copy(),
            domain;
        if (params.isCategory) {
          domain = scale.domain();
          newScale.domain([domain[0], domain[1] - 1]);
        }
        return newScale;
      }
      function textFormatted(v) {
        var formatted = tickFormat ? tickFormat(v) : v;
        return typeof formatted !== 'undefined' ? formatted : '';
      }
      function getSizeFor1Char(tick) {
        if (tickTextCharSize) {
          return tickTextCharSize;
        }
        var size = {
          h: 11.5,
          w: 5.5
        };
        tick.select('text').text(textFormatted).each(function(d) {
          var box = this.getBoundingClientRect(),
              text = textFormatted(d),
              h = box.height,
              w = text ? (box.width / text.length) : undefined;
          if (h && w) {
            size.h = h;
            size.w = w;
          }
        }).text('');
        tickTextCharSize = size;
        return size;
      }
      function transitionise(selection) {
        return params.withoutTransition ? selection : d3.transition(selection);
      }
      function axis(g) {
        g.each(function() {
          var g = axis.g = d3.select(this);
          var scale0 = this.__chart__ || scale,
              scale1 = this.__chart__ = copyScale();
          var ticks = tickValues ? tickValues : generateTicks(scale1),
              tick = g.selectAll(".tick").data(ticks, scale1),
              tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", 1e-6),
              tickExit = tick.exit().remove(),
              tickUpdate = transitionise(tick).style("opacity", 1),
              tickTransform,
              tickX,
              tickY;
          var range = scale.rangeExtent ? scale.rangeExtent() : scaleExtent(scale.range()),
              path = g.selectAll(".domain").data([0]),
              pathUpdate = (path.enter().append("path").attr("class", "domain"), transitionise(path));
          tickEnter.append("line");
          tickEnter.append("text");
          var lineEnter = tickEnter.select("line"),
              lineUpdate = tickUpdate.select("line"),
              textEnter = tickEnter.select("text"),
              textUpdate = tickUpdate.select("text");
          if (params.isCategory) {
            tickOffset = Math.ceil((scale1(1) - scale1(0)) / 2);
            tickX = tickCentered ? 0 : tickOffset;
            tickY = tickCentered ? tickOffset : 0;
          } else {
            tickOffset = tickX = 0;
          }
          var text,
              tspan,
              sizeFor1Char = getSizeFor1Char(g.select('.tick')),
              counts = [];
          var tickLength = Math.max(innerTickSize, 0) + tickPadding,
              isVertical = orient === 'left' || orient === 'right';
          function splitTickText(d, maxWidth) {
            var tickText = textFormatted(d),
                subtext,
                spaceIndex,
                textWidth,
                splitted = [];
            if (Object.prototype.toString.call(tickText) === "[object Array]") {
              return tickText;
            }
            if (!maxWidth || maxWidth <= 0) {
              maxWidth = isVertical ? 95 : params.isCategory ? (Math.ceil(scale1(ticks[1]) - scale1(ticks[0])) - 12) : 110;
            }
            function split(splitted, text) {
              spaceIndex = undefined;
              for (var i = 1; i < text.length; i++) {
                if (text.charAt(i) === ' ') {
                  spaceIndex = i;
                }
                subtext = text.substr(0, i + 1);
                textWidth = sizeFor1Char.w * subtext.length;
                if (maxWidth < textWidth) {
                  return split(splitted.concat(text.substr(0, spaceIndex ? spaceIndex : i)), text.slice(spaceIndex ? spaceIndex + 1 : i));
                }
              }
              return splitted.concat(text);
            }
            return split(splitted, tickText + "");
          }
          function tspanDy(d, i) {
            var dy = sizeFor1Char.h;
            if (i === 0) {
              if (orient === 'left' || orient === 'right') {
                dy = -((counts[d.index] - 1) * (sizeFor1Char.h / 2) - 3);
              } else {
                dy = ".71em";
              }
            }
            return dy;
          }
          function tickSize(d) {
            var tickPosition = scale(d) + (tickCentered ? 0 : tickOffset);
            return range[0] < tickPosition && tickPosition < range[1] ? innerTickSize : 0;
          }
          text = tick.select("text");
          tspan = text.selectAll('tspan').data(function(d, i) {
            var splitted = params.tickMultiline ? splitTickText(d, params.tickWidth) : [].concat(textFormatted(d));
            counts[i] = splitted.length;
            return splitted.map(function(s) {
              return {
                index: i,
                splitted: s
              };
            });
          });
          tspan.enter().append('tspan');
          tspan.exit().remove();
          tspan.text(function(d) {
            return d.splitted;
          });
          var rotate = params.tickTextRotate;
          function textAnchorForText(rotate) {
            if (!rotate) {
              return 'middle';
            }
            return rotate > 0 ? "start" : "end";
          }
          function textTransform(rotate) {
            if (!rotate) {
              return '';
            }
            return "rotate(" + rotate + ")";
          }
          function dxForText(rotate) {
            if (!rotate) {
              return 0;
            }
            return 8 * Math.sin(Math.PI * (rotate / 180));
          }
          function yForText(rotate) {
            if (!rotate) {
              return tickLength;
            }
            return 11.5 - 2.5 * (rotate / 15) * (rotate > 0 ? 1 : -1);
          }
          switch (orient) {
            case "bottom":
              {
                tickTransform = axisX;
                lineEnter.attr("y2", innerTickSize);
                textEnter.attr("y", tickLength);
                lineUpdate.attr("x1", tickX).attr("x2", tickX).attr("y2", tickSize);
                textUpdate.attr("x", 0).attr("y", yForText(rotate)).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate));
                tspan.attr('x', 0).attr("dy", tspanDy).attr('dx', dxForText(rotate));
                pathUpdate.attr("d", "M" + range[0] + "," + outerTickSize + "V0H" + range[1] + "V" + outerTickSize);
                break;
              }
            case "top":
              {
                tickTransform = axisX;
                lineEnter.attr("y2", -innerTickSize);
                textEnter.attr("y", -tickLength);
                lineUpdate.attr("x2", 0).attr("y2", -innerTickSize);
                textUpdate.attr("x", 0).attr("y", -tickLength);
                text.style("text-anchor", "middle");
                tspan.attr('x', 0).attr("dy", "0em");
                pathUpdate.attr("d", "M" + range[0] + "," + -outerTickSize + "V0H" + range[1] + "V" + -outerTickSize);
                break;
              }
            case "left":
              {
                tickTransform = axisY;
                lineEnter.attr("x2", -innerTickSize);
                textEnter.attr("x", -tickLength);
                lineUpdate.attr("x2", -innerTickSize).attr("y1", tickY).attr("y2", tickY);
                textUpdate.attr("x", -tickLength).attr("y", tickOffset);
                text.style("text-anchor", "end");
                tspan.attr('x', -tickLength).attr("dy", tspanDy);
                pathUpdate.attr("d", "M" + -outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + -outerTickSize);
                break;
              }
            case "right":
              {
                tickTransform = axisY;
                lineEnter.attr("x2", innerTickSize);
                textEnter.attr("x", tickLength);
                lineUpdate.attr("x2", innerTickSize).attr("y2", 0);
                textUpdate.attr("x", tickLength).attr("y", 0);
                text.style("text-anchor", "start");
                tspan.attr('x', tickLength).attr("dy", tspanDy);
                pathUpdate.attr("d", "M" + outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + outerTickSize);
                break;
              }
          }
          if (scale1.rangeBand) {
            var x = scale1,
                dx = x.rangeBand() / 2;
            scale0 = scale1 = function(d) {
              return x(d) + dx;
            };
          } else if (scale0.rangeBand) {
            scale0 = scale1;
          } else {
            tickExit.call(tickTransform, scale1);
          }
          tickEnter.call(tickTransform, scale0);
          tickUpdate.call(tickTransform, scale1);
        });
      }
      axis.scale = function(x) {
        if (!arguments.length) {
          return scale;
        }
        scale = x;
        return axis;
      };
      axis.orient = function(x) {
        if (!arguments.length) {
          return orient;
        }
        orient = x in {
          top: 1,
          right: 1,
          bottom: 1,
          left: 1
        } ? x + "" : "bottom";
        return axis;
      };
      axis.tickFormat = function(format) {
        if (!arguments.length) {
          return tickFormat;
        }
        tickFormat = format;
        return axis;
      };
      axis.tickCentered = function(isCentered) {
        if (!arguments.length) {
          return tickCentered;
        }
        tickCentered = isCentered;
        return axis;
      };
      axis.tickOffset = function() {
        return tickOffset;
      };
      axis.tickInterval = function() {
        var interval,
            length;
        if (params.isCategory) {
          interval = tickOffset * 2;
        } else {
          length = axis.g.select('path.domain').node().getTotalLength() - outerTickSize * 2;
          interval = length / axis.g.selectAll('line').size();
        }
        return interval === Infinity ? 0 : interval;
      };
      axis.ticks = function() {
        if (!arguments.length) {
          return tickArguments;
        }
        tickArguments = arguments;
        return axis;
      };
      axis.tickCulling = function(culling) {
        if (!arguments.length) {
          return tickCulling;
        }
        tickCulling = culling;
        return axis;
      };
      axis.tickValues = function(x) {
        if (typeof x === 'function') {
          tickValues = function() {
            return x(scale.domain());
          };
        } else {
          if (!arguments.length) {
            return tickValues;
          }
          tickValues = x;
        }
        return axis;
      };
      return axis;
    }
    c3_chart_internal_fn.isSafari = function() {
      var ua = window.navigator.userAgent;
      return ua.indexOf('Safari') >= 0 && ua.indexOf('Chrome') < 0;
    };
    c3_chart_internal_fn.isChrome = function() {
      var ua = window.navigator.userAgent;
      return ua.indexOf('Chrome') >= 0;
    };
    if (!Function.prototype.bind) {
      Function.prototype.bind = function(oThis) {
        if (typeof this !== 'function') {
          throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }
        var aArgs = Array.prototype.slice.call(arguments, 1),
            fToBind = this,
            fNOP = function() {},
            fBound = function() {
              return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
            };
        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        return fBound;
      };
    }
    if (typeof define === 'function' && define.amd) {
      define("c3", ["d3"], function() {
        return c3;
      });
    } else if ('undefined' !== typeof exports && 'undefined' !== typeof module) {
      module.exports = c3;
    } else {
      window.c3 = c3;
    }
  })(window);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3c", ["3a"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('3a');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(factory) {
    if (typeof module !== "undefined" && typeof exports == "object") {
      if (typeof window != "undefined") {
        module.exports = factory();
      } else {
        module.exports = factory;
      }
    } else {
      window.Modal = factory();
    }
  })(function() {
    var Modal = function(element, options) {
      options = options || {};
      this.isIE = (new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})").exec(navigator.userAgent) != null) ? parseFloat(RegExp.$1) : false;
      this.opened = false;
      this.modal = typeof element === 'object' ? element : document.querySelector(element);
      this.options = {};
      this.options.backdrop = options.backdrop === 'false' ? false : true;
      this.options.keyboard = options.keyboard === 'false' ? false : true;
      this.options.content = options.content;
      this.duration = options.duration || 300;
      this.options.duration = (this.isIE && this.isIE < 10) ? 0 : this.duration;
      this.scrollbarWidth = 0;
      this.dialog = this.modal.querySelector('.modal-dialog');
      this.timer = 0;
      this.init();
    };
    var getWindowWidth = function() {
      var htmlRect = document.documentElement.getBoundingClientRect(),
          fullWindowWidth = window.innerWidth || (htmlRect.right - Math.abs(htmlRect.left));
      return fullWindowWidth;
    };
    Modal.prototype = {
      init: function() {
        this.actions();
        this.trigger();
        if (this.options.content && this.options.content !== undefined) {
          this.content(this.options.content);
        }
      },
      actions: function() {
        var self = this;
        this.open = function() {
          this._open();
        }, this.close = function() {
          this._close();
        }, this._open = function() {
          if (this.options.backdrop) {
            this.createOverlay();
          } else {
            this.overlay = null;
          }
          if (this.overlay) {
            setTimeout(function() {
              self.addClass(self.overlay, 'in');
            }, 0);
          }
          clearTimeout(self.modal.getAttribute('data-timer'));
          this.timer = setTimeout(function() {
            self.modal.style.display = 'block';
            self.opened = true;
            self.checkScrollbar();
            self.adjustDialog();
            self.setScrollbar();
            self.resize();
            self.dismiss();
            self.keydown();
            self.addClass(document.body, 'modal-open');
            self.addClass(self.modal, 'in');
            self.modal.setAttribute('aria-hidden', false);
          }, self.options.duration / 2);
          this.modal.setAttribute('data-timer', self.timer);
        }, this._close = function() {
          if (this.overlay) {
            this.removeClass(this.overlay, 'in');
          }
          this.removeClass(this.modal, 'in');
          this.modal.setAttribute('aria-hidden', true);
          clearTimeout(self.modal.getAttribute('data-timer'));
          this.timer = setTimeout(function() {
            self.opened = false;
            self.removeClass(document.body, 'modal-open');
            self.resize();
            self.resetAdjustments();
            self.resetScrollbar();
            self.dismiss();
            self.keydown();
            self.modal.style.display = '';
          }, self.options.duration / 2);
          this.modal.setAttribute('data-timer', self.timer);
          setTimeout(function() {
            if (!document.querySelector('.modal.in')) {
              self.removeOverlay();
            }
          }, self.options.duration);
        }, this.content = function(content) {
          return this.modal.querySelector('.modal-content').innerHTML = content;
        }, this.createOverlay = function() {
          var backdrop = document.createElement('div'),
              overlay = document.querySelector('.modal-backdrop');
          backdrop.setAttribute('class', 'modal-backdrop fade');
          if (overlay) {
            this.overlay = overlay;
          } else {
            this.overlay = backdrop;
            document.body.appendChild(backdrop);
          }
        }, this.removeOverlay = function() {
          var overlay = document.querySelector('.modal-backdrop');
          if (overlay !== null && overlay !== undefined) {
            document.body.removeChild(overlay);
          }
        }, this.keydown = function() {
          function keyHandler(e) {
            if (self.options.keyboard && e.which == 27) {
              self.close();
            }
          }
          if (this.opened) {
            document.addEventListener('keydown', keyHandler, false);
          } else {
            document.removeEventListener('keydown', keyHandler, false);
          }
        }, this.trigger = function() {
          var triggers = document.querySelectorAll('[data-toggle="modal"]'),
              tgl = triggers.length,
              i = 0;
          for (i; i < tgl; i++) {
            triggers[i].addEventListener('click', function(e) {
              var b = e.target,
                  s = b.getAttribute('data-target') && b.getAttribute('data-target').replace('#', '') || b.getAttribute('href') && b.getAttribute('href').replace('#', '');
              if (document.getElementById(s) === self.modal) {
                self.open();
              }
            });
          }
        }, this._resize = function() {
          var overlay = this.overlay || document.querySelector('.modal-backdrop'),
              dim = {
                w: document.documentElement.clientWidth + 'px',
                h: document.documentElement.clientHeight + 'px'
              };
          if (overlay !== null && /in/.test(overlay.className)) {
            overlay.style.height = dim.h;
            overlay.style.width = dim.w;
          }
        }, this.oneResize = function() {
          function oneResize() {
            self._resize();
            self.handleUpdate();
            window.removeEventListener('resize', oneResize, false);
          }
          window.addEventListener('resize', oneResize, false);
        }, this.resize = function() {
          function resizeHandler() {
            self._resize();
            self.handleUpdate();
            console.log('offresize');
          }
          if (this.opened) {
            window.addEventListener('resize', this.oneResize, false);
          } else {
            window.removeEventListener('resize', this.oneResize, false);
          }
        }, this.dismiss = function() {
          function dismissHandler(e) {
            if (e.target.parentNode.getAttribute('data-dismiss') === 'modal' || e.target.getAttribute('data-dismiss') === 'modal' || e.target === self.modal) {
              e.preventDefault();
              self.close();
            }
          }
          if (this.opened) {
            this.modal.addEventListener('click', dismissHandler, false);
          } else {
            this.modal.removeEventListener('click', dismissHandler, false);
          }
        }, this.handleUpdate = function() {
          this.adjustDialog();
        }, this.adjustDialog = function() {
          this.modal.style.paddingLeft = !this.bodyIsOverflowing && this.modalIsOverflowing ? this.scrollbarWidth + 'px' : '';
          this.modal.style.paddingRight = this.bodyIsOverflowing && !this.modalIsOverflowing ? this.scrollbarWidth + 'px' : '';
        }, this.resetAdjustments = function() {
          this.modal.style.paddingLeft = '';
          this.modal.style.paddingRight = '';
        }, this.checkScrollbar = function() {
          this.bodyIsOverflowing = document.body.clientWidth < getWindowWidth();
          this.modalIsOverflowing = this.modal.scrollHeight > document.documentElement.clientHeight;
          this.scrollbarWidth = this.measureScrollbar();
        }, this.setScrollbar = function() {
          var bodyStyle = window.getComputedStyle(document.body),
              bodyPad = parseInt((bodyStyle.paddingRight), 10);
          if (this.bodyIsOverflowing) {
            document.body.style.paddingRight = (bodyPad + this.scrollbarWidth) + 'px';
          }
        }, this.resetScrollbar = function() {
          document.body.style.paddingRight = '';
        }, this.measureScrollbar = function() {
          var scrollDiv = document.createElement('div');
          scrollDiv.className = 'modal-scrollbar-measure';
          document.body.appendChild(scrollDiv);
          var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
          document.body.removeChild(scrollDiv);
          return scrollbarWidth;
        }, this.addClass = function(el, c) {
          if (el.classList) {
            el.classList.add(c);
          } else {
            el.className += ' ' + c;
          }
        }, this.removeClass = function(el, c) {
          if (el.classList) {
            el.classList.remove(c);
          } else {
            el.className = el.className.replace(c, '').replace(/^\s+|\s+$/g, '');
          }
        };
      }
    };
    var Modals = document.querySelectorAll('.modal'),
        mdl = Modals.length,
        i = 0;
    for (i; i < mdl; i++) {
      var modal = Modals[i],
          options = {};
      options.keyboard = modal.getAttribute('data-keyboard');
      options.backdrop = modal.getAttribute('data-backdrop');
      options.duration = modal.getAttribute('data-duration');
      new Modal(modal, options);
    }
    return Modal;
  });
  global.define = __define;
  return module.exports;
});

$__System.register('3d', ['8', '9', '39', 'c', '3c', 'b'], function (_export) {
  'use strict';

  var $, $$, HTML, i18n, Modal, c3, Action, VIEW, DISCRETE_PROB, html, TEMPLATES, StatisticalCoverageView;
  return {
    setters: [function (_) {
      $ = _.$;
      $$ = _.$$;
      HTML = _.HTML;
    }, function (_3) {
      i18n = _3.i18n;
    }, function (_2) {}, function (_c) {
      Modal = _c['default'];
    }, function (_c2) {
      c3 = _c2['default'];
    }, function (_b) {
      Action = _b['default'];
      VIEW = _b.VIEW;
    }],
    execute: function () {
      DISCRETE_PROB = 'http://www.uncertml.org/statistics/discrete-probability';
      html = '\n<div class="modal fade" id="statisticsViewModal" tabindex="-1" role="dialog" aria-labelledby="statisticsViewModalLabel">\n  <div class="modal-dialog modal-lg" role="document">\n    <div class="modal-content">\n      <div class="modal-header">\n        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>\n        <h4 class="modal-title" id="statisticsViewModalLabel">Statistics View</h4>\n      </div>\n      <div class="modal-body">\n        <div class="param-selector"></div>\n      \n        <div class="chart-container"></div>\n      </div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>\n      </div>\n    </div>\n  </div>\n</div>\n';

      $('body').add(HTML(html));

      TEMPLATES = {
        'param-selector': '<select name="param"></select>'
      };

      /**
       * Displays statistical coverages as a graph, 
       * currently supporting discrete probabilities as statistical measure only.
       * 
       */

      StatisticalCoverageView = (function (_Action) {
        babelHelpers.inherits(StatisticalCoverageView, _Action);

        function StatisticalCoverageView(data, context) {
          babelHelpers.classCallCheck(this, StatisticalCoverageView);

          babelHelpers.get(Object.getPrototypeOf(StatisticalCoverageView.prototype), 'constructor', this).call(this, context);
          this.cov = data;

          this.label = 'View';
          this.icon = '<span class="glyphicon glyphicon-stats"></span>';
        }

        babelHelpers.createClass(StatisticalCoverageView, [{
          key: 'run',
          value: function run() {
            var _this = this;

            Promise.all([this.cov.loadDomain(), this.cov.loadRanges()]).then(function (_ref) {
              var _ref2 = babelHelpers.slicedToArray(_ref, 2);

              var domain = _ref2[0];
              var ranges = _ref2[1];

              if (domain.axes.size > 1) {
                alert('Sorry, only statistical coverages with exactly one axis (often time) are supported.');
                return;
              }

              // We offer two visualizations:
              // 1. A timeseries chart for a single category (http://c3js.org/samples/timeseries.html)
              // 2. A timeseries stacked area chart (http://c3js.org/samples/chart_area_stacked.html)

              _this._displayChart(domain, ranges);
            });
          }
        }, {
          key: '_displayChart',
          value: function _displayChart(domain, ranges) {
            var _this2 = this;

            var modalEl = $('#statisticsViewModal');
            $('.chart-container', modalEl).fill();
            $('.param-selector', modalEl).fill(HTML(TEMPLATES['param-selector']));
            $('select', modalEl).add(HTML('<option value="">All</option>'));

            var getStatTitle = function getStatTitle(param) {
              var cats = param.observedProperty.statisticalCategories;
              var title = undefined;
              if (cats) {
                title = cats.map(function (cat) {
                  return i18n(cat.label);
                }).join(' & ');
              } else {
                title = i18n(param.observedProperty.label);
              }
              return title;
            };

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = this.cov.parameters.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var param = _step.value;

                var title = getStatTitle(param);
                $('select', modalEl).add(HTML('<option value="' + param.key + '">' + title + '</option>'));
              }

              // TODO support bounds
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            var tColumn = ['t'].concat(domain.axes.get('t').values.map(function (t) {
              return new Date(t);
            }));

            var displayStackedChart = function displayStackedChart() {
              // stacked area chart of all parameters

              var names = {};
              var colors = {};
              var types = {};
              var group = [];
              var ratioColumns = [];
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = _this2.cov.parameters.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var param = _step2.value;

                  var key = param.key;
                  // skip params that are 0 during the whole series
                  if (!ranges.get(key).values.some(function (v) {
                    return v > 0;
                  })) {
                    continue;
                  }
                  names[key] = getStatTitle(param);
                  types[key] = 'area';
                  group.push(key);
                  var cats = param.observedProperty.statisticalCategories;
                  if (cats && cats.length === 1 && cats[0].preferredColor) {
                    colors[key] = cats[0].preferredColor;
                  }
                  ratioColumns.push([key].concat(ranges.get(key).values.map(function (v) {
                    return v * 100;
                  })));
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                    _iterator2['return']();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }

              c3.generate({
                bindto: $$('.chart-container', modalEl),
                data: {
                  x: 't',
                  columns: [tColumn].concat(ratioColumns),
                  types: types,
                  groups: [group],
                  names: names,
                  colors: colors
                },
                grid: {
                  y: {
                    show: true
                  }
                },
                tooltip: {
                  format: {
                    value: function value(_value) {
                      return _value.toFixed(2) + '%';
                    }
                  }
                },
                axis: {
                  y: {
                    min: 0,
                    max: 100,
                    padding: 0,
                    label: {
                      text: 'Percentage (%)',
                      position: 'outer-middle'
                    },
                    tick: {
                      format: function format(d) {
                        return d.toFixed(2);
                      }
                    }
                  },
                  x: {
                    type: 'timeseries',
                    tick: {
                      // TODO determine appropriate accuracy
                      format: '%Y-%m-%d'
                    }
                  }
                },
                size: {
                  height: 500
                }
              });
            };

            var displaySingleParamChart = function displaySingleParamChart(key) {
              // timeseries of single parameter
              var param = _this2.cov.parameters.get(key);

              // convert from ratio to percentage
              var percentageColumn = [key].concat(ranges.get(key).values.map(function (v) {
                return v * 100;
              }));

              var obsPropLabel = undefined;
              var cats = param.observedProperty.statisticalCategories;
              if (cats && cats.length === 1) {
                obsPropLabel = i18n(cats[0].label) + ' Percentage';
              } else {
                obsPropLabel = i18n(param.observedProperty.label);
              }

              c3.generate({
                bindto: $$('.chart-container', modalEl),
                data: {
                  x: 't',
                  columns: [tColumn, percentageColumn],
                  names: babelHelpers.defineProperty({}, key, obsPropLabel)
                },
                legend: {
                  show: false
                },
                grid: {
                  y: {
                    show: true
                  }
                },
                tooltip: {
                  format: {
                    value: function value(_value2) {
                      return _value2.toFixed(2) + '%';
                    }
                  }
                },
                axis: {
                  y: {
                    min: 0,
                    padding: {
                      bottom: 0
                    },
                    label: {
                      text: obsPropLabel + ' (%)',
                      position: 'outer-middle'
                    },
                    tick: {
                      format: function format(d) {
                        return d.toFixed(2);
                      }
                    }
                  },
                  x: {
                    type: 'timeseries',
                    tick: {
                      // TODO determine appropriate accuracy
                      format: '%Y-%m-%d'
                    }
                  }
                }
              });
            };

            $('select', modalEl).on('change', function () {
              var key = $$('select', modalEl).value;
              if (!key) {
                displayStackedChart();
              } else {
                displaySingleParamChart(key);
              }
            });

            new Modal(modalEl[0]).open();

            setTimeout(function () {
              return displayStackedChart();
            }, 500);
          }
        }, {
          key: 'isSupported',
          get: function get() {
            if (this.cov.coverages) {
              return false;
            }

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = this.cov.parameters.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var param = _step3.value;

                var obsProp = param.observedProperty;
                if (obsProp.statisticalMeasure !== DISCRETE_PROB) {
                  return false;
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                  _iterator3['return']();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            return true;
          }
        }]);
        return StatisticalCoverageView;
      })(Action);

      _export('default', StatisticalCoverageView);

      StatisticalCoverageView.type = VIEW;
    }
  };
});

$__System.register('b', ['a'], function (_export) {
  'use strict';

  var Eventable, VIEW, PROCESS, EXTERNAL_LINK, Action;
  return {
    setters: [function (_a) {
      Eventable = _a['default'];
    }],
    execute: function () {
      VIEW = 'view';

      _export('VIEW', VIEW);

      PROCESS = 'process';

      _export('PROCESS', PROCESS);

      EXTERNAL_LINK = 'external_link';

      _export('EXTERNAL_LINK', EXTERNAL_LINK);

      /**
       * Every subclass must add a static `type` property with either VIEW or PROCESS.
       * This is automatically assigned as instance property to allow easier access.
       * 
       * When a subclass is loading external data, then the dataLoading and dataLoad events
       * should be fired.
       */

      Action = (function (_Eventable) {
        babelHelpers.inherits(Action, _Eventable);

        function Action(context) {
          babelHelpers.classCallCheck(this, Action);

          babelHelpers.get(Object.getPrototypeOf(Action.prototype), 'constructor', this).call(this);
          this.context = context || {};
          this.type = this.constructor.type;
        }

        /**
         * Called when the context that this action belongs to (e.g. dataset) is removed.
         * It allows the action to clean up any UI etc.
         */
        babelHelpers.createClass(Action, [{
          key: 'remove',
          value: function remove() {}
        }]);
        return Action;
      })(Eventable);

      _export('default', Action);
    }
  };
});

$__System.register("3e", [], function() { return { setters: [], execute: function() {} } });

$__System.registerDynamic("3f", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal(__module.id, "d3", null);
  (function() {
    "format global";
    "exports d3";
    !function() {
      var d3 = {version: "3.5.0"};
      if (!Date.now)
        Date.now = function() {
          return +new Date();
        };
      var d3_arraySlice = [].slice,
          d3_array = function(list) {
            return d3_arraySlice.call(list);
          };
      var d3_document = document,
          d3_documentElement = d3_document.documentElement,
          d3_window = window;
      try {
        d3_array(d3_documentElement.childNodes)[0].nodeType;
      } catch (e) {
        d3_array = function(list) {
          var i = list.length,
              array = new Array(i);
          while (i--)
            array[i] = list[i];
          return array;
        };
      }
      try {
        d3_document.createElement("div").style.setProperty("opacity", 0, "");
      } catch (error) {
        var d3_element_prototype = d3_window.Element.prototype,
            d3_element_setAttribute = d3_element_prototype.setAttribute,
            d3_element_setAttributeNS = d3_element_prototype.setAttributeNS,
            d3_style_prototype = d3_window.CSSStyleDeclaration.prototype,
            d3_style_setProperty = d3_style_prototype.setProperty;
        d3_element_prototype.setAttribute = function(name, value) {
          d3_element_setAttribute.call(this, name, value + "");
        };
        d3_element_prototype.setAttributeNS = function(space, local, value) {
          d3_element_setAttributeNS.call(this, space, local, value + "");
        };
        d3_style_prototype.setProperty = function(name, value, priority) {
          d3_style_setProperty.call(this, name, value + "", priority);
        };
      }
      d3.ascending = d3_ascending;
      function d3_ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
      }
      d3.descending = function(a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
      };
      d3.min = function(array, f) {
        var i = -1,
            n = array.length,
            a,
            b;
        if (arguments.length === 1) {
          while (++i < n)
            if ((b = array[i]) != null && b >= b) {
              a = b;
              break;
            }
          while (++i < n)
            if ((b = array[i]) != null && a > b)
              a = b;
        } else {
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = b;
              break;
            }
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && a > b)
              a = b;
        }
        return a;
      };
      d3.max = function(array, f) {
        var i = -1,
            n = array.length,
            a,
            b;
        if (arguments.length === 1) {
          while (++i < n)
            if ((b = array[i]) != null && b >= b) {
              a = b;
              break;
            }
          while (++i < n)
            if ((b = array[i]) != null && b > a)
              a = b;
        } else {
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = b;
              break;
            }
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && b > a)
              a = b;
        }
        return a;
      };
      d3.extent = function(array, f) {
        var i = -1,
            n = array.length,
            a,
            b,
            c;
        if (arguments.length === 1) {
          while (++i < n)
            if ((b = array[i]) != null && b >= b) {
              a = c = b;
              break;
            }
          while (++i < n)
            if ((b = array[i]) != null) {
              if (a > b)
                a = b;
              if (c < b)
                c = b;
            }
        } else {
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = c = b;
              break;
            }
          while (++i < n)
            if ((b = f.call(array, array[i], i)) != null) {
              if (a > b)
                a = b;
              if (c < b)
                c = b;
            }
        }
        return [a, c];
      };
      function d3_number(x) {
        return x === null ? NaN : +x;
      }
      function d3_numeric(x) {
        return !isNaN(x);
      }
      d3.sum = function(array, f) {
        var s = 0,
            n = array.length,
            a,
            i = -1;
        if (arguments.length === 1) {
          while (++i < n)
            if (d3_numeric(a = +array[i]))
              s += a;
        } else {
          while (++i < n)
            if (d3_numeric(a = +f.call(array, array[i], i)))
              s += a;
        }
        return s;
      };
      d3.mean = function(array, f) {
        var s = 0,
            n = array.length,
            a,
            i = -1,
            j = n;
        if (arguments.length === 1) {
          while (++i < n)
            if (d3_numeric(a = d3_number(array[i])))
              s += a;
            else
              --j;
        } else {
          while (++i < n)
            if (d3_numeric(a = d3_number(f.call(array, array[i], i))))
              s += a;
            else
              --j;
        }
        if (j)
          return s / j;
      };
      d3.quantile = function(values, p) {
        var H = (values.length - 1) * p + 1,
            h = Math.floor(H),
            v = +values[h - 1],
            e = H - h;
        return e ? v + e * (values[h] - v) : v;
      };
      d3.median = function(array, f) {
        var numbers = [],
            n = array.length,
            a,
            i = -1;
        if (arguments.length === 1) {
          while (++i < n)
            if (d3_numeric(a = d3_number(array[i])))
              numbers.push(a);
        } else {
          while (++i < n)
            if (d3_numeric(a = d3_number(f.call(array, array[i], i))))
              numbers.push(a);
        }
        if (numbers.length)
          return d3.quantile(numbers.sort(d3_ascending), .5);
      };
      function d3_bisector(compare) {
        return {
          left: function(a, x, lo, hi) {
            if (arguments.length < 3)
              lo = 0;
            if (arguments.length < 4)
              hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) < 0)
                lo = mid + 1;
              else
                hi = mid;
            }
            return lo;
          },
          right: function(a, x, lo, hi) {
            if (arguments.length < 3)
              lo = 0;
            if (arguments.length < 4)
              hi = a.length;
            while (lo < hi) {
              var mid = lo + hi >>> 1;
              if (compare(a[mid], x) > 0)
                hi = mid;
              else
                lo = mid + 1;
            }
            return lo;
          }
        };
      }
      var d3_bisect = d3_bisector(d3_ascending);
      d3.bisectLeft = d3_bisect.left;
      d3.bisect = d3.bisectRight = d3_bisect.right;
      d3.bisector = function(f) {
        return d3_bisector(f.length === 1 ? function(d, x) {
          return d3_ascending(f(d), x);
        } : f);
      };
      d3.shuffle = function(array, i0, i1) {
        if ((m = arguments.length) < 3) {
          i1 = array.length;
          if (m < 2)
            i0 = 0;
        }
        var m = i1 - i0,
            t,
            i;
        while (m) {
          i = Math.random() * m-- | 0;
          t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
        }
        return array;
      };
      d3.permute = function(array, indexes) {
        var i = indexes.length,
            permutes = new Array(i);
        while (i--)
          permutes[i] = array[indexes[i]];
        return permutes;
      };
      d3.pairs = function(array) {
        var i = 0,
            n = array.length - 1,
            p0,
            p1 = array[0],
            pairs = new Array(n < 0 ? 0 : n);
        while (i < n)
          pairs[i] = [p0 = p1, p1 = array[++i]];
        return pairs;
      };
      d3.zip = function() {
        if (!(n = arguments.length))
          return [];
        for (var i = -1,
            m = d3.min(arguments, d3_zipLength),
            zips = new Array(m); ++i < m; ) {
          for (var j = -1,
              n,
              zip = zips[i] = new Array(n); ++j < n; ) {
            zip[j] = arguments[j][i];
          }
        }
        return zips;
      };
      function d3_zipLength(d) {
        return d.length;
      }
      d3.transpose = function(matrix) {
        return d3.zip.apply(d3, matrix);
      };
      d3.keys = function(map) {
        var keys = [];
        for (var key in map)
          keys.push(key);
        return keys;
      };
      d3.values = function(map) {
        var values = [];
        for (var key in map)
          values.push(map[key]);
        return values;
      };
      d3.entries = function(map) {
        var entries = [];
        for (var key in map)
          entries.push({
            key: key,
            value: map[key]
          });
        return entries;
      };
      d3.merge = function(arrays) {
        var n = arrays.length,
            m,
            i = -1,
            j = 0,
            merged,
            array;
        while (++i < n)
          j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
          array = arrays[n];
          m = array.length;
          while (--m >= 0) {
            merged[--j] = array[m];
          }
        }
        return merged;
      };
      var abs = Math.abs;
      d3.range = function(start, stop, step) {
        if (arguments.length < 3) {
          step = 1;
          if (arguments.length < 2) {
            stop = start;
            start = 0;
          }
        }
        if ((stop - start) / step === Infinity)
          throw new Error("infinite range");
        var range = [],
            k = d3_range_integerScale(abs(step)),
            i = -1,
            j;
        start *= k, stop *= k, step *= k;
        if (step < 0)
          while ((j = start + step * ++i) > stop)
            range.push(j / k);
        else
          while ((j = start + step * ++i) < stop)
            range.push(j / k);
        return range;
      };
      function d3_range_integerScale(x) {
        var k = 1;
        while (x * k % 1)
          k *= 10;
        return k;
      }
      function d3_class(ctor, properties) {
        for (var key in properties) {
          Object.defineProperty(ctor.prototype, key, {
            value: properties[key],
            enumerable: false
          });
        }
      }
      d3.map = function(object, f) {
        var map = new d3_Map();
        if (object instanceof d3_Map) {
          object.forEach(function(key, value) {
            map.set(key, value);
          });
        } else if (Array.isArray(object)) {
          var i = -1,
              n = object.length,
              o;
          if (arguments.length === 1)
            while (++i < n)
              map.set(i, object[i]);
          else
            while (++i < n)
              map.set(f.call(object, o = object[i], i), o);
        } else {
          for (var key in object)
            map.set(key, object[key]);
        }
        return map;
      };
      function d3_Map() {
        this._ = Object.create(null);
      }
      var d3_map_proto = "__proto__",
          d3_map_zero = "\x00";
      d3_class(d3_Map, {
        has: d3_map_has,
        get: function(key) {
          return this._[d3_map_escape(key)];
        },
        set: function(key, value) {
          return this._[d3_map_escape(key)] = value;
        },
        remove: d3_map_remove,
        keys: d3_map_keys,
        values: function() {
          var values = [];
          for (var key in this._)
            values.push(this._[key]);
          return values;
        },
        entries: function() {
          var entries = [];
          for (var key in this._)
            entries.push({
              key: d3_map_unescape(key),
              value: this._[key]
            });
          return entries;
        },
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
          for (var key in this._)
            f.call(this, d3_map_unescape(key), this._[key]);
        }
      });
      function d3_map_escape(key) {
        return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
      }
      function d3_map_unescape(key) {
        return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
      }
      function d3_map_has(key) {
        return d3_map_escape(key) in this._;
      }
      function d3_map_remove(key) {
        return (key = d3_map_escape(key)) in this._ && delete this._[key];
      }
      function d3_map_keys() {
        var keys = [];
        for (var key in this._)
          keys.push(d3_map_unescape(key));
        return keys;
      }
      function d3_map_size() {
        var size = 0;
        for (var key in this._)
          ++size;
        return size;
      }
      function d3_map_empty() {
        for (var key in this._)
          return false;
        return true;
      }
      d3.nest = function() {
        var nest = {},
            keys = [],
            sortKeys = [],
            sortValues,
            rollup;
        function map(mapType, array, depth) {
          if (depth >= keys.length)
            return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
          var i = -1,
              n = array.length,
              key = keys[depth++],
              keyValue,
              object,
              setter,
              valuesByKey = new d3_Map(),
              values;
          while (++i < n) {
            if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
              values.push(object);
            } else {
              valuesByKey.set(keyValue, [object]);
            }
          }
          if (mapType) {
            object = mapType();
            setter = function(keyValue, values) {
              object.set(keyValue, map(mapType, values, depth));
            };
          } else {
            object = {};
            setter = function(keyValue, values) {
              object[keyValue] = map(mapType, values, depth);
            };
          }
          valuesByKey.forEach(setter);
          return object;
        }
        function entries(map, depth) {
          if (depth >= keys.length)
            return map;
          var array = [],
              sortKey = sortKeys[depth++];
          map.forEach(function(key, keyMap) {
            array.push({
              key: key,
              values: entries(keyMap, depth)
            });
          });
          return sortKey ? array.sort(function(a, b) {
            return sortKey(a.key, b.key);
          }) : array;
        }
        nest.map = function(array, mapType) {
          return map(mapType, array, 0);
        };
        nest.entries = function(array) {
          return entries(map(d3.map, array, 0), 0);
        };
        nest.key = function(d) {
          keys.push(d);
          return nest;
        };
        nest.sortKeys = function(order) {
          sortKeys[keys.length - 1] = order;
          return nest;
        };
        nest.sortValues = function(order) {
          sortValues = order;
          return nest;
        };
        nest.rollup = function(f) {
          rollup = f;
          return nest;
        };
        return nest;
      };
      d3.set = function(array) {
        var set = new d3_Set();
        if (array)
          for (var i = 0,
              n = array.length; i < n; ++i)
            set.add(array[i]);
        return set;
      };
      function d3_Set() {
        this._ = Object.create(null);
      }
      d3_class(d3_Set, {
        has: d3_map_has,
        add: function(key) {
          this._[d3_map_escape(key += "")] = true;
          return key;
        },
        remove: d3_map_remove,
        values: d3_map_keys,
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function(f) {
          for (var key in this._)
            f.call(this, d3_map_unescape(key));
        }
      });
      d3.behavior = {};
      d3.rebind = function(target, source) {
        var i = 1,
            n = arguments.length,
            method;
        while (++i < n)
          target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target;
      };
      function d3_rebind(target, source, method) {
        return function() {
          var value = method.apply(source, arguments);
          return value === source ? target : value;
        };
      }
      function d3_vendorSymbol(object, name) {
        if (name in object)
          return name;
        name = name.charAt(0).toUpperCase() + name.slice(1);
        for (var i = 0,
            n = d3_vendorPrefixes.length; i < n; ++i) {
          var prefixName = d3_vendorPrefixes[i] + name;
          if (prefixName in object)
            return prefixName;
        }
      }
      var d3_vendorPrefixes = ["webkit", "ms", "moz", "Moz", "o", "O"];
      function d3_noop() {}
      d3.dispatch = function() {
        var dispatch = new d3_dispatch(),
            i = -1,
            n = arguments.length;
        while (++i < n)
          dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch;
      };
      function d3_dispatch() {}
      d3_dispatch.prototype.on = function(type, listener) {
        var i = type.indexOf("."),
            name = "";
        if (i >= 0) {
          name = type.slice(i + 1);
          type = type.slice(0, i);
        }
        if (type)
          return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        if (arguments.length === 2) {
          if (listener == null)
            for (type in this) {
              if (this.hasOwnProperty(type))
                this[type].on(name, null);
            }
          return this;
        }
      };
      function d3_dispatch_event(dispatch) {
        var listeners = [],
            listenerByName = new d3_Map();
        function event() {
          var z = listeners,
              i = -1,
              n = z.length,
              l;
          while (++i < n)
            if (l = z[i].on)
              l.apply(this, arguments);
          return dispatch;
        }
        event.on = function(name, listener) {
          var l = listenerByName.get(name),
              i;
          if (arguments.length < 2)
            return l && l.on;
          if (l) {
            l.on = null;
            listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
            listenerByName.remove(name);
          }
          if (listener)
            listeners.push(listenerByName.set(name, {on: listener}));
          return dispatch;
        };
        return event;
      }
      d3.event = null;
      function d3_eventPreventDefault() {
        d3.event.preventDefault();
      }
      function d3_eventSource() {
        var e = d3.event,
            s;
        while (s = e.sourceEvent)
          e = s;
        return e;
      }
      function d3_eventDispatch(target) {
        var dispatch = new d3_dispatch(),
            i = 0,
            n = arguments.length;
        while (++i < n)
          dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        dispatch.of = function(thiz, argumentz) {
          return function(e1) {
            try {
              var e0 = e1.sourceEvent = d3.event;
              e1.target = target;
              d3.event = e1;
              dispatch[e1.type].apply(thiz, argumentz);
            } finally {
              d3.event = e0;
            }
          };
        };
        return dispatch;
      }
      d3.requote = function(s) {
        return s.replace(d3_requote_re, "\\$&");
      };
      var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
      var d3_subclass = {}.__proto__ ? function(object, prototype) {
        object.__proto__ = prototype;
      } : function(object, prototype) {
        for (var property in prototype)
          object[property] = prototype[property];
      };
      function d3_selection(groups) {
        d3_subclass(groups, d3_selectionPrototype);
        return groups;
      }
      var d3_select = function(s, n) {
        return n.querySelector(s);
      },
          d3_selectAll = function(s, n) {
            return n.querySelectorAll(s);
          },
          d3_selectMatcher = d3_documentElement.matches || d3_documentElement[d3_vendorSymbol(d3_documentElement, "matchesSelector")],
          d3_selectMatches = function(n, s) {
            return d3_selectMatcher.call(n, s);
          };
      if (typeof Sizzle === "function") {
        d3_select = function(s, n) {
          return Sizzle(s, n)[0] || null;
        };
        d3_selectAll = Sizzle;
        d3_selectMatches = Sizzle.matchesSelector;
      }
      d3.selection = function() {
        return d3_selectionRoot;
      };
      var d3_selectionPrototype = d3.selection.prototype = [];
      d3_selectionPrototype.select = function(selector) {
        var subgroups = [],
            subgroup,
            subnode,
            group,
            node;
        selector = d3_selection_selector(selector);
        for (var j = -1,
            m = this.length; ++j < m; ) {
          subgroups.push(subgroup = []);
          subgroup.parentNode = (group = this[j]).parentNode;
          for (var i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i]) {
              subgroup.push(subnode = selector.call(node, node.__data__, i, j));
              if (subnode && "__data__" in node)
                subnode.__data__ = node.__data__;
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_selector(selector) {
        return typeof selector === "function" ? selector : function() {
          return d3_select(selector, this);
        };
      }
      d3_selectionPrototype.selectAll = function(selector) {
        var subgroups = [],
            subgroup,
            node;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1,
            m = this.length; ++j < m; ) {
          for (var group = this[j],
              i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i]) {
              subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
              subgroup.parentNode = node;
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_selectorAll(selector) {
        return typeof selector === "function" ? selector : function() {
          return d3_selectAll(selector, this);
        };
      }
      var d3_nsPrefix = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: "http://www.w3.org/1999/xhtml",
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
      };
      d3.ns = {
        prefix: d3_nsPrefix,
        qualify: function(name) {
          var i = name.indexOf(":"),
              prefix = name;
          if (i >= 0) {
            prefix = name.slice(0, i);
            name = name.slice(i + 1);
          }
          return d3_nsPrefix.hasOwnProperty(prefix) ? {
            space: d3_nsPrefix[prefix],
            local: name
          } : name;
        }
      };
      d3_selectionPrototype.attr = function(name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string") {
            var node = this.node();
            name = d3.ns.qualify(name);
            return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
          }
          for (value in name)
            this.each(d3_selection_attr(value, name[value]));
          return this;
        }
        return this.each(d3_selection_attr(name, value));
      };
      function d3_selection_attr(name, value) {
        name = d3.ns.qualify(name);
        function attrNull() {
          this.removeAttribute(name);
        }
        function attrNullNS() {
          this.removeAttributeNS(name.space, name.local);
        }
        function attrConstant() {
          this.setAttribute(name, value);
        }
        function attrConstantNS() {
          this.setAttributeNS(name.space, name.local, value);
        }
        function attrFunction() {
          var x = value.apply(this, arguments);
          if (x == null)
            this.removeAttribute(name);
          else
            this.setAttribute(name, x);
        }
        function attrFunctionNS() {
          var x = value.apply(this, arguments);
          if (x == null)
            this.removeAttributeNS(name.space, name.local);
          else
            this.setAttributeNS(name.space, name.local, x);
        }
        return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
      }
      function d3_collapse(s) {
        return s.trim().replace(/\s+/g, " ");
      }
      d3_selectionPrototype.classed = function(name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string") {
            var node = this.node(),
                n = (name = d3_selection_classes(name)).length,
                i = -1;
            if (value = node.classList) {
              while (++i < n)
                if (!value.contains(name[i]))
                  return false;
            } else {
              value = node.getAttribute("class");
              while (++i < n)
                if (!d3_selection_classedRe(name[i]).test(value))
                  return false;
            }
            return true;
          }
          for (value in name)
            this.each(d3_selection_classed(value, name[value]));
          return this;
        }
        return this.each(d3_selection_classed(name, value));
      };
      function d3_selection_classedRe(name) {
        return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
      }
      function d3_selection_classes(name) {
        return (name + "").trim().split(/^|\s+/);
      }
      function d3_selection_classed(name, value) {
        name = d3_selection_classes(name).map(d3_selection_classedName);
        var n = name.length;
        function classedConstant() {
          var i = -1;
          while (++i < n)
            name[i](this, value);
        }
        function classedFunction() {
          var i = -1,
              x = value.apply(this, arguments);
          while (++i < n)
            name[i](this, x);
        }
        return typeof value === "function" ? classedFunction : classedConstant;
      }
      function d3_selection_classedName(name) {
        var re = d3_selection_classedRe(name);
        return function(node, value) {
          if (c = node.classList)
            return value ? c.add(name) : c.remove(name);
          var c = node.getAttribute("class") || "";
          if (value) {
            re.lastIndex = 0;
            if (!re.test(c))
              node.setAttribute("class", d3_collapse(c + " " + name));
          } else {
            node.setAttribute("class", d3_collapse(c.replace(re, " ")));
          }
        };
      }
      d3_selectionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof name !== "string") {
            if (n < 2)
              value = "";
            for (priority in name)
              this.each(d3_selection_style(priority, name[priority], value));
            return this;
          }
          if (n < 2)
            return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name);
          priority = "";
        }
        return this.each(d3_selection_style(name, value, priority));
      };
      function d3_selection_style(name, value, priority) {
        function styleNull() {
          this.style.removeProperty(name);
        }
        function styleConstant() {
          this.style.setProperty(name, value, priority);
        }
        function styleFunction() {
          var x = value.apply(this, arguments);
          if (x == null)
            this.style.removeProperty(name);
          else
            this.style.setProperty(name, x, priority);
        }
        return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
      }
      d3_selectionPrototype.property = function(name, value) {
        if (arguments.length < 2) {
          if (typeof name === "string")
            return this.node()[name];
          for (value in name)
            this.each(d3_selection_property(value, name[value]));
          return this;
        }
        return this.each(d3_selection_property(name, value));
      };
      function d3_selection_property(name, value) {
        function propertyNull() {
          delete this[name];
        }
        function propertyConstant() {
          this[name] = value;
        }
        function propertyFunction() {
          var x = value.apply(this, arguments);
          if (x == null)
            delete this[name];
          else
            this[name] = x;
        }
        return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
      }
      d3_selectionPrototype.text = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
          var v = value.apply(this, arguments);
          this.textContent = v == null ? "" : v;
        } : value == null ? function() {
          this.textContent = "";
        } : function() {
          this.textContent = value;
        }) : this.node().textContent;
      };
      d3_selectionPrototype.html = function(value) {
        return arguments.length ? this.each(typeof value === "function" ? function() {
          var v = value.apply(this, arguments);
          this.innerHTML = v == null ? "" : v;
        } : value == null ? function() {
          this.innerHTML = "";
        } : function() {
          this.innerHTML = value;
        }) : this.node().innerHTML;
      };
      d3_selectionPrototype.append = function(name) {
        name = d3_selection_creator(name);
        return this.select(function() {
          return this.appendChild(name.apply(this, arguments));
        });
      };
      function d3_selection_creator(name) {
        return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? function() {
          return this.ownerDocument.createElementNS(name.space, name.local);
        } : function() {
          return this.ownerDocument.createElementNS(this.namespaceURI, name);
        };
      }
      d3_selectionPrototype.insert = function(name, before) {
        name = d3_selection_creator(name);
        before = d3_selection_selector(before);
        return this.select(function() {
          return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
        });
      };
      d3_selectionPrototype.remove = function() {
        return this.each(d3_selectionRemove);
      };
      function d3_selectionRemove() {
        var parent = this.parentNode;
        if (parent)
          parent.removeChild(this);
      }
      d3_selectionPrototype.data = function(value, key) {
        var i = -1,
            n = this.length,
            group,
            node;
        if (!arguments.length) {
          value = new Array(n = (group = this[0]).length);
          while (++i < n) {
            if (node = group[i]) {
              value[i] = node.__data__;
            }
          }
          return value;
        }
        function bind(group, groupData) {
          var i,
              n = group.length,
              m = groupData.length,
              n0 = Math.min(n, m),
              updateNodes = new Array(m),
              enterNodes = new Array(m),
              exitNodes = new Array(n),
              node,
              nodeData;
          if (key) {
            var nodeByKeyValue = new d3_Map(),
                keyValues = new Array(n),
                keyValue;
            for (i = -1; ++i < n; ) {
              if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {
                exitNodes[i] = node;
              } else {
                nodeByKeyValue.set(keyValue, node);
              }
              keyValues[i] = keyValue;
            }
            for (i = -1; ++i < m; ) {
              if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
                enterNodes[i] = d3_selection_dataNode(nodeData);
              } else if (node !== true) {
                updateNodes[i] = node;
                node.__data__ = nodeData;
              }
              nodeByKeyValue.set(keyValue, true);
            }
            for (i = -1; ++i < n; ) {
              if (nodeByKeyValue.get(keyValues[i]) !== true) {
                exitNodes[i] = group[i];
              }
            }
          } else {
            for (i = -1; ++i < n0; ) {
              node = group[i];
              nodeData = groupData[i];
              if (node) {
                node.__data__ = nodeData;
                updateNodes[i] = node;
              } else {
                enterNodes[i] = d3_selection_dataNode(nodeData);
              }
            }
            for (; i < m; ++i) {
              enterNodes[i] = d3_selection_dataNode(groupData[i]);
            }
            for (; i < n; ++i) {
              exitNodes[i] = group[i];
            }
          }
          enterNodes.update = updateNodes;
          enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
          enter.push(enterNodes);
          update.push(updateNodes);
          exit.push(exitNodes);
        }
        var enter = d3_selection_enter([]),
            update = d3_selection([]),
            exit = d3_selection([]);
        if (typeof value === "function") {
          while (++i < n) {
            bind(group = this[i], value.call(group, group.parentNode.__data__, i));
          }
        } else {
          while (++i < n) {
            bind(group = this[i], value);
          }
        }
        update.enter = function() {
          return enter;
        };
        update.exit = function() {
          return exit;
        };
        return update;
      };
      function d3_selection_dataNode(data) {
        return {__data__: data};
      }
      d3_selectionPrototype.datum = function(value) {
        return arguments.length ? this.property("__data__", value) : this.property("__data__");
      };
      d3_selectionPrototype.filter = function(filter) {
        var subgroups = [],
            subgroup,
            group,
            node;
        if (typeof filter !== "function")
          filter = d3_selection_filter(filter);
        for (var j = 0,
            m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          subgroup.parentNode = (group = this[j]).parentNode;
          for (var i = 0,
              n = group.length; i < n; i++) {
            if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
              subgroup.push(node);
            }
          }
        }
        return d3_selection(subgroups);
      };
      function d3_selection_filter(selector) {
        return function() {
          return d3_selectMatches(this, selector);
        };
      }
      d3_selectionPrototype.order = function() {
        for (var j = -1,
            m = this.length; ++j < m; ) {
          for (var group = this[j],
              i = group.length - 1,
              next = group[i],
              node; --i >= 0; ) {
            if (node = group[i]) {
              if (next && next !== node.nextSibling)
                next.parentNode.insertBefore(node, next);
              next = node;
            }
          }
        }
        return this;
      };
      d3_selectionPrototype.sort = function(comparator) {
        comparator = d3_selection_sortComparator.apply(this, arguments);
        for (var j = -1,
            m = this.length; ++j < m; )
          this[j].sort(comparator);
        return this.order();
      };
      function d3_selection_sortComparator(comparator) {
        if (!arguments.length)
          comparator = d3_ascending;
        return function(a, b) {
          return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
        };
      }
      d3_selectionPrototype.each = function(callback) {
        return d3_selection_each(this, function(node, i, j) {
          callback.call(node, node.__data__, i, j);
        });
      };
      function d3_selection_each(groups, callback) {
        for (var j = 0,
            m = groups.length; j < m; j++) {
          for (var group = groups[j],
              i = 0,
              n = group.length,
              node; i < n; i++) {
            if (node = group[i])
              callback(node, i, j);
          }
        }
        return groups;
      }
      d3_selectionPrototype.call = function(callback) {
        var args = d3_array(arguments);
        callback.apply(args[0] = this, args);
        return this;
      };
      d3_selectionPrototype.empty = function() {
        return !this.node();
      };
      d3_selectionPrototype.node = function() {
        for (var j = 0,
            m = this.length; j < m; j++) {
          for (var group = this[j],
              i = 0,
              n = group.length; i < n; i++) {
            var node = group[i];
            if (node)
              return node;
          }
        }
        return null;
      };
      d3_selectionPrototype.size = function() {
        var n = 0;
        d3_selection_each(this, function() {
          ++n;
        });
        return n;
      };
      function d3_selection_enter(selection) {
        d3_subclass(selection, d3_selection_enterPrototype);
        return selection;
      }
      var d3_selection_enterPrototype = [];
      d3.selection.enter = d3_selection_enter;
      d3.selection.enter.prototype = d3_selection_enterPrototype;
      d3_selection_enterPrototype.append = d3_selectionPrototype.append;
      d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
      d3_selection_enterPrototype.node = d3_selectionPrototype.node;
      d3_selection_enterPrototype.call = d3_selectionPrototype.call;
      d3_selection_enterPrototype.size = d3_selectionPrototype.size;
      d3_selection_enterPrototype.select = function(selector) {
        var subgroups = [],
            subgroup,
            subnode,
            upgroup,
            group,
            node;
        for (var j = -1,
            m = this.length; ++j < m; ) {
          upgroup = (group = this[j]).update;
          subgroups.push(subgroup = []);
          subgroup.parentNode = group.parentNode;
          for (var i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i]) {
              subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
              subnode.__data__ = node.__data__;
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_selection(subgroups);
      };
      d3_selection_enterPrototype.insert = function(name, before) {
        if (arguments.length < 2)
          before = d3_selection_enterInsertBefore(this);
        return d3_selectionPrototype.insert.call(this, name, before);
      };
      function d3_selection_enterInsertBefore(enter) {
        var i0,
            j0;
        return function(d, i, j) {
          var group = enter[j].update,
              n = group.length,
              node;
          if (j != j0)
            j0 = j, i0 = 0;
          if (i >= i0)
            i0 = i + 1;
          while (!(node = group[i0]) && ++i0 < n)
            ;
          return node;
        };
      }
      d3_selectionPrototype.transition = function(name) {
        var id = d3_transitionInheritId || ++d3_transitionId,
            ns = d3_transitionNamespace(name),
            subgroups = [],
            subgroup,
            node,
            transition = d3_transitionInherit || {
              time: Date.now(),
              ease: d3_ease_cubicInOut,
              delay: 0,
              duration: 250
            };
        for (var j = -1,
            m = this.length; ++j < m; ) {
          subgroups.push(subgroup = []);
          for (var group = this[j],
              i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i])
              d3_transitionNode(node, i, ns, id, transition);
            subgroup.push(node);
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_selectionPrototype.interrupt = function(name) {
        var ns = d3_transitionNamespace(name);
        return this.each(function() {
          var lock = this[ns];
          if (lock)
            ++lock.active;
        });
      };
      function d3_selection_interrupt(that) {
        var lock = that.__transition__;
        if (lock)
          ++lock.active;
      }
      d3.select = function(node) {
        var group = [typeof node === "string" ? d3_select(node, d3_document) : node];
        group.parentNode = d3_documentElement;
        return d3_selection([group]);
      };
      d3.selectAll = function(nodes) {
        var group = d3_array(typeof nodes === "string" ? d3_selectAll(nodes, d3_document) : nodes);
        group.parentNode = d3_documentElement;
        return d3_selection([group]);
      };
      var d3_selectionRoot = d3.select(d3_documentElement);
      d3_selectionPrototype.on = function(type, listener, capture) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof type !== "string") {
            if (n < 2)
              listener = false;
            for (capture in type)
              this.each(d3_selection_on(capture, type[capture], listener));
            return this;
          }
          if (n < 2)
            return (n = this.node()["__on" + type]) && n._;
          capture = false;
        }
        return this.each(d3_selection_on(type, listener, capture));
      };
      function d3_selection_on(type, listener, capture) {
        var name = "__on" + type,
            i = type.indexOf("."),
            wrap = d3_selection_onListener;
        if (i > 0)
          type = type.slice(0, i);
        var filter = d3_selection_onFilters.get(type);
        if (filter)
          type = filter, wrap = d3_selection_onFilter;
        function onRemove() {
          var l = this[name];
          if (l) {
            this.removeEventListener(type, l, l.$);
            delete this[name];
          }
        }
        function onAdd() {
          var l = wrap(listener, d3_array(arguments));
          onRemove.call(this);
          this.addEventListener(type, this[name] = l, l.$ = capture);
          l._ = listener;
        }
        function removeAll() {
          var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"),
              match;
          for (var name in this) {
            if (match = name.match(re)) {
              var l = this[name];
              this.removeEventListener(match[1], l, l.$);
              delete this[name];
            }
          }
        }
        return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
      }
      var d3_selection_onFilters = d3.map({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
      });
      d3_selection_onFilters.forEach(function(k) {
        if ("on" + k in d3_document)
          d3_selection_onFilters.remove(k);
      });
      function d3_selection_onListener(listener, argumentz) {
        return function(e) {
          var o = d3.event;
          d3.event = e;
          argumentz[0] = this.__data__;
          try {
            listener.apply(this, argumentz);
          } finally {
            d3.event = o;
          }
        };
      }
      function d3_selection_onFilter(listener, argumentz) {
        var l = d3_selection_onListener(listener, argumentz);
        return function(e) {
          var target = this,
              related = e.relatedTarget;
          if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
            l.call(target, e);
          }
        };
      }
      var d3_event_dragSelect = "onselectstart" in d3_document ? null : d3_vendorSymbol(d3_documentElement.style, "userSelect"),
          d3_event_dragId = 0;
      function d3_event_dragSuppress() {
        var name = ".dragsuppress-" + ++d3_event_dragId,
            click = "click" + name,
            w = d3.select(d3_window).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
        if (d3_event_dragSelect) {
          var style = d3_documentElement.style,
              select = style[d3_event_dragSelect];
          style[d3_event_dragSelect] = "none";
        }
        return function(suppressClick) {
          w.on(name, null);
          if (d3_event_dragSelect)
            style[d3_event_dragSelect] = select;
          if (suppressClick) {
            var off = function() {
              w.on(click, null);
            };
            w.on(click, function() {
              d3_eventPreventDefault();
              off();
            }, true);
            setTimeout(off, 0);
          }
        };
      }
      d3.mouse = function(container) {
        return d3_mousePoint(container, d3_eventSource());
      };
      var d3_mouse_bug44083 = /WebKit/.test(d3_window.navigator.userAgent) ? -1 : 0;
      function d3_mousePoint(container, e) {
        if (e.changedTouches)
          e = e.changedTouches[0];
        var svg = container.ownerSVGElement || container;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          if (d3_mouse_bug44083 < 0 && (d3_window.scrollX || d3_window.scrollY)) {
            svg = d3.select("body").append("svg").style({
              position: "absolute",
              top: 0,
              left: 0,
              margin: 0,
              padding: 0,
              border: "none"
            }, "important");
            var ctm = svg[0][0].getScreenCTM();
            d3_mouse_bug44083 = !(ctm.f || ctm.e);
            svg.remove();
          }
          if (d3_mouse_bug44083)
            point.x = e.pageX, point.y = e.pageY;
          else
            point.x = e.clientX, point.y = e.clientY;
          point = point.matrixTransform(container.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        var rect = container.getBoundingClientRect();
        return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];
      }
      d3.touch = function(container, touches, identifier) {
        if (arguments.length < 3)
          identifier = touches, touches = d3_eventSource().changedTouches;
        if (touches)
          for (var i = 0,
              n = touches.length,
              touch; i < n; ++i) {
            if ((touch = touches[i]).identifier === identifier) {
              return d3_mousePoint(container, touch);
            }
          }
      };
      d3.behavior.drag = function() {
        var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"),
            origin = null,
            mousedown = dragstart(d3_noop, d3.mouse, d3_behavior_dragMouseSubject, "mousemove", "mouseup"),
            touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_behavior_dragTouchSubject, "touchmove", "touchend");
        function drag() {
          this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
        }
        function dragstart(id, position, subject, move, end) {
          return function() {
            var that = this,
                target = d3.event.target,
                parent = that.parentNode,
                dispatch = event.of(that, arguments),
                dragged = 0,
                dragId = id(),
                dragName = ".drag" + (dragId == null ? "" : "-" + dragId),
                dragOffset,
                dragSubject = d3.select(subject()).on(move + dragName, moved).on(end + dragName, ended),
                dragRestore = d3_event_dragSuppress(),
                position0 = position(parent, dragId);
            if (origin) {
              dragOffset = origin.apply(that, arguments);
              dragOffset = [dragOffset.x - position0[0], dragOffset.y - position0[1]];
            } else {
              dragOffset = [0, 0];
            }
            dispatch({type: "dragstart"});
            function moved() {
              var position1 = position(parent, dragId),
                  dx,
                  dy;
              if (!position1)
                return;
              dx = position1[0] - position0[0];
              dy = position1[1] - position0[1];
              dragged |= dx | dy;
              position0 = position1;
              dispatch({
                type: "drag",
                x: position1[0] + dragOffset[0],
                y: position1[1] + dragOffset[1],
                dx: dx,
                dy: dy
              });
            }
            function ended() {
              if (!position(parent, dragId))
                return;
              dragSubject.on(move + dragName, null).on(end + dragName, null);
              dragRestore(dragged && d3.event.target === target);
              dispatch({type: "dragend"});
            }
          };
        }
        drag.origin = function(x) {
          if (!arguments.length)
            return origin;
          origin = x;
          return drag;
        };
        return d3.rebind(drag, event, "on");
      };
      function d3_behavior_dragTouchId() {
        return d3.event.changedTouches[0].identifier;
      }
      function d3_behavior_dragTouchSubject() {
        return d3.event.target;
      }
      function d3_behavior_dragMouseSubject() {
        return d3_window;
      }
      d3.touches = function(container, touches) {
        if (arguments.length < 2)
          touches = d3_eventSource().touches;
        return touches ? d3_array(touches).map(function(touch) {
          var point = d3_mousePoint(container, touch);
          point.identifier = touch.identifier;
          return point;
        }) : [];
      };
      var ε = 1e-6,
          ε2 = ε * ε,
          π = Math.PI,
          τ = 2 * π,
          τε = τ - ε,
          halfπ = π / 2,
          d3_radians = π / 180,
          d3_degrees = 180 / π;
      function d3_sgn(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
      }
      function d3_cross2d(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
      }
      function d3_acos(x) {
        return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
      }
      function d3_asin(x) {
        return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
      }
      function d3_sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
      }
      function d3_cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
      }
      function d3_tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
      }
      function d3_haversin(x) {
        return (x = Math.sin(x / 2)) * x;
      }
      var ρ = Math.SQRT2,
          ρ2 = 2,
          ρ4 = 4;
      d3.interpolateZoom = function(p0, p1) {
        var ux0 = p0[0],
            uy0 = p0[1],
            w0 = p0[2],
            ux1 = p1[0],
            uy1 = p1[1],
            w1 = p1[2];
        var dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            d1 = Math.sqrt(d2),
            b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1),
            b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1),
            r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
            r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1),
            dr = r1 - r0,
            S = (dr || Math.log(w1 / w0)) / ρ;
        function interpolate(t) {
          var s = t * S;
          if (dr) {
            var coshr0 = d3_cosh(r0),
                u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
            return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0)];
          }
          return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * s)];
        }
        interpolate.duration = S * 1e3;
        return interpolate;
      };
      d3.behavior.zoom = function() {
        var view = {
          x: 0,
          y: 0,
          k: 1
        },
            translate0,
            center0,
            center,
            size = [960, 500],
            scaleExtent = d3_behavior_zoomInfinity,
            duration = 250,
            zooming = 0,
            mousedown = "mousedown.zoom",
            mousemove = "mousemove.zoom",
            mouseup = "mouseup.zoom",
            mousewheelTimer,
            touchstart = "touchstart.zoom",
            touchtime,
            event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"),
            x0,
            x1,
            y0,
            y1;
        function zoom(g) {
          g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
        }
        zoom.event = function(g) {
          g.each(function() {
            var dispatch = event.of(this, arguments),
                view1 = view;
            if (d3_transitionInheritId) {
              d3.select(this).transition().each("start.zoom", function() {
                view = this.__chart__ || {
                  x: 0,
                  y: 0,
                  k: 1
                };
                zoomstarted(dispatch);
              }).tween("zoom:zoom", function() {
                var dx = size[0],
                    dy = size[1],
                    cx = center0 ? center0[0] : dx / 2,
                    cy = center0 ? center0[1] : dy / 2,
                    i = d3.interpolateZoom([(cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k], [(cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k]);
                return function(t) {
                  var l = i(t),
                      k = dx / l[2];
                  this.__chart__ = view = {
                    x: cx - l[0] * k,
                    y: cy - l[1] * k,
                    k: k
                  };
                  zoomed(dispatch);
                };
              }).each("interrupt.zoom", function() {
                zoomended(dispatch);
              }).each("end.zoom", function() {
                zoomended(dispatch);
              });
            } else {
              this.__chart__ = view;
              zoomstarted(dispatch);
              zoomed(dispatch);
              zoomended(dispatch);
            }
          });
        };
        zoom.translate = function(_) {
          if (!arguments.length)
            return [view.x, view.y];
          view = {
            x: +_[0],
            y: +_[1],
            k: view.k
          };
          rescale();
          return zoom;
        };
        zoom.scale = function(_) {
          if (!arguments.length)
            return view.k;
          view = {
            x: view.x,
            y: view.y,
            k: +_
          };
          rescale();
          return zoom;
        };
        zoom.scaleExtent = function(_) {
          if (!arguments.length)
            return scaleExtent;
          scaleExtent = _ == null ? d3_behavior_zoomInfinity : [+_[0], +_[1]];
          return zoom;
        };
        zoom.center = function(_) {
          if (!arguments.length)
            return center;
          center = _ && [+_[0], +_[1]];
          return zoom;
        };
        zoom.size = function(_) {
          if (!arguments.length)
            return size;
          size = _ && [+_[0], +_[1]];
          return zoom;
        };
        zoom.duration = function(_) {
          if (!arguments.length)
            return duration;
          duration = +_;
          return zoom;
        };
        zoom.x = function(z) {
          if (!arguments.length)
            return x1;
          x1 = z;
          x0 = z.copy();
          view = {
            x: 0,
            y: 0,
            k: 1
          };
          return zoom;
        };
        zoom.y = function(z) {
          if (!arguments.length)
            return y1;
          y1 = z;
          y0 = z.copy();
          view = {
            x: 0,
            y: 0,
            k: 1
          };
          return zoom;
        };
        function location(p) {
          return [(p[0] - view.x) / view.k, (p[1] - view.y) / view.k];
        }
        function point(l) {
          return [l[0] * view.k + view.x, l[1] * view.k + view.y];
        }
        function scaleTo(s) {
          view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
        }
        function translateTo(p, l) {
          l = point(l);
          view.x += p[0] - l[0];
          view.y += p[1] - l[1];
        }
        function zoomTo(that, p, l, k) {
          that.__chart__ = {
            x: view.x,
            y: view.y,
            k: view.k
          };
          scaleTo(Math.pow(2, k));
          translateTo(center0 = p, l);
          that = d3.select(that);
          if (duration > 0)
            that = that.transition().duration(duration);
          that.call(zoom.event);
        }
        function rescale() {
          if (x1)
            x1.domain(x0.range().map(function(x) {
              return (x - view.x) / view.k;
            }).map(x0.invert));
          if (y1)
            y1.domain(y0.range().map(function(y) {
              return (y - view.y) / view.k;
            }).map(y0.invert));
        }
        function zoomstarted(dispatch) {
          if (!zooming++)
            dispatch({type: "zoomstart"});
        }
        function zoomed(dispatch) {
          rescale();
          dispatch({
            type: "zoom",
            scale: view.k,
            translate: [view.x, view.y]
          });
        }
        function zoomended(dispatch) {
          if (!--zooming)
            dispatch({type: "zoomend"});
          center0 = null;
        }
        function mousedowned() {
          var that = this,
              target = d3.event.target,
              dispatch = event.of(that, arguments),
              dragged = 0,
              subject = d3.select(d3_window).on(mousemove, moved).on(mouseup, ended),
              location0 = location(d3.mouse(that)),
              dragRestore = d3_event_dragSuppress();
          d3_selection_interrupt(that);
          zoomstarted(dispatch);
          function moved() {
            dragged = 1;
            translateTo(d3.mouse(that), location0);
            zoomed(dispatch);
          }
          function ended() {
            subject.on(mousemove, null).on(mouseup, null);
            dragRestore(dragged && d3.event.target === target);
            zoomended(dispatch);
          }
        }
        function touchstarted() {
          var that = this,
              dispatch = event.of(that, arguments),
              locations0 = {},
              distance0 = 0,
              scale0,
              zoomName = ".zoom-" + d3.event.changedTouches[0].identifier,
              touchmove = "touchmove" + zoomName,
              touchend = "touchend" + zoomName,
              targets = [],
              subject = d3.select(that),
              dragRestore = d3_event_dragSuppress();
          started();
          zoomstarted(dispatch);
          subject.on(mousedown, null).on(touchstart, started);
          function relocate() {
            var touches = d3.touches(that);
            scale0 = view.k;
            touches.forEach(function(t) {
              if (t.identifier in locations0)
                locations0[t.identifier] = location(t);
            });
            return touches;
          }
          function started() {
            var target = d3.event.target;
            d3.select(target).on(touchmove, moved).on(touchend, ended);
            targets.push(target);
            var changed = d3.event.changedTouches;
            for (var i = 0,
                n = changed.length; i < n; ++i) {
              locations0[changed[i].identifier] = null;
            }
            var touches = relocate(),
                now = Date.now();
            if (touches.length === 1) {
              if (now - touchtime < 500) {
                var p = touches[0];
                zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                d3_eventPreventDefault();
              }
              touchtime = now;
            } else if (touches.length > 1) {
              var p = touches[0],
                  q = touches[1],
                  dx = p[0] - q[0],
                  dy = p[1] - q[1];
              distance0 = dx * dx + dy * dy;
            }
          }
          function moved() {
            var touches = d3.touches(that),
                p0,
                l0,
                p1,
                l1;
            d3_selection_interrupt(that);
            for (var i = 0,
                n = touches.length; i < n; ++i, l1 = null) {
              p1 = touches[i];
              if (l1 = locations0[p1.identifier]) {
                if (l0)
                  break;
                p0 = p1, l0 = l1;
              }
            }
            if (l1) {
              var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1,
                  scale1 = distance0 && Math.sqrt(distance1 / distance0);
              p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
              l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
              scaleTo(scale1 * scale0);
            }
            touchtime = null;
            translateTo(p0, l0);
            zoomed(dispatch);
          }
          function ended() {
            if (d3.event.touches.length) {
              var changed = d3.event.changedTouches;
              for (var i = 0,
                  n = changed.length; i < n; ++i) {
                delete locations0[changed[i].identifier];
              }
              for (var identifier in locations0) {
                return void relocate();
              }
            }
            d3.selectAll(targets).on(zoomName, null);
            subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
            dragRestore();
            zoomended(dispatch);
          }
        }
        function mousewheeled() {
          var dispatch = event.of(this, arguments);
          if (mousewheelTimer)
            clearTimeout(mousewheelTimer);
          else
            translate0 = location(center0 = center || d3.mouse(this)), d3_selection_interrupt(this), zoomstarted(dispatch);
          mousewheelTimer = setTimeout(function() {
            mousewheelTimer = null;
            zoomended(dispatch);
          }, 50);
          d3_eventPreventDefault();
          scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
          translateTo(center0, translate0);
          zoomed(dispatch);
        }
        function dblclicked() {
          var p = d3.mouse(this),
              k = Math.log(view.k) / Math.LN2;
          zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
        }
        return d3.rebind(zoom, event, "on");
      };
      var d3_behavior_zoomInfinity = [0, Infinity];
      var d3_behavior_zoomDelta,
          d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
            return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
          }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
            return d3.event.wheelDelta;
          }, "mousewheel") : (d3_behavior_zoomDelta = function() {
            return -d3.event.detail;
          }, "MozMousePixelScroll");
      d3.color = d3_color;
      function d3_color() {}
      d3_color.prototype.toString = function() {
        return this.rgb() + "";
      };
      d3.hsl = d3_hsl;
      function d3_hsl(h, s, l) {
        return this instanceof d3_hsl ? void(this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
      }
      var d3_hslPrototype = d3_hsl.prototype = new d3_color();
      d3_hslPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, this.l / k);
      };
      d3_hslPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, k * this.l);
      };
      d3_hslPrototype.rgb = function() {
        return d3_hsl_rgb(this.h, this.s, this.l);
      };
      function d3_hsl_rgb(h, s, l) {
        var m1,
            m2;
        h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
        s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
        l = l < 0 ? 0 : l > 1 ? 1 : l;
        m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
        m1 = 2 * l - m2;
        function v(h) {
          if (h > 360)
            h -= 360;
          else if (h < 0)
            h += 360;
          if (h < 60)
            return m1 + (m2 - m1) * h / 60;
          if (h < 180)
            return m2;
          if (h < 240)
            return m1 + (m2 - m1) * (240 - h) / 60;
          return m1;
        }
        function vv(h) {
          return Math.round(v(h) * 255);
        }
        return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
      }
      d3.hcl = d3_hcl;
      function d3_hcl(h, c, l) {
        return this instanceof d3_hcl ? void(this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
      }
      var d3_hclPrototype = d3_hcl.prototype = new d3_color();
      d3_hclPrototype.brighter = function(k) {
        return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
      };
      d3_hclPrototype.darker = function(k) {
        return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
      };
      d3_hclPrototype.rgb = function() {
        return d3_hcl_lab(this.h, this.c, this.l).rgb();
      };
      function d3_hcl_lab(h, c, l) {
        if (isNaN(h))
          h = 0;
        if (isNaN(c))
          c = 0;
        return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
      }
      d3.lab = d3_lab;
      function d3_lab(l, a, b) {
        return this instanceof d3_lab ? void(this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
      }
      var d3_lab_K = 18;
      var d3_lab_X = .95047,
          d3_lab_Y = 1,
          d3_lab_Z = 1.08883;
      var d3_labPrototype = d3_lab.prototype = new d3_color();
      d3_labPrototype.brighter = function(k) {
        return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
      };
      d3_labPrototype.darker = function(k) {
        return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
      };
      d3_labPrototype.rgb = function() {
        return d3_lab_rgb(this.l, this.a, this.b);
      };
      function d3_lab_rgb(l, a, b) {
        var y = (l + 16) / 116,
            x = y + a / 500,
            z = y - b / 200;
        x = d3_lab_xyz(x) * d3_lab_X;
        y = d3_lab_xyz(y) * d3_lab_Y;
        z = d3_lab_xyz(z) * d3_lab_Z;
        return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
      }
      function d3_lab_hcl(l, a, b) {
        return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
      }
      function d3_lab_xyz(x) {
        return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
      }
      function d3_xyz_lab(x) {
        return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
      }
      function d3_xyz_rgb(r) {
        return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
      }
      d3.rgb = d3_rgb;
      function d3_rgb(r, g, b) {
        return this instanceof d3_rgb ? void(this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
      }
      function d3_rgbNumber(value) {
        return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
      }
      function d3_rgbString(value) {
        return d3_rgbNumber(value) + "";
      }
      var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
      d3_rgbPrototype.brighter = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        var r = this.r,
            g = this.g,
            b = this.b,
            i = 30;
        if (!r && !g && !b)
          return new d3_rgb(i, i, i);
        if (r && r < i)
          r = i;
        if (g && g < i)
          g = i;
        if (b && b < i)
          b = i;
        return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
      };
      d3_rgbPrototype.darker = function(k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_rgb(k * this.r, k * this.g, k * this.b);
      };
      d3_rgbPrototype.hsl = function() {
        return d3_rgb_hsl(this.r, this.g, this.b);
      };
      d3_rgbPrototype.toString = function() {
        return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
      };
      function d3_rgb_hex(v) {
        return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
      }
      function d3_rgb_parse(format, rgb, hsl) {
        var r = 0,
            g = 0,
            b = 0,
            m1,
            m2,
            color;
        m1 = /([a-z]+)\((.*)\)/i.exec(format);
        if (m1) {
          m2 = m1[2].split(",");
          switch (m1[1]) {
            case "hsl":
              {
                return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
              }
            case "rgb":
              {
                return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
              }
          }
        }
        if (color = d3_rgb_names.get(format))
          return rgb(color.r, color.g, color.b);
        if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
          if (format.length === 4) {
            r = (color & 3840) >> 4;
            r = r >> 4 | r;
            g = color & 240;
            g = g >> 4 | g;
            b = color & 15;
            b = b << 4 | b;
          } else if (format.length === 7) {
            r = (color & 16711680) >> 16;
            g = (color & 65280) >> 8;
            b = color & 255;
          }
        }
        return rgb(r, g, b);
      }
      function d3_rgb_hsl(r, g, b) {
        var min = Math.min(r /= 255, g /= 255, b /= 255),
            max = Math.max(r, g, b),
            d = max - min,
            h,
            s,
            l = (max + min) / 2;
        if (d) {
          s = l < .5 ? d / (max + min) : d / (2 - max - min);
          if (r == max)
            h = (g - b) / d + (g < b ? 6 : 0);
          else if (g == max)
            h = (b - r) / d + 2;
          else
            h = (r - g) / d + 4;
          h *= 60;
        } else {
          h = NaN;
          s = l > 0 && l < 1 ? 0 : h;
        }
        return new d3_hsl(h, s, l);
      }
      function d3_rgb_lab(r, g, b) {
        r = d3_rgb_xyz(r);
        g = d3_rgb_xyz(g);
        b = d3_rgb_xyz(b);
        var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X),
            y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y),
            z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
        return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
      }
      function d3_rgb_xyz(r) {
        return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
      }
      function d3_rgb_parseNumber(c) {
        var f = parseFloat(c);
        return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
      }
      var d3_rgb_names = d3.map({
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
      });
      d3_rgb_names.forEach(function(key, value) {
        d3_rgb_names.set(key, d3_rgbNumber(value));
      });
      function d3_functor(v) {
        return typeof v === "function" ? v : function() {
          return v;
        };
      }
      d3.functor = d3_functor;
      function d3_identity(d) {
        return d;
      }
      d3.xhr = d3_xhrType(d3_identity);
      function d3_xhrType(response) {
        return function(url, mimeType, callback) {
          if (arguments.length === 2 && typeof mimeType === "function")
            callback = mimeType, mimeType = null;
          return d3_xhr(url, mimeType, response, callback);
        };
      }
      function d3_xhr(url, mimeType, response, callback) {
        var xhr = {},
            dispatch = d3.dispatch("beforesend", "progress", "load", "error"),
            headers = {},
            request = new XMLHttpRequest(),
            responseType = null;
        if (d3_window.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url))
          request = new XDomainRequest();
        "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
          request.readyState > 3 && respond();
        };
        function respond() {
          var status = request.status,
              result;
          if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
            try {
              result = response.call(xhr, request);
            } catch (e) {
              dispatch.error.call(xhr, e);
              return;
            }
            dispatch.load.call(xhr, result);
          } else {
            dispatch.error.call(xhr, request);
          }
        }
        request.onprogress = function(event) {
          var o = d3.event;
          d3.event = event;
          try {
            dispatch.progress.call(xhr, request);
          } finally {
            d3.event = o;
          }
        };
        xhr.header = function(name, value) {
          name = (name + "").toLowerCase();
          if (arguments.length < 2)
            return headers[name];
          if (value == null)
            delete headers[name];
          else
            headers[name] = value + "";
          return xhr;
        };
        xhr.mimeType = function(value) {
          if (!arguments.length)
            return mimeType;
          mimeType = value == null ? null : value + "";
          return xhr;
        };
        xhr.responseType = function(value) {
          if (!arguments.length)
            return responseType;
          responseType = value;
          return xhr;
        };
        xhr.response = function(value) {
          response = value;
          return xhr;
        };
        ["get", "post"].forEach(function(method) {
          xhr[method] = function() {
            return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));
          };
        });
        xhr.send = function(method, data, callback) {
          if (arguments.length === 2 && typeof data === "function")
            callback = data, data = null;
          request.open(method, url, true);
          if (mimeType != null && !("accept" in headers))
            headers["accept"] = mimeType + ",*/*";
          if (request.setRequestHeader)
            for (var name in headers)
              request.setRequestHeader(name, headers[name]);
          if (mimeType != null && request.overrideMimeType)
            request.overrideMimeType(mimeType);
          if (responseType != null)
            request.responseType = responseType;
          if (callback != null)
            xhr.on("error", callback).on("load", function(request) {
              callback(null, request);
            });
          dispatch.beforesend.call(xhr, request);
          request.send(data == null ? null : data);
          return xhr;
        };
        xhr.abort = function() {
          request.abort();
          return xhr;
        };
        d3.rebind(xhr, dispatch, "on");
        return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
      }
      function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function(error, request) {
          callback(error == null ? request : null);
        } : callback;
      }
      function d3_xhrHasResponse(request) {
        var type = request.responseType;
        return type && type !== "text" ? request.response : request.responseText;
      }
      d3.dsv = function(delimiter, mimeType) {
        var reFormat = new RegExp('["' + delimiter + "\n]"),
            delimiterCode = delimiter.charCodeAt(0);
        function dsv(url, row, callback) {
          if (arguments.length < 3)
            callback = row, row = null;
          var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
          xhr.row = function(_) {
            return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
          };
          return xhr;
        }
        function response(request) {
          return dsv.parse(request.responseText);
        }
        function typedResponse(f) {
          return function(request) {
            return dsv.parse(request.responseText, f);
          };
        }
        dsv.parse = function(text, f) {
          var o;
          return dsv.parseRows(text, function(row, i) {
            if (o)
              return o(row, i - 1);
            var a = new Function("d", "return {" + row.map(function(name, i) {
              return JSON.stringify(name) + ": d[" + i + "]";
            }).join(",") + "}");
            o = f ? function(row, i) {
              return f(a(row), i);
            } : a;
          });
        };
        dsv.parseRows = function(text, f) {
          var EOL = {},
              EOF = {},
              rows = [],
              N = text.length,
              I = 0,
              n = 0,
              t,
              eol;
          function token() {
            if (I >= N)
              return EOF;
            if (eol)
              return eol = false, EOL;
            var j = I;
            if (text.charCodeAt(j) === 34) {
              var i = j;
              while (i++ < N) {
                if (text.charCodeAt(i) === 34) {
                  if (text.charCodeAt(i + 1) !== 34)
                    break;
                  ++i;
                }
              }
              I = i + 2;
              var c = text.charCodeAt(i + 1);
              if (c === 13) {
                eol = true;
                if (text.charCodeAt(i + 2) === 10)
                  ++I;
              } else if (c === 10) {
                eol = true;
              }
              return text.slice(j + 1, i).replace(/""/g, '"');
            }
            while (I < N) {
              var c = text.charCodeAt(I++),
                  k = 1;
              if (c === 10)
                eol = true;
              else if (c === 13) {
                eol = true;
                if (text.charCodeAt(I) === 10)
                  ++I, ++k;
              } else if (c !== delimiterCode)
                continue;
              return text.slice(j, I - k);
            }
            return text.slice(j);
          }
          while ((t = token()) !== EOF) {
            var a = [];
            while (t !== EOL && t !== EOF) {
              a.push(t);
              t = token();
            }
            if (f && (a = f(a, n++)) == null)
              continue;
            rows.push(a);
          }
          return rows;
        };
        dsv.format = function(rows) {
          if (Array.isArray(rows[0]))
            return dsv.formatRows(rows);
          var fieldSet = new d3_Set(),
              fields = [];
          rows.forEach(function(row) {
            for (var field in row) {
              if (!fieldSet.has(field)) {
                fields.push(fieldSet.add(field));
              }
            }
          });
          return [fields.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
            return fields.map(function(field) {
              return formatValue(row[field]);
            }).join(delimiter);
          })).join("\n");
        };
        dsv.formatRows = function(rows) {
          return rows.map(formatRow).join("\n");
        };
        function formatRow(row) {
          return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
          return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
        }
        return dsv;
      };
      d3.csv = d3.dsv(",", "text/csv");
      d3.tsv = d3.dsv("	", "text/tab-separated-values");
      var d3_timer_queueHead,
          d3_timer_queueTail,
          d3_timer_interval,
          d3_timer_timeout,
          d3_timer_active,
          d3_timer_frame = d3_window[d3_vendorSymbol(d3_window, "requestAnimationFrame")] || function(callback) {
            setTimeout(callback, 17);
          };
      d3.timer = function(callback, delay, then) {
        var n = arguments.length;
        if (n < 2)
          delay = 0;
        if (n < 3)
          then = Date.now();
        var time = then + delay,
            timer = {
              c: callback,
              t: time,
              f: false,
              n: null
            };
        if (d3_timer_queueTail)
          d3_timer_queueTail.n = timer;
        else
          d3_timer_queueHead = timer;
        d3_timer_queueTail = timer;
        if (!d3_timer_interval) {
          d3_timer_timeout = clearTimeout(d3_timer_timeout);
          d3_timer_interval = 1;
          d3_timer_frame(d3_timer_step);
        }
      };
      function d3_timer_step() {
        var now = d3_timer_mark(),
            delay = d3_timer_sweep() - now;
        if (delay > 24) {
          if (isFinite(delay)) {
            clearTimeout(d3_timer_timeout);
            d3_timer_timeout = setTimeout(d3_timer_step, delay);
          }
          d3_timer_interval = 0;
        } else {
          d3_timer_interval = 1;
          d3_timer_frame(d3_timer_step);
        }
      }
      d3.timer.flush = function() {
        d3_timer_mark();
        d3_timer_sweep();
      };
      function d3_timer_mark() {
        var now = Date.now();
        d3_timer_active = d3_timer_queueHead;
        while (d3_timer_active) {
          if (now >= d3_timer_active.t)
            d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
          d3_timer_active = d3_timer_active.n;
        }
        return now;
      }
      function d3_timer_sweep() {
        var t0,
            t1 = d3_timer_queueHead,
            time = Infinity;
        while (t1) {
          if (t1.f) {
            t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
          } else {
            if (t1.t < time)
              time = t1.t;
            t1 = (t0 = t1).n;
          }
        }
        d3_timer_queueTail = t0;
        return time;
      }
      function d3_format_precision(x, p) {
        return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
      }
      d3.round = function(x, n) {
        return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
      };
      var d3_formatPrefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"].map(d3_formatPrefix);
      d3.formatPrefix = function(value, precision) {
        var i = 0;
        if (value) {
          if (value < 0)
            value *= -1;
          if (precision)
            value = d3.round(value, d3_format_precision(value, precision));
          i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
          i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
        }
        return d3_formatPrefixes[8 + i / 3];
      };
      function d3_formatPrefix(d, i) {
        var k = Math.pow(10, abs(8 - i) * 3);
        return {
          scale: i > 8 ? function(d) {
            return d / k;
          } : function(d) {
            return d * k;
          },
          symbol: d
        };
      }
      function d3_locale_numberFormat(locale) {
        var locale_decimal = locale.decimal,
            locale_thousands = locale.thousands,
            locale_grouping = locale.grouping,
            locale_currency = locale.currency,
            formatGroup = locale_grouping && locale_thousands ? function(value, width) {
              var i = value.length,
                  t = [],
                  j = 0,
                  g = locale_grouping[0],
                  length = 0;
              while (i > 0 && g > 0) {
                if (length + g + 1 > width)
                  g = Math.max(1, width - length);
                t.push(value.substring(i -= g, i + g));
                if ((length += g + 1) > width)
                  break;
                g = locale_grouping[j = (j + 1) % locale_grouping.length];
              }
              return t.reverse().join(locale_thousands);
            } : d3_identity;
        return function(specifier) {
          var match = d3_format_re.exec(specifier),
              fill = match[1] || " ",
              align = match[2] || ">",
              sign = match[3] || "-",
              symbol = match[4] || "",
              zfill = match[5],
              width = +match[6],
              comma = match[7],
              precision = match[8],
              type = match[9],
              scale = 1,
              prefix = "",
              suffix = "",
              integer = false,
              exponent = true;
          if (precision)
            precision = +precision.substring(1);
          if (zfill || fill === "0" && align === "=") {
            zfill = fill = "0";
            align = "=";
          }
          switch (type) {
            case "n":
              comma = true;
              type = "g";
              break;
            case "%":
              scale = 100;
              suffix = "%";
              type = "f";
              break;
            case "p":
              scale = 100;
              suffix = "%";
              type = "r";
              break;
            case "b":
            case "o":
            case "x":
            case "X":
              if (symbol === "#")
                prefix = "0" + type.toLowerCase();
            case "c":
              exponent = false;
            case "d":
              integer = true;
              precision = 0;
              break;
            case "s":
              scale = -1;
              type = "r";
              break;
          }
          if (symbol === "$")
            prefix = locale_currency[0], suffix = locale_currency[1];
          if (type == "r" && !precision)
            type = "g";
          if (precision != null) {
            if (type == "g")
              precision = Math.max(1, Math.min(21, precision));
            else if (type == "e" || type == "f")
              precision = Math.max(0, Math.min(20, precision));
          }
          type = d3_format_types.get(type) || d3_format_typeDefault;
          var zcomma = zfill && comma;
          return function(value) {
            var fullSuffix = suffix;
            if (integer && value % 1)
              return "";
            var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
            if (scale < 0) {
              var unit = d3.formatPrefix(value, precision);
              value = unit.scale(value);
              fullSuffix = unit.symbol + suffix;
            } else {
              value *= scale;
            }
            value = type(value, precision);
            var i = value.lastIndexOf("."),
                before,
                after;
            if (i < 0) {
              var j = exponent ? value.lastIndexOf("e") : -1;
              if (j < 0)
                before = value, after = "";
              else
                before = value.substring(0, j), after = value.substring(j);
            } else {
              before = value.substring(0, i);
              after = locale_decimal + value.substring(i + 1);
            }
            if (!zfill && comma)
              before = formatGroup(before, Infinity);
            var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length),
                padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
            if (zcomma)
              before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
            negative += prefix;
            value = before + after;
            return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
          };
        };
      }
      var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
      var d3_format_types = d3.map({
        b: function(x) {
          return x.toString(2);
        },
        c: function(x) {
          return String.fromCharCode(x);
        },
        o: function(x) {
          return x.toString(8);
        },
        x: function(x) {
          return x.toString(16);
        },
        X: function(x) {
          return x.toString(16).toUpperCase();
        },
        g: function(x, p) {
          return x.toPrecision(p);
        },
        e: function(x, p) {
          return x.toExponential(p);
        },
        f: function(x, p) {
          return x.toFixed(p);
        },
        r: function(x, p) {
          return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
        }
      });
      function d3_format_typeDefault(x) {
        return x + "";
      }
      var d3_time = d3.time = {},
          d3_date = Date;
      function d3_date_utc() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
      }
      d3_date_utc.prototype = {
        getDate: function() {
          return this._.getUTCDate();
        },
        getDay: function() {
          return this._.getUTCDay();
        },
        getFullYear: function() {
          return this._.getUTCFullYear();
        },
        getHours: function() {
          return this._.getUTCHours();
        },
        getMilliseconds: function() {
          return this._.getUTCMilliseconds();
        },
        getMinutes: function() {
          return this._.getUTCMinutes();
        },
        getMonth: function() {
          return this._.getUTCMonth();
        },
        getSeconds: function() {
          return this._.getUTCSeconds();
        },
        getTime: function() {
          return this._.getTime();
        },
        getTimezoneOffset: function() {
          return 0;
        },
        valueOf: function() {
          return this._.valueOf();
        },
        setDate: function() {
          d3_time_prototype.setUTCDate.apply(this._, arguments);
        },
        setDay: function() {
          d3_time_prototype.setUTCDay.apply(this._, arguments);
        },
        setFullYear: function() {
          d3_time_prototype.setUTCFullYear.apply(this._, arguments);
        },
        setHours: function() {
          d3_time_prototype.setUTCHours.apply(this._, arguments);
        },
        setMilliseconds: function() {
          d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
        },
        setMinutes: function() {
          d3_time_prototype.setUTCMinutes.apply(this._, arguments);
        },
        setMonth: function() {
          d3_time_prototype.setUTCMonth.apply(this._, arguments);
        },
        setSeconds: function() {
          d3_time_prototype.setUTCSeconds.apply(this._, arguments);
        },
        setTime: function() {
          d3_time_prototype.setTime.apply(this._, arguments);
        }
      };
      var d3_time_prototype = Date.prototype;
      function d3_time_interval(local, step, number) {
        function round(date) {
          var d0 = local(date),
              d1 = offset(d0, 1);
          return date - d0 < d1 - date ? d0 : d1;
        }
        function ceil(date) {
          step(date = local(new d3_date(date - 1)), 1);
          return date;
        }
        function offset(date, k) {
          step(date = new d3_date(+date), k);
          return date;
        }
        function range(t0, t1, dt) {
          var time = ceil(t0),
              times = [];
          if (dt > 1) {
            while (time < t1) {
              if (!(number(time) % dt))
                times.push(new Date(+time));
              step(time, 1);
            }
          } else {
            while (time < t1)
              times.push(new Date(+time)), step(time, 1);
          }
          return times;
        }
        function range_utc(t0, t1, dt) {
          try {
            d3_date = d3_date_utc;
            var utc = new d3_date_utc();
            utc._ = t0;
            return range(utc, t1, dt);
          } finally {
            d3_date = Date;
          }
        }
        local.floor = local;
        local.round = round;
        local.ceil = ceil;
        local.offset = offset;
        local.range = range;
        var utc = local.utc = d3_time_interval_utc(local);
        utc.floor = utc;
        utc.round = d3_time_interval_utc(round);
        utc.ceil = d3_time_interval_utc(ceil);
        utc.offset = d3_time_interval_utc(offset);
        utc.range = range_utc;
        return local;
      }
      function d3_time_interval_utc(method) {
        return function(date, k) {
          try {
            d3_date = d3_date_utc;
            var utc = new d3_date_utc();
            utc._ = date;
            return method(utc, k)._;
          } finally {
            d3_date = Date;
          }
        };
      }
      d3_time.year = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setMonth(0, 1);
        return date;
      }, function(date, offset) {
        date.setFullYear(date.getFullYear() + offset);
      }, function(date) {
        return date.getFullYear();
      });
      d3_time.years = d3_time.year.range;
      d3_time.years.utc = d3_time.year.utc.range;
      d3_time.day = d3_time_interval(function(date) {
        var day = new d3_date(2e3, 0);
        day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        return day;
      }, function(date, offset) {
        date.setDate(date.getDate() + offset);
      }, function(date) {
        return date.getDate() - 1;
      });
      d3_time.days = d3_time.day.range;
      d3_time.days.utc = d3_time.day.utc.range;
      d3_time.dayOfYear = function(date) {
        var year = d3_time.year(date);
        return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
      };
      ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"].forEach(function(day, i) {
        i = 7 - i;
        var interval = d3_time[day] = d3_time_interval(function(date) {
          (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
          return date;
        }, function(date, offset) {
          date.setDate(date.getDate() + Math.floor(offset) * 7);
        }, function(date) {
          var day = d3_time.year(date).getDay();
          return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
        });
        d3_time[day + "s"] = interval.range;
        d3_time[day + "s"].utc = interval.utc.range;
        d3_time[day + "OfYear"] = function(date) {
          var day = d3_time.year(date).getDay();
          return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
        };
      });
      d3_time.week = d3_time.sunday;
      d3_time.weeks = d3_time.sunday.range;
      d3_time.weeks.utc = d3_time.sunday.utc.range;
      d3_time.weekOfYear = d3_time.sundayOfYear;
      function d3_locale_timeFormat(locale) {
        var locale_dateTime = locale.dateTime,
            locale_date = locale.date,
            locale_time = locale.time,
            locale_periods = locale.periods,
            locale_days = locale.days,
            locale_shortDays = locale.shortDays,
            locale_months = locale.months,
            locale_shortMonths = locale.shortMonths;
        function d3_time_format(template) {
          var n = template.length;
          function format(date) {
            var string = [],
                i = -1,
                j = 0,
                c,
                p,
                f;
            while (++i < n) {
              if (template.charCodeAt(i) === 37) {
                string.push(template.slice(j, i));
                if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null)
                  c = template.charAt(++i);
                if (f = d3_time_formats[c])
                  c = f(date, p == null ? c === "e" ? " " : "0" : p);
                string.push(c);
                j = i + 1;
              }
            }
            string.push(template.slice(j, i));
            return string.join("");
          }
          format.parse = function(string) {
            var d = {
              y: 1900,
              m: 0,
              d: 1,
              H: 0,
              M: 0,
              S: 0,
              L: 0,
              Z: null
            },
                i = d3_time_parse(d, template, string, 0);
            if (i != string.length)
              return null;
            if ("p" in d)
              d.H = d.H % 12 + d.p * 12;
            var localZ = d.Z != null && d3_date !== d3_date_utc,
                date = new (localZ ? d3_date_utc : d3_date)();
            if ("j" in d)
              date.setFullYear(d.y, 0, d.j);
            else if ("w" in d && ("W" in d || "U" in d)) {
              date.setFullYear(d.y, 0, 1);
              date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
            } else
              date.setFullYear(d.y, d.m, d.d);
            date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
            return localZ ? date._ : date;
          };
          format.toString = function() {
            return template;
          };
          return format;
        }
        function d3_time_parse(date, template, string, j) {
          var c,
              p,
              t,
              i = 0,
              n = template.length,
              m = string.length;
          while (i < n) {
            if (j >= m)
              return -1;
            c = template.charCodeAt(i++);
            if (c === 37) {
              t = template.charAt(i++);
              p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
              if (!p || (j = p(date, string, j)) < 0)
                return -1;
            } else if (c != string.charCodeAt(j++)) {
              return -1;
            }
          }
          return j;
        }
        d3_time_format.utc = function(template) {
          var local = d3_time_format(template);
          function format(date) {
            try {
              d3_date = d3_date_utc;
              var utc = new d3_date();
              utc._ = date;
              return local(utc);
            } finally {
              d3_date = Date;
            }
          }
          format.parse = function(string) {
            try {
              d3_date = d3_date_utc;
              var date = local.parse(string);
              return date && date._;
            } finally {
              d3_date = Date;
            }
          };
          format.toString = local.toString;
          return format;
        };
        d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
        var d3_time_periodLookup = d3.map(),
            d3_time_dayRe = d3_time_formatRe(locale_days),
            d3_time_dayLookup = d3_time_formatLookup(locale_days),
            d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays),
            d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays),
            d3_time_monthRe = d3_time_formatRe(locale_months),
            d3_time_monthLookup = d3_time_formatLookup(locale_months),
            d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths),
            d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
        locale_periods.forEach(function(p, i) {
          d3_time_periodLookup.set(p.toLowerCase(), i);
        });
        var d3_time_formats = {
          a: function(d) {
            return locale_shortDays[d.getDay()];
          },
          A: function(d) {
            return locale_days[d.getDay()];
          },
          b: function(d) {
            return locale_shortMonths[d.getMonth()];
          },
          B: function(d) {
            return locale_months[d.getMonth()];
          },
          c: d3_time_format(locale_dateTime),
          d: function(d, p) {
            return d3_time_formatPad(d.getDate(), p, 2);
          },
          e: function(d, p) {
            return d3_time_formatPad(d.getDate(), p, 2);
          },
          H: function(d, p) {
            return d3_time_formatPad(d.getHours(), p, 2);
          },
          I: function(d, p) {
            return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
          },
          j: function(d, p) {
            return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
          },
          L: function(d, p) {
            return d3_time_formatPad(d.getMilliseconds(), p, 3);
          },
          m: function(d, p) {
            return d3_time_formatPad(d.getMonth() + 1, p, 2);
          },
          M: function(d, p) {
            return d3_time_formatPad(d.getMinutes(), p, 2);
          },
          p: function(d) {
            return locale_periods[+(d.getHours() >= 12)];
          },
          S: function(d, p) {
            return d3_time_formatPad(d.getSeconds(), p, 2);
          },
          U: function(d, p) {
            return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
          },
          w: function(d) {
            return d.getDay();
          },
          W: function(d, p) {
            return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
          },
          x: d3_time_format(locale_date),
          X: d3_time_format(locale_time),
          y: function(d, p) {
            return d3_time_formatPad(d.getFullYear() % 100, p, 2);
          },
          Y: function(d, p) {
            return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
          },
          Z: d3_time_zone,
          "%": function() {
            return "%";
          }
        };
        var d3_time_parsers = {
          a: d3_time_parseWeekdayAbbrev,
          A: d3_time_parseWeekday,
          b: d3_time_parseMonthAbbrev,
          B: d3_time_parseMonth,
          c: d3_time_parseLocaleFull,
          d: d3_time_parseDay,
          e: d3_time_parseDay,
          H: d3_time_parseHour24,
          I: d3_time_parseHour24,
          j: d3_time_parseDayOfYear,
          L: d3_time_parseMilliseconds,
          m: d3_time_parseMonthNumber,
          M: d3_time_parseMinutes,
          p: d3_time_parseAmPm,
          S: d3_time_parseSeconds,
          U: d3_time_parseWeekNumberSunday,
          w: d3_time_parseWeekdayNumber,
          W: d3_time_parseWeekNumberMonday,
          x: d3_time_parseLocaleDate,
          X: d3_time_parseLocaleTime,
          y: d3_time_parseYear,
          Y: d3_time_parseFullYear,
          Z: d3_time_parseZone,
          "%": d3_time_parseLiteralPercent
        };
        function d3_time_parseWeekdayAbbrev(date, string, i) {
          d3_time_dayAbbrevRe.lastIndex = 0;
          var n = d3_time_dayAbbrevRe.exec(string.slice(i));
          return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseWeekday(date, string, i) {
          d3_time_dayRe.lastIndex = 0;
          var n = d3_time_dayRe.exec(string.slice(i));
          return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonthAbbrev(date, string, i) {
          d3_time_monthAbbrevRe.lastIndex = 0;
          var n = d3_time_monthAbbrevRe.exec(string.slice(i));
          return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonth(date, string, i) {
          d3_time_monthRe.lastIndex = 0;
          var n = d3_time_monthRe.exec(string.slice(i));
          return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseLocaleFull(date, string, i) {
          return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
        }
        function d3_time_parseLocaleDate(date, string, i) {
          return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
        }
        function d3_time_parseLocaleTime(date, string, i) {
          return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
        }
        function d3_time_parseAmPm(date, string, i) {
          var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
          return n == null ? -1 : (date.p = n, i);
        }
        return d3_time_format;
      }
      var d3_time_formatPads = {
        "-": "",
        _: " ",
        "0": "0"
      },
          d3_time_numberRe = /^\s*\d+/,
          d3_time_percentRe = /^%/;
      function d3_time_formatPad(value, fill, width) {
        var sign = value < 0 ? "-" : "",
            string = (sign ? -value : value) + "",
            length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
      }
      function d3_time_formatRe(names) {
        return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
      }
      function d3_time_formatLookup(names) {
        var map = new d3_Map(),
            i = -1,
            n = names.length;
        while (++i < n)
          map.set(names[i].toLowerCase(), i);
        return map;
      }
      function d3_time_parseWeekdayNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 1));
        return n ? (date.w = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseWeekNumberSunday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.U = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseWeekNumberMonday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.W = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseFullYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 4));
        return n ? (date.y = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
      }
      function d3_time_parseZone(date, string, i) {
        return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, i + 5) : -1;
      }
      function d3_time_expandYear(d) {
        return d + (d > 68 ? 1900 : 2e3);
      }
      function d3_time_parseMonthNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
      }
      function d3_time_parseDay(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.d = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseDayOfYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.j = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseHour24(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.H = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseMinutes(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.M = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseSeconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.S = +n[0], i + n[0].length) : -1;
      }
      function d3_time_parseMilliseconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.L = +n[0], i + n[0].length) : -1;
      }
      function d3_time_zone(d) {
        var z = d.getTimezoneOffset(),
            zs = z > 0 ? "-" : "+",
            zh = abs(z) / 60 | 0,
            zm = abs(z) % 60;
        return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
      }
      function d3_time_parseLiteralPercent(date, string, i) {
        d3_time_percentRe.lastIndex = 0;
        var n = d3_time_percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
      }
      function d3_time_formatMulti(formats) {
        var n = formats.length,
            i = -1;
        while (++i < n)
          formats[i][0] = this(formats[i][0]);
        return function(date) {
          var i = 0,
              f = formats[i];
          while (!f[1](date))
            f = formats[++i];
          return f[0](date);
        };
      }
      d3.locale = function(locale) {
        return {
          numberFormat: d3_locale_numberFormat(locale),
          timeFormat: d3_locale_timeFormat(locale)
        };
      };
      var d3_locale_enUS = d3.locale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["$", ""],
        dateTime: "%a %b %e %X %Y",
        date: "%m/%d/%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
      });
      d3.format = d3_locale_enUS.numberFormat;
      d3.geo = {};
      function d3_adder() {}
      d3_adder.prototype = {
        s: 0,
        t: 0,
        add: function(y) {
          d3_adderSum(y, this.t, d3_adderTemp);
          d3_adderSum(d3_adderTemp.s, this.s, this);
          if (this.s)
            this.t += d3_adderTemp.t;
          else
            this.s = d3_adderTemp.t;
        },
        reset: function() {
          this.s = this.t = 0;
        },
        valueOf: function() {
          return this.s;
        }
      };
      var d3_adderTemp = new d3_adder();
      function d3_adderSum(a, b, o) {
        var x = o.s = a + b,
            bv = x - a,
            av = x - bv;
        o.t = a - av + (b - bv);
      }
      d3.geo.stream = function(object, listener) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
          d3_geo_streamObjectType[object.type](object, listener);
        } else {
          d3_geo_streamGeometry(object, listener);
        }
      };
      function d3_geo_streamGeometry(geometry, listener) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
          d3_geo_streamGeometryType[geometry.type](geometry, listener);
        }
      }
      var d3_geo_streamObjectType = {
        Feature: function(feature, listener) {
          d3_geo_streamGeometry(feature.geometry, listener);
        },
        FeatureCollection: function(object, listener) {
          var features = object.features,
              i = -1,
              n = features.length;
          while (++i < n)
            d3_geo_streamGeometry(features[i].geometry, listener);
        }
      };
      var d3_geo_streamGeometryType = {
        Sphere: function(object, listener) {
          listener.sphere();
        },
        Point: function(object, listener) {
          object = object.coordinates;
          listener.point(object[0], object[1], object[2]);
        },
        MultiPoint: function(object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n)
            object = coordinates[i], listener.point(object[0], object[1], object[2]);
        },
        LineString: function(object, listener) {
          d3_geo_streamLine(object.coordinates, listener, 0);
        },
        MultiLineString: function(object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n)
            d3_geo_streamLine(coordinates[i], listener, 0);
        },
        Polygon: function(object, listener) {
          d3_geo_streamPolygon(object.coordinates, listener);
        },
        MultiPolygon: function(object, listener) {
          var coordinates = object.coordinates,
              i = -1,
              n = coordinates.length;
          while (++i < n)
            d3_geo_streamPolygon(coordinates[i], listener);
        },
        GeometryCollection: function(object, listener) {
          var geometries = object.geometries,
              i = -1,
              n = geometries.length;
          while (++i < n)
            d3_geo_streamGeometry(geometries[i], listener);
        }
      };
      function d3_geo_streamLine(coordinates, listener, closed) {
        var i = -1,
            n = coordinates.length - closed,
            coordinate;
        listener.lineStart();
        while (++i < n)
          coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
        listener.lineEnd();
      }
      function d3_geo_streamPolygon(coordinates, listener) {
        var i = -1,
            n = coordinates.length;
        listener.polygonStart();
        while (++i < n)
          d3_geo_streamLine(coordinates[i], listener, 1);
        listener.polygonEnd();
      }
      d3.geo.area = function(object) {
        d3_geo_areaSum = 0;
        d3.geo.stream(object, d3_geo_area);
        return d3_geo_areaSum;
      };
      var d3_geo_areaSum,
          d3_geo_areaRingSum = new d3_adder();
      var d3_geo_area = {
        sphere: function() {
          d3_geo_areaSum += 4 * π;
        },
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function() {
          d3_geo_areaRingSum.reset();
          d3_geo_area.lineStart = d3_geo_areaRingStart;
        },
        polygonEnd: function() {
          var area = 2 * d3_geo_areaRingSum;
          d3_geo_areaSum += area < 0 ? 4 * π + area : area;
          d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
        }
      };
      function d3_geo_areaRingStart() {
        var λ00,
            φ00,
            λ0,
            cosφ0,
            sinφ0;
        d3_geo_area.point = function(λ, φ) {
          d3_geo_area.point = nextPoint;
          λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), sinφ0 = Math.sin(φ);
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          φ = φ * d3_radians / 2 + π / 4;
          var dλ = λ - λ0,
              sdλ = dλ >= 0 ? 1 : -1,
              adλ = sdλ * dλ,
              cosφ = Math.cos(φ),
              sinφ = Math.sin(φ),
              k = sinφ0 * sinφ,
              u = cosφ0 * cosφ + k * Math.cos(adλ),
              v = k * sdλ * Math.sin(adλ);
          d3_geo_areaRingSum.add(Math.atan2(v, u));
          λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
        }
        d3_geo_area.lineEnd = function() {
          nextPoint(λ00, φ00);
        };
      }
      function d3_geo_cartesian(spherical) {
        var λ = spherical[0],
            φ = spherical[1],
            cosφ = Math.cos(φ);
        return [cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ)];
      }
      function d3_geo_cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
      }
      function d3_geo_cartesianCross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
      }
      function d3_geo_cartesianAdd(a, b) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
      }
      function d3_geo_cartesianScale(vector, k) {
        return [vector[0] * k, vector[1] * k, vector[2] * k];
      }
      function d3_geo_cartesianNormalize(d) {
        var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l;
        d[1] /= l;
        d[2] /= l;
      }
      function d3_geo_spherical(cartesian) {
        return [Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2])];
      }
      function d3_geo_sphericalEqual(a, b) {
        return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
      }
      d3.geo.bounds = function() {
        var λ0,
            φ0,
            λ1,
            φ1,
            λ_,
            λ__,
            φ__,
            p0,
            dλSum,
            ranges,
            range;
        var bound = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            bound.point = ringPoint;
            bound.lineStart = ringStart;
            bound.lineEnd = ringEnd;
            dλSum = 0;
            d3_geo_area.polygonStart();
          },
          polygonEnd: function() {
            d3_geo_area.polygonEnd();
            bound.point = point;
            bound.lineStart = lineStart;
            bound.lineEnd = lineEnd;
            if (d3_geo_areaRingSum < 0)
              λ0 = -(λ1 = 180), φ0 = -(φ1 = 90);
            else if (dλSum > ε)
              φ1 = 90;
            else if (dλSum < -ε)
              φ0 = -90;
            range[0] = λ0, range[1] = λ1;
          }
        };
        function point(λ, φ) {
          ranges.push(range = [λ0 = λ, λ1 = λ]);
          if (φ < φ0)
            φ0 = φ;
          if (φ > φ1)
            φ1 = φ;
        }
        function linePoint(λ, φ) {
          var p = d3_geo_cartesian([λ * d3_radians, φ * d3_radians]);
          if (p0) {
            var normal = d3_geo_cartesianCross(p0, p),
                equatorial = [normal[1], -normal[0], 0],
                inflection = d3_geo_cartesianCross(equatorial, normal);
            d3_geo_cartesianNormalize(inflection);
            inflection = d3_geo_spherical(inflection);
            var dλ = λ - λ_,
                s = dλ > 0 ? 1 : -1,
                λi = inflection[0] * d3_degrees * s,
                antimeridian = abs(dλ) > 180;
            if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
              var φi = inflection[1] * d3_degrees;
              if (φi > φ1)
                φ1 = φi;
            } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
              var φi = -inflection[1] * d3_degrees;
              if (φi < φ0)
                φ0 = φi;
            } else {
              if (φ < φ0)
                φ0 = φ;
              if (φ > φ1)
                φ1 = φ;
            }
            if (antimeridian) {
              if (λ < λ_) {
                if (angle(λ0, λ) > angle(λ0, λ1))
                  λ1 = λ;
              } else {
                if (angle(λ, λ1) > angle(λ0, λ1))
                  λ0 = λ;
              }
            } else {
              if (λ1 >= λ0) {
                if (λ < λ0)
                  λ0 = λ;
                if (λ > λ1)
                  λ1 = λ;
              } else {
                if (λ > λ_) {
                  if (angle(λ0, λ) > angle(λ0, λ1))
                    λ1 = λ;
                } else {
                  if (angle(λ, λ1) > angle(λ0, λ1))
                    λ0 = λ;
                }
              }
            }
          } else {
            point(λ, φ);
          }
          p0 = p, λ_ = λ;
        }
        function lineStart() {
          bound.point = linePoint;
        }
        function lineEnd() {
          range[0] = λ0, range[1] = λ1;
          bound.point = point;
          p0 = null;
        }
        function ringPoint(λ, φ) {
          if (p0) {
            var dλ = λ - λ_;
            dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
          } else
            λ__ = λ, φ__ = φ;
          d3_geo_area.point(λ, φ);
          linePoint(λ, φ);
        }
        function ringStart() {
          d3_geo_area.lineStart();
        }
        function ringEnd() {
          ringPoint(λ__, φ__);
          d3_geo_area.lineEnd();
          if (abs(dλSum) > ε)
            λ0 = -(λ1 = 180);
          range[0] = λ0, range[1] = λ1;
          p0 = null;
        }
        function angle(λ0, λ1) {
          return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
        }
        function compareRanges(a, b) {
          return a[0] - b[0];
        }
        function withinRange(x, range) {
          return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
        }
        return function(feature) {
          φ1 = λ1 = -(λ0 = φ0 = Infinity);
          ranges = [];
          d3.geo.stream(feature, bound);
          var n = ranges.length;
          if (n) {
            ranges.sort(compareRanges);
            for (var i = 1,
                a = ranges[0],
                b,
                merged = [a]; i < n; ++i) {
              b = ranges[i];
              if (withinRange(b[0], a) || withinRange(b[1], a)) {
                if (angle(a[0], b[1]) > angle(a[0], a[1]))
                  a[1] = b[1];
                if (angle(b[0], a[1]) > angle(a[0], a[1]))
                  a[0] = b[0];
              } else {
                merged.push(a = b);
              }
            }
            var best = -Infinity,
                dλ;
            for (var n = merged.length - 1,
                i = 0,
                a = merged[n],
                b; i <= n; a = b, ++i) {
              b = merged[i];
              if ((dλ = angle(a[1], b[0])) > best)
                best = dλ, λ0 = b[0], λ1 = a[1];
            }
          }
          ranges = range = null;
          return λ0 === Infinity || φ0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[λ0, φ0], [λ1, φ1]];
        };
      }();
      d3.geo.centroid = function(object) {
        d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
        d3.geo.stream(object, d3_geo_centroid);
        var x = d3_geo_centroidX2,
            y = d3_geo_centroidY2,
            z = d3_geo_centroidZ2,
            m = x * x + y * y + z * z;
        if (m < ε2) {
          x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
          if (d3_geo_centroidW1 < ε)
            x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
          m = x * x + y * y + z * z;
          if (m < ε2)
            return [NaN, NaN];
        }
        return [Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees];
      };
      var d3_geo_centroidW0,
          d3_geo_centroidW1,
          d3_geo_centroidX0,
          d3_geo_centroidY0,
          d3_geo_centroidZ0,
          d3_geo_centroidX1,
          d3_geo_centroidY1,
          d3_geo_centroidZ1,
          d3_geo_centroidX2,
          d3_geo_centroidY2,
          d3_geo_centroidZ2;
      var d3_geo_centroid = {
        sphere: d3_noop,
        point: d3_geo_centroidPoint,
        lineStart: d3_geo_centroidLineStart,
        lineEnd: d3_geo_centroidLineEnd,
        polygonStart: function() {
          d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
        },
        polygonEnd: function() {
          d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
        }
      };
      function d3_geo_centroidPoint(λ, φ) {
        λ *= d3_radians;
        var cosφ = Math.cos(φ *= d3_radians);
        d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
      }
      function d3_geo_centroidPointXYZ(x, y, z) {
        ++d3_geo_centroidW0;
        d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
        d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
        d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
      }
      function d3_geo_centroidLineStart() {
        var x0,
            y0,
            z0;
        d3_geo_centroid.point = function(λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians);
          x0 = cosφ * Math.cos(λ);
          y0 = cosφ * Math.sin(λ);
          z0 = Math.sin(φ);
          d3_geo_centroid.point = nextPoint;
          d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians),
              x = cosφ * Math.cos(λ),
              y = cosφ * Math.sin(λ),
              z = Math.sin(φ),
              w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
          d3_geo_centroidW1 += w;
          d3_geo_centroidX1 += w * (x0 + (x0 = x));
          d3_geo_centroidY1 += w * (y0 + (y0 = y));
          d3_geo_centroidZ1 += w * (z0 + (z0 = z));
          d3_geo_centroidPointXYZ(x0, y0, z0);
        }
      }
      function d3_geo_centroidLineEnd() {
        d3_geo_centroid.point = d3_geo_centroidPoint;
      }
      function d3_geo_centroidRingStart() {
        var λ00,
            φ00,
            x0,
            y0,
            z0;
        d3_geo_centroid.point = function(λ, φ) {
          λ00 = λ, φ00 = φ;
          d3_geo_centroid.point = nextPoint;
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians);
          x0 = cosφ * Math.cos(λ);
          y0 = cosφ * Math.sin(λ);
          z0 = Math.sin(φ);
          d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        d3_geo_centroid.lineEnd = function() {
          nextPoint(λ00, φ00);
          d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
          d3_geo_centroid.point = d3_geo_centroidPoint;
        };
        function nextPoint(λ, φ) {
          λ *= d3_radians;
          var cosφ = Math.cos(φ *= d3_radians),
              x = cosφ * Math.cos(λ),
              y = cosφ * Math.sin(λ),
              z = Math.sin(φ),
              cx = y0 * z - z0 * y,
              cy = z0 * x - x0 * z,
              cz = x0 * y - y0 * x,
              m = Math.sqrt(cx * cx + cy * cy + cz * cz),
              u = x0 * x + y0 * y + z0 * z,
              v = m && -d3_acos(u) / m,
              w = Math.atan2(m, u);
          d3_geo_centroidX2 += v * cx;
          d3_geo_centroidY2 += v * cy;
          d3_geo_centroidZ2 += v * cz;
          d3_geo_centroidW1 += w;
          d3_geo_centroidX1 += w * (x0 + (x0 = x));
          d3_geo_centroidY1 += w * (y0 + (y0 = y));
          d3_geo_centroidZ1 += w * (z0 + (z0 = z));
          d3_geo_centroidPointXYZ(x0, y0, z0);
        }
      }
      function d3_geo_compose(a, b) {
        function compose(x, y) {
          return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert)
          compose.invert = function(x, y) {
            return x = b.invert(x, y), x && a.invert(x[0], x[1]);
          };
        return compose;
      }
      function d3_true() {
        return true;
      }
      function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
        var subject = [],
            clip = [];
        segments.forEach(function(segment) {
          if ((n = segment.length - 1) <= 0)
            return;
          var n,
              p0 = segment[0],
              p1 = segment[n];
          if (d3_geo_sphericalEqual(p0, p1)) {
            listener.lineStart();
            for (var i = 0; i < n; ++i)
              listener.point((p0 = segment[i])[0], p0[1]);
            listener.lineEnd();
            return;
          }
          var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true),
              b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
          a.o = b;
          subject.push(a);
          clip.push(b);
          a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
          b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
          a.o = b;
          subject.push(a);
          clip.push(b);
        });
        clip.sort(compare);
        d3_geo_clipPolygonLinkCircular(subject);
        d3_geo_clipPolygonLinkCircular(clip);
        if (!subject.length)
          return;
        for (var i = 0,
            entry = clipStartInside,
            n = clip.length; i < n; ++i) {
          clip[i].e = entry = !entry;
        }
        var start = subject[0],
            points,
            point;
        while (1) {
          var current = start,
              isSubject = true;
          while (current.v)
            if ((current = current.n) === start)
              return;
          points = current.z;
          listener.lineStart();
          do {
            current.v = current.o.v = true;
            if (current.e) {
              if (isSubject) {
                for (var i = 0,
                    n = points.length; i < n; ++i)
                  listener.point((point = points[i])[0], point[1]);
              } else {
                interpolate(current.x, current.n.x, 1, listener);
              }
              current = current.n;
            } else {
              if (isSubject) {
                points = current.p.z;
                for (var i = points.length - 1; i >= 0; --i)
                  listener.point((point = points[i])[0], point[1]);
              } else {
                interpolate(current.x, current.p.x, -1, listener);
              }
              current = current.p;
            }
            current = current.o;
            points = current.z;
            isSubject = !isSubject;
          } while (!current.v);
          listener.lineEnd();
        }
      }
      function d3_geo_clipPolygonLinkCircular(array) {
        if (!(n = array.length))
          return;
        var n,
            i = 0,
            a = array[0],
            b;
        while (++i < n) {
          a.n = b = array[i];
          b.p = a;
          a = b;
        }
        a.n = b = array[0];
        b.p = a;
      }
      function d3_geo_clipPolygonIntersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
      }
      function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
        return function(rotate, listener) {
          var line = clipLine(listener),
              rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
          var clip = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
              clip.point = pointRing;
              clip.lineStart = ringStart;
              clip.lineEnd = ringEnd;
              segments = [];
              polygon = [];
            },
            polygonEnd: function() {
              clip.point = point;
              clip.lineStart = lineStart;
              clip.lineEnd = lineEnd;
              segments = d3.merge(segments);
              var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
              if (segments.length) {
                if (!polygonStarted)
                  listener.polygonStart(), polygonStarted = true;
                d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
              } else if (clipStartInside) {
                if (!polygonStarted)
                  listener.polygonStart(), polygonStarted = true;
                listener.lineStart();
                interpolate(null, null, 1, listener);
                listener.lineEnd();
              }
              if (polygonStarted)
                listener.polygonEnd(), polygonStarted = false;
              segments = polygon = null;
            },
            sphere: function() {
              listener.polygonStart();
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
              listener.polygonEnd();
            }
          };
          function point(λ, φ) {
            var point = rotate(λ, φ);
            if (pointVisible(λ = point[0], φ = point[1]))
              listener.point(λ, φ);
          }
          function pointLine(λ, φ) {
            var point = rotate(λ, φ);
            line.point(point[0], point[1]);
          }
          function lineStart() {
            clip.point = pointLine;
            line.lineStart();
          }
          function lineEnd() {
            clip.point = point;
            line.lineEnd();
          }
          var segments;
          var buffer = d3_geo_clipBufferListener(),
              ringListener = clipLine(buffer),
              polygonStarted = false,
              polygon,
              ring;
          function pointRing(λ, φ) {
            ring.push([λ, φ]);
            var point = rotate(λ, φ);
            ringListener.point(point[0], point[1]);
          }
          function ringStart() {
            ringListener.lineStart();
            ring = [];
          }
          function ringEnd() {
            pointRing(ring[0][0], ring[0][1]);
            ringListener.lineEnd();
            var clean = ringListener.clean(),
                ringSegments = buffer.buffer(),
                segment,
                n = ringSegments.length;
            ring.pop();
            polygon.push(ring);
            ring = null;
            if (!n)
              return;
            if (clean & 1) {
              segment = ringSegments[0];
              var n = segment.length - 1,
                  i = -1,
                  point;
              if (n > 0) {
                if (!polygonStarted)
                  listener.polygonStart(), polygonStarted = true;
                listener.lineStart();
                while (++i < n)
                  listener.point((point = segment[i])[0], point[1]);
                listener.lineEnd();
              }
              return;
            }
            if (n > 1 && clean & 2)
              ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
            segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
          }
          return clip;
        };
      }
      function d3_geo_clipSegmentLength1(segment) {
        return segment.length > 1;
      }
      function d3_geo_clipBufferListener() {
        var lines = [],
            line;
        return {
          lineStart: function() {
            lines.push(line = []);
          },
          point: function(λ, φ) {
            line.push([λ, φ]);
          },
          lineEnd: d3_noop,
          buffer: function() {
            var buffer = lines;
            lines = [];
            line = null;
            return buffer;
          },
          rejoin: function() {
            if (lines.length > 1)
              lines.push(lines.pop().concat(lines.shift()));
          }
        };
      }
      function d3_geo_clipSort(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
      }
      var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [-π, -π / 2]);
      function d3_geo_clipAntimeridianLine(listener) {
        var λ0 = NaN,
            φ0 = NaN,
            sλ0 = NaN,
            clean;
        return {
          lineStart: function() {
            listener.lineStart();
            clean = 1;
          },
          point: function(λ1, φ1) {
            var sλ1 = λ1 > 0 ? π : -π,
                dλ = abs(λ1 - λ0);
            if (abs(dλ - π) < ε) {
              listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
              listener.point(sλ0, φ0);
              listener.lineEnd();
              listener.lineStart();
              listener.point(sλ1, φ0);
              listener.point(λ1, φ0);
              clean = 0;
            } else if (sλ0 !== sλ1 && dλ >= π) {
              if (abs(λ0 - sλ0) < ε)
                λ0 -= sλ0 * ε;
              if (abs(λ1 - sλ1) < ε)
                λ1 -= sλ1 * ε;
              φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
              listener.point(sλ0, φ0);
              listener.lineEnd();
              listener.lineStart();
              listener.point(sλ1, φ0);
              clean = 0;
            }
            listener.point(λ0 = λ1, φ0 = φ1);
            sλ0 = sλ1;
          },
          lineEnd: function() {
            listener.lineEnd();
            λ0 = φ0 = NaN;
          },
          clean: function() {
            return 2 - clean;
          }
        };
      }
      function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
        var cosφ0,
            cosφ1,
            sinλ0_λ1 = Math.sin(λ0 - λ1);
        return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
      }
      function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
        var φ;
        if (from == null) {
          φ = direction * halfπ;
          listener.point(-π, φ);
          listener.point(0, φ);
          listener.point(π, φ);
          listener.point(π, 0);
          listener.point(π, -φ);
          listener.point(0, -φ);
          listener.point(-π, -φ);
          listener.point(-π, 0);
          listener.point(-π, φ);
        } else if (abs(from[0] - to[0]) > ε) {
          var s = from[0] < to[0] ? π : -π;
          φ = direction * s / 2;
          listener.point(-s, φ);
          listener.point(0, φ);
          listener.point(s, φ);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function d3_geo_pointInPolygon(point, polygon) {
        var meridian = point[0],
            parallel = point[1],
            meridianNormal = [Math.sin(meridian), -Math.cos(meridian), 0],
            polarAngle = 0,
            winding = 0;
        d3_geo_areaRingSum.reset();
        for (var i = 0,
            n = polygon.length; i < n; ++i) {
          var ring = polygon[i],
              m = ring.length;
          if (!m)
            continue;
          var point0 = ring[0],
              λ0 = point0[0],
              φ0 = point0[1] / 2 + π / 4,
              sinφ0 = Math.sin(φ0),
              cosφ0 = Math.cos(φ0),
              j = 1;
          while (true) {
            if (j === m)
              j = 0;
            point = ring[j];
            var λ = point[0],
                φ = point[1] / 2 + π / 4,
                sinφ = Math.sin(φ),
                cosφ = Math.cos(φ),
                dλ = λ - λ0,
                sdλ = dλ >= 0 ? 1 : -1,
                adλ = sdλ * dλ,
                antimeridian = adλ > π,
                k = sinφ0 * sinφ;
            d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
            polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
            if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
              var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
              d3_geo_cartesianNormalize(arc);
              var intersection = d3_geo_cartesianCross(meridianNormal, arc);
              d3_geo_cartesianNormalize(intersection);
              var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
              if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
                winding += antimeridian ^ dλ >= 0 ? 1 : -1;
              }
            }
            if (!j++)
              break;
            λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
          }
        }
        return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
      }
      function d3_geo_clipCircle(radius) {
        var cr = Math.cos(radius),
            smallRadius = cr > 0,
            notHemisphere = abs(cr) > ε,
            interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
        return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-π, radius - π]);
        function visible(λ, φ) {
          return Math.cos(λ) * Math.cos(φ) > cr;
        }
        function clipLine(listener) {
          var point0,
              c0,
              v0,
              v00,
              clean;
          return {
            lineStart: function() {
              v00 = v0 = false;
              clean = 1;
            },
            point: function(λ, φ) {
              var point1 = [λ, φ],
                  point2,
                  v = visible(λ, φ),
                  c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
              if (!point0 && (v00 = v0 = v))
                listener.lineStart();
              if (v !== v0) {
                point2 = intersect(point0, point1);
                if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                  point1[0] += ε;
                  point1[1] += ε;
                  v = visible(point1[0], point1[1]);
                }
              }
              if (v !== v0) {
                clean = 0;
                if (v) {
                  listener.lineStart();
                  point2 = intersect(point1, point0);
                  listener.point(point2[0], point2[1]);
                } else {
                  point2 = intersect(point0, point1);
                  listener.point(point2[0], point2[1]);
                  listener.lineEnd();
                }
                point0 = point2;
              } else if (notHemisphere && point0 && smallRadius ^ v) {
                var t;
                if (!(c & c0) && (t = intersect(point1, point0, true))) {
                  clean = 0;
                  if (smallRadius) {
                    listener.lineStart();
                    listener.point(t[0][0], t[0][1]);
                    listener.point(t[1][0], t[1][1]);
                    listener.lineEnd();
                  } else {
                    listener.point(t[1][0], t[1][1]);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(t[0][0], t[0][1]);
                  }
                }
              }
              if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                listener.point(point1[0], point1[1]);
              }
              point0 = point1, v0 = v, c0 = c;
            },
            lineEnd: function() {
              if (v0)
                listener.lineEnd();
              point0 = null;
            },
            clean: function() {
              return clean | (v00 && v0) << 1;
            }
          };
        }
        function intersect(a, b, two) {
          var pa = d3_geo_cartesian(a),
              pb = d3_geo_cartesian(b);
          var n1 = [1, 0, 0],
              n2 = d3_geo_cartesianCross(pa, pb),
              n2n2 = d3_geo_cartesianDot(n2, n2),
              n1n2 = n2[0],
              determinant = n2n2 - n1n2 * n1n2;
          if (!determinant)
            return !two && a;
          var c1 = cr * n2n2 / determinant,
              c2 = -cr * n1n2 / determinant,
              n1xn2 = d3_geo_cartesianCross(n1, n2),
              A = d3_geo_cartesianScale(n1, c1),
              B = d3_geo_cartesianScale(n2, c2);
          d3_geo_cartesianAdd(A, B);
          var u = n1xn2,
              w = d3_geo_cartesianDot(A, u),
              uu = d3_geo_cartesianDot(u, u),
              t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
          if (t2 < 0)
            return;
          var t = Math.sqrt(t2),
              q = d3_geo_cartesianScale(u, (-w - t) / uu);
          d3_geo_cartesianAdd(q, A);
          q = d3_geo_spherical(q);
          if (!two)
            return q;
          var λ0 = a[0],
              λ1 = b[0],
              φ0 = a[1],
              φ1 = b[1],
              z;
          if (λ1 < λ0)
            z = λ0, λ0 = λ1, λ1 = z;
          var δλ = λ1 - λ0,
              polar = abs(δλ - π) < ε,
              meridian = polar || δλ < ε;
          if (!polar && φ1 < φ0)
            z = φ0, φ0 = φ1, φ1 = z;
          if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
            var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
            d3_geo_cartesianAdd(q1, A);
            return [q, d3_geo_spherical(q1)];
          }
        }
        function code(λ, φ) {
          var r = smallRadius ? radius : π - radius,
              code = 0;
          if (λ < -r)
            code |= 1;
          else if (λ > r)
            code |= 2;
          if (φ < -r)
            code |= 4;
          else if (φ > r)
            code |= 8;
          return code;
        }
      }
      function d3_geom_clipLine(x0, y0, x1, y1) {
        return function(line) {
          var a = line.a,
              b = line.b,
              ax = a.x,
              ay = a.y,
              bx = b.x,
              by = b.y,
              t0 = 0,
              t1 = 1,
              dx = bx - ax,
              dy = by - ay,
              r;
          r = x0 - ax;
          if (!dx && r > 0)
            return;
          r /= dx;
          if (dx < 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          } else if (dx > 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          }
          r = x1 - ax;
          if (!dx && r < 0)
            return;
          r /= dx;
          if (dx < 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          } else if (dx > 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          }
          r = y0 - ay;
          if (!dy && r > 0)
            return;
          r /= dy;
          if (dy < 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          } else if (dy > 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          }
          r = y1 - ay;
          if (!dy && r < 0)
            return;
          r /= dy;
          if (dy < 0) {
            if (r > t1)
              return;
            if (r > t0)
              t0 = r;
          } else if (dy > 0) {
            if (r < t0)
              return;
            if (r < t1)
              t1 = r;
          }
          if (t0 > 0)
            line.a = {
              x: ax + t0 * dx,
              y: ay + t0 * dy
            };
          if (t1 < 1)
            line.b = {
              x: ax + t1 * dx,
              y: ay + t1 * dy
            };
          return line;
        };
      }
      var d3_geo_clipExtentMAX = 1e9;
      d3.geo.clipExtent = function() {
        var x0,
            y0,
            x1,
            y1,
            stream,
            clip,
            clipExtent = {
              stream: function(output) {
                if (stream)
                  stream.valid = false;
                stream = clip(output);
                stream.valid = true;
                return stream;
              },
              extent: function(_) {
                if (!arguments.length)
                  return [[x0, y0], [x1, y1]];
                clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
                if (stream)
                  stream.valid = false, stream = null;
                return clipExtent;
              }
            };
        return clipExtent.extent([[0, 0], [960, 500]]);
      };
      function d3_geo_clipExtent(x0, y0, x1, y1) {
        return function(listener) {
          var listener_ = listener,
              bufferListener = d3_geo_clipBufferListener(),
              clipLine = d3_geom_clipLine(x0, y0, x1, y1),
              segments,
              polygon,
              ring;
          var clip = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
              listener = bufferListener;
              segments = [];
              polygon = [];
              clean = true;
            },
            polygonEnd: function() {
              listener = listener_;
              segments = d3.merge(segments);
              var clipStartInside = insidePolygon([x0, y1]),
                  inside = clean && clipStartInside,
                  visible = segments.length;
              if (inside || visible) {
                listener.polygonStart();
                if (inside) {
                  listener.lineStart();
                  interpolate(null, null, 1, listener);
                  listener.lineEnd();
                }
                if (visible) {
                  d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
                }
                listener.polygonEnd();
              }
              segments = polygon = ring = null;
            }
          };
          function insidePolygon(p) {
            var wn = 0,
                n = polygon.length,
                y = p[1];
            for (var i = 0; i < n; ++i) {
              for (var j = 1,
                  v = polygon[i],
                  m = v.length,
                  a = v[0],
                  b; j < m; ++j) {
                b = v[j];
                if (a[1] <= y) {
                  if (b[1] > y && d3_cross2d(a, b, p) > 0)
                    ++wn;
                } else {
                  if (b[1] <= y && d3_cross2d(a, b, p) < 0)
                    --wn;
                }
                a = b;
              }
            }
            return wn !== 0;
          }
          function interpolate(from, to, direction, listener) {
            var a = 0,
                a1 = 0;
            if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
              do {
                listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
              } while ((a = (a + direction + 4) % 4) !== a1);
            } else {
              listener.point(to[0], to[1]);
            }
          }
          function pointVisible(x, y) {
            return x0 <= x && x <= x1 && y0 <= y && y <= y1;
          }
          function point(x, y) {
            if (pointVisible(x, y))
              listener.point(x, y);
          }
          var x__,
              y__,
              v__,
              x_,
              y_,
              v_,
              first,
              clean;
          function lineStart() {
            clip.point = linePoint;
            if (polygon)
              polygon.push(ring = []);
            first = true;
            v_ = false;
            x_ = y_ = NaN;
          }
          function lineEnd() {
            if (segments) {
              linePoint(x__, y__);
              if (v__ && v_)
                bufferListener.rejoin();
              segments.push(bufferListener.buffer());
            }
            clip.point = point;
            if (v_)
              listener.lineEnd();
          }
          function linePoint(x, y) {
            x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
            y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
            var v = pointVisible(x, y);
            if (polygon)
              ring.push([x, y]);
            if (first) {
              x__ = x, y__ = y, v__ = v;
              first = false;
              if (v) {
                listener.lineStart();
                listener.point(x, y);
              }
            } else {
              if (v && v_)
                listener.point(x, y);
              else {
                var l = {
                  a: {
                    x: x_,
                    y: y_
                  },
                  b: {
                    x: x,
                    y: y
                  }
                };
                if (clipLine(l)) {
                  if (!v_) {
                    listener.lineStart();
                    listener.point(l.a.x, l.a.y);
                  }
                  listener.point(l.b.x, l.b.y);
                  if (!v)
                    listener.lineEnd();
                  clean = false;
                } else if (v) {
                  listener.lineStart();
                  listener.point(x, y);
                  clean = false;
                }
              }
            }
            x_ = x, y_ = y, v_ = v;
          }
          return clip;
        };
        function corner(p, direction) {
          return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compare(a, b) {
          return comparePoints(a.x, b.x);
        }
        function comparePoints(a, b) {
          var ca = corner(a, 1),
              cb = corner(b, 1);
          return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
      }
      function d3_geo_conic(projectAt) {
        var φ0 = 0,
            φ1 = π / 3,
            m = d3_geo_projectionMutator(projectAt),
            p = m(φ0, φ1);
        p.parallels = function(_) {
          if (!arguments.length)
            return [φ0 / π * 180, φ1 / π * 180];
          return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
        };
        return p;
      }
      function d3_geo_conicEqualArea(φ0, φ1) {
        var sinφ0 = Math.sin(φ0),
            n = (sinφ0 + Math.sin(φ1)) / 2,
            C = 1 + sinφ0 * (2 * n - sinφ0),
            ρ0 = Math.sqrt(C) / n;
        function forward(λ, φ) {
          var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
          return [ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ)];
        }
        forward.invert = function(x, y) {
          var ρ0_y = ρ0 - y;
          return [Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n))];
        };
        return forward;
      }
      (d3.geo.conicEqualArea = function() {
        return d3_geo_conic(d3_geo_conicEqualArea);
      }).raw = d3_geo_conicEqualArea;
      d3.geo.albers = function() {
        return d3.geo.conicEqualArea().rotate([96, 0]).center([-.6, 38.7]).parallels([29.5, 45.5]).scale(1070);
      };
      d3.geo.albersUsa = function() {
        var lower48 = d3.geo.albers();
        var alaska = d3.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]);
        var hawaii = d3.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]);
        var point,
            pointStream = {point: function(x, y) {
                point = [x, y];
              }},
            lower48Point,
            alaskaPoint,
            hawaiiPoint;
        function albersUsa(coordinates) {
          var x = coordinates[0],
              y = coordinates[1];
          point = null;
          (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
          return point;
        }
        albersUsa.invert = function(coordinates) {
          var k = lower48.scale(),
              t = lower48.translate(),
              x = (coordinates[0] - t[0]) / k,
              y = (coordinates[1] - t[1]) / k;
          return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
        };
        albersUsa.stream = function(stream) {
          var lower48Stream = lower48.stream(stream),
              alaskaStream = alaska.stream(stream),
              hawaiiStream = hawaii.stream(stream);
          return {
            point: function(x, y) {
              lower48Stream.point(x, y);
              alaskaStream.point(x, y);
              hawaiiStream.point(x, y);
            },
            sphere: function() {
              lower48Stream.sphere();
              alaskaStream.sphere();
              hawaiiStream.sphere();
            },
            lineStart: function() {
              lower48Stream.lineStart();
              alaskaStream.lineStart();
              hawaiiStream.lineStart();
            },
            lineEnd: function() {
              lower48Stream.lineEnd();
              alaskaStream.lineEnd();
              hawaiiStream.lineEnd();
            },
            polygonStart: function() {
              lower48Stream.polygonStart();
              alaskaStream.polygonStart();
              hawaiiStream.polygonStart();
            },
            polygonEnd: function() {
              lower48Stream.polygonEnd();
              alaskaStream.polygonEnd();
              hawaiiStream.polygonEnd();
            }
          };
        };
        albersUsa.precision = function(_) {
          if (!arguments.length)
            return lower48.precision();
          lower48.precision(_);
          alaska.precision(_);
          hawaii.precision(_);
          return albersUsa;
        };
        albersUsa.scale = function(_) {
          if (!arguments.length)
            return lower48.scale();
          lower48.scale(_);
          alaska.scale(_ * .35);
          hawaii.scale(_);
          return albersUsa.translate(lower48.translate());
        };
        albersUsa.translate = function(_) {
          if (!arguments.length)
            return lower48.translate();
          var k = lower48.scale(),
              x = +_[0],
              y = +_[1];
          lower48Point = lower48.translate(_).clipExtent([[x - .455 * k, y - .238 * k], [x + .455 * k, y + .238 * k]]).stream(pointStream).point;
          alaskaPoint = alaska.translate([x - .307 * k, y + .201 * k]).clipExtent([[x - .425 * k + ε, y + .12 * k + ε], [x - .214 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;
          hawaiiPoint = hawaii.translate([x - .205 * k, y + .212 * k]).clipExtent([[x - .214 * k + ε, y + .166 * k + ε], [x - .115 * k - ε, y + .234 * k - ε]]).stream(pointStream).point;
          return albersUsa;
        };
        return albersUsa.scale(1070);
      };
      var d3_geo_pathAreaSum,
          d3_geo_pathAreaPolygon,
          d3_geo_pathArea = {
            point: d3_noop,
            lineStart: d3_noop,
            lineEnd: d3_noop,
            polygonStart: function() {
              d3_geo_pathAreaPolygon = 0;
              d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
            },
            polygonEnd: function() {
              d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
              d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
            }
          };
      function d3_geo_pathAreaRingStart() {
        var x00,
            y00,
            x0,
            y0;
        d3_geo_pathArea.point = function(x, y) {
          d3_geo_pathArea.point = nextPoint;
          x00 = x0 = x, y00 = y0 = y;
        };
        function nextPoint(x, y) {
          d3_geo_pathAreaPolygon += y0 * x - x0 * y;
          x0 = x, y0 = y;
        }
        d3_geo_pathArea.lineEnd = function() {
          nextPoint(x00, y00);
        };
      }
      var d3_geo_pathBoundsX0,
          d3_geo_pathBoundsY0,
          d3_geo_pathBoundsX1,
          d3_geo_pathBoundsY1;
      var d3_geo_pathBounds = {
        point: d3_geo_pathBoundsPoint,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
      };
      function d3_geo_pathBoundsPoint(x, y) {
        if (x < d3_geo_pathBoundsX0)
          d3_geo_pathBoundsX0 = x;
        if (x > d3_geo_pathBoundsX1)
          d3_geo_pathBoundsX1 = x;
        if (y < d3_geo_pathBoundsY0)
          d3_geo_pathBoundsY0 = y;
        if (y > d3_geo_pathBoundsY1)
          d3_geo_pathBoundsY1 = y;
      }
      function d3_geo_pathBuffer() {
        var pointCircle = d3_geo_pathBufferCircle(4.5),
            buffer = [];
        var stream = {
          point: point,
          lineStart: function() {
            stream.point = pointLineStart;
          },
          lineEnd: lineEnd,
          polygonStart: function() {
            stream.lineEnd = lineEndPolygon;
          },
          polygonEnd: function() {
            stream.lineEnd = lineEnd;
            stream.point = point;
          },
          pointRadius: function(_) {
            pointCircle = d3_geo_pathBufferCircle(_);
            return stream;
          },
          result: function() {
            if (buffer.length) {
              var result = buffer.join("");
              buffer = [];
              return result;
            }
          }
        };
        function point(x, y) {
          buffer.push("M", x, ",", y, pointCircle);
        }
        function pointLineStart(x, y) {
          buffer.push("M", x, ",", y);
          stream.point = pointLine;
        }
        function pointLine(x, y) {
          buffer.push("L", x, ",", y);
        }
        function lineEnd() {
          stream.point = point;
        }
        function lineEndPolygon() {
          buffer.push("Z");
        }
        return stream;
      }
      function d3_geo_pathBufferCircle(radius) {
        return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
      }
      var d3_geo_pathCentroid = {
        point: d3_geo_pathCentroidPoint,
        lineStart: d3_geo_pathCentroidLineStart,
        lineEnd: d3_geo_pathCentroidLineEnd,
        polygonStart: function() {
          d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
        },
        polygonEnd: function() {
          d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
          d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
          d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
        }
      };
      function d3_geo_pathCentroidPoint(x, y) {
        d3_geo_centroidX0 += x;
        d3_geo_centroidY0 += y;
        ++d3_geo_centroidZ0;
      }
      function d3_geo_pathCentroidLineStart() {
        var x0,
            y0;
        d3_geo_pathCentroid.point = function(x, y) {
          d3_geo_pathCentroid.point = nextPoint;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        };
        function nextPoint(x, y) {
          var dx = x - x0,
              dy = y - y0,
              z = Math.sqrt(dx * dx + dy * dy);
          d3_geo_centroidX1 += z * (x0 + x) / 2;
          d3_geo_centroidY1 += z * (y0 + y) / 2;
          d3_geo_centroidZ1 += z;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
      }
      function d3_geo_pathCentroidLineEnd() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      }
      function d3_geo_pathCentroidRingStart() {
        var x00,
            y00,
            x0,
            y0;
        d3_geo_pathCentroid.point = function(x, y) {
          d3_geo_pathCentroid.point = nextPoint;
          d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
        };
        function nextPoint(x, y) {
          var dx = x - x0,
              dy = y - y0,
              z = Math.sqrt(dx * dx + dy * dy);
          d3_geo_centroidX1 += z * (x0 + x) / 2;
          d3_geo_centroidY1 += z * (y0 + y) / 2;
          d3_geo_centroidZ1 += z;
          z = y0 * x - x0 * y;
          d3_geo_centroidX2 += z * (x0 + x);
          d3_geo_centroidY2 += z * (y0 + y);
          d3_geo_centroidZ2 += z * 3;
          d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
        d3_geo_pathCentroid.lineEnd = function() {
          nextPoint(x00, y00);
        };
      }
      function d3_geo_pathContext(context) {
        var pointRadius = 4.5;
        var stream = {
          point: point,
          lineStart: function() {
            stream.point = pointLineStart;
          },
          lineEnd: lineEnd,
          polygonStart: function() {
            stream.lineEnd = lineEndPolygon;
          },
          polygonEnd: function() {
            stream.lineEnd = lineEnd;
            stream.point = point;
          },
          pointRadius: function(_) {
            pointRadius = _;
            return stream;
          },
          result: d3_noop
        };
        function point(x, y) {
          context.moveTo(x + pointRadius, y);
          context.arc(x, y, pointRadius, 0, τ);
        }
        function pointLineStart(x, y) {
          context.moveTo(x, y);
          stream.point = pointLine;
        }
        function pointLine(x, y) {
          context.lineTo(x, y);
        }
        function lineEnd() {
          stream.point = point;
        }
        function lineEndPolygon() {
          context.closePath();
        }
        return stream;
      }
      function d3_geo_resample(project) {
        var δ2 = .5,
            cosMinDistance = Math.cos(30 * d3_radians),
            maxDepth = 16;
        function resample(stream) {
          return (maxDepth ? resampleRecursive : resampleNone)(stream);
        }
        function resampleNone(stream) {
          return d3_geo_transformPoint(stream, function(x, y) {
            x = project(x, y);
            stream.point(x[0], x[1]);
          });
        }
        function resampleRecursive(stream) {
          var λ00,
              φ00,
              x00,
              y00,
              a00,
              b00,
              c00,
              λ0,
              x0,
              y0,
              a0,
              b0,
              c0;
          var resample = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function() {
              stream.polygonStart();
              resample.lineStart = ringStart;
            },
            polygonEnd: function() {
              stream.polygonEnd();
              resample.lineStart = lineStart;
            }
          };
          function point(x, y) {
            x = project(x, y);
            stream.point(x[0], x[1]);
          }
          function lineStart() {
            x0 = NaN;
            resample.point = linePoint;
            stream.lineStart();
          }
          function linePoint(λ, φ) {
            var c = d3_geo_cartesian([λ, φ]),
                p = project(λ, φ);
            resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
            stream.point(x0, y0);
          }
          function lineEnd() {
            resample.point = point;
            stream.lineEnd();
          }
          function ringStart() {
            lineStart();
            resample.point = ringPoint;
            resample.lineEnd = ringEnd;
          }
          function ringPoint(λ, φ) {
            linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
            resample.point = linePoint;
          }
          function ringEnd() {
            resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
            resample.lineEnd = lineEnd;
            lineEnd();
          }
          return resample;
        }
        function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
          var dx = x1 - x0,
              dy = y1 - y0,
              d2 = dx * dx + dy * dy;
          if (d2 > 4 * δ2 && depth--) {
            var a = a0 + a1,
                b = b0 + b1,
                c = c0 + c1,
                m = Math.sqrt(a * a + b * b + c * c),
                φ2 = Math.asin(c /= m),
                λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a),
                p = project(λ2, φ2),
                x2 = p[0],
                y2 = p[1],
                dx2 = x2 - x0,
                dy2 = y2 - y0,
                dz = dy * dx2 - dx * dy2;
            if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
              resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
              stream.point(x2, y2);
              resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
            }
          }
        }
        resample.precision = function(_) {
          if (!arguments.length)
            return Math.sqrt(δ2);
          maxDepth = (δ2 = _ * _) > 0 && 16;
          return resample;
        };
        return resample;
      }
      d3.geo.path = function() {
        var pointRadius = 4.5,
            projection,
            context,
            projectStream,
            contextStream,
            cacheStream;
        function path(object) {
          if (object) {
            if (typeof pointRadius === "function")
              contextStream.pointRadius(+pointRadius.apply(this, arguments));
            if (!cacheStream || !cacheStream.valid)
              cacheStream = projectStream(contextStream);
            d3.geo.stream(object, cacheStream);
          }
          return contextStream.result();
        }
        path.area = function(object) {
          d3_geo_pathAreaSum = 0;
          d3.geo.stream(object, projectStream(d3_geo_pathArea));
          return d3_geo_pathAreaSum;
        };
        path.centroid = function(object) {
          d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
          d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
          return d3_geo_centroidZ2 ? [d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2] : d3_geo_centroidZ1 ? [d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1] : d3_geo_centroidZ0 ? [d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0] : [NaN, NaN];
        };
        path.bounds = function(object) {
          d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
          d3.geo.stream(object, projectStream(d3_geo_pathBounds));
          return [[d3_geo_pathBoundsX0, d3_geo_pathBoundsY0], [d3_geo_pathBoundsX1, d3_geo_pathBoundsY1]];
        };
        path.projection = function(_) {
          if (!arguments.length)
            return projection;
          projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
          return reset();
        };
        path.context = function(_) {
          if (!arguments.length)
            return context;
          contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
          if (typeof pointRadius !== "function")
            contextStream.pointRadius(pointRadius);
          return reset();
        };
        path.pointRadius = function(_) {
          if (!arguments.length)
            return pointRadius;
          pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
          return path;
        };
        function reset() {
          cacheStream = null;
          return path;
        }
        return path.projection(d3.geo.albersUsa()).context(null);
      };
      function d3_geo_pathProjectStream(project) {
        var resample = d3_geo_resample(function(x, y) {
          return project([x * d3_degrees, y * d3_degrees]);
        });
        return function(stream) {
          return d3_geo_projectionRadians(resample(stream));
        };
      }
      d3.geo.transform = function(methods) {
        return {stream: function(stream) {
            var transform = new d3_geo_transform(stream);
            for (var k in methods)
              transform[k] = methods[k];
            return transform;
          }};
      };
      function d3_geo_transform(stream) {
        this.stream = stream;
      }
      d3_geo_transform.prototype = {
        point: function(x, y) {
          this.stream.point(x, y);
        },
        sphere: function() {
          this.stream.sphere();
        },
        lineStart: function() {
          this.stream.lineStart();
        },
        lineEnd: function() {
          this.stream.lineEnd();
        },
        polygonStart: function() {
          this.stream.polygonStart();
        },
        polygonEnd: function() {
          this.stream.polygonEnd();
        }
      };
      function d3_geo_transformPoint(stream, point) {
        return {
          point: point,
          sphere: function() {
            stream.sphere();
          },
          lineStart: function() {
            stream.lineStart();
          },
          lineEnd: function() {
            stream.lineEnd();
          },
          polygonStart: function() {
            stream.polygonStart();
          },
          polygonEnd: function() {
            stream.polygonEnd();
          }
        };
      }
      d3.geo.projection = d3_geo_projection;
      d3.geo.projectionMutator = d3_geo_projectionMutator;
      function d3_geo_projection(project) {
        return d3_geo_projectionMutator(function() {
          return project;
        })();
      }
      function d3_geo_projectionMutator(projectAt) {
        var project,
            rotate,
            projectRotate,
            projectResample = d3_geo_resample(function(x, y) {
              x = project(x, y);
              return [x[0] * k + δx, δy - x[1] * k];
            }),
            k = 150,
            x = 480,
            y = 250,
            λ = 0,
            φ = 0,
            δλ = 0,
            δφ = 0,
            δγ = 0,
            δx,
            δy,
            preclip = d3_geo_clipAntimeridian,
            postclip = d3_identity,
            clipAngle = null,
            clipExtent = null,
            stream;
        function projection(point) {
          point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
          return [point[0] * k + δx, δy - point[1] * k];
        }
        function invert(point) {
          point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
          return point && [point[0] * d3_degrees, point[1] * d3_degrees];
        }
        projection.stream = function(output) {
          if (stream)
            stream.valid = false;
          stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
          stream.valid = true;
          return stream;
        };
        projection.clipAngle = function(_) {
          if (!arguments.length)
            return clipAngle;
          preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
          return invalidate();
        };
        projection.clipExtent = function(_) {
          if (!arguments.length)
            return clipExtent;
          clipExtent = _;
          postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
          return invalidate();
        };
        projection.scale = function(_) {
          if (!arguments.length)
            return k;
          k = +_;
          return reset();
        };
        projection.translate = function(_) {
          if (!arguments.length)
            return [x, y];
          x = +_[0];
          y = +_[1];
          return reset();
        };
        projection.center = function(_) {
          if (!arguments.length)
            return [λ * d3_degrees, φ * d3_degrees];
          λ = _[0] % 360 * d3_radians;
          φ = _[1] % 360 * d3_radians;
          return reset();
        };
        projection.rotate = function(_) {
          if (!arguments.length)
            return [δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees];
          δλ = _[0] % 360 * d3_radians;
          δφ = _[1] % 360 * d3_radians;
          δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
          return reset();
        };
        d3.rebind(projection, projectResample, "precision");
        function reset() {
          projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
          var center = project(λ, φ);
          δx = x - center[0] * k;
          δy = y + center[1] * k;
          return invalidate();
        }
        function invalidate() {
          if (stream)
            stream.valid = false, stream = null;
          return projection;
        }
        return function() {
          project = projectAt.apply(this, arguments);
          projection.invert = project.invert && invert;
          return reset();
        };
      }
      function d3_geo_projectionRadians(stream) {
        return d3_geo_transformPoint(stream, function(x, y) {
          stream.point(x * d3_radians, y * d3_radians);
        });
      }
      function d3_geo_equirectangular(λ, φ) {
        return [λ, φ];
      }
      (d3.geo.equirectangular = function() {
        return d3_geo_projection(d3_geo_equirectangular);
      }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
      d3.geo.rotation = function(rotate) {
        rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
        function forward(coordinates) {
          coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
          return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        }
        forward.invert = function(coordinates) {
          coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
          return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        };
        return forward;
      };
      function d3_geo_identityRotation(λ, φ) {
        return [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];
      }
      d3_geo_identityRotation.invert = d3_geo_equirectangular;
      function d3_geo_rotation(δλ, δφ, δγ) {
        return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
      }
      function d3_geo_forwardRotationλ(δλ) {
        return function(λ, φ) {
          return λ += δλ, [λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ];
        };
      }
      function d3_geo_rotationλ(δλ) {
        var rotation = d3_geo_forwardRotationλ(δλ);
        rotation.invert = d3_geo_forwardRotationλ(-δλ);
        return rotation;
      }
      function d3_geo_rotationφγ(δφ, δγ) {
        var cosδφ = Math.cos(δφ),
            sinδφ = Math.sin(δφ),
            cosδγ = Math.cos(δγ),
            sinδγ = Math.sin(δγ);
        function rotation(λ, φ) {
          var cosφ = Math.cos(φ),
              x = Math.cos(λ) * cosφ,
              y = Math.sin(λ) * cosφ,
              z = Math.sin(φ),
              k = z * cosδφ + x * sinδφ;
          return [Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ)];
        }
        rotation.invert = function(λ, φ) {
          var cosφ = Math.cos(φ),
              x = Math.cos(λ) * cosφ,
              y = Math.sin(λ) * cosφ,
              z = Math.sin(φ),
              k = z * cosδγ - y * sinδγ;
          return [Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ)];
        };
        return rotation;
      }
      d3.geo.circle = function() {
        var origin = [0, 0],
            angle,
            precision = 6,
            interpolate;
        function circle() {
          var center = typeof origin === "function" ? origin.apply(this, arguments) : origin,
              rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert,
              ring = [];
          interpolate(null, null, 1, {point: function(x, y) {
              ring.push(x = rotate(x, y));
              x[0] *= d3_degrees, x[1] *= d3_degrees;
            }});
          return {
            type: "Polygon",
            coordinates: [ring]
          };
        }
        circle.origin = function(x) {
          if (!arguments.length)
            return origin;
          origin = x;
          return circle;
        };
        circle.angle = function(x) {
          if (!arguments.length)
            return angle;
          interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
          return circle;
        };
        circle.precision = function(_) {
          if (!arguments.length)
            return precision;
          interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
          return circle;
        };
        return circle.angle(90);
      };
      function d3_geo_circleInterpolate(radius, precision) {
        var cr = Math.cos(radius),
            sr = Math.sin(radius);
        return function(from, to, direction, listener) {
          var step = direction * precision;
          if (from != null) {
            from = d3_geo_circleAngle(cr, from);
            to = d3_geo_circleAngle(cr, to);
            if (direction > 0 ? from < to : from > to)
              from += direction * τ;
          } else {
            from = radius + direction * τ;
            to = radius - .5 * step;
          }
          for (var point,
              t = from; direction > 0 ? t > to : t < to; t -= step) {
            listener.point((point = d3_geo_spherical([cr, -sr * Math.cos(t), -sr * Math.sin(t)]))[0], point[1]);
          }
        };
      }
      function d3_geo_circleAngle(cr, point) {
        var a = d3_geo_cartesian(point);
        a[0] -= cr;
        d3_geo_cartesianNormalize(a);
        var angle = d3_acos(-a[1]);
        return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
      }
      d3.geo.distance = function(a, b) {
        var Δλ = (b[0] - a[0]) * d3_radians,
            φ0 = a[1] * d3_radians,
            φ1 = b[1] * d3_radians,
            sinΔλ = Math.sin(Δλ),
            cosΔλ = Math.cos(Δλ),
            sinφ0 = Math.sin(φ0),
            cosφ0 = Math.cos(φ0),
            sinφ1 = Math.sin(φ1),
            cosφ1 = Math.cos(φ1),
            t;
        return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
      };
      d3.geo.graticule = function() {
        var x1,
            x0,
            X1,
            X0,
            y1,
            y0,
            Y1,
            Y0,
            dx = 10,
            dy = dx,
            DX = 90,
            DY = 360,
            x,
            y,
            X,
            Y,
            precision = 2.5;
        function graticule() {
          return {
            type: "MultiLineString",
            coordinates: lines()
          };
        }
        function lines() {
          return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
            return abs(x % DX) > ε;
          }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
            return abs(y % DY) > ε;
          }).map(y));
        }
        graticule.lines = function() {
          return lines().map(function(coordinates) {
            return {
              type: "LineString",
              coordinates: coordinates
            };
          });
        };
        graticule.outline = function() {
          return {
            type: "Polygon",
            coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
          };
        };
        graticule.extent = function(_) {
          if (!arguments.length)
            return graticule.minorExtent();
          return graticule.majorExtent(_).minorExtent(_);
        };
        graticule.majorExtent = function(_) {
          if (!arguments.length)
            return [[X0, Y0], [X1, Y1]];
          X0 = +_[0][0], X1 = +_[1][0];
          Y0 = +_[0][1], Y1 = +_[1][1];
          if (X0 > X1)
            _ = X0, X0 = X1, X1 = _;
          if (Y0 > Y1)
            _ = Y0, Y0 = Y1, Y1 = _;
          return graticule.precision(precision);
        };
        graticule.minorExtent = function(_) {
          if (!arguments.length)
            return [[x0, y0], [x1, y1]];
          x0 = +_[0][0], x1 = +_[1][0];
          y0 = +_[0][1], y1 = +_[1][1];
          if (x0 > x1)
            _ = x0, x0 = x1, x1 = _;
          if (y0 > y1)
            _ = y0, y0 = y1, y1 = _;
          return graticule.precision(precision);
        };
        graticule.step = function(_) {
          if (!arguments.length)
            return graticule.minorStep();
          return graticule.majorStep(_).minorStep(_);
        };
        graticule.majorStep = function(_) {
          if (!arguments.length)
            return [DX, DY];
          DX = +_[0], DY = +_[1];
          return graticule;
        };
        graticule.minorStep = function(_) {
          if (!arguments.length)
            return [dx, dy];
          dx = +_[0], dy = +_[1];
          return graticule;
        };
        graticule.precision = function(_) {
          if (!arguments.length)
            return precision;
          precision = +_;
          x = d3_geo_graticuleX(y0, y1, 90);
          y = d3_geo_graticuleY(x0, x1, precision);
          X = d3_geo_graticuleX(Y0, Y1, 90);
          Y = d3_geo_graticuleY(X0, X1, precision);
          return graticule;
        };
        return graticule.majorExtent([[-180, -90 + ε], [180, 90 - ε]]).minorExtent([[-180, -80 - ε], [180, 80 + ε]]);
      };
      function d3_geo_graticuleX(y0, y1, dy) {
        var y = d3.range(y0, y1 - ε, dy).concat(y1);
        return function(x) {
          return y.map(function(y) {
            return [x, y];
          });
        };
      }
      function d3_geo_graticuleY(x0, x1, dx) {
        var x = d3.range(x0, x1 - ε, dx).concat(x1);
        return function(y) {
          return x.map(function(x) {
            return [x, y];
          });
        };
      }
      function d3_source(d) {
        return d.source;
      }
      function d3_target(d) {
        return d.target;
      }
      d3.geo.greatArc = function() {
        var source = d3_source,
            source_,
            target = d3_target,
            target_;
        function greatArc() {
          return {
            type: "LineString",
            coordinates: [source_ || source.apply(this, arguments), target_ || target.apply(this, arguments)]
          };
        }
        greatArc.distance = function() {
          return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
        };
        greatArc.source = function(_) {
          if (!arguments.length)
            return source;
          source = _, source_ = typeof _ === "function" ? null : _;
          return greatArc;
        };
        greatArc.target = function(_) {
          if (!arguments.length)
            return target;
          target = _, target_ = typeof _ === "function" ? null : _;
          return greatArc;
        };
        greatArc.precision = function() {
          return arguments.length ? greatArc : 0;
        };
        return greatArc;
      };
      d3.geo.interpolate = function(source, target) {
        return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
      };
      function d3_geo_interpolate(x0, y0, x1, y1) {
        var cy0 = Math.cos(y0),
            sy0 = Math.sin(y0),
            cy1 = Math.cos(y1),
            sy1 = Math.sin(y1),
            kx0 = cy0 * Math.cos(x0),
            ky0 = cy0 * Math.sin(x0),
            kx1 = cy1 * Math.cos(x1),
            ky1 = cy1 * Math.sin(x1),
            d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))),
            k = 1 / Math.sin(d);
        var interpolate = d ? function(t) {
          var B = Math.sin(t *= d) * k,
              A = Math.sin(d - t) * k,
              x = A * kx0 + B * kx1,
              y = A * ky0 + B * ky1,
              z = A * sy0 + B * sy1;
          return [Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees];
        } : function() {
          return [x0 * d3_degrees, y0 * d3_degrees];
        };
        interpolate.distance = d;
        return interpolate;
      }
      d3.geo.length = function(object) {
        d3_geo_lengthSum = 0;
        d3.geo.stream(object, d3_geo_length);
        return d3_geo_lengthSum;
      };
      var d3_geo_lengthSum;
      var d3_geo_length = {
        sphere: d3_noop,
        point: d3_noop,
        lineStart: d3_geo_lengthLineStart,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
      };
      function d3_geo_lengthLineStart() {
        var λ0,
            sinφ0,
            cosφ0;
        d3_geo_length.point = function(λ, φ) {
          λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
          d3_geo_length.point = nextPoint;
        };
        d3_geo_length.lineEnd = function() {
          d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
        };
        function nextPoint(λ, φ) {
          var sinφ = Math.sin(φ *= d3_radians),
              cosφ = Math.cos(φ),
              t = abs((λ *= d3_radians) - λ0),
              cosΔλ = Math.cos(t);
          d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
          λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
        }
      }
      function d3_geo_azimuthal(scale, angle) {
        function azimuthal(λ, φ) {
          var cosλ = Math.cos(λ),
              cosφ = Math.cos(φ),
              k = scale(cosλ * cosφ);
          return [k * cosφ * Math.sin(λ), k * Math.sin(φ)];
        }
        azimuthal.invert = function(x, y) {
          var ρ = Math.sqrt(x * x + y * y),
              c = angle(ρ),
              sinc = Math.sin(c),
              cosc = Math.cos(c);
          return [Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ)];
        };
        return azimuthal;
      }
      var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
        return Math.sqrt(2 / (1 + cosλcosφ));
      }, function(ρ) {
        return 2 * Math.asin(ρ / 2);
      });
      (d3.geo.azimuthalEqualArea = function() {
        return d3_geo_projection(d3_geo_azimuthalEqualArea);
      }).raw = d3_geo_azimuthalEqualArea;
      var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
        var c = Math.acos(cosλcosφ);
        return c && c / Math.sin(c);
      }, d3_identity);
      (d3.geo.azimuthalEquidistant = function() {
        return d3_geo_projection(d3_geo_azimuthalEquidistant);
      }).raw = d3_geo_azimuthalEquidistant;
      function d3_geo_conicConformal(φ0, φ1) {
        var cosφ0 = Math.cos(φ0),
            t = function(φ) {
              return Math.tan(π / 4 + φ / 2);
            },
            n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)),
            F = cosφ0 * Math.pow(t(φ0), n) / n;
        if (!n)
          return d3_geo_mercator;
        function forward(λ, φ) {
          if (F > 0) {
            if (φ < -halfπ + ε)
              φ = -halfπ + ε;
          } else {
            if (φ > halfπ - ε)
              φ = halfπ - ε;
          }
          var ρ = F / Math.pow(t(φ), n);
          return [ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ)];
        }
        forward.invert = function(x, y) {
          var ρ0_y = F - y,
              ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
          return [Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ];
        };
        return forward;
      }
      (d3.geo.conicConformal = function() {
        return d3_geo_conic(d3_geo_conicConformal);
      }).raw = d3_geo_conicConformal;
      function d3_geo_conicEquidistant(φ0, φ1) {
        var cosφ0 = Math.cos(φ0),
            n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0),
            G = cosφ0 / n + φ0;
        if (abs(n) < ε)
          return d3_geo_equirectangular;
        function forward(λ, φ) {
          var ρ = G - φ;
          return [ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ)];
        }
        forward.invert = function(x, y) {
          var ρ0_y = G - y;
          return [Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y)];
        };
        return forward;
      }
      (d3.geo.conicEquidistant = function() {
        return d3_geo_conic(d3_geo_conicEquidistant);
      }).raw = d3_geo_conicEquidistant;
      var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / cosλcosφ;
      }, Math.atan);
      (d3.geo.gnomonic = function() {
        return d3_geo_projection(d3_geo_gnomonic);
      }).raw = d3_geo_gnomonic;
      function d3_geo_mercator(λ, φ) {
        return [λ, Math.log(Math.tan(π / 4 + φ / 2))];
      }
      d3_geo_mercator.invert = function(x, y) {
        return [x, 2 * Math.atan(Math.exp(y)) - halfπ];
      };
      function d3_geo_mercatorProjection(project) {
        var m = d3_geo_projection(project),
            scale = m.scale,
            translate = m.translate,
            clipExtent = m.clipExtent,
            clipAuto;
        m.scale = function() {
          var v = scale.apply(m, arguments);
          return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.translate = function() {
          var v = translate.apply(m, arguments);
          return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.clipExtent = function(_) {
          var v = clipExtent.apply(m, arguments);
          if (v === m) {
            if (clipAuto = _ == null) {
              var k = π * scale(),
                  t = translate();
              clipExtent([[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]]);
            }
          } else if (clipAuto) {
            v = null;
          }
          return v;
        };
        return m.clipExtent(null);
      }
      (d3.geo.mercator = function() {
        return d3_geo_mercatorProjection(d3_geo_mercator);
      }).raw = d3_geo_mercator;
      var d3_geo_orthographic = d3_geo_azimuthal(function() {
        return 1;
      }, Math.asin);
      (d3.geo.orthographic = function() {
        return d3_geo_projection(d3_geo_orthographic);
      }).raw = d3_geo_orthographic;
      var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
        return 1 / (1 + cosλcosφ);
      }, function(ρ) {
        return 2 * Math.atan(ρ);
      });
      (d3.geo.stereographic = function() {
        return d3_geo_projection(d3_geo_stereographic);
      }).raw = d3_geo_stereographic;
      function d3_geo_transverseMercator(λ, φ) {
        return [Math.log(Math.tan(π / 4 + φ / 2)), -λ];
      }
      d3_geo_transverseMercator.invert = function(x, y) {
        return [-y, 2 * Math.atan(Math.exp(x)) - halfπ];
      };
      (d3.geo.transverseMercator = function() {
        var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator),
            center = projection.center,
            rotate = projection.rotate;
        projection.center = function(_) {
          return _ ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
        };
        projection.rotate = function(_) {
          return _ ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
        };
        return rotate([0, 0, 90]);
      }).raw = d3_geo_transverseMercator;
      d3.geom = {};
      function d3_geom_pointX(d) {
        return d[0];
      }
      function d3_geom_pointY(d) {
        return d[1];
      }
      d3.geom.hull = function(vertices) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY;
        if (arguments.length)
          return hull(vertices);
        function hull(data) {
          if (data.length < 3)
            return [];
          var fx = d3_functor(x),
              fy = d3_functor(y),
              i,
              n = data.length,
              points = [],
              flippedPoints = [];
          for (i = 0; i < n; i++) {
            points.push([+fx.call(this, data[i], i), +fy.call(this, data[i], i), i]);
          }
          points.sort(d3_geom_hullOrder);
          for (i = 0; i < n; i++)
            flippedPoints.push([points[i][0], -points[i][1]]);
          var upper = d3_geom_hullUpper(points),
              lower = d3_geom_hullUpper(flippedPoints);
          var skipLeft = lower[0] === upper[0],
              skipRight = lower[lower.length - 1] === upper[upper.length - 1],
              polygon = [];
          for (i = upper.length - 1; i >= 0; --i)
            polygon.push(data[points[upper[i]][2]]);
          for (i = +skipLeft; i < lower.length - skipRight; ++i)
            polygon.push(data[points[lower[i]][2]]);
          return polygon;
        }
        hull.x = function(_) {
          return arguments.length ? (x = _, hull) : x;
        };
        hull.y = function(_) {
          return arguments.length ? (y = _, hull) : y;
        };
        return hull;
      };
      function d3_geom_hullUpper(points) {
        var n = points.length,
            hull = [0, 1],
            hs = 2;
        for (var i = 2; i < n; i++) {
          while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0)
            --hs;
          hull[hs++] = i;
        }
        return hull.slice(0, hs);
      }
      function d3_geom_hullOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1];
      }
      d3.geom.polygon = function(coordinates) {
        d3_subclass(coordinates, d3_geom_polygonPrototype);
        return coordinates;
      };
      var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
      d3_geom_polygonPrototype.area = function() {
        var i = -1,
            n = this.length,
            a,
            b = this[n - 1],
            area = 0;
        while (++i < n) {
          a = b;
          b = this[i];
          area += a[1] * b[0] - a[0] * b[1];
        }
        return area * .5;
      };
      d3_geom_polygonPrototype.centroid = function(k) {
        var i = -1,
            n = this.length,
            x = 0,
            y = 0,
            a,
            b = this[n - 1],
            c;
        if (!arguments.length)
          k = -1 / (6 * this.area());
        while (++i < n) {
          a = b;
          b = this[i];
          c = a[0] * b[1] - b[0] * a[1];
          x += (a[0] + b[0]) * c;
          y += (a[1] + b[1]) * c;
        }
        return [x * k, y * k];
      };
      d3_geom_polygonPrototype.clip = function(subject) {
        var input,
            closed = d3_geom_polygonClosed(subject),
            i = -1,
            n = this.length - d3_geom_polygonClosed(this),
            j,
            m,
            a = this[n - 1],
            b,
            c,
            d;
        while (++i < n) {
          input = subject.slice();
          subject.length = 0;
          b = this[i];
          c = input[(m = input.length - closed) - 1];
          j = -1;
          while (++j < m) {
            d = input[j];
            if (d3_geom_polygonInside(d, a, b)) {
              if (!d3_geom_polygonInside(c, a, b)) {
                subject.push(d3_geom_polygonIntersect(c, d, a, b));
              }
              subject.push(d);
            } else if (d3_geom_polygonInside(c, a, b)) {
              subject.push(d3_geom_polygonIntersect(c, d, a, b));
            }
            c = d;
          }
          if (closed)
            subject.push(subject[0]);
          a = b;
        }
        return subject;
      };
      function d3_geom_polygonInside(p, a, b) {
        return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
      }
      function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0],
            x3 = a[0],
            x21 = d[0] - x1,
            x43 = b[0] - x3,
            y1 = c[1],
            y3 = a[1],
            y21 = d[1] - y1,
            y43 = b[1] - y3,
            ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [x1 + ua * x21, y1 + ua * y21];
      }
      function d3_geom_polygonClosed(coordinates) {
        var a = coordinates[0],
            b = coordinates[coordinates.length - 1];
        return !(a[0] - b[0] || a[1] - b[1]);
      }
      var d3_geom_voronoiEdges,
          d3_geom_voronoiCells,
          d3_geom_voronoiBeaches,
          d3_geom_voronoiBeachPool = [],
          d3_geom_voronoiFirstCircle,
          d3_geom_voronoiCircles,
          d3_geom_voronoiCirclePool = [];
      function d3_geom_voronoiBeach() {
        d3_geom_voronoiRedBlackNode(this);
        this.edge = this.site = this.circle = null;
      }
      function d3_geom_voronoiCreateBeach(site) {
        var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
        beach.site = site;
        return beach;
      }
      function d3_geom_voronoiDetachBeach(beach) {
        d3_geom_voronoiDetachCircle(beach);
        d3_geom_voronoiBeaches.remove(beach);
        d3_geom_voronoiBeachPool.push(beach);
        d3_geom_voronoiRedBlackNode(beach);
      }
      function d3_geom_voronoiRemoveBeach(beach) {
        var circle = beach.circle,
            x = circle.x,
            y = circle.cy,
            vertex = {
              x: x,
              y: y
            },
            previous = beach.P,
            next = beach.N,
            disappearing = [beach];
        d3_geom_voronoiDetachBeach(beach);
        var lArc = previous;
        while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
          previous = lArc.P;
          disappearing.unshift(lArc);
          d3_geom_voronoiDetachBeach(lArc);
          lArc = previous;
        }
        disappearing.unshift(lArc);
        d3_geom_voronoiDetachCircle(lArc);
        var rArc = next;
        while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
          next = rArc.N;
          disappearing.push(rArc);
          d3_geom_voronoiDetachBeach(rArc);
          rArc = next;
        }
        disappearing.push(rArc);
        d3_geom_voronoiDetachCircle(rArc);
        var nArcs = disappearing.length,
            iArc;
        for (iArc = 1; iArc < nArcs; ++iArc) {
          rArc = disappearing[iArc];
          lArc = disappearing[iArc - 1];
          d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
      }
      function d3_geom_voronoiAddBeach(site) {
        var x = site.x,
            directrix = site.y,
            lArc,
            rArc,
            dxl,
            dxr,
            node = d3_geom_voronoiBeaches._;
        while (node) {
          dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
          if (dxl > ε)
            node = node.L;
          else {
            dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
            if (dxr > ε) {
              if (!node.R) {
                lArc = node;
                break;
              }
              node = node.R;
            } else {
              if (dxl > -ε) {
                lArc = node.P;
                rArc = node;
              } else if (dxr > -ε) {
                lArc = node;
                rArc = node.N;
              } else {
                lArc = rArc = node;
              }
              break;
            }
          }
        }
        var newArc = d3_geom_voronoiCreateBeach(site);
        d3_geom_voronoiBeaches.insert(lArc, newArc);
        if (!lArc && !rArc)
          return;
        if (lArc === rArc) {
          d3_geom_voronoiDetachCircle(lArc);
          rArc = d3_geom_voronoiCreateBeach(lArc.site);
          d3_geom_voronoiBeaches.insert(newArc, rArc);
          newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
          d3_geom_voronoiAttachCircle(lArc);
          d3_geom_voronoiAttachCircle(rArc);
          return;
        }
        if (!rArc) {
          newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
          return;
        }
        d3_geom_voronoiDetachCircle(lArc);
        d3_geom_voronoiDetachCircle(rArc);
        var lSite = lArc.site,
            ax = lSite.x,
            ay = lSite.y,
            bx = site.x - ax,
            by = site.y - ay,
            rSite = rArc.site,
            cx = rSite.x - ax,
            cy = rSite.y - ay,
            d = 2 * (bx * cy - by * cx),
            hb = bx * bx + by * by,
            hc = cx * cx + cy * cy,
            vertex = {
              x: (cy * hb - by * hc) / d + ax,
              y: (bx * hc - cx * hb) / d + ay
            };
        d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
        rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
      }
      function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
        var site = arc.site,
            rfocx = site.x,
            rfocy = site.y,
            pby2 = rfocy - directrix;
        if (!pby2)
          return rfocx;
        var lArc = arc.P;
        if (!lArc)
          return -Infinity;
        site = lArc.site;
        var lfocx = site.x,
            lfocy = site.y,
            plby2 = lfocy - directrix;
        if (!plby2)
          return lfocx;
        var hl = lfocx - rfocx,
            aby2 = 1 / pby2 - 1 / plby2,
            b = hl / plby2;
        if (aby2)
          return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
      }
      function d3_geom_voronoiRightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc)
          return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site.y === directrix ? site.x : Infinity;
      }
      function d3_geom_voronoiCell(site) {
        this.site = site;
        this.edges = [];
      }
      d3_geom_voronoiCell.prototype.prepare = function() {
        var halfEdges = this.edges,
            iHalfEdge = halfEdges.length,
            edge;
        while (iHalfEdge--) {
          edge = halfEdges[iHalfEdge].edge;
          if (!edge.b || !edge.a)
            halfEdges.splice(iHalfEdge, 1);
        }
        halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
        return halfEdges.length;
      };
      function d3_geom_voronoiCloseCells(extent) {
        var x0 = extent[0][0],
            x1 = extent[1][0],
            y0 = extent[0][1],
            y1 = extent[1][1],
            x2,
            y2,
            x3,
            y3,
            cells = d3_geom_voronoiCells,
            iCell = cells.length,
            cell,
            iHalfEdge,
            halfEdges,
            nHalfEdges,
            start,
            end;
        while (iCell--) {
          cell = cells[iCell];
          if (!cell || !cell.prepare())
            continue;
          halfEdges = cell.edges;
          nHalfEdges = halfEdges.length;
          iHalfEdge = 0;
          while (iHalfEdge < nHalfEdges) {
            end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
            start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
            if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
              halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
                x: x0,
                y: abs(x2 - x0) < ε ? y2 : y1
              } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
                x: abs(y2 - y1) < ε ? x2 : x1,
                y: y1
              } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
                x: x1,
                y: abs(x2 - x1) < ε ? y2 : y0
              } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
                x: abs(y2 - y0) < ε ? x2 : x0,
                y: y0
              } : null), cell.site, null));
              ++nHalfEdges;
            }
          }
        }
      }
      function d3_geom_voronoiHalfEdgeOrder(a, b) {
        return b.angle - a.angle;
      }
      function d3_geom_voronoiCircle() {
        d3_geom_voronoiRedBlackNode(this);
        this.x = this.y = this.arc = this.site = this.cy = null;
      }
      function d3_geom_voronoiAttachCircle(arc) {
        var lArc = arc.P,
            rArc = arc.N;
        if (!lArc || !rArc)
          return;
        var lSite = lArc.site,
            cSite = arc.site,
            rSite = rArc.site;
        if (lSite === rSite)
          return;
        var bx = cSite.x,
            by = cSite.y,
            ax = lSite.x - bx,
            ay = lSite.y - by,
            cx = rSite.x - bx,
            cy = rSite.y - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -ε2)
          return;
        var ha = ax * ax + ay * ay,
            hc = cx * cx + cy * cy,
            x = (cy * ha - ay * hc) / d,
            y = (ax * hc - cx * ha) / d,
            cy = y + by;
        var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x + bx;
        circle.y = cy + Math.sqrt(x * x + y * y);
        circle.cy = cy;
        arc.circle = circle;
        var before = null,
            node = d3_geom_voronoiCircles._;
        while (node) {
          if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
            if (node.L)
              node = node.L;
            else {
              before = node.P;
              break;
            }
          } else {
            if (node.R)
              node = node.R;
            else {
              before = node;
              break;
            }
          }
        }
        d3_geom_voronoiCircles.insert(before, circle);
        if (!before)
          d3_geom_voronoiFirstCircle = circle;
      }
      function d3_geom_voronoiDetachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
          if (!circle.P)
            d3_geom_voronoiFirstCircle = circle.N;
          d3_geom_voronoiCircles.remove(circle);
          d3_geom_voronoiCirclePool.push(circle);
          d3_geom_voronoiRedBlackNode(circle);
          arc.circle = null;
        }
      }
      function d3_geom_voronoiClipEdges(extent) {
        var edges = d3_geom_voronoiEdges,
            clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]),
            i = edges.length,
            e;
        while (i--) {
          e = edges[i];
          if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
            e.a = e.b = null;
            edges.splice(i, 1);
          }
        }
      }
      function d3_geom_voronoiConnectEdge(edge, extent) {
        var vb = edge.b;
        if (vb)
          return true;
        var va = edge.a,
            x0 = extent[0][0],
            x1 = extent[1][0],
            y0 = extent[0][1],
            y1 = extent[1][1],
            lSite = edge.l,
            rSite = edge.r,
            lx = lSite.x,
            ly = lSite.y,
            rx = rSite.x,
            ry = rSite.y,
            fx = (lx + rx) / 2,
            fy = (ly + ry) / 2,
            fm,
            fb;
        if (ry === ly) {
          if (fx < x0 || fx >= x1)
            return;
          if (lx > rx) {
            if (!va)
              va = {
                x: fx,
                y: y0
              };
            else if (va.y >= y1)
              return;
            vb = {
              x: fx,
              y: y1
            };
          } else {
            if (!va)
              va = {
                x: fx,
                y: y1
              };
            else if (va.y < y0)
              return;
            vb = {
              x: fx,
              y: y0
            };
          }
        } else {
          fm = (lx - rx) / (ry - ly);
          fb = fy - fm * fx;
          if (fm < -1 || fm > 1) {
            if (lx > rx) {
              if (!va)
                va = {
                  x: (y0 - fb) / fm,
                  y: y0
                };
              else if (va.y >= y1)
                return;
              vb = {
                x: (y1 - fb) / fm,
                y: y1
              };
            } else {
              if (!va)
                va = {
                  x: (y1 - fb) / fm,
                  y: y1
                };
              else if (va.y < y0)
                return;
              vb = {
                x: (y0 - fb) / fm,
                y: y0
              };
            }
          } else {
            if (ly < ry) {
              if (!va)
                va = {
                  x: x0,
                  y: fm * x0 + fb
                };
              else if (va.x >= x1)
                return;
              vb = {
                x: x1,
                y: fm * x1 + fb
              };
            } else {
              if (!va)
                va = {
                  x: x1,
                  y: fm * x1 + fb
                };
              else if (va.x < x0)
                return;
              vb = {
                x: x0,
                y: fm * x0 + fb
              };
            }
          }
        }
        edge.a = va;
        edge.b = vb;
        return true;
      }
      function d3_geom_voronoiEdge(lSite, rSite) {
        this.l = lSite;
        this.r = rSite;
        this.a = this.b = null;
      }
      function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, rSite);
        d3_geom_voronoiEdges.push(edge);
        if (va)
          d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
        if (vb)
          d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
        d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
        d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
        return edge;
      }
      function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, null);
        edge.a = va;
        edge.b = vb;
        d3_geom_voronoiEdges.push(edge);
        return edge;
      }
      function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
        if (!edge.a && !edge.b) {
          edge.a = vertex;
          edge.l = lSite;
          edge.r = rSite;
        } else if (edge.l === rSite) {
          edge.b = vertex;
        } else {
          edge.a = vertex;
        }
      }
      function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
        var va = edge.a,
            vb = edge.b;
        this.edge = edge;
        this.site = lSite;
        this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
      }
      d3_geom_voronoiHalfEdge.prototype = {
        start: function() {
          return this.edge.l === this.site ? this.edge.a : this.edge.b;
        },
        end: function() {
          return this.edge.l === this.site ? this.edge.b : this.edge.a;
        }
      };
      function d3_geom_voronoiRedBlackTree() {
        this._ = null;
      }
      function d3_geom_voronoiRedBlackNode(node) {
        node.U = node.C = node.L = node.R = node.P = node.N = null;
      }
      d3_geom_voronoiRedBlackTree.prototype = {
        insert: function(after, node) {
          var parent,
              grandpa,
              uncle;
          if (after) {
            node.P = after;
            node.N = after.N;
            if (after.N)
              after.N.P = node;
            after.N = node;
            if (after.R) {
              after = after.R;
              while (after.L)
                after = after.L;
              after.L = node;
            } else {
              after.R = node;
            }
            parent = after;
          } else if (this._) {
            after = d3_geom_voronoiRedBlackFirst(this._);
            node.P = null;
            node.N = after;
            after.P = after.L = node;
            parent = after;
          } else {
            node.P = node.N = null;
            this._ = node;
            parent = null;
          }
          node.L = node.R = null;
          node.U = parent;
          node.C = true;
          after = node;
          while (parent && parent.C) {
            grandpa = parent.U;
            if (parent === grandpa.L) {
              uncle = grandpa.R;
              if (uncle && uncle.C) {
                parent.C = uncle.C = false;
                grandpa.C = true;
                after = grandpa;
              } else {
                if (after === parent.R) {
                  d3_geom_voronoiRedBlackRotateLeft(this, parent);
                  after = parent;
                  parent = after.U;
                }
                parent.C = false;
                grandpa.C = true;
                d3_geom_voronoiRedBlackRotateRight(this, grandpa);
              }
            } else {
              uncle = grandpa.L;
              if (uncle && uncle.C) {
                parent.C = uncle.C = false;
                grandpa.C = true;
                after = grandpa;
              } else {
                if (after === parent.L) {
                  d3_geom_voronoiRedBlackRotateRight(this, parent);
                  after = parent;
                  parent = after.U;
                }
                parent.C = false;
                grandpa.C = true;
                d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
              }
            }
            parent = after.U;
          }
          this._.C = false;
        },
        remove: function(node) {
          if (node.N)
            node.N.P = node.P;
          if (node.P)
            node.P.N = node.N;
          node.N = node.P = null;
          var parent = node.U,
              sibling,
              left = node.L,
              right = node.R,
              next,
              red;
          if (!left)
            next = right;
          else if (!right)
            next = left;
          else
            next = d3_geom_voronoiRedBlackFirst(right);
          if (parent) {
            if (parent.L === node)
              parent.L = next;
            else
              parent.R = next;
          } else {
            this._ = next;
          }
          if (left && right) {
            red = next.C;
            next.C = node.C;
            next.L = left;
            left.U = next;
            if (next !== right) {
              parent = next.U;
              next.U = node.U;
              node = next.R;
              parent.L = node;
              next.R = right;
              right.U = next;
            } else {
              next.U = parent;
              parent = next;
              node = next.R;
            }
          } else {
            red = node.C;
            node = next;
          }
          if (node)
            node.U = parent;
          if (red)
            return;
          if (node && node.C) {
            node.C = false;
            return;
          }
          do {
            if (node === this._)
              break;
            if (node === parent.L) {
              sibling = parent.R;
              if (sibling.C) {
                sibling.C = false;
                parent.C = true;
                d3_geom_voronoiRedBlackRotateLeft(this, parent);
                sibling = parent.R;
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.R || !sibling.R.C) {
                  sibling.L.C = false;
                  sibling.C = true;
                  d3_geom_voronoiRedBlackRotateRight(this, sibling);
                  sibling = parent.R;
                }
                sibling.C = parent.C;
                parent.C = sibling.R.C = false;
                d3_geom_voronoiRedBlackRotateLeft(this, parent);
                node = this._;
                break;
              }
            } else {
              sibling = parent.L;
              if (sibling.C) {
                sibling.C = false;
                parent.C = true;
                d3_geom_voronoiRedBlackRotateRight(this, parent);
                sibling = parent.L;
              }
              if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                if (!sibling.L || !sibling.L.C) {
                  sibling.R.C = false;
                  sibling.C = true;
                  d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                  sibling = parent.L;
                }
                sibling.C = parent.C;
                parent.C = sibling.L.C = false;
                d3_geom_voronoiRedBlackRotateRight(this, parent);
                node = this._;
                break;
              }
            }
            sibling.C = true;
            node = parent;
            parent = parent.U;
          } while (!node.C);
          if (node)
            node.C = false;
        }
      };
      function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
        var p = node,
            q = node.R,
            parent = p.U;
        if (parent) {
          if (parent.L === p)
            parent.L = q;
          else
            parent.R = q;
        } else {
          tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R)
          p.R.U = p;
        q.L = p;
      }
      function d3_geom_voronoiRedBlackRotateRight(tree, node) {
        var p = node,
            q = node.L,
            parent = p.U;
        if (parent) {
          if (parent.L === p)
            parent.L = q;
          else
            parent.R = q;
        } else {
          tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L)
          p.L.U = p;
        q.R = p;
      }
      function d3_geom_voronoiRedBlackFirst(node) {
        while (node.L)
          node = node.L;
        return node;
      }
      function d3_geom_voronoi(sites, bbox) {
        var site = sites.sort(d3_geom_voronoiVertexOrder).pop(),
            x0,
            y0,
            circle;
        d3_geom_voronoiEdges = [];
        d3_geom_voronoiCells = new Array(sites.length);
        d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
        d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
        while (true) {
          circle = d3_geom_voronoiFirstCircle;
          if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
            if (site.x !== x0 || site.y !== y0) {
              d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
              d3_geom_voronoiAddBeach(site);
              x0 = site.x, y0 = site.y;
            }
            site = sites.pop();
          } else if (circle) {
            d3_geom_voronoiRemoveBeach(circle.arc);
          } else {
            break;
          }
        }
        if (bbox)
          d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
        var diagram = {
          cells: d3_geom_voronoiCells,
          edges: d3_geom_voronoiEdges
        };
        d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
        return diagram;
      }
      function d3_geom_voronoiVertexOrder(a, b) {
        return b.y - a.y || b.x - a.x;
      }
      d3.geom.voronoi = function(points) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            fx = x,
            fy = y,
            clipExtent = d3_geom_voronoiClipExtent;
        if (points)
          return voronoi(points);
        function voronoi(data) {
          var polygons = new Array(data.length),
              x0 = clipExtent[0][0],
              y0 = clipExtent[0][1],
              x1 = clipExtent[1][0],
              y1 = clipExtent[1][1];
          d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
            var edges = cell.edges,
                site = cell.site,
                polygon = polygons[i] = edges.length ? edges.map(function(e) {
                  var s = e.start();
                  return [s.x, s.y];
                }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]] : [];
            polygon.point = data[i];
          });
          return polygons;
        }
        function sites(data) {
          return data.map(function(d, i) {
            return {
              x: Math.round(fx(d, i) / ε) * ε,
              y: Math.round(fy(d, i) / ε) * ε,
              i: i
            };
          });
        }
        voronoi.links = function(data) {
          return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
            return edge.l && edge.r;
          }).map(function(edge) {
            return {
              source: data[edge.l.i],
              target: data[edge.r.i]
            };
          });
        };
        voronoi.triangles = function(data) {
          var triangles = [];
          d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
            var site = cell.site,
                edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder),
                j = -1,
                m = edges.length,
                e0,
                s0,
                e1 = edges[m - 1].edge,
                s1 = e1.l === site ? e1.r : e1.l;
            while (++j < m) {
              e0 = e1;
              s0 = s1;
              e1 = edges[j].edge;
              s1 = e1.l === site ? e1.r : e1.l;
              if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                triangles.push([data[i], data[s0.i], data[s1.i]]);
              }
            }
          });
          return triangles;
        };
        voronoi.x = function(_) {
          return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
        };
        voronoi.y = function(_) {
          return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
        };
        voronoi.clipExtent = function(_) {
          if (!arguments.length)
            return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
          clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
          return voronoi;
        };
        voronoi.size = function(_) {
          if (!arguments.length)
            return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
          return voronoi.clipExtent(_ && [[0, 0], _]);
        };
        return voronoi;
      };
      var d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];
      function d3_geom_voronoiTriangleArea(a, b, c) {
        return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
      }
      d3.geom.delaunay = function(vertices) {
        return d3.geom.voronoi().triangles(vertices);
      };
      d3.geom.quadtree = function(points, x1, y1, x2, y2) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            compat;
        if (compat = arguments.length) {
          x = d3_geom_quadtreeCompatX;
          y = d3_geom_quadtreeCompatY;
          if (compat === 3) {
            y2 = y1;
            x2 = x1;
            y1 = x1 = 0;
          }
          return quadtree(points);
        }
        function quadtree(data) {
          var d,
              fx = d3_functor(x),
              fy = d3_functor(y),
              xs,
              ys,
              i,
              n,
              x1_,
              y1_,
              x2_,
              y2_;
          if (x1 != null) {
            x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
          } else {
            x2_ = y2_ = -(x1_ = y1_ = Infinity);
            xs = [], ys = [];
            n = data.length;
            if (compat)
              for (i = 0; i < n; ++i) {
                d = data[i];
                if (d.x < x1_)
                  x1_ = d.x;
                if (d.y < y1_)
                  y1_ = d.y;
                if (d.x > x2_)
                  x2_ = d.x;
                if (d.y > y2_)
                  y2_ = d.y;
                xs.push(d.x);
                ys.push(d.y);
              }
            else
              for (i = 0; i < n; ++i) {
                var x_ = +fx(d = data[i], i),
                    y_ = +fy(d, i);
                if (x_ < x1_)
                  x1_ = x_;
                if (y_ < y1_)
                  y1_ = y_;
                if (x_ > x2_)
                  x2_ = x_;
                if (y_ > y2_)
                  y2_ = y_;
                xs.push(x_);
                ys.push(y_);
              }
          }
          var dx = x2_ - x1_,
              dy = y2_ - y1_;
          if (dx > dy)
            y2_ = y1_ + dx;
          else
            x2_ = x1_ + dy;
          function insert(n, d, x, y, x1, y1, x2, y2) {
            if (isNaN(x) || isNaN(y))
              return;
            if (n.leaf) {
              var nx = n.x,
                  ny = n.y;
              if (nx != null) {
                if (abs(nx - x) + abs(ny - y) < .01) {
                  insertChild(n, d, x, y, x1, y1, x2, y2);
                } else {
                  var nPoint = n.point;
                  n.x = n.y = n.point = null;
                  insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                  insertChild(n, d, x, y, x1, y1, x2, y2);
                }
              } else {
                n.x = x, n.y = y, n.point = d;
              }
            } else {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          }
          function insertChild(n, d, x, y, x1, y1, x2, y2) {
            var xm = (x1 + x2) * .5,
                ym = (y1 + y2) * .5,
                right = x >= xm,
                below = y >= ym,
                i = below << 1 | right;
            n.leaf = false;
            n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
            if (right)
              x1 = xm;
            else
              x2 = xm;
            if (below)
              y1 = ym;
            else
              y2 = ym;
            insert(n, d, x, y, x1, y1, x2, y2);
          }
          var root = d3_geom_quadtreeNode();
          root.add = function(d) {
            insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
          };
          root.visit = function(f) {
            d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
          };
          root.find = function(point) {
            return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
          };
          i = -1;
          if (x1 == null) {
            while (++i < n) {
              insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
            }
            --i;
          } else
            data.forEach(root.add);
          xs = ys = data = d = null;
          return root;
        }
        quadtree.x = function(_) {
          return arguments.length ? (x = _, quadtree) : x;
        };
        quadtree.y = function(_) {
          return arguments.length ? (y = _, quadtree) : y;
        };
        quadtree.extent = function(_) {
          if (!arguments.length)
            return x1 == null ? null : [[x1, y1], [x2, y2]];
          if (_ == null)
            x1 = y1 = x2 = y2 = null;
          else
            x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], y2 = +_[1][1];
          return quadtree;
        };
        quadtree.size = function(_) {
          if (!arguments.length)
            return x1 == null ? null : [x2 - x1, y2 - y1];
          if (_ == null)
            x1 = y1 = x2 = y2 = null;
          else
            x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
          return quadtree;
        };
        return quadtree;
      };
      function d3_geom_quadtreeCompatX(d) {
        return d.x;
      }
      function d3_geom_quadtreeCompatY(d) {
        return d.y;
      }
      function d3_geom_quadtreeNode() {
        return {
          leaf: true,
          nodes: [],
          point: null,
          x: null,
          y: null
        };
      }
      function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
          var sx = (x1 + x2) * .5,
              sy = (y1 + y2) * .5,
              children = node.nodes;
          if (children[0])
            d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
          if (children[1])
            d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
          if (children[2])
            d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
          if (children[3])
            d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
        }
      }
      function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
        var minDistance2 = Infinity,
            closestPoint;
        (function find(node, x1, y1, x2, y2) {
          if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0)
            return;
          if (point = node.point) {
            var point,
                dx = x - point[0],
                dy = y - point[1],
                distance2 = dx * dx + dy * dy;
            if (distance2 < minDistance2) {
              var distance = Math.sqrt(minDistance2 = distance2);
              x0 = x - distance, y0 = y - distance;
              x3 = x + distance, y3 = y + distance;
              closestPoint = point;
            }
          }
          var children = node.nodes,
              xm = (x1 + x2) * .5,
              ym = (y1 + y2) * .5,
              right = x >= xm,
              below = y >= ym;
          for (var i = below << 1 | right,
              j = i + 4; i < j; ++i) {
            if (node = children[i & 3])
              switch (i & 3) {
                case 0:
                  find(node, x1, y1, xm, ym);
                  break;
                case 1:
                  find(node, xm, y1, x2, ym);
                  break;
                case 2:
                  find(node, x1, ym, xm, y2);
                  break;
                case 3:
                  find(node, xm, ym, x2, y2);
                  break;
              }
          }
        })(root, x0, y0, x3, y3);
        return closestPoint;
      }
      d3.interpolateRgb = d3_interpolateRgb;
      function d3_interpolateRgb(a, b) {
        a = d3.rgb(a);
        b = d3.rgb(b);
        var ar = a.r,
            ag = a.g,
            ab = a.b,
            br = b.r - ar,
            bg = b.g - ag,
            bb = b.b - ab;
        return function(t) {
          return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        };
      }
      d3.interpolateObject = d3_interpolateObject;
      function d3_interpolateObject(a, b) {
        var i = {},
            c = {},
            k;
        for (k in a) {
          if (k in b) {
            i[k] = d3_interpolate(a[k], b[k]);
          } else {
            c[k] = a[k];
          }
        }
        for (k in b) {
          if (!(k in a)) {
            c[k] = b[k];
          }
        }
        return function(t) {
          for (k in i)
            c[k] = i[k](t);
          return c;
        };
      }
      d3.interpolateNumber = d3_interpolateNumber;
      function d3_interpolateNumber(a, b) {
        a = +a, b = +b;
        return function(t) {
          return a * (1 - t) + b * t;
        };
      }
      d3.interpolateString = d3_interpolateString;
      function d3_interpolateString(a, b) {
        var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0,
            am,
            bm,
            bs,
            i = -1,
            s = [],
            q = [];
        a = a + "", b = b + "";
        while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
          if ((bs = bm.index) > bi) {
            bs = b.slice(bi, bs);
            if (s[i])
              s[i] += bs;
            else
              s[++i] = bs;
          }
          if ((am = am[0]) === (bm = bm[0])) {
            if (s[i])
              s[i] += bm;
            else
              s[++i] = bm;
          } else {
            s[++i] = null;
            q.push({
              i: i,
              x: d3_interpolateNumber(am, bm)
            });
          }
          bi = d3_interpolate_numberB.lastIndex;
        }
        if (bi < b.length) {
          bs = b.slice(bi);
          if (s[i])
            s[i] += bs;
          else
            s[++i] = bs;
        }
        return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
          return b(t) + "";
        }) : function() {
          return b;
        } : (b = q.length, function(t) {
          for (var i = 0,
              o; i < b; ++i)
            s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
      }
      var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
          d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
      d3.interpolate = d3_interpolate;
      function d3_interpolate(a, b) {
        var i = d3.interpolators.length,
            f;
        while (--i >= 0 && !(f = d3.interpolators[i](a, b)))
          ;
        return f;
      }
      d3.interpolators = [function(a, b) {
        var t = typeof b;
        return (t === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
      }];
      d3.interpolateArray = d3_interpolateArray;
      function d3_interpolateArray(a, b) {
        var x = [],
            c = [],
            na = a.length,
            nb = b.length,
            n0 = Math.min(a.length, b.length),
            i;
        for (i = 0; i < n0; ++i)
          x.push(d3_interpolate(a[i], b[i]));
        for (; i < na; ++i)
          c[i] = a[i];
        for (; i < nb; ++i)
          c[i] = b[i];
        return function(t) {
          for (i = 0; i < n0; ++i)
            c[i] = x[i](t);
          return c;
        };
      }
      var d3_ease_default = function() {
        return d3_identity;
      };
      var d3_ease = d3.map({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function() {
          return d3_ease_quad;
        },
        cubic: function() {
          return d3_ease_cubic;
        },
        sin: function() {
          return d3_ease_sin;
        },
        exp: function() {
          return d3_ease_exp;
        },
        circle: function() {
          return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function() {
          return d3_ease_bounce;
        }
      });
      var d3_ease_mode = d3.map({
        "in": d3_identity,
        out: d3_ease_reverse,
        "in-out": d3_ease_reflect,
        "out-in": function(f) {
          return d3_ease_reflect(d3_ease_reverse(f));
        }
      });
      d3.ease = function(name) {
        var i = name.indexOf("-"),
            t = i >= 0 ? name.slice(0, i) : name,
            m = i >= 0 ? name.slice(i + 1) : "in";
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
      };
      function d3_ease_clamp(f) {
        return function(t) {
          return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        };
      }
      function d3_ease_reverse(f) {
        return function(t) {
          return 1 - f(1 - t);
        };
      }
      function d3_ease_reflect(f) {
        return function(t) {
          return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
      }
      function d3_ease_quad(t) {
        return t * t;
      }
      function d3_ease_cubic(t) {
        return t * t * t;
      }
      function d3_ease_cubicInOut(t) {
        if (t <= 0)
          return 0;
        if (t >= 1)
          return 1;
        var t2 = t * t,
            t3 = t2 * t;
        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
      }
      function d3_ease_poly(e) {
        return function(t) {
          return Math.pow(t, e);
        };
      }
      function d3_ease_sin(t) {
        return 1 - Math.cos(t * halfπ);
      }
      function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
      }
      function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
      }
      function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2)
          p = .45;
        if (arguments.length)
          s = p / τ * Math.asin(1 / a);
        else
          a = 1, s = p / 4;
        return function(t) {
          return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
        };
      }
      function d3_ease_back(s) {
        if (!s)
          s = 1.70158;
        return function(t) {
          return t * t * ((s + 1) * t - s);
        };
      }
      function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
      }
      d3.interpolateHcl = d3_interpolateHcl;
      function d3_interpolateHcl(a, b) {
        a = d3.hcl(a);
        b = d3.hcl(b);
        var ah = a.h,
            ac = a.c,
            al = a.l,
            bh = b.h - ah,
            bc = b.c - ac,
            bl = b.l - al;
        if (isNaN(bc))
          bc = 0, ac = isNaN(ac) ? b.c : ac;
        if (isNaN(bh))
          bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
          bh -= 360;
        else if (bh < -180)
          bh += 360;
        return function(t) {
          return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
        };
      }
      d3.interpolateHsl = d3_interpolateHsl;
      function d3_interpolateHsl(a, b) {
        a = d3.hsl(a);
        b = d3.hsl(b);
        var ah = a.h,
            as = a.s,
            al = a.l,
            bh = b.h - ah,
            bs = b.s - as,
            bl = b.l - al;
        if (isNaN(bs))
          bs = 0, as = isNaN(as) ? b.s : as;
        if (isNaN(bh))
          bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
          bh -= 360;
        else if (bh < -180)
          bh += 360;
        return function(t) {
          return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
        };
      }
      d3.interpolateLab = d3_interpolateLab;
      function d3_interpolateLab(a, b) {
        a = d3.lab(a);
        b = d3.lab(b);
        var al = a.l,
            aa = a.a,
            ab = a.b,
            bl = b.l - al,
            ba = b.a - aa,
            bb = b.b - ab;
        return function(t) {
          return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
        };
      }
      d3.interpolateRound = d3_interpolateRound;
      function d3_interpolateRound(a, b) {
        b -= a;
        return function(t) {
          return Math.round(a + b * t);
        };
      }
      d3.transform = function(string) {
        var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
        return (d3.transform = function(string) {
          if (string != null) {
            g.setAttribute("transform", string);
            var t = g.transform.baseVal.consolidate();
          }
          return new d3_transform(t ? t.matrix : d3_transformIdentity);
        })(string);
      };
      function d3_transform(m) {
        var r0 = [m.a, m.b],
            r1 = [m.c, m.d],
            kx = d3_transformNormalize(r0),
            kz = d3_transformDot(r0, r1),
            ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
          r0[0] *= -1;
          r0[1] *= -1;
          kx *= -1;
          kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
        this.translate = [m.e, m.f];
        this.scale = [kx, ky];
        this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
      }
      d3_transform.prototype.toString = function() {
        return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
      };
      function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
      }
      function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
          a[0] /= k;
          a[1] /= k;
        }
        return k;
      }
      function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
      }
      var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
      };
      d3.interpolateTransform = d3_interpolateTransform;
      function d3_interpolateTransform(a, b) {
        var s = [],
            q = [],
            n,
            A = d3.transform(a),
            B = d3.transform(b),
            ta = A.translate,
            tb = B.translate,
            ra = A.rotate,
            rb = B.rotate,
            wa = A.skew,
            wb = B.skew,
            ka = A.scale,
            kb = B.scale;
        if (ta[0] != tb[0] || ta[1] != tb[1]) {
          s.push("translate(", null, ",", null, ")");
          q.push({
            i: 1,
            x: d3_interpolateNumber(ta[0], tb[0])
          }, {
            i: 3,
            x: d3_interpolateNumber(ta[1], tb[1])
          });
        } else if (tb[0] || tb[1]) {
          s.push("translate(" + tb + ")");
        } else {
          s.push("");
        }
        if (ra != rb) {
          if (ra - rb > 180)
            rb += 360;
          else if (rb - ra > 180)
            ra += 360;
          q.push({
            i: s.push(s.pop() + "rotate(", null, ")") - 2,
            x: d3_interpolateNumber(ra, rb)
          });
        } else if (rb) {
          s.push(s.pop() + "rotate(" + rb + ")");
        }
        if (wa != wb) {
          q.push({
            i: s.push(s.pop() + "skewX(", null, ")") - 2,
            x: d3_interpolateNumber(wa, wb)
          });
        } else if (wb) {
          s.push(s.pop() + "skewX(" + wb + ")");
        }
        if (ka[0] != kb[0] || ka[1] != kb[1]) {
          n = s.push(s.pop() + "scale(", null, ",", null, ")");
          q.push({
            i: n - 4,
            x: d3_interpolateNumber(ka[0], kb[0])
          }, {
            i: n - 2,
            x: d3_interpolateNumber(ka[1], kb[1])
          });
        } else if (kb[0] != 1 || kb[1] != 1) {
          s.push(s.pop() + "scale(" + kb + ")");
        }
        n = q.length;
        return function(t) {
          var i = -1,
              o;
          while (++i < n)
            s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      }
      function d3_uninterpolateNumber(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function(x) {
          return (x - a) / b;
        };
      }
      function d3_uninterpolateClamp(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function(x) {
          return Math.max(0, Math.min(1, (x - a) / b));
        };
      }
      d3.layout = {};
      d3.layout.bundle = function() {
        return function(links) {
          var paths = [],
              i = -1,
              n = links.length;
          while (++i < n)
            paths.push(d3_layout_bundlePath(links[i]));
          return paths;
        };
      };
      function d3_layout_bundlePath(link) {
        var start = link.source,
            end = link.target,
            lca = d3_layout_bundleLeastCommonAncestor(start, end),
            points = [start];
        while (start !== lca) {
          start = start.parent;
          points.push(start);
        }
        var k = points.length;
        while (end !== lca) {
          points.splice(k, 0, end);
          end = end.parent;
        }
        return points;
      }
      function d3_layout_bundleAncestors(node) {
        var ancestors = [],
            parent = node.parent;
        while (parent != null) {
          ancestors.push(node);
          node = parent;
          parent = parent.parent;
        }
        ancestors.push(node);
        return ancestors;
      }
      function d3_layout_bundleLeastCommonAncestor(a, b) {
        if (a === b)
          return a;
        var aNodes = d3_layout_bundleAncestors(a),
            bNodes = d3_layout_bundleAncestors(b),
            aNode = aNodes.pop(),
            bNode = bNodes.pop(),
            sharedNode = null;
        while (aNode === bNode) {
          sharedNode = aNode;
          aNode = aNodes.pop();
          bNode = bNodes.pop();
        }
        return sharedNode;
      }
      d3.layout.chord = function() {
        var chord = {},
            chords,
            groups,
            matrix,
            n,
            padding = 0,
            sortGroups,
            sortSubgroups,
            sortChords;
        function relayout() {
          var subgroups = {},
              groupSums = [],
              groupIndex = d3.range(n),
              subgroupIndex = [],
              k,
              x,
              x0,
              i,
              j;
          chords = [];
          groups = [];
          k = 0, i = -1;
          while (++i < n) {
            x = 0, j = -1;
            while (++j < n) {
              x += matrix[i][j];
            }
            groupSums.push(x);
            subgroupIndex.push(d3.range(n));
            k += x;
          }
          if (sortGroups) {
            groupIndex.sort(function(a, b) {
              return sortGroups(groupSums[a], groupSums[b]);
            });
          }
          if (sortSubgroups) {
            subgroupIndex.forEach(function(d, i) {
              d.sort(function(a, b) {
                return sortSubgroups(matrix[i][a], matrix[i][b]);
              });
            });
          }
          k = (τ - padding * n) / k;
          x = 0, i = -1;
          while (++i < n) {
            x0 = x, j = -1;
            while (++j < n) {
              var di = groupIndex[i],
                  dj = subgroupIndex[di][j],
                  v = matrix[di][dj],
                  a0 = x,
                  a1 = x += v * k;
              subgroups[di + "-" + dj] = {
                index: di,
                subindex: dj,
                startAngle: a0,
                endAngle: a1,
                value: v
              };
            }
            groups[di] = {
              index: di,
              startAngle: x0,
              endAngle: x,
              value: (x - x0) / k
            };
            x += padding;
          }
          i = -1;
          while (++i < n) {
            j = i - 1;
            while (++j < n) {
              var source = subgroups[i + "-" + j],
                  target = subgroups[j + "-" + i];
              if (source.value || target.value) {
                chords.push(source.value < target.value ? {
                  source: target,
                  target: source
                } : {
                  source: source,
                  target: target
                });
              }
            }
          }
          if (sortChords)
            resort();
        }
        function resort() {
          chords.sort(function(a, b) {
            return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
          });
        }
        chord.matrix = function(x) {
          if (!arguments.length)
            return matrix;
          n = (matrix = x) && matrix.length;
          chords = groups = null;
          return chord;
        };
        chord.padding = function(x) {
          if (!arguments.length)
            return padding;
          padding = x;
          chords = groups = null;
          return chord;
        };
        chord.sortGroups = function(x) {
          if (!arguments.length)
            return sortGroups;
          sortGroups = x;
          chords = groups = null;
          return chord;
        };
        chord.sortSubgroups = function(x) {
          if (!arguments.length)
            return sortSubgroups;
          sortSubgroups = x;
          chords = null;
          return chord;
        };
        chord.sortChords = function(x) {
          if (!arguments.length)
            return sortChords;
          sortChords = x;
          if (chords)
            resort();
          return chord;
        };
        chord.chords = function() {
          if (!chords)
            relayout();
          return chords;
        };
        chord.groups = function() {
          if (!groups)
            relayout();
          return groups;
        };
        return chord;
      };
      d3.layout.force = function() {
        var force = {},
            event = d3.dispatch("start", "tick", "end"),
            size = [1, 1],
            drag,
            alpha,
            friction = .9,
            linkDistance = d3_layout_forceLinkDistance,
            linkStrength = d3_layout_forceLinkStrength,
            charge = -30,
            chargeDistance2 = d3_layout_forceChargeDistance2,
            gravity = .1,
            theta2 = .64,
            nodes = [],
            links = [],
            distances,
            strengths,
            charges;
        function repulse(node) {
          return function(quad, x1, _, x2) {
            if (quad.point !== node) {
              var dx = quad.cx - node.x,
                  dy = quad.cy - node.y,
                  dw = x2 - x1,
                  dn = dx * dx + dy * dy;
              if (dw * dw / theta2 < dn) {
                if (dn < chargeDistance2) {
                  var k = quad.charge / dn;
                  node.px -= dx * k;
                  node.py -= dy * k;
                }
                return true;
              }
              if (quad.point && dn && dn < chargeDistance2) {
                var k = quad.pointCharge / dn;
                node.px -= dx * k;
                node.py -= dy * k;
              }
            }
            return !quad.charge;
          };
        }
        force.tick = function() {
          if ((alpha *= .99) < .005) {
            event.end({
              type: "end",
              alpha: alpha = 0
            });
            return true;
          }
          var n = nodes.length,
              m = links.length,
              q,
              i,
              o,
              s,
              t,
              l,
              k,
              x,
              y;
          for (i = 0; i < m; ++i) {
            o = links[i];
            s = o.source;
            t = o.target;
            x = t.x - s.x;
            y = t.y - s.y;
            if (l = x * x + y * y) {
              l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
              x *= l;
              y *= l;
              t.x -= x * (k = s.weight / (t.weight + s.weight));
              t.y -= y * k;
              s.x += x * (k = 1 - k);
              s.y += y * k;
            }
          }
          if (k = alpha * gravity) {
            x = size[0] / 2;
            y = size[1] / 2;
            i = -1;
            if (k)
              while (++i < n) {
                o = nodes[i];
                o.x += (x - o.x) * k;
                o.y += (y - o.y) * k;
              }
          }
          if (charge) {
            d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
            i = -1;
            while (++i < n) {
              if (!(o = nodes[i]).fixed) {
                q.visit(repulse(o));
              }
            }
          }
          i = -1;
          while (++i < n) {
            o = nodes[i];
            if (o.fixed) {
              o.x = o.px;
              o.y = o.py;
            } else {
              o.x -= (o.px - (o.px = o.x)) * friction;
              o.y -= (o.py - (o.py = o.y)) * friction;
            }
          }
          event.tick({
            type: "tick",
            alpha: alpha
          });
        };
        force.nodes = function(x) {
          if (!arguments.length)
            return nodes;
          nodes = x;
          return force;
        };
        force.links = function(x) {
          if (!arguments.length)
            return links;
          links = x;
          return force;
        };
        force.size = function(x) {
          if (!arguments.length)
            return size;
          size = x;
          return force;
        };
        force.linkDistance = function(x) {
          if (!arguments.length)
            return linkDistance;
          linkDistance = typeof x === "function" ? x : +x;
          return force;
        };
        force.distance = force.linkDistance;
        force.linkStrength = function(x) {
          if (!arguments.length)
            return linkStrength;
          linkStrength = typeof x === "function" ? x : +x;
          return force;
        };
        force.friction = function(x) {
          if (!arguments.length)
            return friction;
          friction = +x;
          return force;
        };
        force.charge = function(x) {
          if (!arguments.length)
            return charge;
          charge = typeof x === "function" ? x : +x;
          return force;
        };
        force.chargeDistance = function(x) {
          if (!arguments.length)
            return Math.sqrt(chargeDistance2);
          chargeDistance2 = x * x;
          return force;
        };
        force.gravity = function(x) {
          if (!arguments.length)
            return gravity;
          gravity = +x;
          return force;
        };
        force.theta = function(x) {
          if (!arguments.length)
            return Math.sqrt(theta2);
          theta2 = x * x;
          return force;
        };
        force.alpha = function(x) {
          if (!arguments.length)
            return alpha;
          x = +x;
          if (alpha) {
            if (x > 0)
              alpha = x;
            else
              alpha = 0;
          } else if (x > 0) {
            event.start({
              type: "start",
              alpha: alpha = x
            });
            d3.timer(force.tick);
          }
          return force;
        };
        force.start = function() {
          var i,
              n = nodes.length,
              m = links.length,
              w = size[0],
              h = size[1],
              neighbors,
              o;
          for (i = 0; i < n; ++i) {
            (o = nodes[i]).index = i;
            o.weight = 0;
          }
          for (i = 0; i < m; ++i) {
            o = links[i];
            if (typeof o.source == "number")
              o.source = nodes[o.source];
            if (typeof o.target == "number")
              o.target = nodes[o.target];
            ++o.source.weight;
            ++o.target.weight;
          }
          for (i = 0; i < n; ++i) {
            o = nodes[i];
            if (isNaN(o.x))
              o.x = position("x", w);
            if (isNaN(o.y))
              o.y = position("y", h);
            if (isNaN(o.px))
              o.px = o.x;
            if (isNaN(o.py))
              o.py = o.y;
          }
          distances = [];
          if (typeof linkDistance === "function")
            for (i = 0; i < m; ++i)
              distances[i] = +linkDistance.call(this, links[i], i);
          else
            for (i = 0; i < m; ++i)
              distances[i] = linkDistance;
          strengths = [];
          if (typeof linkStrength === "function")
            for (i = 0; i < m; ++i)
              strengths[i] = +linkStrength.call(this, links[i], i);
          else
            for (i = 0; i < m; ++i)
              strengths[i] = linkStrength;
          charges = [];
          if (typeof charge === "function")
            for (i = 0; i < n; ++i)
              charges[i] = +charge.call(this, nodes[i], i);
          else
            for (i = 0; i < n; ++i)
              charges[i] = charge;
          function position(dimension, size) {
            if (!neighbors) {
              neighbors = new Array(n);
              for (j = 0; j < n; ++j) {
                neighbors[j] = [];
              }
              for (j = 0; j < m; ++j) {
                var o = links[j];
                neighbors[o.source.index].push(o.target);
                neighbors[o.target.index].push(o.source);
              }
            }
            var candidates = neighbors[i],
                j = -1,
                m = candidates.length,
                x;
            while (++j < m)
              if (!isNaN(x = candidates[j][dimension]))
                return x;
            return Math.random() * size;
          }
          return force.resume();
        };
        force.resume = function() {
          return force.alpha(.1);
        };
        force.stop = function() {
          return force.alpha(0);
        };
        force.drag = function() {
          if (!drag)
            drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
          if (!arguments.length)
            return drag;
          this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
        };
        function dragmove(d) {
          d.px = d3.event.x, d.py = d3.event.y;
          force.resume();
        }
        return d3.rebind(force, event, "on");
      };
      function d3_layout_forceDragstart(d) {
        d.fixed |= 2;
      }
      function d3_layout_forceDragend(d) {
        d.fixed &= ~6;
      }
      function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
      }
      function d3_layout_forceMouseout(d) {
        d.fixed &= ~4;
      }
      function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0,
            cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
          var nodes = quad.nodes,
              n = nodes.length,
              i = -1,
              c;
          while (++i < n) {
            c = nodes[i];
            if (c == null)
              continue;
            d3_layout_forceAccumulate(c, alpha, charges);
            quad.charge += c.charge;
            cx += c.charge * c.cx;
            cy += c.charge * c.cy;
          }
        }
        if (quad.point) {
          if (!quad.leaf) {
            quad.point.x += Math.random() - .5;
            quad.point.y += Math.random() - .5;
          }
          var k = alpha * charges[quad.point.index];
          quad.charge += quad.pointCharge = k;
          cx += k * quad.point.x;
          cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
      }
      var d3_layout_forceLinkDistance = 20,
          d3_layout_forceLinkStrength = 1,
          d3_layout_forceChargeDistance2 = Infinity;
      d3.layout.hierarchy = function() {
        var sort = d3_layout_hierarchySort,
            children = d3_layout_hierarchyChildren,
            value = d3_layout_hierarchyValue;
        function hierarchy(root) {
          var stack = [root],
              nodes = [],
              node;
          root.depth = 0;
          while ((node = stack.pop()) != null) {
            nodes.push(node);
            if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
              var n,
                  childs,
                  child;
              while (--n >= 0) {
                stack.push(child = childs[n]);
                child.parent = node;
                child.depth = node.depth + 1;
              }
              if (value)
                node.value = 0;
              node.children = childs;
            } else {
              if (value)
                node.value = +value.call(hierarchy, node, node.depth) || 0;
              delete node.children;
            }
          }
          d3_layout_hierarchyVisitAfter(root, function(node) {
            var childs,
                parent;
            if (sort && (childs = node.children))
              childs.sort(sort);
            if (value && (parent = node.parent))
              parent.value += node.value;
          });
          return nodes;
        }
        hierarchy.sort = function(x) {
          if (!arguments.length)
            return sort;
          sort = x;
          return hierarchy;
        };
        hierarchy.children = function(x) {
          if (!arguments.length)
            return children;
          children = x;
          return hierarchy;
        };
        hierarchy.value = function(x) {
          if (!arguments.length)
            return value;
          value = x;
          return hierarchy;
        };
        hierarchy.revalue = function(root) {
          if (value) {
            d3_layout_hierarchyVisitBefore(root, function(node) {
              if (node.children)
                node.value = 0;
            });
            d3_layout_hierarchyVisitAfter(root, function(node) {
              var parent;
              if (!node.children)
                node.value = +value.call(hierarchy, node, node.depth) || 0;
              if (parent = node.parent)
                parent.value += node.value;
            });
          }
          return root;
        };
        return hierarchy;
      };
      function d3_layout_hierarchyRebind(object, hierarchy) {
        d3.rebind(object, hierarchy, "sort", "children", "value");
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
      }
      function d3_layout_hierarchyVisitBefore(node, callback) {
        var nodes = [node];
        while ((node = nodes.pop()) != null) {
          callback(node);
          if ((children = node.children) && (n = children.length)) {
            var n,
                children;
            while (--n >= 0)
              nodes.push(children[n]);
          }
        }
      }
      function d3_layout_hierarchyVisitAfter(node, callback) {
        var nodes = [node],
            nodes2 = [];
        while ((node = nodes.pop()) != null) {
          nodes2.push(node);
          if ((children = node.children) && (n = children.length)) {
            var i = -1,
                n,
                children;
            while (++i < n)
              nodes.push(children[i]);
          }
        }
        while ((node = nodes2.pop()) != null) {
          callback(node);
        }
      }
      function d3_layout_hierarchyChildren(d) {
        return d.children;
      }
      function d3_layout_hierarchyValue(d) {
        return d.value;
      }
      function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
      }
      function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function(parent) {
          return (parent.children || []).map(function(child) {
            return {
              source: parent,
              target: child
            };
          });
        }));
      }
      d3.layout.partition = function() {
        var hierarchy = d3.layout.hierarchy(),
            size = [1, 1];
        function position(node, x, dx, dy) {
          var children = node.children;
          node.x = x;
          node.y = node.depth * dy;
          node.dx = dx;
          node.dy = dy;
          if (children && (n = children.length)) {
            var i = -1,
                n,
                c,
                d;
            dx = node.value ? dx / node.value : 0;
            while (++i < n) {
              position(c = children[i], x, d = c.value * dx, dy);
              x += d;
            }
          }
        }
        function depth(node) {
          var children = node.children,
              d = 0;
          if (children && (n = children.length)) {
            var i = -1,
                n;
            while (++i < n)
              d = Math.max(d, depth(children[i]));
          }
          return 1 + d;
        }
        function partition(d, i) {
          var nodes = hierarchy.call(this, d, i);
          position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
          return nodes;
        }
        partition.size = function(x) {
          if (!arguments.length)
            return size;
          size = x;
          return partition;
        };
        return d3_layout_hierarchyRebind(partition, hierarchy);
      };
      d3.layout.pie = function() {
        var value = Number,
            sort = d3_layout_pieSortByValue,
            startAngle = 0,
            endAngle = τ,
            padAngle = 0;
        function pie(data) {
          var n = data.length,
              values = data.map(function(d, i) {
                return +value.call(pie, d, i);
              }),
              a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle),
              da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a,
              p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)),
              pa = p * (da < 0 ? -1 : 1),
              k = (da - n * pa) / d3.sum(values),
              index = d3.range(n),
              arcs = [],
              v;
          if (sort != null)
            index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
              return values[j] - values[i];
            } : function(i, j) {
              return sort(data[i], data[j]);
            });
          index.forEach(function(i) {
            arcs[i] = {
              data: data[i],
              value: v = values[i],
              startAngle: a,
              endAngle: a += v * k + pa,
              padAngle: p
            };
          });
          return arcs;
        }
        pie.value = function(_) {
          if (!arguments.length)
            return value;
          value = _;
          return pie;
        };
        pie.sort = function(_) {
          if (!arguments.length)
            return sort;
          sort = _;
          return pie;
        };
        pie.startAngle = function(_) {
          if (!arguments.length)
            return startAngle;
          startAngle = _;
          return pie;
        };
        pie.endAngle = function(_) {
          if (!arguments.length)
            return endAngle;
          endAngle = _;
          return pie;
        };
        pie.padAngle = function(_) {
          if (!arguments.length)
            return padAngle;
          padAngle = _;
          return pie;
        };
        return pie;
      };
      var d3_layout_pieSortByValue = {};
      d3.layout.stack = function() {
        var values = d3_identity,
            order = d3_layout_stackOrderDefault,
            offset = d3_layout_stackOffsetZero,
            out = d3_layout_stackOut,
            x = d3_layout_stackX,
            y = d3_layout_stackY;
        function stack(data, index) {
          if (!(n = data.length))
            return data;
          var series = data.map(function(d, i) {
            return values.call(stack, d, i);
          });
          var points = series.map(function(d) {
            return d.map(function(v, i) {
              return [x.call(stack, v, i), y.call(stack, v, i)];
            });
          });
          var orders = order.call(stack, points, index);
          series = d3.permute(series, orders);
          points = d3.permute(points, orders);
          var offsets = offset.call(stack, points, index);
          var m = series[0].length,
              n,
              i,
              j,
              o;
          for (j = 0; j < m; ++j) {
            out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
            for (i = 1; i < n; ++i) {
              out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
            }
          }
          return data;
        }
        stack.values = function(x) {
          if (!arguments.length)
            return values;
          values = x;
          return stack;
        };
        stack.order = function(x) {
          if (!arguments.length)
            return order;
          order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
          return stack;
        };
        stack.offset = function(x) {
          if (!arguments.length)
            return offset;
          offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
          return stack;
        };
        stack.x = function(z) {
          if (!arguments.length)
            return x;
          x = z;
          return stack;
        };
        stack.y = function(z) {
          if (!arguments.length)
            return y;
          y = z;
          return stack;
        };
        stack.out = function(z) {
          if (!arguments.length)
            return out;
          out = z;
          return stack;
        };
        return stack;
      };
      function d3_layout_stackX(d) {
        return d.x;
      }
      function d3_layout_stackY(d) {
        return d.y;
      }
      function d3_layout_stackOut(d, y0, y) {
        d.y0 = y0;
        d.y = y;
      }
      var d3_layout_stackOrders = d3.map({
        "inside-out": function(data) {
          var n = data.length,
              i,
              j,
              max = data.map(d3_layout_stackMaxIndex),
              sums = data.map(d3_layout_stackReduceSum),
              index = d3.range(n).sort(function(a, b) {
                return max[a] - max[b];
              }),
              top = 0,
              bottom = 0,
              tops = [],
              bottoms = [];
          for (i = 0; i < n; ++i) {
            j = index[i];
            if (top < bottom) {
              top += sums[j];
              tops.push(j);
            } else {
              bottom += sums[j];
              bottoms.push(j);
            }
          }
          return bottoms.reverse().concat(tops);
        },
        reverse: function(data) {
          return d3.range(data.length).reverse();
        },
        "default": d3_layout_stackOrderDefault
      });
      var d3_layout_stackOffsets = d3.map({
        silhouette: function(data) {
          var n = data.length,
              m = data[0].length,
              sums = [],
              max = 0,
              i,
              j,
              o,
              y0 = [];
          for (j = 0; j < m; ++j) {
            for (i = 0, o = 0; i < n; i++)
              o += data[i][j][1];
            if (o > max)
              max = o;
            sums.push(o);
          }
          for (j = 0; j < m; ++j) {
            y0[j] = (max - sums[j]) / 2;
          }
          return y0;
        },
        wiggle: function(data) {
          var n = data.length,
              x = data[0],
              m = x.length,
              i,
              j,
              k,
              s1,
              s2,
              s3,
              dx,
              o,
              o0,
              y0 = [];
          y0[0] = o = o0 = 0;
          for (j = 1; j < m; ++j) {
            for (i = 0, s1 = 0; i < n; ++i)
              s1 += data[i][j][1];
            for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
              for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
              }
              s2 += s3 * data[i][j][1];
            }
            y0[j] = o -= s1 ? s2 / s1 * dx : 0;
            if (o < o0)
              o0 = o;
          }
          for (j = 0; j < m; ++j)
            y0[j] -= o0;
          return y0;
        },
        expand: function(data) {
          var n = data.length,
              m = data[0].length,
              k = 1 / n,
              i,
              j,
              o,
              y0 = [];
          for (j = 0; j < m; ++j) {
            for (i = 0, o = 0; i < n; i++)
              o += data[i][j][1];
            if (o)
              for (i = 0; i < n; i++)
                data[i][j][1] /= o;
            else
              for (i = 0; i < n; i++)
                data[i][j][1] = k;
          }
          for (j = 0; j < m; ++j)
            y0[j] = 0;
          return y0;
        },
        zero: d3_layout_stackOffsetZero
      });
      function d3_layout_stackOrderDefault(data) {
        return d3.range(data.length);
      }
      function d3_layout_stackOffsetZero(data) {
        var j = -1,
            m = data[0].length,
            y0 = [];
        while (++j < m)
          y0[j] = 0;
        return y0;
      }
      function d3_layout_stackMaxIndex(array) {
        var i = 1,
            j = 0,
            v = array[0][1],
            k,
            n = array.length;
        for (; i < n; ++i) {
          if ((k = array[i][1]) > v) {
            j = i;
            v = k;
          }
        }
        return j;
      }
      function d3_layout_stackReduceSum(d) {
        return d.reduce(d3_layout_stackSum, 0);
      }
      function d3_layout_stackSum(p, d) {
        return p + d[1];
      }
      d3.layout.histogram = function() {
        var frequency = true,
            valuer = Number,
            ranger = d3_layout_histogramRange,
            binner = d3_layout_histogramBinSturges;
        function histogram(data, i) {
          var bins = [],
              values = data.map(valuer, this),
              range = ranger.call(this, values, i),
              thresholds = binner.call(this, range, values, i),
              bin,
              i = -1,
              n = values.length,
              m = thresholds.length - 1,
              k = frequency ? 1 : 1 / n,
              x;
          while (++i < m) {
            bin = bins[i] = [];
            bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
            bin.y = 0;
          }
          if (m > 0) {
            i = -1;
            while (++i < n) {
              x = values[i];
              if (x >= range[0] && x <= range[1]) {
                bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                bin.y += k;
                bin.push(data[i]);
              }
            }
          }
          return bins;
        }
        histogram.value = function(x) {
          if (!arguments.length)
            return valuer;
          valuer = x;
          return histogram;
        };
        histogram.range = function(x) {
          if (!arguments.length)
            return ranger;
          ranger = d3_functor(x);
          return histogram;
        };
        histogram.bins = function(x) {
          if (!arguments.length)
            return binner;
          binner = typeof x === "number" ? function(range) {
            return d3_layout_histogramBinFixed(range, x);
          } : d3_functor(x);
          return histogram;
        };
        histogram.frequency = function(x) {
          if (!arguments.length)
            return frequency;
          frequency = !!x;
          return histogram;
        };
        return histogram;
      };
      function d3_layout_histogramBinSturges(range, values) {
        return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
      }
      function d3_layout_histogramBinFixed(range, n) {
        var x = -1,
            b = +range[0],
            m = (range[1] - b) / n,
            f = [];
        while (++x <= n)
          f[x] = m * x + b;
        return f;
      }
      function d3_layout_histogramRange(values) {
        return [d3.min(values), d3.max(values)];
      }
      d3.layout.pack = function() {
        var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort),
            padding = 0,
            size = [1, 1],
            radius;
        function pack(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root = nodes[0],
              w = size[0],
              h = size[1],
              r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
                return radius;
              };
          root.x = root.y = 0;
          d3_layout_hierarchyVisitAfter(root, function(d) {
            d.r = +r(d.value);
          });
          d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
          if (padding) {
            var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
            d3_layout_hierarchyVisitAfter(root, function(d) {
              d.r += dr;
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            d3_layout_hierarchyVisitAfter(root, function(d) {
              d.r -= dr;
            });
          }
          d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
          return nodes;
        }
        pack.size = function(_) {
          if (!arguments.length)
            return size;
          size = _;
          return pack;
        };
        pack.radius = function(_) {
          if (!arguments.length)
            return radius;
          radius = _ == null || typeof _ === "function" ? _ : +_;
          return pack;
        };
        pack.padding = function(_) {
          if (!arguments.length)
            return padding;
          padding = +_;
          return pack;
        };
        return d3_layout_hierarchyRebind(pack, hierarchy);
      };
      function d3_layout_packSort(a, b) {
        return a.value - b.value;
      }
      function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b;
        b._pack_prev = a;
        b._pack_next = c;
        c._pack_prev = b;
      }
      function d3_layout_packSplice(a, b) {
        a._pack_next = b;
        b._pack_prev = a;
      }
      function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x,
            dy = b.y - a.y,
            dr = a.r + b.r;
        return .999 * dr * dr > dx * dx + dy * dy;
      }
      function d3_layout_packSiblings(node) {
        if (!(nodes = node.children) || !(n = nodes.length))
          return;
        var nodes,
            xMin = Infinity,
            xMax = -Infinity,
            yMin = Infinity,
            yMax = -Infinity,
            a,
            b,
            c,
            i,
            j,
            k,
            n;
        function bound(node) {
          xMin = Math.min(node.x - node.r, xMin);
          xMax = Math.max(node.x + node.r, xMax);
          yMin = Math.min(node.y - node.r, yMin);
          yMax = Math.max(node.y + node.r, yMax);
        }
        nodes.forEach(d3_layout_packLink);
        a = nodes[0];
        a.x = -a.r;
        a.y = 0;
        bound(a);
        if (n > 1) {
          b = nodes[1];
          b.x = b.r;
          b.y = 0;
          bound(b);
          if (n > 2) {
            c = nodes[2];
            d3_layout_packPlace(a, b, c);
            bound(c);
            d3_layout_packInsert(a, c);
            a._pack_prev = c;
            d3_layout_packInsert(c, b);
            b = a._pack_next;
            for (i = 3; i < n; i++) {
              d3_layout_packPlace(a, b, c = nodes[i]);
              var isect = 0,
                  s1 = 1,
                  s2 = 1;
              for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                if (d3_layout_packIntersects(j, c)) {
                  isect = 1;
                  break;
                }
              }
              if (isect == 1) {
                for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                  if (d3_layout_packIntersects(k, c)) {
                    break;
                  }
                }
              }
              if (isect) {
                if (s1 < s2 || s1 == s2 && b.r < a.r)
                  d3_layout_packSplice(a, b = j);
                else
                  d3_layout_packSplice(a = k, b);
                i--;
              } else {
                d3_layout_packInsert(a, c);
                b = c;
                bound(c);
              }
            }
          }
        }
        var cx = (xMin + xMax) / 2,
            cy = (yMin + yMax) / 2,
            cr = 0;
        for (i = 0; i < n; i++) {
          c = nodes[i];
          c.x -= cx;
          c.y -= cy;
          cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
        }
        node.r = cr;
        nodes.forEach(d3_layout_packUnlink);
      }
      function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node;
      }
      function d3_layout_packUnlink(node) {
        delete node._pack_next;
        delete node._pack_prev;
      }
      function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        node.x = x += k * node.x;
        node.y = y += k * node.y;
        node.r *= k;
        if (children) {
          var i = -1,
              n = children.length;
          while (++i < n)
            d3_layout_packTransform(children[i], x, y, k);
        }
      }
      function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r,
            dx = b.x - a.x,
            dy = b.y - a.y;
        if (db && (dx || dy)) {
          var da = b.r + c.r,
              dc = dx * dx + dy * dy;
          da *= da;
          db *= db;
          var x = .5 + (db - da) / (2 * dc),
              y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
          c.x = a.x + x * dx + y * dy;
          c.y = a.y + x * dy - y * dx;
        } else {
          c.x = a.x + db;
          c.y = a.y;
        }
      }
      d3.layout.tree = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null),
            separation = d3_layout_treeSeparation,
            size = [1, 1],
            nodeSize = null;
        function tree(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root0 = nodes[0],
              root1 = wrapTree(root0);
          d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
          d3_layout_hierarchyVisitBefore(root1, secondWalk);
          if (nodeSize)
            d3_layout_hierarchyVisitBefore(root0, sizeNode);
          else {
            var left = root0,
                right = root0,
                bottom = root0;
            d3_layout_hierarchyVisitBefore(root0, function(node) {
              if (node.x < left.x)
                left = node;
              if (node.x > right.x)
                right = node;
              if (node.depth > bottom.depth)
                bottom = node;
            });
            var tx = separation(left, right) / 2 - left.x,
                kx = size[0] / (right.x + separation(right, left) / 2 + tx),
                ky = size[1] / (bottom.depth || 1);
            d3_layout_hierarchyVisitBefore(root0, function(node) {
              node.x = (node.x + tx) * kx;
              node.y = node.depth * ky;
            });
          }
          return nodes;
        }
        function wrapTree(root0) {
          var root1 = {
            A: null,
            children: [root0]
          },
              queue = [root1],
              node1;
          while ((node1 = queue.pop()) != null) {
            for (var children = node1.children,
                child,
                i = 0,
                n = children.length; i < n; ++i) {
              queue.push((children[i] = child = {
                _: children[i],
                parent: node1,
                children: (child = children[i].children) && child.slice() || [],
                A: null,
                a: null,
                z: 0,
                m: 0,
                c: 0,
                s: 0,
                t: null,
                i: i
              }).a = child);
            }
          }
          return root1.children[0];
        }
        function firstWalk(v) {
          var children = v.children,
              siblings = v.parent.children,
              w = v.i ? siblings[v.i - 1] : null;
          if (children.length) {
            d3_layout_treeShift(v);
            var midpoint = (children[0].z + children[children.length - 1].z) / 2;
            if (w) {
              v.z = w.z + separation(v._, w._);
              v.m = v.z - midpoint;
            } else {
              v.z = midpoint;
            }
          } else if (w) {
            v.z = w.z + separation(v._, w._);
          }
          v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        function secondWalk(v) {
          v._.x = v.z + v.parent.m;
          v.m += v.parent.m;
        }
        function apportion(v, w, ancestor) {
          if (w) {
            var vip = v,
                vop = v,
                vim = w,
                vom = vip.parent.children[0],
                sip = vip.m,
                sop = vop.m,
                sim = vim.m,
                som = vom.m,
                shift;
            while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
              vom = d3_layout_treeLeft(vom);
              vop = d3_layout_treeRight(vop);
              vop.a = v;
              shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
              if (shift > 0) {
                d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                sip += shift;
                sop += shift;
              }
              sim += vim.m;
              sip += vip.m;
              som += vom.m;
              sop += vop.m;
            }
            if (vim && !d3_layout_treeRight(vop)) {
              vop.t = vim;
              vop.m += sim - sop;
            }
            if (vip && !d3_layout_treeLeft(vom)) {
              vom.t = vip;
              vom.m += sip - som;
              ancestor = v;
            }
          }
          return ancestor;
        }
        function sizeNode(node) {
          node.x *= size[0];
          node.y = node.depth * size[1];
        }
        tree.separation = function(x) {
          if (!arguments.length)
            return separation;
          separation = x;
          return tree;
        };
        tree.size = function(x) {
          if (!arguments.length)
            return nodeSize ? null : size;
          nodeSize = (size = x) == null ? sizeNode : null;
          return tree;
        };
        tree.nodeSize = function(x) {
          if (!arguments.length)
            return nodeSize ? size : null;
          nodeSize = (size = x) == null ? null : sizeNode;
          return tree;
        };
        return d3_layout_hierarchyRebind(tree, hierarchy);
      };
      function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
      }
      function d3_layout_treeLeft(v) {
        var children = v.children;
        return children.length ? children[0] : v.t;
      }
      function d3_layout_treeRight(v) {
        var children = v.children,
            n;
        return (n = children.length) ? children[n - 1] : v.t;
      }
      function d3_layout_treeMove(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
      }
      function d3_layout_treeShift(v) {
        var shift = 0,
            change = 0,
            children = v.children,
            i = children.length,
            w;
        while (--i >= 0) {
          w = children[i];
          w.z += shift;
          w.m += shift;
          shift += w.s + (change += w.c);
        }
      }
      function d3_layout_treeAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
      }
      d3.layout.cluster = function() {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null),
            separation = d3_layout_treeSeparation,
            size = [1, 1],
            nodeSize = false;
        function cluster(d, i) {
          var nodes = hierarchy.call(this, d, i),
              root = nodes[0],
              previousNode,
              x = 0;
          d3_layout_hierarchyVisitAfter(root, function(node) {
            var children = node.children;
            if (children && children.length) {
              node.x = d3_layout_clusterX(children);
              node.y = d3_layout_clusterY(children);
            } else {
              node.x = previousNode ? x += separation(node, previousNode) : 0;
              node.y = 0;
              previousNode = node;
            }
          });
          var left = d3_layout_clusterLeft(root),
              right = d3_layout_clusterRight(root),
              x0 = left.x - separation(left, right) / 2,
              x1 = right.x + separation(right, left) / 2;
          d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
            node.x = (node.x - root.x) * size[0];
            node.y = (root.y - node.y) * size[1];
          } : function(node) {
            node.x = (node.x - x0) / (x1 - x0) * size[0];
            node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
          });
          return nodes;
        }
        cluster.separation = function(x) {
          if (!arguments.length)
            return separation;
          separation = x;
          return cluster;
        };
        cluster.size = function(x) {
          if (!arguments.length)
            return nodeSize ? null : size;
          nodeSize = (size = x) == null;
          return cluster;
        };
        cluster.nodeSize = function(x) {
          if (!arguments.length)
            return nodeSize ? size : null;
          nodeSize = (size = x) != null;
          return cluster;
        };
        return d3_layout_hierarchyRebind(cluster, hierarchy);
      };
      function d3_layout_clusterY(children) {
        return 1 + d3.max(children, function(child) {
          return child.y;
        });
      }
      function d3_layout_clusterX(children) {
        return children.reduce(function(x, child) {
          return x + child.x;
        }, 0) / children.length;
      }
      function d3_layout_clusterLeft(node) {
        var children = node.children;
        return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
      }
      function d3_layout_clusterRight(node) {
        var children = node.children,
            n;
        return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
      }
      d3.layout.treemap = function() {
        var hierarchy = d3.layout.hierarchy(),
            round = Math.round,
            size = [1, 1],
            padding = null,
            pad = d3_layout_treemapPadNull,
            sticky = false,
            stickies,
            mode = "squarify",
            ratio = .5 * (1 + Math.sqrt(5));
        function scale(children, k) {
          var i = -1,
              n = children.length,
              child,
              area;
          while (++i < n) {
            area = (child = children[i]).value * (k < 0 ? 0 : k);
            child.area = isNaN(area) || area <= 0 ? 0 : area;
          }
        }
        function squarify(node) {
          var children = node.children;
          if (children && children.length) {
            var rect = pad(node),
                row = [],
                remaining = children.slice(),
                child,
                best = Infinity,
                score,
                u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy),
                n;
            scale(remaining, rect.dx * rect.dy / node.value);
            row.area = 0;
            while ((n = remaining.length) > 0) {
              row.push(child = remaining[n - 1]);
              row.area += child.area;
              if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                remaining.pop();
                best = score;
              } else {
                row.area -= row.pop().area;
                position(row, u, rect, false);
                u = Math.min(rect.dx, rect.dy);
                row.length = row.area = 0;
                best = Infinity;
              }
            }
            if (row.length) {
              position(row, u, rect, true);
              row.length = row.area = 0;
            }
            children.forEach(squarify);
          }
        }
        function stickify(node) {
          var children = node.children;
          if (children && children.length) {
            var rect = pad(node),
                remaining = children.slice(),
                child,
                row = [];
            scale(remaining, rect.dx * rect.dy / node.value);
            row.area = 0;
            while (child = remaining.pop()) {
              row.push(child);
              row.area += child.area;
              if (child.z != null) {
                position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                row.length = row.area = 0;
              }
            }
            children.forEach(stickify);
          }
        }
        function worst(row, u) {
          var s = row.area,
              r,
              rmax = 0,
              rmin = Infinity,
              i = -1,
              n = row.length;
          while (++i < n) {
            if (!(r = row[i].area))
              continue;
            if (r < rmin)
              rmin = r;
            if (r > rmax)
              rmax = r;
          }
          s *= s;
          u *= u;
          return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
          var i = -1,
              n = row.length,
              x = rect.x,
              y = rect.y,
              v = u ? round(row.area / u) : 0,
              o;
          if (u == rect.dx) {
            if (flush || v > rect.dy)
              v = rect.dy;
            while (++i < n) {
              o = row[i];
              o.x = x;
              o.y = y;
              o.dy = v;
              x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
            }
            o.z = true;
            o.dx += rect.x + rect.dx - x;
            rect.y += v;
            rect.dy -= v;
          } else {
            if (flush || v > rect.dx)
              v = rect.dx;
            while (++i < n) {
              o = row[i];
              o.x = x;
              o.y = y;
              o.dx = v;
              y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
            }
            o.z = false;
            o.dy += rect.y + rect.dy - y;
            rect.x += v;
            rect.dx -= v;
          }
        }
        function treemap(d) {
          var nodes = stickies || hierarchy(d),
              root = nodes[0];
          root.x = 0;
          root.y = 0;
          root.dx = size[0];
          root.dy = size[1];
          if (stickies)
            hierarchy.revalue(root);
          scale([root], root.dx * root.dy / root.value);
          (stickies ? stickify : squarify)(root);
          if (sticky)
            stickies = nodes;
          return nodes;
        }
        treemap.size = function(x) {
          if (!arguments.length)
            return size;
          size = x;
          return treemap;
        };
        treemap.padding = function(x) {
          if (!arguments.length)
            return padding;
          function padFunction(node) {
            var p = x.call(treemap, node, node.depth);
            return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [p, p, p, p] : p);
          }
          function padConstant(node) {
            return d3_layout_treemapPad(node, x);
          }
          var type;
          pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [x, x, x, x], padConstant) : padConstant;
          return treemap;
        };
        treemap.round = function(x) {
          if (!arguments.length)
            return round != Number;
          round = x ? Math.round : Number;
          return treemap;
        };
        treemap.sticky = function(x) {
          if (!arguments.length)
            return sticky;
          sticky = x;
          stickies = null;
          return treemap;
        };
        treemap.ratio = function(x) {
          if (!arguments.length)
            return ratio;
          ratio = x;
          return treemap;
        };
        treemap.mode = function(x) {
          if (!arguments.length)
            return mode;
          mode = x + "";
          return treemap;
        };
        return d3_layout_hierarchyRebind(treemap, hierarchy);
      };
      function d3_layout_treemapPadNull(node) {
        return {
          x: node.x,
          y: node.y,
          dx: node.dx,
          dy: node.dy
        };
      }
      function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3],
            y = node.y + padding[0],
            dx = node.dx - padding[1] - padding[3],
            dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
          x += dx / 2;
          dx = 0;
        }
        if (dy < 0) {
          y += dy / 2;
          dy = 0;
        }
        return {
          x: x,
          y: y,
          dx: dx,
          dy: dy
        };
      }
      d3.random = {
        normal: function(µ, σ) {
          var n = arguments.length;
          if (n < 2)
            σ = 1;
          if (n < 1)
            µ = 0;
          return function() {
            var x,
                y,
                r;
            do {
              x = Math.random() * 2 - 1;
              y = Math.random() * 2 - 1;
              r = x * x + y * y;
            } while (!r || r > 1);
            return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
          };
        },
        logNormal: function() {
          var random = d3.random.normal.apply(d3, arguments);
          return function() {
            return Math.exp(random());
          };
        },
        bates: function(m) {
          var random = d3.random.irwinHall(m);
          return function() {
            return random() / m;
          };
        },
        irwinHall: function(m) {
          return function() {
            for (var s = 0,
                j = 0; j < m; j++)
              s += Math.random();
            return s;
          };
        }
      };
      d3.scale = {};
      function d3_scaleExtent(domain) {
        var start = domain[0],
            stop = domain[domain.length - 1];
        return start < stop ? [start, stop] : [stop, start];
      }
      function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
      }
      function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]),
            i = interpolate(range[0], range[1]);
        return function(x) {
          return i(u(x));
        };
      }
      function d3_scale_nice(domain, nice) {
        var i0 = 0,
            i1 = domain.length - 1,
            x0 = domain[i0],
            x1 = domain[i1],
            dx;
        if (x1 < x0) {
          dx = i0, i0 = i1, i1 = dx;
          dx = x0, x0 = x1, x1 = dx;
        }
        domain[i0] = nice.floor(x0);
        domain[i1] = nice.ceil(x1);
        return domain;
      }
      function d3_scale_niceStep(step) {
        return step ? {
          floor: function(x) {
            return Math.floor(x / step) * step;
          },
          ceil: function(x) {
            return Math.ceil(x / step) * step;
          }
        } : d3_scale_niceIdentity;
      }
      var d3_scale_niceIdentity = {
        floor: d3_identity,
        ceil: d3_identity
      };
      function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [],
            i = [],
            j = 0,
            k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
          domain = domain.slice().reverse();
          range = range.slice().reverse();
        }
        while (++j <= k) {
          u.push(uninterpolate(domain[j - 1], domain[j]));
          i.push(interpolate(range[j - 1], range[j]));
        }
        return function(x) {
          var j = d3.bisect(domain, x, 1, k) - 1;
          return i[j](u[j](x));
        };
      }
      d3.scale.linear = function() {
        return d3_scale_linear([0, 1], [0, 1], d3_interpolate, false);
      };
      function d3_scale_linear(domain, range, interpolate, clamp) {
        var output,
            input;
        function rescale() {
          var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear,
              uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
          output = linear(domain, range, uninterpolate, interpolate);
          input = linear(range, domain, uninterpolate, d3_interpolate);
          return scale;
        }
        function scale(x) {
          return output(x);
        }
        scale.invert = function(y) {
          return input(y);
        };
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          domain = x.map(Number);
          return rescale();
        };
        scale.range = function(x) {
          if (!arguments.length)
            return range;
          range = x;
          return rescale();
        };
        scale.rangeRound = function(x) {
          return scale.range(x).interpolate(d3_interpolateRound);
        };
        scale.clamp = function(x) {
          if (!arguments.length)
            return clamp;
          clamp = x;
          return rescale();
        };
        scale.interpolate = function(x) {
          if (!arguments.length)
            return interpolate;
          interpolate = x;
          return rescale();
        };
        scale.ticks = function(m) {
          return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function(m) {
          d3_scale_linearNice(domain, m);
          return rescale();
        };
        scale.copy = function() {
          return d3_scale_linear(domain, range, interpolate, clamp);
        };
        return rescale();
      }
      function d3_scale_linearRebind(scale, linear) {
        return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
      }
      function d3_scale_linearNice(domain, m) {
        return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
      }
      function d3_scale_linearTickRange(domain, m) {
        if (m == null)
          m = 10;
        var extent = d3_scaleExtent(domain),
            span = extent[1] - extent[0],
            step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),
            err = m / span * step;
        if (err <= .15)
          step *= 10;
        else if (err <= .35)
          step *= 5;
        else if (err <= .75)
          step *= 2;
        extent[0] = Math.ceil(extent[0] / step) * step;
        extent[1] = Math.floor(extent[1] / step) * step + step * .5;
        extent[2] = step;
        return extent;
      }
      function d3_scale_linearTicks(domain, m) {
        return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
      }
      function d3_scale_linearTickFormat(domain, m, format) {
        var range = d3_scale_linearTickRange(domain, m);
        if (format) {
          var match = d3_format_re.exec(format);
          match.shift();
          if (match[8] === "s") {
            var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
            if (!match[7])
              match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
            match[8] = "f";
            format = d3.format(match.join(""));
            return function(d) {
              return format(prefix.scale(d)) + prefix.symbol;
            };
          }
          if (!match[7])
            match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
          format = match.join("");
        } else {
          format = ",." + d3_scale_linearPrecision(range[2]) + "f";
        }
        return d3.format(format);
      }
      var d3_scale_linearFormatSignificant = {
        s: 1,
        g: 1,
        p: 1,
        r: 1,
        e: 1
      };
      function d3_scale_linearPrecision(value) {
        return -Math.floor(Math.log(value) / Math.LN10 + .01);
      }
      function d3_scale_linearFormatPrecision(type, range) {
        var p = d3_scale_linearPrecision(range[2]);
        return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
      }
      d3.scale.log = function() {
        return d3_scale_log(d3.scale.linear().domain([0, 1]), 10, true, [1, 10]);
      };
      function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
          return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
        }
        function pow(x) {
          return positive ? Math.pow(base, x) : -Math.pow(base, -x);
        }
        function scale(x) {
          return linear(log(x));
        }
        scale.invert = function(x) {
          return pow(linear.invert(x));
        };
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          positive = x[0] >= 0;
          linear.domain((domain = x.map(Number)).map(log));
          return scale;
        };
        scale.base = function(_) {
          if (!arguments.length)
            return base;
          base = +_;
          linear.domain(domain.map(log));
          return scale;
        };
        scale.nice = function() {
          var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
          linear.domain(niced);
          domain = niced.map(pow);
          return scale;
        };
        scale.ticks = function() {
          var extent = d3_scaleExtent(domain),
              ticks = [],
              u = extent[0],
              v = extent[1],
              i = Math.floor(log(u)),
              j = Math.ceil(log(v)),
              n = base % 1 ? 2 : base;
          if (isFinite(j - i)) {
            if (positive) {
              for (; i < j; i++)
                for (var k = 1; k < n; k++)
                  ticks.push(pow(i) * k);
              ticks.push(pow(i));
            } else {
              ticks.push(pow(i));
              for (; i++ < j; )
                for (var k = n - 1; k > 0; k--)
                  ticks.push(pow(i) * k);
            }
            for (i = 0; ticks[i] < u; i++) {}
            for (j = ticks.length; ticks[j - 1] > v; j--) {}
            ticks = ticks.slice(i, j);
          }
          return ticks;
        };
        scale.tickFormat = function(n, format) {
          if (!arguments.length)
            return d3_scale_logFormat;
          if (arguments.length < 2)
            format = d3_scale_logFormat;
          else if (typeof format !== "function")
            format = d3.format(format);
          var k = Math.max(.1, n / scale.ticks().length),
              f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, Math.floor),
              e;
          return function(d) {
            return d / pow(f(log(d) + e)) <= k ? format(d) : "";
          };
        };
        scale.copy = function() {
          return d3_scale_log(linear.copy(), base, positive, domain);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      var d3_scale_logFormat = d3.format(".0e"),
          d3_scale_logNiceNegative = {
            floor: function(x) {
              return -Math.ceil(-x);
            },
            ceil: function(x) {
              return -Math.floor(-x);
            }
          };
      d3.scale.pow = function() {
        return d3_scale_pow(d3.scale.linear(), 1, [0, 1]);
      };
      function d3_scale_pow(linear, exponent, domain) {
        var powp = d3_scale_powPow(exponent),
            powb = d3_scale_powPow(1 / exponent);
        function scale(x) {
          return linear(powp(x));
        }
        scale.invert = function(x) {
          return powb(linear.invert(x));
        };
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          linear.domain((domain = x.map(Number)).map(powp));
          return scale;
        };
        scale.ticks = function(m) {
          return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function(m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function(m) {
          return scale.domain(d3_scale_linearNice(domain, m));
        };
        scale.exponent = function(x) {
          if (!arguments.length)
            return exponent;
          powp = d3_scale_powPow(exponent = x);
          powb = d3_scale_powPow(1 / exponent);
          linear.domain(domain.map(powp));
          return scale;
        };
        scale.copy = function() {
          return d3_scale_pow(linear.copy(), exponent, domain);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      function d3_scale_powPow(e) {
        return function(x) {
          return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
        };
      }
      d3.scale.sqrt = function() {
        return d3.scale.pow().exponent(.5);
      };
      d3.scale.ordinal = function() {
        return d3_scale_ordinal([], {
          t: "range",
          a: [[]]
        });
      };
      function d3_scale_ordinal(domain, ranger) {
        var index,
            range,
            rangeBand;
        function scale(x) {
          return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
        }
        function steps(start, step) {
          return d3.range(domain.length).map(function(i) {
            return start + step * i;
          });
        }
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          domain = [];
          index = new d3_Map();
          var i = -1,
              n = x.length,
              xi;
          while (++i < n)
            if (!index.has(xi = x[i]))
              index.set(xi, domain.push(xi));
          return scale[ranger.t].apply(scale, ranger.a);
        };
        scale.range = function(x) {
          if (!arguments.length)
            return range;
          range = x;
          rangeBand = 0;
          ranger = {
            t: "range",
            a: arguments
          };
          return scale;
        };
        scale.rangePoints = function(x, padding) {
          if (arguments.length < 2)
            padding = 0;
          var start = x[0],
              stop = x[1],
              step = domain.length < 2 ? (start = (start + stop) / 2, 0) : (stop - start) / (domain.length - 1 + padding);
          range = steps(start + step * padding / 2, step);
          rangeBand = 0;
          ranger = {
            t: "rangePoints",
            a: arguments
          };
          return scale;
        };
        scale.rangeRoundPoints = function(x, padding) {
          if (arguments.length < 2)
            padding = 0;
          var start = x[0],
              stop = x[1],
              step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 0) : (stop - start) / (domain.length - 1 + padding) | 0;
          range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
          rangeBand = 0;
          ranger = {
            t: "rangeRoundPoints",
            a: arguments
          };
          return scale;
        };
        scale.rangeBands = function(x, padding, outerPadding) {
          if (arguments.length < 2)
            padding = 0;
          if (arguments.length < 3)
            outerPadding = padding;
          var reverse = x[1] < x[0],
              start = x[reverse - 0],
              stop = x[1 - reverse],
              step = (stop - start) / (domain.length - padding + 2 * outerPadding);
          range = steps(start + step * outerPadding, step);
          if (reverse)
            range.reverse();
          rangeBand = step * (1 - padding);
          ranger = {
            t: "rangeBands",
            a: arguments
          };
          return scale;
        };
        scale.rangeRoundBands = function(x, padding, outerPadding) {
          if (arguments.length < 2)
            padding = 0;
          if (arguments.length < 3)
            outerPadding = padding;
          var reverse = x[1] < x[0],
              start = x[reverse - 0],
              stop = x[1 - reverse],
              step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
          range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
          if (reverse)
            range.reverse();
          rangeBand = Math.round(step * (1 - padding));
          ranger = {
            t: "rangeRoundBands",
            a: arguments
          };
          return scale;
        };
        scale.rangeBand = function() {
          return rangeBand;
        };
        scale.rangeExtent = function() {
          return d3_scaleExtent(ranger.a[0]);
        };
        scale.copy = function() {
          return d3_scale_ordinal(domain, ranger);
        };
        return scale.domain(domain);
      }
      d3.scale.category10 = function() {
        return d3.scale.ordinal().range(d3_category10);
      };
      d3.scale.category20 = function() {
        return d3.scale.ordinal().range(d3_category20);
      };
      d3.scale.category20b = function() {
        return d3.scale.ordinal().range(d3_category20b);
      };
      d3.scale.category20c = function() {
        return d3.scale.ordinal().range(d3_category20c);
      };
      var d3_category10 = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(d3_rgbString);
      var d3_category20 = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(d3_rgbString);
      var d3_category20b = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(d3_rgbString);
      var d3_category20c = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(d3_rgbString);
      d3.scale.quantile = function() {
        return d3_scale_quantile([], []);
      };
      function d3_scale_quantile(domain, range) {
        var thresholds;
        function rescale() {
          var k = 0,
              q = range.length;
          thresholds = [];
          while (++k < q)
            thresholds[k - 1] = d3.quantile(domain, k / q);
          return scale;
        }
        function scale(x) {
          if (!isNaN(x = +x))
            return range[d3.bisect(thresholds, x)];
        }
        scale.domain = function(x) {
          if (!arguments.length)
            return domain;
          domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
          return rescale();
        };
        scale.range = function(x) {
          if (!arguments.length)
            return range;
          range = x;
          return rescale();
        };
        scale.quantiles = function() {
          return thresholds;
        };
        scale.invertExtent = function(y) {
          y = range.indexOf(y);
          return y < 0 ? [NaN, NaN] : [y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1]];
        };
        scale.copy = function() {
          return d3_scale_quantile(domain, range);
        };
        return rescale();
      }
      d3.scale.quantize = function() {
        return d3_scale_quantize(0, 1, [0, 1]);
      };
      function d3_scale_quantize(x0, x1, range) {
        var kx,
            i;
        function scale(x) {
          return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
          kx = range.length / (x1 - x0);
          i = range.length - 1;
          return scale;
        }
        scale.domain = function(x) {
          if (!arguments.length)
            return [x0, x1];
          x0 = +x[0];
          x1 = +x[x.length - 1];
          return rescale();
        };
        scale.range = function(x) {
          if (!arguments.length)
            return range;
          range = x;
          return rescale();
        };
        scale.invertExtent = function(y) {
          y = range.indexOf(y);
          y = y < 0 ? NaN : y / kx + x0;
          return [y, y + 1 / kx];
        };
        scale.copy = function() {
          return d3_scale_quantize(x0, x1, range);
        };
        return rescale();
      }
      d3.scale.threshold = function() {
        return d3_scale_threshold([.5], [0, 1]);
      };
      function d3_scale_threshold(domain, range) {
        function scale(x) {
          if (x <= x)
            return range[d3.bisect(domain, x)];
        }
        scale.domain = function(_) {
          if (!arguments.length)
            return domain;
          domain = _;
          return scale;
        };
        scale.range = function(_) {
          if (!arguments.length)
            return range;
          range = _;
          return scale;
        };
        scale.invertExtent = function(y) {
          y = range.indexOf(y);
          return [domain[y - 1], domain[y]];
        };
        scale.copy = function() {
          return d3_scale_threshold(domain, range);
        };
        return scale;
      }
      d3.scale.identity = function() {
        return d3_scale_identity([0, 1]);
      };
      function d3_scale_identity(domain) {
        function identity(x) {
          return +x;
        }
        identity.invert = identity;
        identity.domain = identity.range = function(x) {
          if (!arguments.length)
            return domain;
          domain = x.map(identity);
          return identity;
        };
        identity.ticks = function(m) {
          return d3_scale_linearTicks(domain, m);
        };
        identity.tickFormat = function(m, format) {
          return d3_scale_linearTickFormat(domain, m, format);
        };
        identity.copy = function() {
          return d3_scale_identity(domain);
        };
        return identity;
      }
      d3.svg = {};
      function d3_zero() {
        return 0;
      }
      d3.svg.arc = function() {
        var innerRadius = d3_svg_arcInnerRadius,
            outerRadius = d3_svg_arcOuterRadius,
            cornerRadius = d3_zero,
            padRadius = d3_svg_arcAuto,
            startAngle = d3_svg_arcStartAngle,
            endAngle = d3_svg_arcEndAngle,
            padAngle = d3_svg_arcPadAngle;
        function arc() {
          var r0 = Math.max(0, +innerRadius.apply(this, arguments)),
              r1 = Math.max(0, +outerRadius.apply(this, arguments)),
              a0 = startAngle.apply(this, arguments) - halfπ,
              a1 = endAngle.apply(this, arguments) - halfπ,
              da = Math.abs(a1 - a0),
              cw = a0 > a1 ? 0 : 1;
          if (r1 < r0)
            rc = r1, r1 = r0, r0 = rc;
          if (da >= τε)
            return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
          var rc,
              cr,
              rp,
              ap,
              p0 = 0,
              p1 = 0,
              x0,
              y0,
              x1,
              y1,
              x2,
              y2,
              x3,
              y3,
              path = [];
          if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
            rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
            if (!cw)
              p1 *= -1;
            if (r1)
              p1 = d3_asin(rp / r1 * Math.sin(ap));
            if (r0)
              p0 = d3_asin(rp / r0 * Math.sin(ap));
          }
          if (r1) {
            x0 = r1 * Math.cos(a0 + p1);
            y0 = r1 * Math.sin(a0 + p1);
            x1 = r1 * Math.cos(a1 - p1);
            y1 = r1 * Math.sin(a1 - p1);
            var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
            if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
              var h1 = (a0 + a1) / 2;
              x0 = r1 * Math.cos(h1);
              y0 = r1 * Math.sin(h1);
              x1 = y1 = null;
            }
          } else {
            x0 = y0 = 0;
          }
          if (r0) {
            x2 = r0 * Math.cos(a1 - p0);
            y2 = r0 * Math.sin(a1 - p0);
            x3 = r0 * Math.cos(a0 + p0);
            y3 = r0 * Math.sin(a0 + p0);
            var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
            if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
              var h0 = (a0 + a1) / 2;
              x2 = r0 * Math.cos(h0);
              y2 = r0 * Math.sin(h0);
              x3 = y3 = null;
            }
          } else {
            x2 = y2 = 0;
          }
          if ((rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
            cr = r0 < r1 ^ cw ? 0 : 1;
            var oc = x3 == null ? [x2, y2] : x1 == null ? [x0, y0] : d3_geom_polygonIntersect([x0, y0], [x3, y3], [x1, y1], [x2, y2]),
                ax = x0 - oc[0],
                ay = y0 - oc[1],
                bx = x1 - oc[0],
                by = y1 - oc[1],
                kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2),
                lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            if (x1 != null) {
              var rc1 = Math.min(rc, (r1 - lc) / (kc + 1)),
                  t30 = d3_svg_arcCornerTangents(x3 == null ? [x2, y2] : [x3, y3], [x0, y0], r1, rc1, cw),
                  t12 = d3_svg_arcCornerTangents([x1, y1], [x2, y2], r1, rc1, cw);
              if (rc === rc1) {
                path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
              } else {
                path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
              }
            } else {
              path.push("M", x0, ",", y0);
            }
            if (x3 != null) {
              var rc0 = Math.min(rc, (r0 - lc) / (kc - 1)),
                  t03 = d3_svg_arcCornerTangents([x0, y0], [x3, y3], r0, -rc0, cw),
                  t21 = d3_svg_arcCornerTangents([x2, y2], x1 == null ? [x0, y0] : [x1, y1], r0, -rc0, cw);
              if (rc === rc0) {
                path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
              } else {
                path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
              }
            } else {
              path.push("L", x2, ",", y2);
            }
          } else {
            path.push("M", x0, ",", y0);
            if (x1 != null)
              path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
            path.push("L", x2, ",", y2);
            if (x3 != null)
              path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
          }
          path.push("Z");
          return path.join("");
        }
        function circleSegment(r1, cw) {
          return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
        }
        arc.innerRadius = function(v) {
          if (!arguments.length)
            return innerRadius;
          innerRadius = d3_functor(v);
          return arc;
        };
        arc.outerRadius = function(v) {
          if (!arguments.length)
            return outerRadius;
          outerRadius = d3_functor(v);
          return arc;
        };
        arc.cornerRadius = function(v) {
          if (!arguments.length)
            return cornerRadius;
          cornerRadius = d3_functor(v);
          return arc;
        };
        arc.padRadius = function(v) {
          if (!arguments.length)
            return padRadius;
          padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
          return arc;
        };
        arc.startAngle = function(v) {
          if (!arguments.length)
            return startAngle;
          startAngle = d3_functor(v);
          return arc;
        };
        arc.endAngle = function(v) {
          if (!arguments.length)
            return endAngle;
          endAngle = d3_functor(v);
          return arc;
        };
        arc.padAngle = function(v) {
          if (!arguments.length)
            return padAngle;
          padAngle = d3_functor(v);
          return arc;
        };
        arc.centroid = function() {
          var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
              a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
          return [Math.cos(a) * r, Math.sin(a) * r];
        };
        return arc;
      };
      var d3_svg_arcAuto = "auto";
      function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
      }
      function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
      }
      function d3_svg_arcStartAngle(d) {
        return d.startAngle;
      }
      function d3_svg_arcEndAngle(d) {
        return d.endAngle;
      }
      function d3_svg_arcPadAngle(d) {
        return d && d.padAngle;
      }
      function d3_svg_arcSweep(x0, y0, x1, y1) {
        return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
      }
      function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
        var x01 = p0[0] - p1[0],
            y01 = p0[1] - p1[1],
            lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
            ox = lo * y01,
            oy = -lo * x01,
            x1 = p0[0] + ox,
            y1 = p0[1] + oy,
            x2 = p1[0] + ox,
            y2 = p1[1] + oy,
            x3 = (x1 + x2) / 2,
            y3 = (y1 + y2) / 2,
            dx = x2 - x1,
            dy = y2 - y1,
            d2 = dx * dx + dy * dy,
            r = r1 - rc,
            D = x1 * y2 - x2 * y1,
            d = (dy < 0 ? -1 : 1) * Math.sqrt(r * r * d2 - D * D),
            cx0 = (D * dy - dx * d) / d2,
            cy0 = (-D * dx - dy * d) / d2,
            cx1 = (D * dy + dx * d) / d2,
            cy1 = (-D * dx + dy * d) / d2,
            dx0 = cx0 - x3,
            dy0 = cy0 - y3,
            dx1 = cx1 - x3,
            dy1 = cy1 - y3;
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
          cx0 = cx1, cy0 = cy1;
        return [[cx0 - ox, cy0 - oy], [cx0 * r1 / r, cy0 * r1 / r]];
      }
      function d3_svg_line(projection) {
        var x = d3_geom_pointX,
            y = d3_geom_pointY,
            defined = d3_true,
            interpolate = d3_svg_lineLinear,
            interpolateKey = interpolate.key,
            tension = .7;
        function line(data) {
          var segments = [],
              points = [],
              i = -1,
              n = data.length,
              d,
              fx = d3_functor(x),
              fy = d3_functor(y);
          function segment() {
            segments.push("M", interpolate(projection(points), tension));
          }
          while (++i < n) {
            if (defined.call(this, d = data[i], i)) {
              points.push([+fx.call(this, d, i), +fy.call(this, d, i)]);
            } else if (points.length) {
              segment();
              points = [];
            }
          }
          if (points.length)
            segment();
          return segments.length ? segments.join("") : null;
        }
        line.x = function(_) {
          if (!arguments.length)
            return x;
          x = _;
          return line;
        };
        line.y = function(_) {
          if (!arguments.length)
            return y;
          y = _;
          return line;
        };
        line.defined = function(_) {
          if (!arguments.length)
            return defined;
          defined = _;
          return line;
        };
        line.interpolate = function(_) {
          if (!arguments.length)
            return interpolateKey;
          if (typeof _ === "function")
            interpolateKey = interpolate = _;
          else
            interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
          return line;
        };
        line.tension = function(_) {
          if (!arguments.length)
            return tension;
          tension = _;
          return line;
        };
        return line;
      }
      d3.svg.line = function() {
        return d3_svg_line(d3_identity);
      };
      var d3_svg_lineInterpolators = d3.map({
        linear: d3_svg_lineLinear,
        "linear-closed": d3_svg_lineLinearClosed,
        step: d3_svg_lineStep,
        "step-before": d3_svg_lineStepBefore,
        "step-after": d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        "basis-open": d3_svg_lineBasisOpen,
        "basis-closed": d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        "cardinal-open": d3_svg_lineCardinalOpen,
        "cardinal-closed": d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
      });
      d3_svg_lineInterpolators.forEach(function(key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
      });
      function d3_svg_lineLinear(points) {
        return points.join("L");
      }
      function d3_svg_lineLinearClosed(points) {
        return d3_svg_lineLinear(points) + "Z";
      }
      function d3_svg_lineStep(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n)
          path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
        if (n > 1)
          path.push("H", p[0]);
        return path.join("");
      }
      function d3_svg_lineStepBefore(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n)
          path.push("V", (p = points[i])[1], "H", p[0]);
        return path.join("");
      }
      function d3_svg_lineStepAfter(points) {
        var i = 0,
            n = points.length,
            p = points[0],
            path = [p[0], ",", p[1]];
        while (++i < n)
          path.push("H", (p = points[i])[0], "V", p[1]);
        return path.join("");
      }
      function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
      }
      function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));
      }
      function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
      }
      function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
          return d3_svg_lineLinear(points);
        }
        var quad = points.length != tangents.length,
            path = "",
            p0 = points[0],
            p = points[1],
            t0 = tangents[0],
            t = t0,
            pi = 1;
        if (quad) {
          path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
          p0 = points[1];
          pi = 2;
        }
        if (tangents.length > 1) {
          t = tangents[1];
          p = points[pi];
          pi++;
          path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
          for (var i = 2; i < tangents.length; i++, pi++) {
            p = points[pi];
            t = tangents[i];
            path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
          }
        }
        if (quad) {
          var lp = points[pi];
          path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
        }
        return path;
      }
      function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [],
            a = (1 - tension) / 2,
            p0,
            p1 = points[0],
            p2 = points[1],
            i = 1,
            n = points.length;
        while (++i < n) {
          p0 = p1;
          p1 = p2;
          p2 = points[i];
          tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
        }
        return tangents;
      }
      function d3_svg_lineBasis(points) {
        if (points.length < 3)
          return d3_svg_lineLinear(points);
        var i = 1,
            n = points.length,
            pi = points[0],
            x0 = pi[0],
            y0 = pi[1],
            px = [x0, x0, x0, (pi = points[1])[0]],
            py = [y0, y0, y0, pi[1]],
            path = [x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
        points.push(points[n - 1]);
        while (++i <= n) {
          pi = points[i];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        points.pop();
        path.push("L", pi);
        return path.join("");
      }
      function d3_svg_lineBasisOpen(points) {
        if (points.length < 4)
          return d3_svg_lineLinear(points);
        var path = [],
            i = -1,
            n = points.length,
            pi,
            px = [0],
            py = [0];
        while (++i < 3) {
          pi = points[i];
          px.push(pi[0]);
          py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while (++i < n) {
          pi = points[i];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
      }
      function d3_svg_lineBasisClosed(points) {
        var path,
            i = -1,
            n = points.length,
            m = n + 4,
            pi,
            px = [],
            py = [];
        while (++i < 4) {
          pi = points[i % n];
          px.push(pi[0]);
          py.push(pi[1]);
        }
        path = [d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
        --i;
        while (++i < m) {
          pi = points[i % n];
          px.shift();
          px.push(pi[0]);
          py.shift();
          py.push(pi[1]);
          d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
      }
      function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
          var x0 = points[0][0],
              y0 = points[0][1],
              dx = points[n][0] - x0,
              dy = points[n][1] - y0,
              i = -1,
              p,
              t;
          while (++i <= n) {
            p = points[i];
            t = i / n;
            p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
            p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
          }
        }
        return d3_svg_lineBasis(points);
      }
      function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
      }
      var d3_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0],
          d3_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0],
          d3_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];
      function d3_svg_lineBasisBezier(path, x, y) {
        path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
      }
      function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
      }
      function d3_svg_lineFiniteDifferences(points) {
        var i = 0,
            j = points.length - 1,
            m = [],
            p0 = points[0],
            p1 = points[1],
            d = m[0] = d3_svg_lineSlope(p0, p1);
        while (++i < j) {
          m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        }
        m[i] = d;
        return m;
      }
      function d3_svg_lineMonotoneTangents(points) {
        var tangents = [],
            d,
            a,
            b,
            s,
            m = d3_svg_lineFiniteDifferences(points),
            i = -1,
            j = points.length - 1;
        while (++i < j) {
          d = d3_svg_lineSlope(points[i], points[i + 1]);
          if (abs(d) < ε) {
            m[i] = m[i + 1] = 0;
          } else {
            a = m[i] / d;
            b = m[i + 1] / d;
            s = a * a + b * b;
            if (s > 9) {
              s = d * 3 / Math.sqrt(s);
              m[i] = s * a;
              m[i + 1] = s * b;
            }
          }
        }
        i = -1;
        while (++i <= j) {
          s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
          tangents.push([s || 0, m[i] * s || 0]);
        }
        return tangents;
      }
      function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
      }
      d3.svg.line.radial = function() {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x, delete line.x;
        line.angle = line.y, delete line.y;
        return line;
      };
      function d3_svg_lineRadial(points) {
        var point,
            i = -1,
            n = points.length,
            r,
            a;
        while (++i < n) {
          point = points[i];
          r = point[0];
          a = point[1] - halfπ;
          point[0] = r * Math.cos(a);
          point[1] = r * Math.sin(a);
        }
        return points;
      }
      function d3_svg_area(projection) {
        var x0 = d3_geom_pointX,
            x1 = d3_geom_pointX,
            y0 = 0,
            y1 = d3_geom_pointY,
            defined = d3_true,
            interpolate = d3_svg_lineLinear,
            interpolateKey = interpolate.key,
            interpolateReverse = interpolate,
            L = "L",
            tension = .7;
        function area(data) {
          var segments = [],
              points0 = [],
              points1 = [],
              i = -1,
              n = data.length,
              d,
              fx0 = d3_functor(x0),
              fy0 = d3_functor(y0),
              fx1 = x0 === x1 ? function() {
                return x;
              } : d3_functor(x1),
              fy1 = y0 === y1 ? function() {
                return y;
              } : d3_functor(y1),
              x,
              y;
          function segment() {
            segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
          }
          while (++i < n) {
            if (defined.call(this, d = data[i], i)) {
              points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]);
              points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)]);
            } else if (points0.length) {
              segment();
              points0 = [];
              points1 = [];
            }
          }
          if (points0.length)
            segment();
          return segments.length ? segments.join("") : null;
        }
        area.x = function(_) {
          if (!arguments.length)
            return x1;
          x0 = x1 = _;
          return area;
        };
        area.x0 = function(_) {
          if (!arguments.length)
            return x0;
          x0 = _;
          return area;
        };
        area.x1 = function(_) {
          if (!arguments.length)
            return x1;
          x1 = _;
          return area;
        };
        area.y = function(_) {
          if (!arguments.length)
            return y1;
          y0 = y1 = _;
          return area;
        };
        area.y0 = function(_) {
          if (!arguments.length)
            return y0;
          y0 = _;
          return area;
        };
        area.y1 = function(_) {
          if (!arguments.length)
            return y1;
          y1 = _;
          return area;
        };
        area.defined = function(_) {
          if (!arguments.length)
            return defined;
          defined = _;
          return area;
        };
        area.interpolate = function(_) {
          if (!arguments.length)
            return interpolateKey;
          if (typeof _ === "function")
            interpolateKey = interpolate = _;
          else
            interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
          interpolateReverse = interpolate.reverse || interpolate;
          L = interpolate.closed ? "M" : "L";
          return area;
        };
        area.tension = function(_) {
          if (!arguments.length)
            return tension;
          tension = _;
          return area;
        };
        return area;
      }
      d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
      d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
      d3.svg.area = function() {
        return d3_svg_area(d3_identity);
      };
      d3.svg.area.radial = function() {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x, delete area.x;
        area.innerRadius = area.x0, delete area.x0;
        area.outerRadius = area.x1, delete area.x1;
        area.angle = area.y, delete area.y;
        area.startAngle = area.y0, delete area.y0;
        area.endAngle = area.y1, delete area.y1;
        return area;
      };
      d3.svg.chord = function() {
        var source = d3_source,
            target = d3_target,
            radius = d3_svg_chordRadius,
            startAngle = d3_svg_arcStartAngle,
            endAngle = d3_svg_arcEndAngle;
        function chord(d, i) {
          var s = subgroup(this, source, d, i),
              t = subgroup(this, target, d, i);
          return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
        }
        function subgroup(self, f, d, i) {
          var subgroup = f.call(self, d, i),
              r = radius.call(self, subgroup, i),
              a0 = startAngle.call(self, subgroup, i) - halfπ,
              a1 = endAngle.call(self, subgroup, i) - halfπ;
          return {
            r: r,
            a0: a0,
            a1: a1,
            p0: [r * Math.cos(a0), r * Math.sin(a0)],
            p1: [r * Math.cos(a1), r * Math.sin(a1)]
          };
        }
        function equals(a, b) {
          return a.a0 == b.a0 && a.a1 == b.a1;
        }
        function arc(r, p, a) {
          return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
        }
        function curve(r0, p0, r1, p1) {
          return "Q 0,0 " + p1;
        }
        chord.radius = function(v) {
          if (!arguments.length)
            return radius;
          radius = d3_functor(v);
          return chord;
        };
        chord.source = function(v) {
          if (!arguments.length)
            return source;
          source = d3_functor(v);
          return chord;
        };
        chord.target = function(v) {
          if (!arguments.length)
            return target;
          target = d3_functor(v);
          return chord;
        };
        chord.startAngle = function(v) {
          if (!arguments.length)
            return startAngle;
          startAngle = d3_functor(v);
          return chord;
        };
        chord.endAngle = function(v) {
          if (!arguments.length)
            return endAngle;
          endAngle = d3_functor(v);
          return chord;
        };
        return chord;
      };
      function d3_svg_chordRadius(d) {
        return d.radius;
      }
      d3.svg.diagonal = function() {
        var source = d3_source,
            target = d3_target,
            projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
          var p0 = source.call(this, d, i),
              p3 = target.call(this, d, i),
              m = (p0.y + p3.y) / 2,
              p = [p0, {
                x: p0.x,
                y: m
              }, {
                x: p3.x,
                y: m
              }, p3];
          p = p.map(projection);
          return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
        }
        diagonal.source = function(x) {
          if (!arguments.length)
            return source;
          source = d3_functor(x);
          return diagonal;
        };
        diagonal.target = function(x) {
          if (!arguments.length)
            return target;
          target = d3_functor(x);
          return diagonal;
        };
        diagonal.projection = function(x) {
          if (!arguments.length)
            return projection;
          projection = x;
          return diagonal;
        };
        return diagonal;
      };
      function d3_svg_diagonalProjection(d) {
        return [d.x, d.y];
      }
      d3.svg.diagonal.radial = function() {
        var diagonal = d3.svg.diagonal(),
            projection = d3_svg_diagonalProjection,
            projection_ = diagonal.projection;
        diagonal.projection = function(x) {
          return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
        };
        return diagonal;
      };
      function d3_svg_diagonalRadialProjection(projection) {
        return function() {
          var d = projection.apply(this, arguments),
              r = d[0],
              a = d[1] - halfπ;
          return [r * Math.cos(a), r * Math.sin(a)];
        };
      }
      d3.svg.symbol = function() {
        var type = d3_svg_symbolType,
            size = d3_svg_symbolSize;
        function symbol(d, i) {
          return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
        }
        symbol.type = function(x) {
          if (!arguments.length)
            return type;
          type = d3_functor(x);
          return symbol;
        };
        symbol.size = function(x) {
          if (!arguments.length)
            return size;
          size = d3_functor(x);
          return symbol;
        };
        return symbol;
      };
      function d3_svg_symbolSize() {
        return 64;
      }
      function d3_svg_symbolType() {
        return "circle";
      }
      function d3_svg_symbolCircle(size) {
        var r = Math.sqrt(size / π);
        return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
      }
      var d3_svg_symbols = d3.map({
        circle: d3_svg_symbolCircle,
        cross: function(size) {
          var r = Math.sqrt(size / 5) / 2;
          return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
        },
        diamond: function(size) {
          var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),
              rx = ry * d3_svg_symbolTan30;
          return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
        },
        square: function(size) {
          var r = Math.sqrt(size) / 2;
          return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
        },
        "triangle-down": function(size) {
          var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
              ry = rx * d3_svg_symbolSqrt3 / 2;
          return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
        },
        "triangle-up": function(size) {
          var rx = Math.sqrt(size / d3_svg_symbolSqrt3),
              ry = rx * d3_svg_symbolSqrt3 / 2;
          return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
        }
      });
      d3.svg.symbolTypes = d3_svg_symbols.keys();
      var d3_svg_symbolSqrt3 = Math.sqrt(3),
          d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
      function d3_transition(groups, namespace, id) {
        d3_subclass(groups, d3_transitionPrototype);
        groups.namespace = namespace;
        groups.id = id;
        return groups;
      }
      var d3_transitionPrototype = [],
          d3_transitionId = 0,
          d3_transitionInheritId,
          d3_transitionInherit;
      d3_transitionPrototype.call = d3_selectionPrototype.call;
      d3_transitionPrototype.empty = d3_selectionPrototype.empty;
      d3_transitionPrototype.node = d3_selectionPrototype.node;
      d3_transitionPrototype.size = d3_selectionPrototype.size;
      d3.transition = function(selection) {
        return arguments.length ? d3_transitionInheritId ? selection.transition() : selection : d3_selectionRoot.transition();
      };
      d3.transition.prototype = d3_transitionPrototype;
      d3_transitionPrototype.select = function(selector) {
        var id = this.id,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            subnode,
            node;
        selector = d3_selection_selector(selector);
        for (var j = -1,
            m = this.length; ++j < m; ) {
          subgroups.push(subgroup = []);
          for (var group = this[j],
              i = -1,
              n = group.length; ++i < n; ) {
            if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
              if ("__data__" in node)
                subnode.__data__ = node.__data__;
              d3_transitionNode(subnode, i, ns, id, node[ns][id]);
              subgroup.push(subnode);
            } else {
              subgroup.push(null);
            }
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_transitionPrototype.selectAll = function(selector) {
        var id = this.id,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            subnodes,
            node,
            subnode,
            transition;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1,
            m = this.length; ++j < m; ) {
          for (var group = this[j],
              i = -1,
              n = group.length; ++i < n; ) {
            if (node = group[i]) {
              transition = node[ns][id];
              subnodes = selector.call(node, node.__data__, i, j);
              subgroups.push(subgroup = []);
              for (var k = -1,
                  o = subnodes.length; ++k < o; ) {
                if (subnode = subnodes[k])
                  d3_transitionNode(subnode, k, ns, id, transition);
                subgroup.push(subnode);
              }
            }
          }
        }
        return d3_transition(subgroups, ns, id);
      };
      d3_transitionPrototype.filter = function(filter) {
        var subgroups = [],
            subgroup,
            group,
            node;
        if (typeof filter !== "function")
          filter = d3_selection_filter(filter);
        for (var j = 0,
            m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          for (var group = this[j],
              i = 0,
              n = group.length; i < n; i++) {
            if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
              subgroup.push(node);
            }
          }
        }
        return d3_transition(subgroups, this.namespace, this.id);
      };
      d3_transitionPrototype.tween = function(name, tween) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 2)
          return this.node()[ns][id].tween.get(name);
        return d3_selection_each(this, tween == null ? function(node) {
          node[ns][id].tween.remove(name);
        } : function(node) {
          node[ns][id].tween.set(name, tween);
        });
      };
      function d3_transition_tween(groups, name, value, tween) {
        var id = groups.id,
            ns = groups.namespace;
        return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
          node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
        } : (value = tween(value), function(node) {
          node[ns][id].tween.set(name, value);
        }));
      }
      d3_transitionPrototype.attr = function(nameNS, value) {
        if (arguments.length < 2) {
          for (value in nameNS)
            this.attr(value, nameNS[value]);
          return this;
        }
        var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate,
            name = d3.ns.qualify(nameNS);
        function attrNull() {
          this.removeAttribute(name);
        }
        function attrNullNS() {
          this.removeAttributeNS(name.space, name.local);
        }
        function attrTween(b) {
          return b == null ? attrNull : (b += "", function() {
            var a = this.getAttribute(name),
                i;
            return a !== b && (i = interpolate(a, b), function(t) {
              this.setAttribute(name, i(t));
            });
          });
        }
        function attrTweenNS(b) {
          return b == null ? attrNullNS : (b += "", function() {
            var a = this.getAttributeNS(name.space, name.local),
                i;
            return a !== b && (i = interpolate(a, b), function(t) {
              this.setAttributeNS(name.space, name.local, i(t));
            });
          });
        }
        return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
      };
      d3_transitionPrototype.attrTween = function(nameNS, tween) {
        var name = d3.ns.qualify(nameNS);
        function attrTween(d, i) {
          var f = tween.call(this, d, i, this.getAttribute(name));
          return f && function(t) {
            this.setAttribute(name, f(t));
          };
        }
        function attrTweenNS(d, i) {
          var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
          return f && function(t) {
            this.setAttributeNS(name.space, name.local, f(t));
          };
        }
        return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
      };
      d3_transitionPrototype.style = function(name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
          if (typeof name !== "string") {
            if (n < 2)
              value = "";
            for (priority in name)
              this.style(priority, name[priority], value);
            return this;
          }
          priority = "";
        }
        function styleNull() {
          this.style.removeProperty(name);
        }
        function styleString(b) {
          return b == null ? styleNull : (b += "", function() {
            var a = d3_window.getComputedStyle(this, null).getPropertyValue(name),
                i;
            return a !== b && (i = d3_interpolate(a, b), function(t) {
              this.style.setProperty(name, i(t), priority);
            });
          });
        }
        return d3_transition_tween(this, "style." + name, value, styleString);
      };
      d3_transitionPrototype.styleTween = function(name, tween, priority) {
        if (arguments.length < 3)
          priority = "";
        function styleTween(d, i) {
          var f = tween.call(this, d, i, d3_window.getComputedStyle(this, null).getPropertyValue(name));
          return f && function(t) {
            this.style.setProperty(name, f(t), priority);
          };
        }
        return this.tween("style." + name, styleTween);
      };
      d3_transitionPrototype.text = function(value) {
        return d3_transition_tween(this, "text", value, d3_transition_text);
      };
      function d3_transition_text(b) {
        if (b == null)
          b = "";
        return function() {
          this.textContent = b;
        };
      }
      d3_transitionPrototype.remove = function() {
        var ns = this.namespace;
        return this.each("end.transition", function() {
          var p;
          if (this[ns].count < 2 && (p = this.parentNode))
            p.removeChild(this);
        });
      };
      d3_transitionPrototype.ease = function(value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1)
          return this.node()[ns][id].ease;
        if (typeof value !== "function")
          value = d3.ease.apply(d3, arguments);
        return d3_selection_each(this, function(node) {
          node[ns][id].ease = value;
        });
      };
      d3_transitionPrototype.delay = function(value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1)
          return this.node()[ns][id].delay;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
          node[ns][id].delay = +value.call(node, node.__data__, i, j);
        } : (value = +value, function(node) {
          node[ns][id].delay = value;
        }));
      };
      d3_transitionPrototype.duration = function(value) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 1)
          return this.node()[ns][id].duration;
        return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
          node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
        } : (value = Math.max(1, value), function(node) {
          node[ns][id].duration = value;
        }));
      };
      d3_transitionPrototype.each = function(type, listener) {
        var id = this.id,
            ns = this.namespace;
        if (arguments.length < 2) {
          var inherit = d3_transitionInherit,
              inheritId = d3_transitionInheritId;
          d3_transitionInheritId = id;
          d3_selection_each(this, function(node, i, j) {
            d3_transitionInherit = node[ns][id];
            type.call(node, node.__data__, i, j);
          });
          d3_transitionInherit = inherit;
          d3_transitionInheritId = inheritId;
        } else {
          d3_selection_each(this, function(node) {
            var transition = node[ns][id];
            (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
          });
        }
        return this;
      };
      d3_transitionPrototype.transition = function() {
        var id0 = this.id,
            id1 = ++d3_transitionId,
            ns = this.namespace,
            subgroups = [],
            subgroup,
            group,
            node,
            transition;
        for (var j = 0,
            m = this.length; j < m; j++) {
          subgroups.push(subgroup = []);
          for (var group = this[j],
              i = 0,
              n = group.length; i < n; i++) {
            if (node = group[i]) {
              transition = node[ns][id0];
              d3_transitionNode(node, i, ns, id1, {
                time: transition.time,
                ease: transition.ease,
                delay: transition.delay + transition.duration,
                duration: transition.duration
              });
            }
            subgroup.push(node);
          }
        }
        return d3_transition(subgroups, ns, id1);
      };
      function d3_transitionNamespace(name) {
        return name == null ? "__transition__" : "__transition_" + name + "__";
      }
      function d3_transitionNode(node, i, namespace, id, inherit) {
        var lock = node[namespace] || (node[namespace] = {
          active: 0,
          count: 0
        }),
            transition = lock[id];
        if (!transition) {
          var time = inherit.time;
          transition = lock[id] = {
            tween: new d3_Map(),
            time: time,
            delay: inherit.delay,
            duration: inherit.duration,
            ease: inherit.ease
          };
          inherit = null;
          ++lock.count;
          d3.timer(function(elapsed) {
            var d = node.__data__,
                delay = transition.delay,
                duration,
                ease,
                timer = d3_timer_active,
                tweened = [];
            timer.t = delay + time;
            if (delay <= elapsed)
              return start(elapsed - delay);
            timer.c = start;
            function start(elapsed) {
              if (lock.active > id)
                return stop(false);
              lock.active = id;
              transition.event && transition.event.start.call(node, d, i);
              transition.tween.forEach(function(key, value) {
                if (value = value.call(node, d, i)) {
                  tweened.push(value);
                }
              });
              ease = transition.ease;
              duration = transition.duration;
              d3.timer(function() {
                timer.c = tick(elapsed || 1) ? d3_true : tick;
                return 1;
              }, 0, time);
            }
            function tick(elapsed) {
              if (lock.active !== id)
                return stop(false);
              var t = elapsed / duration,
                  e = ease(t),
                  n = tweened.length;
              while (n > 0) {
                tweened[--n].call(node, e);
              }
              if (t >= 1)
                return stop(true);
            }
            function stop(end) {
              if (transition.event)
                transition.event[end ? "end" : "interrupt"].call(node, d, i);
              if (--lock.count)
                delete lock[id];
              else
                delete node[namespace];
              return 1;
            }
          }, 0, time);
        }
      }
      d3.svg.axis = function() {
        var scale = d3.scale.linear(),
            orient = d3_svg_axisDefaultOrient,
            innerTickSize = 6,
            outerTickSize = 6,
            tickPadding = 3,
            tickArguments_ = [10],
            tickValues = null,
            tickFormat_;
        function axis(g) {
          g.each(function() {
            var g = d3.select(this);
            var scale0 = this.__chart__ || scale,
                scale1 = this.__chart__ = scale.copy();
            var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues,
                tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_,
                tick = g.selectAll(".tick").data(ticks, scale1),
                tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε),
                tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(),
                tickUpdate = d3.transition(tick.order()).style("opacity", 1),
                tickSpacing = Math.max(innerTickSize, 0) + tickPadding,
                tickTransform;
            var range = d3_scaleRange(scale1),
                path = g.selectAll(".domain").data([0]),
                pathUpdate = (path.enter().append("path").attr("class", "domain"), d3.transition(path));
            tickEnter.append("line");
            tickEnter.append("text");
            var lineEnter = tickEnter.select("line"),
                lineUpdate = tickUpdate.select("line"),
                text = tick.select("text").text(tickFormat),
                textEnter = tickEnter.select("text"),
                textUpdate = tickUpdate.select("text"),
                sign = orient === "top" || orient === "left" ? -1 : 1,
                x1,
                x2,
                y1,
                y2;
            if (orient === "bottom" || orient === "top") {
              tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
              text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
              pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
            } else {
              tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
              text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
              pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
            }
            lineEnter.attr(y2, sign * innerTickSize);
            textEnter.attr(y1, sign * tickSpacing);
            lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
            textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
            if (scale1.rangeBand) {
              var x = scale1,
                  dx = x.rangeBand() / 2;
              scale0 = scale1 = function(d) {
                return x(d) + dx;
              };
            } else if (scale0.rangeBand) {
              scale0 = scale1;
            } else {
              tickExit.call(tickTransform, scale1, scale0);
            }
            tickEnter.call(tickTransform, scale0, scale1);
            tickUpdate.call(tickTransform, scale1, scale1);
          });
        }
        axis.scale = function(x) {
          if (!arguments.length)
            return scale;
          scale = x;
          return axis;
        };
        axis.orient = function(x) {
          if (!arguments.length)
            return orient;
          orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
          return axis;
        };
        axis.ticks = function() {
          if (!arguments.length)
            return tickArguments_;
          tickArguments_ = arguments;
          return axis;
        };
        axis.tickValues = function(x) {
          if (!arguments.length)
            return tickValues;
          tickValues = x;
          return axis;
        };
        axis.tickFormat = function(x) {
          if (!arguments.length)
            return tickFormat_;
          tickFormat_ = x;
          return axis;
        };
        axis.tickSize = function(x) {
          var n = arguments.length;
          if (!n)
            return innerTickSize;
          innerTickSize = +x;
          outerTickSize = +arguments[n - 1];
          return axis;
        };
        axis.innerTickSize = function(x) {
          if (!arguments.length)
            return innerTickSize;
          innerTickSize = +x;
          return axis;
        };
        axis.outerTickSize = function(x) {
          if (!arguments.length)
            return outerTickSize;
          outerTickSize = +x;
          return axis;
        };
        axis.tickPadding = function(x) {
          if (!arguments.length)
            return tickPadding;
          tickPadding = +x;
          return axis;
        };
        axis.tickSubdivide = function() {
          return arguments.length && axis;
        };
        return axis;
      };
      var d3_svg_axisDefaultOrient = "bottom",
          d3_svg_axisOrients = {
            top: 1,
            right: 1,
            bottom: 1,
            left: 1
          };
      function d3_svg_axisX(selection, x0, x1) {
        selection.attr("transform", function(d) {
          var v0 = x0(d);
          return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
        });
      }
      function d3_svg_axisY(selection, y0, y1) {
        selection.attr("transform", function(d) {
          var v0 = y0(d);
          return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
        });
      }
      d3.svg.brush = function() {
        var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"),
            x = null,
            y = null,
            xExtent = [0, 0],
            yExtent = [0, 0],
            xExtentDomain,
            yExtentDomain,
            xClamp = true,
            yClamp = true,
            resizes = d3_svg_brushResizes[0];
        function brush(g) {
          g.each(function() {
            var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
            var background = g.selectAll(".background").data([0]);
            background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
            g.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
            var resize = g.selectAll(".resize").data(resizes, d3_identity);
            resize.exit().remove();
            resize.enter().append("g").attr("class", function(d) {
              return "resize " + d;
            }).style("cursor", function(d) {
              return d3_svg_brushCursor[d];
            }).append("rect").attr("x", function(d) {
              return /[ew]$/.test(d) ? -3 : null;
            }).attr("y", function(d) {
              return /^[ns]/.test(d) ? -3 : null;
            }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
            resize.style("display", brush.empty() ? "none" : null);
            var gUpdate = d3.transition(g),
                backgroundUpdate = d3.transition(background),
                range;
            if (x) {
              range = d3_scaleRange(x);
              backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
              redrawX(gUpdate);
            }
            if (y) {
              range = d3_scaleRange(y);
              backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
              redrawY(gUpdate);
            }
            redraw(gUpdate);
          });
        }
        brush.event = function(g) {
          g.each(function() {
            var event_ = event.of(this, arguments),
                extent1 = {
                  x: xExtent,
                  y: yExtent,
                  i: xExtentDomain,
                  j: yExtentDomain
                },
                extent0 = this.__chart__ || extent1;
            this.__chart__ = extent1;
            if (d3_transitionInheritId) {
              d3.select(this).transition().each("start.brush", function() {
                xExtentDomain = extent0.i;
                yExtentDomain = extent0.j;
                xExtent = extent0.x;
                yExtent = extent0.y;
                event_({type: "brushstart"});
              }).tween("brush:brush", function() {
                var xi = d3_interpolateArray(xExtent, extent1.x),
                    yi = d3_interpolateArray(yExtent, extent1.y);
                xExtentDomain = yExtentDomain = null;
                return function(t) {
                  xExtent = extent1.x = xi(t);
                  yExtent = extent1.y = yi(t);
                  event_({
                    type: "brush",
                    mode: "resize"
                  });
                };
              }).each("end.brush", function() {
                xExtentDomain = extent1.i;
                yExtentDomain = extent1.j;
                event_({
                  type: "brush",
                  mode: "resize"
                });
                event_({type: "brushend"});
              });
            } else {
              event_({type: "brushstart"});
              event_({
                type: "brush",
                mode: "resize"
              });
              event_({type: "brushend"});
            }
          });
        };
        function redraw(g) {
          g.selectAll(".resize").attr("transform", function(d) {
            return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
          });
        }
        function redrawX(g) {
          g.select(".extent").attr("x", xExtent[0]);
          g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
        }
        function redrawY(g) {
          g.select(".extent").attr("y", yExtent[0]);
          g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
        }
        function brushstart() {
          var target = this,
              eventTarget = d3.select(d3.event.target),
              event_ = event.of(target, arguments),
              g = d3.select(target),
              resizing = eventTarget.datum(),
              resizingX = !/^(n|s)$/.test(resizing) && x,
              resizingY = !/^(e|w)$/.test(resizing) && y,
              dragging = eventTarget.classed("extent"),
              dragRestore = d3_event_dragSuppress(),
              center,
              origin = d3.mouse(target),
              offset;
          var w = d3.select(d3_window).on("keydown.brush", keydown).on("keyup.brush", keyup);
          if (d3.event.changedTouches) {
            w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
          } else {
            w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
          }
          g.interrupt().selectAll("*").interrupt();
          if (dragging) {
            origin[0] = xExtent[0] - origin[0];
            origin[1] = yExtent[0] - origin[1];
          } else if (resizing) {
            var ex = +/w$/.test(resizing),
                ey = +/^n/.test(resizing);
            offset = [xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1]];
            origin[0] = xExtent[ex];
            origin[1] = yExtent[ey];
          } else if (d3.event.altKey)
            center = origin.slice();
          g.style("pointer-events", "none").selectAll(".resize").style("display", null);
          d3.select("body").style("cursor", eventTarget.style("cursor"));
          event_({type: "brushstart"});
          brushmove();
          function keydown() {
            if (d3.event.keyCode == 32) {
              if (!dragging) {
                center = null;
                origin[0] -= xExtent[1];
                origin[1] -= yExtent[1];
                dragging = 2;
              }
              d3_eventPreventDefault();
            }
          }
          function keyup() {
            if (d3.event.keyCode == 32 && dragging == 2) {
              origin[0] += xExtent[1];
              origin[1] += yExtent[1];
              dragging = 0;
              d3_eventPreventDefault();
            }
          }
          function brushmove() {
            var point = d3.mouse(target),
                moved = false;
            if (offset) {
              point[0] += offset[0];
              point[1] += offset[1];
            }
            if (!dragging) {
              if (d3.event.altKey) {
                if (!center)
                  center = [(xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2];
                origin[0] = xExtent[+(point[0] < center[0])];
                origin[1] = yExtent[+(point[1] < center[1])];
              } else
                center = null;
            }
            if (resizingX && move1(point, x, 0)) {
              redrawX(g);
              moved = true;
            }
            if (resizingY && move1(point, y, 1)) {
              redrawY(g);
              moved = true;
            }
            if (moved) {
              redraw(g);
              event_({
                type: "brush",
                mode: dragging ? "move" : "resize"
              });
            }
          }
          function move1(point, scale, i) {
            var range = d3_scaleRange(scale),
                r0 = range[0],
                r1 = range[1],
                position = origin[i],
                extent = i ? yExtent : xExtent,
                size = extent[1] - extent[0],
                min,
                max;
            if (dragging) {
              r0 -= position;
              r1 -= size + position;
            }
            min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
            if (dragging) {
              max = (min += position) + size;
            } else {
              if (center)
                position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
              if (position < min) {
                max = min;
                min = position;
              } else {
                max = position;
              }
            }
            if (extent[0] != min || extent[1] != max) {
              if (i)
                yExtentDomain = null;
              else
                xExtentDomain = null;
              extent[0] = min;
              extent[1] = max;
              return true;
            }
          }
          function brushend() {
            brushmove();
            g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
            d3.select("body").style("cursor", null);
            w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
            dragRestore();
            event_({type: "brushend"});
          }
        }
        brush.x = function(z) {
          if (!arguments.length)
            return x;
          x = z;
          resizes = d3_svg_brushResizes[!x << 1 | !y];
          return brush;
        };
        brush.y = function(z) {
          if (!arguments.length)
            return y;
          y = z;
          resizes = d3_svg_brushResizes[!x << 1 | !y];
          return brush;
        };
        brush.clamp = function(z) {
          if (!arguments.length)
            return x && y ? [xClamp, yClamp] : x ? xClamp : y ? yClamp : null;
          if (x && y)
            xClamp = !!z[0], yClamp = !!z[1];
          else if (x)
            xClamp = !!z;
          else if (y)
            yClamp = !!z;
          return brush;
        };
        brush.extent = function(z) {
          var x0,
              x1,
              y0,
              y1,
              t;
          if (!arguments.length) {
            if (x) {
              if (xExtentDomain) {
                x0 = xExtentDomain[0], x1 = xExtentDomain[1];
              } else {
                x0 = xExtent[0], x1 = xExtent[1];
                if (x.invert)
                  x0 = x.invert(x0), x1 = x.invert(x1);
                if (x1 < x0)
                  t = x0, x0 = x1, x1 = t;
              }
            }
            if (y) {
              if (yExtentDomain) {
                y0 = yExtentDomain[0], y1 = yExtentDomain[1];
              } else {
                y0 = yExtent[0], y1 = yExtent[1];
                if (y.invert)
                  y0 = y.invert(y0), y1 = y.invert(y1);
                if (y1 < y0)
                  t = y0, y0 = y1, y1 = t;
              }
            }
            return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];
          }
          if (x) {
            x0 = z[0], x1 = z[1];
            if (y)
              x0 = x0[0], x1 = x1[0];
            xExtentDomain = [x0, x1];
            if (x.invert)
              x0 = x(x0), x1 = x(x1);
            if (x1 < x0)
              t = x0, x0 = x1, x1 = t;
            if (x0 != xExtent[0] || x1 != xExtent[1])
              xExtent = [x0, x1];
          }
          if (y) {
            y0 = z[0], y1 = z[1];
            if (x)
              y0 = y0[1], y1 = y1[1];
            yExtentDomain = [y0, y1];
            if (y.invert)
              y0 = y(y0), y1 = y(y1);
            if (y1 < y0)
              t = y0, y0 = y1, y1 = t;
            if (y0 != yExtent[0] || y1 != yExtent[1])
              yExtent = [y0, y1];
          }
          return brush;
        };
        brush.clear = function() {
          if (!brush.empty()) {
            xExtent = [0, 0], yExtent = [0, 0];
            xExtentDomain = yExtentDomain = null;
          }
          return brush;
        };
        brush.empty = function() {
          return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
        };
        return d3.rebind(brush, event, "on");
      };
      var d3_svg_brushCursor = {
        n: "ns-resize",
        e: "ew-resize",
        s: "ns-resize",
        w: "ew-resize",
        nw: "nwse-resize",
        ne: "nesw-resize",
        se: "nwse-resize",
        sw: "nesw-resize"
      };
      var d3_svg_brushResizes = [["n", "e", "s", "w", "nw", "ne", "se", "sw"], ["e", "w"], ["n", "s"], []];
      var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
      var d3_time_formatUtc = d3_time_format.utc;
      var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
      d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
      function d3_time_formatIsoNative(date) {
        return date.toISOString();
      }
      d3_time_formatIsoNative.parse = function(string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
      };
      d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
      d3_time.second = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 1e3) * 1e3);
      }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 1e3);
      }, function(date) {
        return date.getSeconds();
      });
      d3_time.seconds = d3_time.second.range;
      d3_time.seconds.utc = d3_time.second.utc.range;
      d3_time.minute = d3_time_interval(function(date) {
        return new d3_date(Math.floor(date / 6e4) * 6e4);
      }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 6e4);
      }, function(date) {
        return date.getMinutes();
      });
      d3_time.minutes = d3_time.minute.range;
      d3_time.minutes.utc = d3_time.minute.utc.range;
      d3_time.hour = d3_time_interval(function(date) {
        var timezone = date.getTimezoneOffset() / 60;
        return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
      }, function(date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 36e5);
      }, function(date) {
        return date.getHours();
      });
      d3_time.hours = d3_time.hour.range;
      d3_time.hours.utc = d3_time.hour.utc.range;
      d3_time.month = d3_time_interval(function(date) {
        date = d3_time.day(date);
        date.setDate(1);
        return date;
      }, function(date, offset) {
        date.setMonth(date.getMonth() + offset);
      }, function(date) {
        return date.getMonth();
      });
      d3_time.months = d3_time.month.range;
      d3_time.months.utc = d3_time.month.utc.range;
      function d3_time_scale(linear, methods, format) {
        function scale(x) {
          return linear(x);
        }
        scale.invert = function(x) {
          return d3_time_scaleDate(linear.invert(x));
        };
        scale.domain = function(x) {
          if (!arguments.length)
            return linear.domain().map(d3_time_scaleDate);
          linear.domain(x);
          return scale;
        };
        function tickMethod(extent, count) {
          var span = extent[1] - extent[0],
              target = span / count,
              i = d3.bisect(d3_time_scaleSteps, target);
          return i == d3_time_scaleSteps.length ? [methods.year, d3_scale_linearTickRange(extent.map(function(d) {
            return d / 31536e6;
          }), count)[2]] : !i ? [d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2]] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
        }
        scale.nice = function(interval, skip) {
          var domain = scale.domain(),
              extent = d3_scaleExtent(domain),
              method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
          if (method)
            interval = method[0], skip = method[1];
          function skipped(date) {
            return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
          }
          return scale.domain(d3_scale_nice(domain, skip > 1 ? {
            floor: function(date) {
              while (skipped(date = interval.floor(date)))
                date = d3_time_scaleDate(date - 1);
              return date;
            },
            ceil: function(date) {
              while (skipped(date = interval.ceil(date)))
                date = d3_time_scaleDate(+date + 1);
              return date;
            }
          } : interval));
        };
        scale.ticks = function(interval, skip) {
          var extent = d3_scaleExtent(scale.domain()),
              method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [{range: interval}, skip];
          if (method)
            interval = method[0], skip = method[1];
          return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
        };
        scale.tickFormat = function() {
          return format;
        };
        scale.copy = function() {
          return d3_time_scale(linear.copy(), methods, format);
        };
        return d3_scale_linearRebind(scale, linear);
      }
      function d3_time_scaleDate(t) {
        return new Date(t);
      }
      var d3_time_scaleSteps = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6];
      var d3_time_scaleLocalMethods = [[d3_time.second, 1], [d3_time.second, 5], [d3_time.second, 15], [d3_time.second, 30], [d3_time.minute, 1], [d3_time.minute, 5], [d3_time.minute, 15], [d3_time.minute, 30], [d3_time.hour, 1], [d3_time.hour, 3], [d3_time.hour, 6], [d3_time.hour, 12], [d3_time.day, 1], [d3_time.day, 2], [d3_time.week, 1], [d3_time.month, 1], [d3_time.month, 3], [d3_time.year, 1]];
      var d3_time_scaleLocalFormat = d3_time_format.multi([[".%L", function(d) {
        return d.getMilliseconds();
      }], [":%S", function(d) {
        return d.getSeconds();
      }], ["%I:%M", function(d) {
        return d.getMinutes();
      }], ["%I %p", function(d) {
        return d.getHours();
      }], ["%a %d", function(d) {
        return d.getDay() && d.getDate() != 1;
      }], ["%b %d", function(d) {
        return d.getDate() != 1;
      }], ["%B", function(d) {
        return d.getMonth();
      }], ["%Y", d3_true]]);
      var d3_time_scaleMilliseconds = {
        range: function(start, stop, step) {
          return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
        },
        floor: d3_identity,
        ceil: d3_identity
      };
      d3_time_scaleLocalMethods.year = d3_time.year;
      d3_time.scale = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
      };
      var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
        return [m[0].utc, m[1]];
      });
      var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([[".%L", function(d) {
        return d.getUTCMilliseconds();
      }], [":%S", function(d) {
        return d.getUTCSeconds();
      }], ["%I:%M", function(d) {
        return d.getUTCMinutes();
      }], ["%I %p", function(d) {
        return d.getUTCHours();
      }], ["%a %d", function(d) {
        return d.getUTCDay() && d.getUTCDate() != 1;
      }], ["%b %d", function(d) {
        return d.getUTCDate() != 1;
      }], ["%B", function(d) {
        return d.getUTCMonth();
      }], ["%Y", d3_true]]);
      d3_time_scaleUtcMethods.year = d3_time.year.utc;
      d3_time.scale.utc = function() {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
      };
      d3.text = d3_xhrType(function(request) {
        return request.responseText;
      });
      d3.json = function(url, callback) {
        return d3_xhr(url, "application/json", d3_json, callback);
      };
      function d3_json(request) {
        return JSON.parse(request.responseText);
      }
      d3.html = function(url, callback) {
        return d3_xhr(url, "text/html", d3_html, callback);
      };
      function d3_html(request) {
        var range = d3_document.createRange();
        range.selectNode(d3_document.body);
        return range.createContextualFragment(request.responseText);
      }
      d3.xml = d3_xhrType(function(request) {
        return request.responseXML;
      });
      if (typeof define === "function" && define.amd)
        define(d3);
      else if (typeof module === "object" && module.exports)
        module.exports = d3;
      this.d3 = d3;
    }();
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("3b", ["3f"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('3f');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("40", ["3b"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(window) {
    'use strict';
    var c3 = {version: "0.4.10"};
    var c3_chart_fn,
        c3_chart_internal_fn,
        c3_chart_internal_axis_fn;
    function API(owner) {
      this.owner = owner;
    }
    function inherit(base, derived) {
      if (Object.create) {
        derived.prototype = Object.create(base.prototype);
      } else {
        var f = function f() {};
        f.prototype = base.prototype;
        derived.prototype = new f();
      }
      derived.prototype.constructor = derived;
      return derived;
    }
    function Chart(config) {
      var $$ = this.internal = new ChartInternal(this);
      $$.loadConfig(config);
      $$.init();
      (function bindThis(fn, target, argThis) {
        Object.keys(fn).forEach(function(key) {
          target[key] = fn[key].bind(argThis);
          if (Object.keys(fn[key]).length > 0) {
            bindThis(fn[key], target[key], argThis);
          }
        });
      })(c3_chart_fn, this, this);
    }
    function ChartInternal(api) {
      var $$ = this;
      $$.d3 = window.d3 ? window.d3 : typeof req !== 'undefined' ? req('3b') : undefined;
      $$.api = api;
      $$.config = $$.getDefaultConfig();
      $$.data = {};
      $$.cache = {};
      $$.axes = {};
    }
    c3.generate = function(config) {
      return new Chart(config);
    };
    c3.chart = {
      fn: Chart.prototype,
      internal: {
        fn: ChartInternal.prototype,
        axis: {fn: Axis.prototype}
      }
    };
    c3_chart_fn = c3.chart.fn;
    c3_chart_internal_fn = c3.chart.internal.fn;
    c3_chart_internal_axis_fn = c3.chart.internal.axis.fn;
    c3_chart_internal_fn.init = function() {
      var $$ = this,
          config = $$.config;
      $$.initParams();
      if (config.data_url) {
        $$.convertUrlToData(config.data_url, config.data_mimeType, config.data_keys, $$.initWithData);
      } else if (config.data_json) {
        $$.initWithData($$.convertJsonToData(config.data_json, config.data_keys));
      } else if (config.data_rows) {
        $$.initWithData($$.convertRowsToData(config.data_rows));
      } else if (config.data_columns) {
        $$.initWithData($$.convertColumnsToData(config.data_columns));
      } else {
        throw Error('url or json or rows or columns is required.');
      }
    };
    c3_chart_internal_fn.initParams = function() {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config;
      $$.clipId = "c3-" + (+new Date()) + '-clip', $$.clipIdForXAxis = $$.clipId + '-xaxis', $$.clipIdForYAxis = $$.clipId + '-yaxis', $$.clipIdForGrid = $$.clipId + '-grid', $$.clipIdForSubchart = $$.clipId + '-subchart', $$.clipPath = $$.getClipPath($$.clipId), $$.clipPathForXAxis = $$.getClipPath($$.clipIdForXAxis), $$.clipPathForYAxis = $$.getClipPath($$.clipIdForYAxis);
      $$.clipPathForGrid = $$.getClipPath($$.clipIdForGrid), $$.clipPathForSubchart = $$.getClipPath($$.clipIdForSubchart), $$.dragStart = null;
      $$.dragging = false;
      $$.flowing = false;
      $$.cancelClick = false;
      $$.mouseover = false;
      $$.transiting = false;
      $$.color = $$.generateColor();
      $$.levelColor = $$.generateLevelColor();
      $$.dataTimeFormat = config.data_xLocaltime ? d3.time.format : d3.time.format.utc;
      $$.axisTimeFormat = config.axis_x_localtime ? d3.time.format : d3.time.format.utc;
      $$.defaultAxisTimeFormat = $$.axisTimeFormat.multi([[".%L", function(d) {
        return d.getMilliseconds();
      }], [":%S", function(d) {
        return d.getSeconds();
      }], ["%I:%M", function(d) {
        return d.getMinutes();
      }], ["%I %p", function(d) {
        return d.getHours();
      }], ["%-m/%-d", function(d) {
        return d.getDay() && d.getDate() !== 1;
      }], ["%-m/%-d", function(d) {
        return d.getDate() !== 1;
      }], ["%-m/%-d", function(d) {
        return d.getMonth();
      }], ["%Y/%-m/%-d", function() {
        return true;
      }]]);
      $$.hiddenTargetIds = [];
      $$.hiddenLegendIds = [];
      $$.focusedTargetIds = [];
      $$.defocusedTargetIds = [];
      $$.xOrient = config.axis_rotated ? "left" : "bottom";
      $$.yOrient = config.axis_rotated ? (config.axis_y_inner ? "top" : "bottom") : (config.axis_y_inner ? "right" : "left");
      $$.y2Orient = config.axis_rotated ? (config.axis_y2_inner ? "bottom" : "top") : (config.axis_y2_inner ? "left" : "right");
      $$.subXOrient = config.axis_rotated ? "left" : "bottom";
      $$.isLegendRight = config.legend_position === 'right';
      $$.isLegendInset = config.legend_position === 'inset';
      $$.isLegendTop = config.legend_inset_anchor === 'top-left' || config.legend_inset_anchor === 'top-right';
      $$.isLegendLeft = config.legend_inset_anchor === 'top-left' || config.legend_inset_anchor === 'bottom-left';
      $$.legendStep = 0;
      $$.legendItemWidth = 0;
      $$.legendItemHeight = 0;
      $$.currentMaxTickWidths = {
        x: 0,
        y: 0,
        y2: 0
      };
      $$.rotated_padding_left = 30;
      $$.rotated_padding_right = config.axis_rotated && !config.axis_x_show ? 0 : 30;
      $$.rotated_padding_top = 5;
      $$.withoutFadeIn = {};
      $$.intervalForObserveInserted = undefined;
      $$.axes.subx = d3.selectAll([]);
    };
    c3_chart_internal_fn.initChartElements = function() {
      if (this.initBar) {
        this.initBar();
      }
      if (this.initLine) {
        this.initLine();
      }
      if (this.initArc) {
        this.initArc();
      }
      if (this.initGauge) {
        this.initGauge();
      }
      if (this.initText) {
        this.initText();
      }
    };
    c3_chart_internal_fn.initWithData = function(data) {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config;
      var defs,
          main,
          binding = true;
      $$.axis = new Axis($$);
      if ($$.initPie) {
        $$.initPie();
      }
      if ($$.initBrush) {
        $$.initBrush();
      }
      if ($$.initZoom) {
        $$.initZoom();
      }
      if (!config.bindto) {
        $$.selectChart = d3.selectAll([]);
      } else if (typeof config.bindto.node === 'function') {
        $$.selectChart = config.bindto;
      } else {
        $$.selectChart = d3.select(config.bindto);
      }
      if ($$.selectChart.empty()) {
        $$.selectChart = d3.select(document.createElement('div')).style('opacity', 0);
        $$.observeInserted($$.selectChart);
        binding = false;
      }
      $$.selectChart.html("").classed("c3", true);
      $$.data.xs = {};
      $$.data.targets = $$.convertDataToTargets(data);
      if (config.data_filter) {
        $$.data.targets = $$.data.targets.filter(config.data_filter);
      }
      if (config.data_hide) {
        $$.addHiddenTargetIds(config.data_hide === true ? $$.mapToIds($$.data.targets) : config.data_hide);
      }
      if (config.legend_hide) {
        $$.addHiddenLegendIds(config.legend_hide === true ? $$.mapToIds($$.data.targets) : config.legend_hide);
      }
      if ($$.hasType('gauge')) {
        config.legend_show = false;
      }
      $$.updateSizes();
      $$.updateScales();
      $$.x.domain(d3.extent($$.getXDomain($$.data.targets)));
      $$.y.domain($$.getYDomain($$.data.targets, 'y'));
      $$.y2.domain($$.getYDomain($$.data.targets, 'y2'));
      $$.subX.domain($$.x.domain());
      $$.subY.domain($$.y.domain());
      $$.subY2.domain($$.y2.domain());
      $$.orgXDomain = $$.x.domain();
      if ($$.brush) {
        $$.brush.scale($$.subX);
      }
      if (config.zoom_enabled) {
        $$.zoom.scale($$.x);
      }
      $$.svg = $$.selectChart.append("svg").style("overflow", "hidden").on('mouseenter', function() {
        return config.onmouseover.call($$);
      }).on('mouseleave', function() {
        return config.onmouseout.call($$);
      });
      defs = $$.svg.append("defs");
      $$.clipChart = $$.appendClip(defs, $$.clipId);
      $$.clipXAxis = $$.appendClip(defs, $$.clipIdForXAxis);
      $$.clipYAxis = $$.appendClip(defs, $$.clipIdForYAxis);
      $$.clipGrid = $$.appendClip(defs, $$.clipIdForGrid);
      $$.clipSubchart = $$.appendClip(defs, $$.clipIdForSubchart);
      $$.updateSvgSize();
      main = $$.main = $$.svg.append("g").attr("transform", $$.getTranslate('main'));
      if ($$.initSubchart) {
        $$.initSubchart();
      }
      if ($$.initTooltip) {
        $$.initTooltip();
      }
      if ($$.initLegend) {
        $$.initLegend();
      }
      main.append("text").attr("class", CLASS.text + ' ' + CLASS.empty).attr("text-anchor", "middle").attr("dominant-baseline", "middle");
      $$.initRegion();
      $$.initGrid();
      main.append('g').attr("clip-path", $$.clipPath).attr('class', CLASS.chart);
      if (config.grid_lines_front) {
        $$.initGridLines();
      }
      $$.initEventRect();
      $$.initChartElements();
      main.insert('rect', config.zoom_privileged ? null : 'g.' + CLASS.regions).attr('class', CLASS.zoomRect).attr('width', $$.width).attr('height', $$.height).style('opacity', 0).on("dblclick.zoom", null);
      if (config.axis_x_extent) {
        $$.brush.extent($$.getDefaultExtent());
      }
      $$.axis.init();
      $$.updateTargets($$.data.targets);
      if (binding) {
        $$.updateDimension();
        $$.config.oninit.call($$);
        $$.redraw({
          withTransition: false,
          withTransform: true,
          withUpdateXDomain: true,
          withUpdateOrgXDomain: true,
          withTransitionForAxis: false
        });
      }
      if (window.onresize == null) {
        window.onresize = $$.generateResize();
      }
      if (window.onresize.add) {
        window.onresize.add(function() {
          config.onresize.call($$);
        });
        window.onresize.add(function() {
          $$.api.flush();
        });
        window.onresize.add(function() {
          config.onresized.call($$);
        });
      }
      $$.api.element = $$.selectChart.node();
    };
    c3_chart_internal_fn.smoothLines = function(el, type) {
      var $$ = this;
      if (type === 'grid') {
        el.each(function() {
          var g = $$.d3.select(this),
              x1 = g.attr('x1'),
              x2 = g.attr('x2'),
              y1 = g.attr('y1'),
              y2 = g.attr('y2');
          g.attr({
            'x1': Math.ceil(x1),
            'x2': Math.ceil(x2),
            'y1': Math.ceil(y1),
            'y2': Math.ceil(y2)
          });
        });
      }
    };
    c3_chart_internal_fn.updateSizes = function() {
      var $$ = this,
          config = $$.config;
      var legendHeight = $$.legend ? $$.getLegendHeight() : 0,
          legendWidth = $$.legend ? $$.getLegendWidth() : 0,
          legendHeightForBottom = $$.isLegendRight || $$.isLegendInset ? 0 : legendHeight,
          hasArc = $$.hasArcType(),
          xAxisHeight = config.axis_rotated || hasArc ? 0 : $$.getHorizontalAxisHeight('x'),
          subchartHeight = config.subchart_show && !hasArc ? (config.subchart_size_height + xAxisHeight) : 0;
      $$.currentWidth = $$.getCurrentWidth();
      $$.currentHeight = $$.getCurrentHeight();
      $$.margin = config.axis_rotated ? {
        top: $$.getHorizontalAxisHeight('y2') + $$.getCurrentPaddingTop(),
        right: hasArc ? 0 : $$.getCurrentPaddingRight(),
        bottom: $$.getHorizontalAxisHeight('y') + legendHeightForBottom + $$.getCurrentPaddingBottom(),
        left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
      } : {
        top: 4 + $$.getCurrentPaddingTop(),
        right: hasArc ? 0 : $$.getCurrentPaddingRight(),
        bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),
        left: hasArc ? 0 : $$.getCurrentPaddingLeft()
      };
      $$.margin2 = config.axis_rotated ? {
        top: $$.margin.top,
        right: NaN,
        bottom: 20 + legendHeightForBottom,
        left: $$.rotated_padding_left
      } : {
        top: $$.currentHeight - subchartHeight - legendHeightForBottom,
        right: NaN,
        bottom: xAxisHeight + legendHeightForBottom,
        left: $$.margin.left
      };
      $$.margin3 = {
        top: 0,
        right: NaN,
        bottom: 0,
        left: 0
      };
      if ($$.updateSizeForLegend) {
        $$.updateSizeForLegend(legendHeight, legendWidth);
      }
      $$.width = $$.currentWidth - $$.margin.left - $$.margin.right;
      $$.height = $$.currentHeight - $$.margin.top - $$.margin.bottom;
      if ($$.width < 0) {
        $$.width = 0;
      }
      if ($$.height < 0) {
        $$.height = 0;
      }
      $$.width2 = config.axis_rotated ? $$.margin.left - $$.rotated_padding_left - $$.rotated_padding_right : $$.width;
      $$.height2 = config.axis_rotated ? $$.height : $$.currentHeight - $$.margin2.top - $$.margin2.bottom;
      if ($$.width2 < 0) {
        $$.width2 = 0;
      }
      if ($$.height2 < 0) {
        $$.height2 = 0;
      }
      $$.arcWidth = $$.width - ($$.isLegendRight ? legendWidth + 10 : 0);
      $$.arcHeight = $$.height - ($$.isLegendRight ? 0 : 10);
      if ($$.hasType('gauge')) {
        $$.arcHeight += $$.height - $$.getGaugeLabelHeight();
      }
      if ($$.updateRadius) {
        $$.updateRadius();
      }
      if ($$.isLegendRight && hasArc) {
        $$.margin3.left = $$.arcWidth / 2 + $$.radiusExpanded * 1.1;
      }
    };
    c3_chart_internal_fn.updateTargets = function(targets) {
      var $$ = this;
      $$.updateTargetsForText(targets);
      $$.updateTargetsForBar(targets);
      $$.updateTargetsForLine(targets);
      if ($$.hasArcType() && $$.updateTargetsForArc) {
        $$.updateTargetsForArc(targets);
      }
      if ($$.updateTargetsForSubchart) {
        $$.updateTargetsForSubchart(targets);
      }
      $$.showTargets();
    };
    c3_chart_internal_fn.showTargets = function() {
      var $$ = this;
      $$.svg.selectAll('.' + CLASS.target).filter(function(d) {
        return $$.isTargetToShow(d.id);
      }).transition().duration($$.config.transition_duration).style("opacity", 1);
    };
    c3_chart_internal_fn.redraw = function(options, transitions) {
      var $$ = this,
          main = $$.main,
          d3 = $$.d3,
          config = $$.config;
      var areaIndices = $$.getShapeIndices($$.isAreaType),
          barIndices = $$.getShapeIndices($$.isBarType),
          lineIndices = $$.getShapeIndices($$.isLineType);
      var withY,
          withSubchart,
          withTransition,
          withTransitionForExit,
          withTransitionForAxis,
          withTransform,
          withUpdateXDomain,
          withUpdateOrgXDomain,
          withTrimXDomain,
          withLegend,
          withEventRect,
          withDimension,
          withUpdateXAxis;
      var hideAxis = $$.hasArcType();
      var drawArea,
          drawBar,
          drawLine,
          xForText,
          yForText;
      var duration,
          durationForExit,
          durationForAxis;
      var waitForDraw,
          flow;
      var targetsToShow = $$.filterTargetsToShow($$.data.targets),
          tickValues,
          i,
          intervalForCulling,
          xDomainForZoom;
      var xv = $$.xv.bind($$),
          cx,
          cy;
      options = options || {};
      withY = getOption(options, "withY", true);
      withSubchart = getOption(options, "withSubchart", true);
      withTransition = getOption(options, "withTransition", true);
      withTransform = getOption(options, "withTransform", false);
      withUpdateXDomain = getOption(options, "withUpdateXDomain", false);
      withUpdateOrgXDomain = getOption(options, "withUpdateOrgXDomain", false);
      withTrimXDomain = getOption(options, "withTrimXDomain", true);
      withUpdateXAxis = getOption(options, "withUpdateXAxis", withUpdateXDomain);
      withLegend = getOption(options, "withLegend", false);
      withEventRect = getOption(options, "withEventRect", true);
      withDimension = getOption(options, "withDimension", true);
      withTransitionForExit = getOption(options, "withTransitionForExit", withTransition);
      withTransitionForAxis = getOption(options, "withTransitionForAxis", withTransition);
      duration = withTransition ? config.transition_duration : 0;
      durationForExit = withTransitionForExit ? duration : 0;
      durationForAxis = withTransitionForAxis ? duration : 0;
      transitions = transitions || $$.axis.generateTransitions(durationForAxis);
      if (withLegend && config.legend_show) {
        $$.updateLegend($$.mapToIds($$.data.targets), options, transitions);
      } else if (withDimension) {
        $$.updateDimension(true);
      }
      if ($$.isCategorized() && targetsToShow.length === 0) {
        $$.x.domain([0, $$.axes.x.selectAll('.tick').size()]);
      }
      if (targetsToShow.length) {
        $$.updateXDomain(targetsToShow, withUpdateXDomain, withUpdateOrgXDomain, withTrimXDomain);
        if (!config.axis_x_tick_values) {
          tickValues = $$.axis.updateXAxisTickValues(targetsToShow);
        }
      } else {
        $$.xAxis.tickValues([]);
        $$.subXAxis.tickValues([]);
      }
      if (config.zoom_rescale && !options.flow) {
        xDomainForZoom = $$.x.orgDomain();
      }
      $$.y.domain($$.getYDomain(targetsToShow, 'y', xDomainForZoom));
      $$.y2.domain($$.getYDomain(targetsToShow, 'y2', xDomainForZoom));
      if (!config.axis_y_tick_values && config.axis_y_tick_count) {
        $$.yAxis.tickValues($$.axis.generateTickValues($$.y.domain(), config.axis_y_tick_count));
      }
      if (!config.axis_y2_tick_values && config.axis_y2_tick_count) {
        $$.y2Axis.tickValues($$.axis.generateTickValues($$.y2.domain(), config.axis_y2_tick_count));
      }
      $$.axis.redraw(transitions, hideAxis);
      $$.axis.updateLabels(withTransition);
      if ((withUpdateXDomain || withUpdateXAxis) && targetsToShow.length) {
        if (config.axis_x_tick_culling && tickValues) {
          for (i = 1; i < tickValues.length; i++) {
            if (tickValues.length / i < config.axis_x_tick_culling_max) {
              intervalForCulling = i;
              break;
            }
          }
          $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').each(function(e) {
            var index = tickValues.indexOf(e);
            if (index >= 0) {
              d3.select(this).style('display', index % intervalForCulling ? 'none' : 'block');
            }
          });
        } else {
          $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').style('display', 'block');
        }
      }
      drawArea = $$.generateDrawArea ? $$.generateDrawArea(areaIndices, false) : undefined;
      drawBar = $$.generateDrawBar ? $$.generateDrawBar(barIndices) : undefined;
      drawLine = $$.generateDrawLine ? $$.generateDrawLine(lineIndices, false) : undefined;
      xForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, true);
      yForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, false);
      if (withY) {
        $$.subY.domain($$.getYDomain(targetsToShow, 'y'));
        $$.subY2.domain($$.getYDomain(targetsToShow, 'y2'));
      }
      $$.tooltip.style("display", "none");
      $$.updateXgridFocus();
      main.select("text." + CLASS.text + '.' + CLASS.empty).attr("x", $$.width / 2).attr("y", $$.height / 2).text(config.data_empty_label_text).transition().style('opacity', targetsToShow.length ? 0 : 1);
      $$.updateGrid(duration);
      $$.updateRegion(duration);
      $$.updateBar(durationForExit);
      $$.updateLine(durationForExit);
      $$.updateArea(durationForExit);
      $$.updateCircle();
      if ($$.hasDataLabel()) {
        $$.updateText(durationForExit);
      }
      if ($$.redrawArc) {
        $$.redrawArc(duration, durationForExit, withTransform);
      }
      if ($$.redrawSubchart) {
        $$.redrawSubchart(withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices);
      }
      main.selectAll('.' + CLASS.selectedCircles).filter($$.isBarType.bind($$)).selectAll('circle').remove();
      if (config.interaction_enabled && !options.flow && withEventRect) {
        $$.redrawEventRect();
        if ($$.updateZoom) {
          $$.updateZoom();
        }
      }
      $$.updateCircleY();
      cx = ($$.config.axis_rotated ? $$.circleY : $$.circleX).bind($$);
      cy = ($$.config.axis_rotated ? $$.circleX : $$.circleY).bind($$);
      if (options.flow) {
        flow = $$.generateFlow({
          targets: targetsToShow,
          flow: options.flow,
          duration: options.flow.duration,
          drawBar: drawBar,
          drawLine: drawLine,
          drawArea: drawArea,
          cx: cx,
          cy: cy,
          xv: xv,
          xForText: xForText,
          yForText: yForText
        });
      }
      if ((duration || flow) && $$.isTabVisible()) {
        d3.transition().duration(duration).each(function() {
          var transitionsToWait = [];
          [$$.redrawBar(drawBar, true), $$.redrawLine(drawLine, true), $$.redrawArea(drawArea, true), $$.redrawCircle(cx, cy, true), $$.redrawText(xForText, yForText, options.flow, true), $$.redrawRegion(true), $$.redrawGrid(true)].forEach(function(transitions) {
            transitions.forEach(function(transition) {
              transitionsToWait.push(transition);
            });
          });
          waitForDraw = $$.generateWait();
          transitionsToWait.forEach(function(t) {
            waitForDraw.add(t);
          });
        }).call(waitForDraw, function() {
          if (flow) {
            flow();
          }
          if (config.onrendered) {
            config.onrendered.call($$);
          }
        });
      } else {
        $$.redrawBar(drawBar);
        $$.redrawLine(drawLine);
        $$.redrawArea(drawArea);
        $$.redrawCircle(cx, cy);
        $$.redrawText(xForText, yForText, options.flow);
        $$.redrawRegion();
        $$.redrawGrid();
        if (config.onrendered) {
          config.onrendered.call($$);
        }
      }
      $$.mapToIds($$.data.targets).forEach(function(id) {
        $$.withoutFadeIn[id] = true;
      });
    };
    c3_chart_internal_fn.updateAndRedraw = function(options) {
      var $$ = this,
          config = $$.config,
          transitions;
      options = options || {};
      options.withTransition = getOption(options, "withTransition", true);
      options.withTransform = getOption(options, "withTransform", false);
      options.withLegend = getOption(options, "withLegend", false);
      options.withUpdateXDomain = true;
      options.withUpdateOrgXDomain = true;
      options.withTransitionForExit = false;
      options.withTransitionForTransform = getOption(options, "withTransitionForTransform", options.withTransition);
      $$.updateSizes();
      if (!(options.withLegend && config.legend_show)) {
        transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0);
        $$.updateScales();
        $$.updateSvgSize();
        $$.transformAll(options.withTransitionForTransform, transitions);
      }
      $$.redraw(options, transitions);
    };
    c3_chart_internal_fn.redrawWithoutRescale = function() {
      this.redraw({
        withY: false,
        withSubchart: false,
        withEventRect: false,
        withTransitionForAxis: false
      });
    };
    c3_chart_internal_fn.isTimeSeries = function() {
      return this.config.axis_x_type === 'timeseries';
    };
    c3_chart_internal_fn.isCategorized = function() {
      return this.config.axis_x_type.indexOf('categor') >= 0;
    };
    c3_chart_internal_fn.isCustomX = function() {
      var $$ = this,
          config = $$.config;
      return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
    };
    c3_chart_internal_fn.isTimeSeriesY = function() {
      return this.config.axis_y_type === 'timeseries';
    };
    c3_chart_internal_fn.getTranslate = function(target) {
      var $$ = this,
          config = $$.config,
          x,
          y;
      if (target === 'main') {
        x = asHalfPixel($$.margin.left);
        y = asHalfPixel($$.margin.top);
      } else if (target === 'context') {
        x = asHalfPixel($$.margin2.left);
        y = asHalfPixel($$.margin2.top);
      } else if (target === 'legend') {
        x = $$.margin3.left;
        y = $$.margin3.top;
      } else if (target === 'x') {
        x = 0;
        y = config.axis_rotated ? 0 : $$.height;
      } else if (target === 'y') {
        x = 0;
        y = config.axis_rotated ? $$.height : 0;
      } else if (target === 'y2') {
        x = config.axis_rotated ? 0 : $$.width;
        y = config.axis_rotated ? 1 : 0;
      } else if (target === 'subx') {
        x = 0;
        y = config.axis_rotated ? 0 : $$.height2;
      } else if (target === 'arc') {
        x = $$.arcWidth / 2;
        y = $$.arcHeight / 2;
      }
      return "translate(" + x + "," + y + ")";
    };
    c3_chart_internal_fn.initialOpacity = function(d) {
      return d.value !== null && this.withoutFadeIn[d.id] ? 1 : 0;
    };
    c3_chart_internal_fn.initialOpacityForCircle = function(d) {
      return d.value !== null && this.withoutFadeIn[d.id] ? this.opacityForCircle(d) : 0;
    };
    c3_chart_internal_fn.opacityForCircle = function(d) {
      var opacity = this.config.point_show ? 1 : 0;
      return isValue(d.value) ? (this.isScatterType(d) ? 0.5 : opacity) : 0;
    };
    c3_chart_internal_fn.opacityForText = function() {
      return this.hasDataLabel() ? 1 : 0;
    };
    c3_chart_internal_fn.xx = function(d) {
      return d ? this.x(d.x) : null;
    };
    c3_chart_internal_fn.xv = function(d) {
      var $$ = this,
          value = d.value;
      if ($$.isTimeSeries()) {
        value = $$.parseDate(d.value);
      } else if ($$.isCategorized() && typeof d.value === 'string') {
        value = $$.config.axis_x_categories.indexOf(d.value);
      }
      return Math.ceil($$.x(value));
    };
    c3_chart_internal_fn.yv = function(d) {
      var $$ = this,
          yScale = d.axis && d.axis === 'y2' ? $$.y2 : $$.y;
      return Math.ceil(yScale(d.value));
    };
    c3_chart_internal_fn.subxx = function(d) {
      return d ? this.subX(d.x) : null;
    };
    c3_chart_internal_fn.transformMain = function(withTransition, transitions) {
      var $$ = this,
          xAxis,
          yAxis,
          y2Axis;
      if (transitions && transitions.axisX) {
        xAxis = transitions.axisX;
      } else {
        xAxis = $$.main.select('.' + CLASS.axisX);
        if (withTransition) {
          xAxis = xAxis.transition();
        }
      }
      if (transitions && transitions.axisY) {
        yAxis = transitions.axisY;
      } else {
        yAxis = $$.main.select('.' + CLASS.axisY);
        if (withTransition) {
          yAxis = yAxis.transition();
        }
      }
      if (transitions && transitions.axisY2) {
        y2Axis = transitions.axisY2;
      } else {
        y2Axis = $$.main.select('.' + CLASS.axisY2);
        if (withTransition) {
          y2Axis = y2Axis.transition();
        }
      }
      (withTransition ? $$.main.transition() : $$.main).attr("transform", $$.getTranslate('main'));
      xAxis.attr("transform", $$.getTranslate('x'));
      yAxis.attr("transform", $$.getTranslate('y'));
      y2Axis.attr("transform", $$.getTranslate('y2'));
      $$.main.select('.' + CLASS.chartArcs).attr("transform", $$.getTranslate('arc'));
    };
    c3_chart_internal_fn.transformAll = function(withTransition, transitions) {
      var $$ = this;
      $$.transformMain(withTransition, transitions);
      if ($$.config.subchart_show) {
        $$.transformContext(withTransition, transitions);
      }
      if ($$.legend) {
        $$.transformLegend(withTransition);
      }
    };
    c3_chart_internal_fn.updateSvgSize = function() {
      var $$ = this,
          brush = $$.svg.select(".c3-brush .background");
      $$.svg.attr('width', $$.currentWidth).attr('height', $$.currentHeight);
      $$.svg.selectAll(['#' + $$.clipId, '#' + $$.clipIdForGrid]).select('rect').attr('width', $$.width).attr('height', $$.height);
      $$.svg.select('#' + $$.clipIdForXAxis).select('rect').attr('x', $$.getXAxisClipX.bind($$)).attr('y', $$.getXAxisClipY.bind($$)).attr('width', $$.getXAxisClipWidth.bind($$)).attr('height', $$.getXAxisClipHeight.bind($$));
      $$.svg.select('#' + $$.clipIdForYAxis).select('rect').attr('x', $$.getYAxisClipX.bind($$)).attr('y', $$.getYAxisClipY.bind($$)).attr('width', $$.getYAxisClipWidth.bind($$)).attr('height', $$.getYAxisClipHeight.bind($$));
      $$.svg.select('#' + $$.clipIdForSubchart).select('rect').attr('width', $$.width).attr('height', brush.size() ? brush.attr('height') : 0);
      $$.svg.select('.' + CLASS.zoomRect).attr('width', $$.width).attr('height', $$.height);
      $$.selectChart.style('max-height', $$.currentHeight + "px");
    };
    c3_chart_internal_fn.updateDimension = function(withoutAxis) {
      var $$ = this;
      if (!withoutAxis) {
        if ($$.config.axis_rotated) {
          $$.axes.x.call($$.xAxis);
          $$.axes.subx.call($$.subXAxis);
        } else {
          $$.axes.y.call($$.yAxis);
          $$.axes.y2.call($$.y2Axis);
        }
      }
      $$.updateSizes();
      $$.updateScales();
      $$.updateSvgSize();
      $$.transformAll(false);
    };
    c3_chart_internal_fn.observeInserted = function(selection) {
      var $$ = this,
          observer;
      if (typeof MutationObserver === 'undefined') {
        window.console.error("MutationObserver not defined.");
        return;
      }
      observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          if (mutation.type === 'childList' && mutation.previousSibling) {
            observer.disconnect();
            $$.intervalForObserveInserted = window.setInterval(function() {
              if (selection.node().parentNode) {
                window.clearInterval($$.intervalForObserveInserted);
                $$.updateDimension();
                $$.config.oninit.call($$);
                $$.redraw({
                  withTransform: true,
                  withUpdateXDomain: true,
                  withUpdateOrgXDomain: true,
                  withTransition: false,
                  withTransitionForTransform: false,
                  withLegend: true
                });
                selection.transition().style('opacity', 1);
              }
            }, 10);
          }
        });
      });
      observer.observe(selection.node(), {
        attributes: true,
        childList: true,
        characterData: true
      });
    };
    c3_chart_internal_fn.generateResize = function() {
      var resizeFunctions = [];
      function callResizeFunctions() {
        resizeFunctions.forEach(function(f) {
          f();
        });
      }
      callResizeFunctions.add = function(f) {
        resizeFunctions.push(f);
      };
      return callResizeFunctions;
    };
    c3_chart_internal_fn.endall = function(transition, callback) {
      var n = 0;
      transition.each(function() {
        ++n;
      }).each("end", function() {
        if (!--n) {
          callback.apply(this, arguments);
        }
      });
    };
    c3_chart_internal_fn.generateWait = function() {
      var transitionsToWait = [],
          f = function(transition, callback) {
            var timer = setInterval(function() {
              var done = 0;
              transitionsToWait.forEach(function(t) {
                if (t.empty()) {
                  done += 1;
                  return;
                }
                try {
                  t.transition();
                } catch (e) {
                  done += 1;
                }
              });
              if (done === transitionsToWait.length) {
                clearInterval(timer);
                if (callback) {
                  callback();
                }
              }
            }, 10);
          };
      f.add = function(transition) {
        transitionsToWait.push(transition);
      };
      return f;
    };
    c3_chart_internal_fn.parseDate = function(date) {
      var $$ = this,
          parsedDate;
      if (date instanceof Date) {
        parsedDate = date;
      } else if (typeof date === 'string') {
        parsedDate = $$.dataTimeFormat($$.config.data_xFormat).parse(date);
      } else if (typeof date === 'number' || !isNaN(date)) {
        parsedDate = new Date(+date);
      }
      if (!parsedDate || isNaN(+parsedDate)) {
        window.console.error("Failed to parse x '" + date + "' to Date object");
      }
      return parsedDate;
    };
    c3_chart_internal_fn.isTabVisible = function() {
      var hidden;
      if (typeof document.hidden !== "undefined") {
        hidden = "hidden";
      } else if (typeof document.mozHidden !== "undefined") {
        hidden = "mozHidden";
      } else if (typeof document.msHidden !== "undefined") {
        hidden = "msHidden";
      } else if (typeof document.webkitHidden !== "undefined") {
        hidden = "webkitHidden";
      }
      return document[hidden] ? false : true;
    };
    c3_chart_internal_fn.getDefaultConfig = function() {
      var config = {
        bindto: '#chart',
        size_width: undefined,
        size_height: undefined,
        padding_left: undefined,
        padding_right: undefined,
        padding_top: undefined,
        padding_bottom: undefined,
        zoom_enabled: false,
        zoom_extent: undefined,
        zoom_privileged: false,
        zoom_rescale: false,
        zoom_onzoom: function() {},
        zoom_onzoomstart: function() {},
        zoom_onzoomend: function() {},
        interaction_enabled: true,
        onmouseover: function() {},
        onmouseout: function() {},
        onresize: function() {},
        onresized: function() {},
        oninit: function() {},
        onrendered: function() {},
        transition_duration: 350,
        data_x: undefined,
        data_xs: {},
        data_xFormat: '%Y-%m-%d',
        data_xLocaltime: true,
        data_xSort: true,
        data_idConverter: function(id) {
          return id;
        },
        data_names: {},
        data_classes: {},
        data_groups: [],
        data_axes: {},
        data_type: undefined,
        data_types: {},
        data_labels: {},
        data_order: 'desc',
        data_regions: {},
        data_color: undefined,
        data_colors: {},
        data_hide: false,
        data_filter: undefined,
        data_selection_enabled: false,
        data_selection_grouped: false,
        data_selection_isselectable: function() {
          return true;
        },
        data_selection_multiple: true,
        data_selection_draggable: false,
        data_onclick: function() {},
        data_onmouseover: function() {},
        data_onmouseout: function() {},
        data_onselected: function() {},
        data_onunselected: function() {},
        data_url: undefined,
        data_json: undefined,
        data_rows: undefined,
        data_columns: undefined,
        data_mimeType: undefined,
        data_keys: undefined,
        data_empty_label_text: "",
        subchart_show: false,
        subchart_size_height: 60,
        subchart_onbrush: function() {},
        color_pattern: [],
        color_threshold: {},
        legend_show: true,
        legend_hide: false,
        legend_position: 'bottom',
        legend_inset_anchor: 'top-left',
        legend_inset_x: 10,
        legend_inset_y: 0,
        legend_inset_step: undefined,
        legend_item_onclick: undefined,
        legend_item_onmouseover: undefined,
        legend_item_onmouseout: undefined,
        legend_equally: false,
        axis_rotated: false,
        axis_x_show: true,
        axis_x_type: 'indexed',
        axis_x_localtime: true,
        axis_x_categories: [],
        axis_x_tick_centered: false,
        axis_x_tick_format: undefined,
        axis_x_tick_culling: {},
        axis_x_tick_culling_max: 10,
        axis_x_tick_count: undefined,
        axis_x_tick_fit: true,
        axis_x_tick_values: null,
        axis_x_tick_rotate: 0,
        axis_x_tick_outer: true,
        axis_x_tick_multiline: true,
        axis_x_tick_width: null,
        axis_x_max: undefined,
        axis_x_min: undefined,
        axis_x_padding: {},
        axis_x_height: undefined,
        axis_x_extent: undefined,
        axis_x_label: {},
        axis_y_show: true,
        axis_y_type: undefined,
        axis_y_max: undefined,
        axis_y_min: undefined,
        axis_y_inverted: false,
        axis_y_center: undefined,
        axis_y_inner: undefined,
        axis_y_label: {},
        axis_y_tick_format: undefined,
        axis_y_tick_outer: true,
        axis_y_tick_values: null,
        axis_y_tick_count: undefined,
        axis_y_tick_time_value: undefined,
        axis_y_tick_time_interval: undefined,
        axis_y_padding: {},
        axis_y_default: undefined,
        axis_y2_show: false,
        axis_y2_max: undefined,
        axis_y2_min: undefined,
        axis_y2_inverted: false,
        axis_y2_center: undefined,
        axis_y2_inner: undefined,
        axis_y2_label: {},
        axis_y2_tick_format: undefined,
        axis_y2_tick_outer: true,
        axis_y2_tick_values: null,
        axis_y2_tick_count: undefined,
        axis_y2_padding: {},
        axis_y2_default: undefined,
        grid_x_show: false,
        grid_x_type: 'tick',
        grid_x_lines: [],
        grid_y_show: false,
        grid_y_lines: [],
        grid_y_ticks: 10,
        grid_focus_show: true,
        grid_lines_front: true,
        point_show: true,
        point_r: 2.5,
        point_focus_expand_enabled: true,
        point_focus_expand_r: undefined,
        point_select_r: undefined,
        line_connectNull: false,
        line_step_type: 'step',
        bar_width: undefined,
        bar_width_ratio: 0.6,
        bar_width_max: undefined,
        bar_zerobased: true,
        area_zerobased: true,
        pie_label_show: true,
        pie_label_format: undefined,
        pie_label_threshold: 0.05,
        pie_expand: true,
        gauge_label_show: true,
        gauge_label_format: undefined,
        gauge_expand: true,
        gauge_min: 0,
        gauge_max: 100,
        gauge_units: undefined,
        gauge_width: undefined,
        donut_label_show: true,
        donut_label_format: undefined,
        donut_label_threshold: 0.05,
        donut_width: undefined,
        donut_expand: true,
        donut_title: "",
        regions: [],
        tooltip_show: true,
        tooltip_grouped: true,
        tooltip_format_title: undefined,
        tooltip_format_name: undefined,
        tooltip_format_value: undefined,
        tooltip_position: undefined,
        tooltip_contents: function(d, defaultTitleFormat, defaultValueFormat, color) {
          return this.getTooltipContent ? this.getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) : '';
        },
        tooltip_init_show: false,
        tooltip_init_x: 0,
        tooltip_init_position: {
          top: '0px',
          left: '50px'
        }
      };
      Object.keys(this.additionalConfig).forEach(function(key) {
        config[key] = this.additionalConfig[key];
      }, this);
      return config;
    };
    c3_chart_internal_fn.additionalConfig = {};
    c3_chart_internal_fn.loadConfig = function(config) {
      var this_config = this.config,
          target,
          keys,
          read;
      function find() {
        var key = keys.shift();
        if (key && target && typeof target === 'object' && key in target) {
          target = target[key];
          return find();
        } else if (!key) {
          return target;
        } else {
          return undefined;
        }
      }
      Object.keys(this_config).forEach(function(key) {
        target = config;
        keys = key.split('_');
        read = find();
        if (isDefined(read)) {
          this_config[key] = read;
        }
      });
    };
    c3_chart_internal_fn.getScale = function(min, max, forTimeseries) {
      return (forTimeseries ? this.d3.time.scale() : this.d3.scale.linear()).range([min, max]);
    };
    c3_chart_internal_fn.getX = function(min, max, domain, offset) {
      var $$ = this,
          scale = $$.getScale(min, max, $$.isTimeSeries()),
          _scale = domain ? scale.domain(domain) : scale,
          key;
      if ($$.isCategorized()) {
        offset = offset || function() {
          return 0;
        };
        scale = function(d, raw) {
          var v = _scale(d) + offset(d);
          return raw ? v : Math.ceil(v);
        };
      } else {
        scale = function(d, raw) {
          var v = _scale(d);
          return raw ? v : Math.ceil(v);
        };
      }
      for (key in _scale) {
        scale[key] = _scale[key];
      }
      scale.orgDomain = function() {
        return _scale.domain();
      };
      if ($$.isCategorized()) {
        scale.domain = function(domain) {
          if (!arguments.length) {
            domain = this.orgDomain();
            return [domain[0], domain[1] + 1];
          }
          _scale.domain(domain);
          return scale;
        };
      }
      return scale;
    };
    c3_chart_internal_fn.getY = function(min, max, domain) {
      var scale = this.getScale(min, max, this.isTimeSeriesY());
      if (domain) {
        scale.domain(domain);
      }
      return scale;
    };
    c3_chart_internal_fn.getYScale = function(id) {
      return this.axis.getId(id) === 'y2' ? this.y2 : this.y;
    };
    c3_chart_internal_fn.getSubYScale = function(id) {
      return this.axis.getId(id) === 'y2' ? this.subY2 : this.subY;
    };
    c3_chart_internal_fn.updateScales = function() {
      var $$ = this,
          config = $$.config,
          forInit = !$$.x;
      $$.xMin = config.axis_rotated ? 1 : 0;
      $$.xMax = config.axis_rotated ? $$.height : $$.width;
      $$.yMin = config.axis_rotated ? 0 : $$.height;
      $$.yMax = config.axis_rotated ? $$.width : 1;
      $$.subXMin = $$.xMin;
      $$.subXMax = $$.xMax;
      $$.subYMin = config.axis_rotated ? 0 : $$.height2;
      $$.subYMax = config.axis_rotated ? $$.width2 : 1;
      $$.x = $$.getX($$.xMin, $$.xMax, forInit ? undefined : $$.x.orgDomain(), function() {
        return $$.xAxis.tickOffset();
      });
      $$.y = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y_default : $$.y.domain());
      $$.y2 = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y2_default : $$.y2.domain());
      $$.subX = $$.getX($$.xMin, $$.xMax, $$.orgXDomain, function(d) {
        return d % 1 ? 0 : $$.subXAxis.tickOffset();
      });
      $$.subY = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y_default : $$.subY.domain());
      $$.subY2 = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y2_default : $$.subY2.domain());
      $$.xAxisTickFormat = $$.axis.getXAxisTickFormat();
      $$.xAxisTickValues = $$.axis.getXAxisTickValues();
      $$.yAxisTickValues = $$.axis.getYAxisTickValues();
      $$.y2AxisTickValues = $$.axis.getY2AxisTickValues();
      $$.xAxis = $$.axis.getXAxis($$.x, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer);
      $$.subXAxis = $$.axis.getXAxis($$.subX, $$.subXOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer);
      $$.yAxis = $$.axis.getYAxis($$.y, $$.yOrient, config.axis_y_tick_format, $$.yAxisTickValues, config.axis_y_tick_outer);
      $$.y2Axis = $$.axis.getYAxis($$.y2, $$.y2Orient, config.axis_y2_tick_format, $$.y2AxisTickValues, config.axis_y2_tick_outer);
      if (!forInit) {
        if ($$.brush) {
          $$.brush.scale($$.subX);
        }
        if (config.zoom_enabled) {
          $$.zoom.scale($$.x);
        }
      }
      if ($$.updateArc) {
        $$.updateArc();
      }
    };
    c3_chart_internal_fn.getYDomainMin = function(targets) {
      var $$ = this,
          config = $$.config,
          ids = $$.mapToIds(targets),
          ys = $$.getValuesAsIdKeyed(targets),
          j,
          k,
          baseId,
          idsInGroup,
          id,
          hasNegativeValue;
      if (config.data_groups.length > 0) {
        hasNegativeValue = $$.hasNegativeValueInTargets(targets);
        for (j = 0; j < config.data_groups.length; j++) {
          idsInGroup = config.data_groups[j].filter(function(id) {
            return ids.indexOf(id) >= 0;
          });
          if (idsInGroup.length === 0) {
            continue;
          }
          baseId = idsInGroup[0];
          if (hasNegativeValue && ys[baseId]) {
            ys[baseId].forEach(function(v, i) {
              ys[baseId][i] = v < 0 ? v : 0;
            });
          }
          for (k = 1; k < idsInGroup.length; k++) {
            id = idsInGroup[k];
            if (!ys[id]) {
              continue;
            }
            ys[id].forEach(function(v, i) {
              if ($$.axis.getId(id) === $$.axis.getId(baseId) && ys[baseId] && !(hasNegativeValue && +v > 0)) {
                ys[baseId][i] += +v;
              }
            });
          }
        }
      }
      return $$.d3.min(Object.keys(ys).map(function(key) {
        return $$.d3.min(ys[key]);
      }));
    };
    c3_chart_internal_fn.getYDomainMax = function(targets) {
      var $$ = this,
          config = $$.config,
          ids = $$.mapToIds(targets),
          ys = $$.getValuesAsIdKeyed(targets),
          j,
          k,
          baseId,
          idsInGroup,
          id,
          hasPositiveValue;
      if (config.data_groups.length > 0) {
        hasPositiveValue = $$.hasPositiveValueInTargets(targets);
        for (j = 0; j < config.data_groups.length; j++) {
          idsInGroup = config.data_groups[j].filter(function(id) {
            return ids.indexOf(id) >= 0;
          });
          if (idsInGroup.length === 0) {
            continue;
          }
          baseId = idsInGroup[0];
          if (hasPositiveValue && ys[baseId]) {
            ys[baseId].forEach(function(v, i) {
              ys[baseId][i] = v > 0 ? v : 0;
            });
          }
          for (k = 1; k < idsInGroup.length; k++) {
            id = idsInGroup[k];
            if (!ys[id]) {
              continue;
            }
            ys[id].forEach(function(v, i) {
              if ($$.axis.getId(id) === $$.axis.getId(baseId) && ys[baseId] && !(hasPositiveValue && +v < 0)) {
                ys[baseId][i] += +v;
              }
            });
          }
        }
      }
      return $$.d3.max(Object.keys(ys).map(function(key) {
        return $$.d3.max(ys[key]);
      }));
    };
    c3_chart_internal_fn.getYDomain = function(targets, axisId, xDomain) {
      var $$ = this,
          config = $$.config,
          targetsByAxisId = targets.filter(function(t) {
            return $$.axis.getId(t.id) === axisId;
          }),
          yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId,
          yMin = axisId === 'y2' ? config.axis_y2_min : config.axis_y_min,
          yMax = axisId === 'y2' ? config.axis_y2_max : config.axis_y_max,
          yDomainMin = $$.getYDomainMin(yTargets),
          yDomainMax = $$.getYDomainMax(yTargets),
          domain,
          domainLength,
          padding,
          padding_top,
          padding_bottom,
          center = axisId === 'y2' ? config.axis_y2_center : config.axis_y_center,
          yDomainAbs,
          lengths,
          diff,
          ratio,
          isAllPositive,
          isAllNegative,
          isZeroBased = ($$.hasType('bar', yTargets) && config.bar_zerobased) || ($$.hasType('area', yTargets) && config.area_zerobased),
          isInverted = axisId === 'y2' ? config.axis_y2_inverted : config.axis_y_inverted,
          showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,
          showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;
      yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? (yDomainMin < yMax ? yDomainMin : yMax - 10) : yDomainMin;
      yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? (yMin < yDomainMax ? yDomainMax : yMin + 10) : yDomainMax;
      if (yTargets.length === 0) {
        return axisId === 'y2' ? $$.y2.domain() : $$.y.domain();
      }
      if (isNaN(yDomainMin)) {
        yDomainMin = 0;
      }
      if (isNaN(yDomainMax)) {
        yDomainMax = yDomainMin;
      }
      if (yDomainMin === yDomainMax) {
        yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0;
      }
      isAllPositive = yDomainMin >= 0 && yDomainMax >= 0;
      isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;
      if ((isValue(yMin) && isAllPositive) || (isValue(yMax) && isAllNegative)) {
        isZeroBased = false;
      }
      if (isZeroBased) {
        if (isAllPositive) {
          yDomainMin = 0;
        }
        if (isAllNegative) {
          yDomainMax = 0;
        }
      }
      domainLength = Math.abs(yDomainMax - yDomainMin);
      padding = padding_top = padding_bottom = domainLength * 0.1;
      if (typeof center !== 'undefined') {
        yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
        yDomainMax = center + yDomainAbs;
        yDomainMin = center - yDomainAbs;
      }
      if (showHorizontalDataLabel) {
        lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'width');
        diff = diffDomain($$.y.range());
        ratio = [lengths[0] / diff, lengths[1] / diff];
        padding_top += domainLength * (ratio[1] / (1 - ratio[0] - ratio[1]));
        padding_bottom += domainLength * (ratio[0] / (1 - ratio[0] - ratio[1]));
      } else if (showVerticalDataLabel) {
        lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'height');
        padding_top += $$.axis.convertPixelsToAxisPadding(lengths[1], domainLength);
        padding_bottom += $$.axis.convertPixelsToAxisPadding(lengths[0], domainLength);
      }
      if (axisId === 'y' && notEmpty(config.axis_y_padding)) {
        padding_top = $$.axis.getPadding(config.axis_y_padding, 'top', padding_top, domainLength);
        padding_bottom = $$.axis.getPadding(config.axis_y_padding, 'bottom', padding_bottom, domainLength);
      }
      if (axisId === 'y2' && notEmpty(config.axis_y2_padding)) {
        padding_top = $$.axis.getPadding(config.axis_y2_padding, 'top', padding_top, domainLength);
        padding_bottom = $$.axis.getPadding(config.axis_y2_padding, 'bottom', padding_bottom, domainLength);
      }
      if (isZeroBased) {
        if (isAllPositive) {
          padding_bottom = yDomainMin;
        }
        if (isAllNegative) {
          padding_top = -yDomainMax;
        }
      }
      domain = [yDomainMin - padding_bottom, yDomainMax + padding_top];
      return isInverted ? domain.reverse() : domain;
    };
    c3_chart_internal_fn.getXDomainMin = function(targets) {
      var $$ = this,
          config = $$.config;
      return isDefined(config.axis_x_min) ? ($$.isTimeSeries() ? this.parseDate(config.axis_x_min) : config.axis_x_min) : $$.d3.min(targets, function(t) {
        return $$.d3.min(t.values, function(v) {
          return v.x;
        });
      });
    };
    c3_chart_internal_fn.getXDomainMax = function(targets) {
      var $$ = this,
          config = $$.config;
      return isDefined(config.axis_x_max) ? ($$.isTimeSeries() ? this.parseDate(config.axis_x_max) : config.axis_x_max) : $$.d3.max(targets, function(t) {
        return $$.d3.max(t.values, function(v) {
          return v.x;
        });
      });
    };
    c3_chart_internal_fn.getXDomainPadding = function(domain) {
      var $$ = this,
          config = $$.config,
          diff = domain[1] - domain[0],
          maxDataCount,
          padding,
          paddingLeft,
          paddingRight;
      if ($$.isCategorized()) {
        padding = 0;
      } else if ($$.hasType('bar')) {
        maxDataCount = $$.getMaxDataCount();
        padding = maxDataCount > 1 ? (diff / (maxDataCount - 1)) / 2 : 0.5;
      } else {
        padding = diff * 0.01;
      }
      if (typeof config.axis_x_padding === 'object' && notEmpty(config.axis_x_padding)) {
        paddingLeft = isValue(config.axis_x_padding.left) ? config.axis_x_padding.left : padding;
        paddingRight = isValue(config.axis_x_padding.right) ? config.axis_x_padding.right : padding;
      } else if (typeof config.axis_x_padding === 'number') {
        paddingLeft = paddingRight = config.axis_x_padding;
      } else {
        paddingLeft = paddingRight = padding;
      }
      return {
        left: paddingLeft,
        right: paddingRight
      };
    };
    c3_chart_internal_fn.getXDomain = function(targets) {
      var $$ = this,
          xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],
          firstX = xDomain[0],
          lastX = xDomain[1],
          padding = $$.getXDomainPadding(xDomain),
          min = 0,
          max = 0;
      if ((firstX - lastX) === 0 && !$$.isCategorized()) {
        if ($$.isTimeSeries()) {
          firstX = new Date(firstX.getTime() * 0.5);
          lastX = new Date(lastX.getTime() * 1.5);
        } else {
          firstX = firstX === 0 ? 1 : (firstX * 0.5);
          lastX = lastX === 0 ? -1 : (lastX * 1.5);
        }
      }
      if (firstX || firstX === 0) {
        min = $$.isTimeSeries() ? new Date(firstX.getTime() - padding.left) : firstX - padding.left;
      }
      if (lastX || lastX === 0) {
        max = $$.isTimeSeries() ? new Date(lastX.getTime() + padding.right) : lastX + padding.right;
      }
      return [min, max];
    };
    c3_chart_internal_fn.updateXDomain = function(targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
      var $$ = this,
          config = $$.config;
      if (withUpdateOrgXDomain) {
        $$.x.domain(domain ? domain : $$.d3.extent($$.getXDomain(targets)));
        $$.orgXDomain = $$.x.domain();
        if (config.zoom_enabled) {
          $$.zoom.scale($$.x).updateScaleExtent();
        }
        $$.subX.domain($$.x.domain());
        if ($$.brush) {
          $$.brush.scale($$.subX);
        }
      }
      if (withUpdateXDomain) {
        $$.x.domain(domain ? domain : (!$$.brush || $$.brush.empty()) ? $$.orgXDomain : $$.brush.extent());
        if (config.zoom_enabled) {
          $$.zoom.scale($$.x).updateScaleExtent();
        }
      }
      if (withTrim) {
        $$.x.domain($$.trimXDomain($$.x.orgDomain()));
      }
      return $$.x.domain();
    };
    c3_chart_internal_fn.trimXDomain = function(domain) {
      var $$ = this;
      if (domain[0] <= $$.orgXDomain[0]) {
        domain[1] = +domain[1] + ($$.orgXDomain[0] - domain[0]);
        domain[0] = $$.orgXDomain[0];
      }
      if ($$.orgXDomain[1] <= domain[1]) {
        domain[0] = +domain[0] - (domain[1] - $$.orgXDomain[1]);
        domain[1] = $$.orgXDomain[1];
      }
      return domain;
    };
    c3_chart_internal_fn.isX = function(key) {
      var $$ = this,
          config = $$.config;
      return (config.data_x && key === config.data_x) || (notEmpty(config.data_xs) && hasValue(config.data_xs, key));
    };
    c3_chart_internal_fn.isNotX = function(key) {
      return !this.isX(key);
    };
    c3_chart_internal_fn.getXKey = function(id) {
      var $$ = this,
          config = $$.config;
      return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null;
    };
    c3_chart_internal_fn.getXValuesOfXKey = function(key, targets) {
      var $$ = this,
          xValues,
          ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
      ids.forEach(function(id) {
        if ($$.getXKey(id) === key) {
          xValues = $$.data.xs[id];
        }
      });
      return xValues;
    };
    c3_chart_internal_fn.getIndexByX = function(x) {
      var $$ = this,
          data = $$.filterByX($$.data.targets, x);
      return data.length ? data[0].index : null;
    };
    c3_chart_internal_fn.getXValue = function(id, i) {
      var $$ = this;
      return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;
    };
    c3_chart_internal_fn.getOtherTargetXs = function() {
      var $$ = this,
          idsForX = Object.keys($$.data.xs);
      return idsForX.length ? $$.data.xs[idsForX[0]] : null;
    };
    c3_chart_internal_fn.getOtherTargetX = function(index) {
      var xs = this.getOtherTargetXs();
      return xs && index < xs.length ? xs[index] : null;
    };
    c3_chart_internal_fn.addXs = function(xs) {
      var $$ = this;
      Object.keys(xs).forEach(function(id) {
        $$.config.data_xs[id] = xs[id];
      });
    };
    c3_chart_internal_fn.hasMultipleX = function(xs) {
      return this.d3.set(Object.keys(xs).map(function(id) {
        return xs[id];
      })).size() > 1;
    };
    c3_chart_internal_fn.isMultipleX = function() {
      return notEmpty(this.config.data_xs) || !this.config.data_xSort || this.hasType('scatter');
    };
    c3_chart_internal_fn.addName = function(data) {
      var $$ = this,
          name;
      if (data) {
        name = $$.config.data_names[data.id];
        data.name = name ? name : data.id;
      }
      return data;
    };
    c3_chart_internal_fn.getValueOnIndex = function(values, index) {
      var valueOnIndex = values.filter(function(v) {
        return v.index === index;
      });
      return valueOnIndex.length ? valueOnIndex[0] : null;
    };
    c3_chart_internal_fn.updateTargetX = function(targets, x) {
      var $$ = this;
      targets.forEach(function(t) {
        t.values.forEach(function(v, i) {
          v.x = $$.generateTargetX(x[i], t.id, i);
        });
        $$.data.xs[t.id] = x;
      });
    };
    c3_chart_internal_fn.updateTargetXs = function(targets, xs) {
      var $$ = this;
      targets.forEach(function(t) {
        if (xs[t.id]) {
          $$.updateTargetX([t], xs[t.id]);
        }
      });
    };
    c3_chart_internal_fn.generateTargetX = function(rawX, id, index) {
      var $$ = this,
          x;
      if ($$.isTimeSeries()) {
        x = rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index));
      } else if ($$.isCustomX() && !$$.isCategorized()) {
        x = isValue(rawX) ? +rawX : $$.getXValue(id, index);
      } else {
        x = index;
      }
      return x;
    };
    c3_chart_internal_fn.cloneTarget = function(target) {
      return {
        id: target.id,
        id_org: target.id_org,
        values: target.values.map(function(d) {
          return {
            x: d.x,
            value: d.value,
            id: d.id
          };
        })
      };
    };
    c3_chart_internal_fn.updateXs = function() {
      var $$ = this;
      if ($$.data.targets.length) {
        $$.xs = [];
        $$.data.targets[0].values.forEach(function(v) {
          $$.xs[v.index] = v.x;
        });
      }
    };
    c3_chart_internal_fn.getPrevX = function(i) {
      var x = this.xs[i - 1];
      return typeof x !== 'undefined' ? x : null;
    };
    c3_chart_internal_fn.getNextX = function(i) {
      var x = this.xs[i + 1];
      return typeof x !== 'undefined' ? x : null;
    };
    c3_chart_internal_fn.getMaxDataCount = function() {
      var $$ = this;
      return $$.d3.max($$.data.targets, function(t) {
        return t.values.length;
      });
    };
    c3_chart_internal_fn.getMaxDataCountTarget = function(targets) {
      var length = targets.length,
          max = 0,
          maxTarget;
      if (length > 1) {
        targets.forEach(function(t) {
          if (t.values.length > max) {
            maxTarget = t;
            max = t.values.length;
          }
        });
      } else {
        maxTarget = length ? targets[0] : null;
      }
      return maxTarget;
    };
    c3_chart_internal_fn.getEdgeX = function(targets) {
      var $$ = this;
      return !targets.length ? [0, 0] : [$$.d3.min(targets, function(t) {
        return t.values[0].x;
      }), $$.d3.max(targets, function(t) {
        return t.values[t.values.length - 1].x;
      })];
    };
    c3_chart_internal_fn.mapToIds = function(targets) {
      return targets.map(function(d) {
        return d.id;
      });
    };
    c3_chart_internal_fn.mapToTargetIds = function(ids) {
      var $$ = this;
      return ids ? (isString(ids) ? [ids] : ids) : $$.mapToIds($$.data.targets);
    };
    c3_chart_internal_fn.hasTarget = function(targets, id) {
      var ids = this.mapToIds(targets),
          i;
      for (i = 0; i < ids.length; i++) {
        if (ids[i] === id) {
          return true;
        }
      }
      return false;
    };
    c3_chart_internal_fn.isTargetToShow = function(targetId) {
      return this.hiddenTargetIds.indexOf(targetId) < 0;
    };
    c3_chart_internal_fn.isLegendToShow = function(targetId) {
      return this.hiddenLegendIds.indexOf(targetId) < 0;
    };
    c3_chart_internal_fn.filterTargetsToShow = function(targets) {
      var $$ = this;
      return targets.filter(function(t) {
        return $$.isTargetToShow(t.id);
      });
    };
    c3_chart_internal_fn.mapTargetsToUniqueXs = function(targets) {
      var $$ = this;
      var xs = $$.d3.set($$.d3.merge(targets.map(function(t) {
        return t.values.map(function(v) {
          return +v.x;
        });
      }))).values();
      return $$.isTimeSeries() ? xs.map(function(x) {
        return new Date(+x);
      }) : xs.map(function(x) {
        return +x;
      });
    };
    c3_chart_internal_fn.addHiddenTargetIds = function(targetIds) {
      this.hiddenTargetIds = this.hiddenTargetIds.concat(targetIds);
    };
    c3_chart_internal_fn.removeHiddenTargetIds = function(targetIds) {
      this.hiddenTargetIds = this.hiddenTargetIds.filter(function(id) {
        return targetIds.indexOf(id) < 0;
      });
    };
    c3_chart_internal_fn.addHiddenLegendIds = function(targetIds) {
      this.hiddenLegendIds = this.hiddenLegendIds.concat(targetIds);
    };
    c3_chart_internal_fn.removeHiddenLegendIds = function(targetIds) {
      this.hiddenLegendIds = this.hiddenLegendIds.filter(function(id) {
        return targetIds.indexOf(id) < 0;
      });
    };
    c3_chart_internal_fn.getValuesAsIdKeyed = function(targets) {
      var ys = {};
      targets.forEach(function(t) {
        ys[t.id] = [];
        t.values.forEach(function(v) {
          ys[t.id].push(v.value);
        });
      });
      return ys;
    };
    c3_chart_internal_fn.checkValueInTargets = function(targets, checker) {
      var ids = Object.keys(targets),
          i,
          j,
          values;
      for (i = 0; i < ids.length; i++) {
        values = targets[ids[i]].values;
        for (j = 0; j < values.length; j++) {
          if (checker(values[j].value)) {
            return true;
          }
        }
      }
      return false;
    };
    c3_chart_internal_fn.hasNegativeValueInTargets = function(targets) {
      return this.checkValueInTargets(targets, function(v) {
        return v < 0;
      });
    };
    c3_chart_internal_fn.hasPositiveValueInTargets = function(targets) {
      return this.checkValueInTargets(targets, function(v) {
        return v > 0;
      });
    };
    c3_chart_internal_fn.isOrderDesc = function() {
      var config = this.config;
      return typeof(config.data_order) === 'string' && config.data_order.toLowerCase() === 'desc';
    };
    c3_chart_internal_fn.isOrderAsc = function() {
      var config = this.config;
      return typeof(config.data_order) === 'string' && config.data_order.toLowerCase() === 'asc';
    };
    c3_chart_internal_fn.orderTargets = function(targets) {
      var $$ = this,
          config = $$.config,
          orderAsc = $$.isOrderAsc(),
          orderDesc = $$.isOrderDesc();
      if (orderAsc || orderDesc) {
        targets.sort(function(t1, t2) {
          var reducer = function(p, c) {
            return p + Math.abs(c.value);
          };
          var t1Sum = t1.values.reduce(reducer, 0),
              t2Sum = t2.values.reduce(reducer, 0);
          return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
        });
      } else if (isFunction(config.data_order)) {
        targets.sort(config.data_order);
      }
      return targets;
    };
    c3_chart_internal_fn.filterByX = function(targets, x) {
      return this.d3.merge(targets.map(function(t) {
        return t.values;
      })).filter(function(v) {
        return v.x - x === 0;
      });
    };
    c3_chart_internal_fn.filterRemoveNull = function(data) {
      return data.filter(function(d) {
        return isValue(d.value);
      });
    };
    c3_chart_internal_fn.filterByXDomain = function(targets, xDomain) {
      return targets.map(function(t) {
        return {
          id: t.id,
          id_org: t.id_org,
          values: t.values.filter(function(v) {
            return xDomain[0] <= v.x && v.x <= xDomain[1];
          })
        };
      });
    };
    c3_chart_internal_fn.hasDataLabel = function() {
      var config = this.config;
      if (typeof config.data_labels === 'boolean' && config.data_labels) {
        return true;
      } else if (typeof config.data_labels === 'object' && notEmpty(config.data_labels)) {
        return true;
      }
      return false;
    };
    c3_chart_internal_fn.getDataLabelLength = function(min, max, key) {
      var $$ = this,
          lengths = [0, 0],
          paddingCoef = 1.3;
      $$.selectChart.select('svg').selectAll('.dummy').data([min, max]).enter().append('text').text(function(d) {
        return $$.dataLabelFormat(d.id)(d);
      }).each(function(d, i) {
        lengths[i] = this.getBoundingClientRect()[key] * paddingCoef;
      }).remove();
      return lengths;
    };
    c3_chart_internal_fn.isNoneArc = function(d) {
      return this.hasTarget(this.data.targets, d.id);
    }, c3_chart_internal_fn.isArc = function(d) {
      return 'data' in d && this.hasTarget(this.data.targets, d.data.id);
    };
    c3_chart_internal_fn.findSameXOfValues = function(values, index) {
      var i,
          targetX = values[index].x,
          sames = [];
      for (i = index - 1; i >= 0; i--) {
        if (targetX !== values[i].x) {
          break;
        }
        sames.push(values[i]);
      }
      for (i = index; i < values.length; i++) {
        if (targetX !== values[i].x) {
          break;
        }
        sames.push(values[i]);
      }
      return sames;
    };
    c3_chart_internal_fn.findClosestFromTargets = function(targets, pos) {
      var $$ = this,
          candidates;
      candidates = targets.map(function(target) {
        return $$.findClosest(target.values, pos);
      });
      return $$.findClosest(candidates, pos);
    };
    c3_chart_internal_fn.findClosest = function(values, pos) {
      var $$ = this,
          minDist = 100,
          closest;
      values.filter(function(v) {
        return v && $$.isBarType(v.id);
      }).forEach(function(v) {
        var shape = $$.main.select('.' + CLASS.bars + $$.getTargetSelectorSuffix(v.id) + ' .' + CLASS.bar + '-' + v.index).node();
        if (!closest && $$.isWithinBar(shape)) {
          closest = v;
        }
      });
      values.filter(function(v) {
        return v && !$$.isBarType(v.id);
      }).forEach(function(v) {
        var d = $$.dist(v, pos);
        if (d < minDist) {
          minDist = d;
          closest = v;
        }
      });
      return closest;
    };
    c3_chart_internal_fn.dist = function(data, pos) {
      var $$ = this,
          config = $$.config,
          xIndex = config.axis_rotated ? 1 : 0,
          yIndex = config.axis_rotated ? 0 : 1,
          y = $$.circleY(data, data.index),
          x = $$.x(data.x);
      return Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2);
    };
    c3_chart_internal_fn.convertValuesToStep = function(values) {
      var converted = [].concat(values),
          i;
      if (!this.isCategorized()) {
        return values;
      }
      for (i = values.length + 1; 0 < i; i--) {
        converted[i] = converted[i - 1];
      }
      converted[0] = {
        x: converted[0].x - 1,
        value: converted[0].value,
        id: converted[0].id
      };
      converted[values.length + 1] = {
        x: converted[values.length].x + 1,
        value: converted[values.length].value,
        id: converted[values.length].id
      };
      return converted;
    };
    c3_chart_internal_fn.updateDataAttributes = function(name, attrs) {
      var $$ = this,
          config = $$.config,
          current = config['data_' + name];
      if (typeof attrs === 'undefined') {
        return current;
      }
      Object.keys(attrs).forEach(function(id) {
        current[id] = attrs[id];
      });
      $$.redraw({withLegend: true});
      return current;
    };
    c3_chart_internal_fn.convertUrlToData = function(url, mimeType, keys, done) {
      var $$ = this,
          type = mimeType ? mimeType : 'csv';
      $$.d3.xhr(url, function(error, data) {
        var d;
        if (!data) {
          throw new Error(error.responseURL + ' ' + error.status + ' (' + error.statusText + ')');
        }
        if (type === 'json') {
          d = $$.convertJsonToData(JSON.parse(data.response), keys);
        } else if (type === 'tsv') {
          d = $$.convertTsvToData(data.response);
        } else {
          d = $$.convertCsvToData(data.response);
        }
        done.call($$, d);
      });
    };
    c3_chart_internal_fn.convertXsvToData = function(xsv, parser) {
      var rows = parser.parseRows(xsv),
          d;
      if (rows.length === 1) {
        d = [{}];
        rows[0].forEach(function(id) {
          d[0][id] = null;
        });
      } else {
        d = parser.parse(xsv);
      }
      return d;
    };
    c3_chart_internal_fn.convertCsvToData = function(csv) {
      return this.convertXsvToData(csv, this.d3.csv);
    };
    c3_chart_internal_fn.convertTsvToData = function(tsv) {
      return this.convertXsvToData(tsv, this.d3.tsv);
    };
    c3_chart_internal_fn.convertJsonToData = function(json, keys) {
      var $$ = this,
          new_rows = [],
          targetKeys,
          data;
      if (keys) {
        if (keys.x) {
          targetKeys = keys.value.concat(keys.x);
          $$.config.data_x = keys.x;
        } else {
          targetKeys = keys.value;
        }
        new_rows.push(targetKeys);
        json.forEach(function(o) {
          var new_row = [];
          targetKeys.forEach(function(key) {
            var v = isUndefined(o[key]) ? null : o[key];
            new_row.push(v);
          });
          new_rows.push(new_row);
        });
        data = $$.convertRowsToData(new_rows);
      } else {
        Object.keys(json).forEach(function(key) {
          new_rows.push([key].concat(json[key]));
        });
        data = $$.convertColumnsToData(new_rows);
      }
      return data;
    };
    c3_chart_internal_fn.convertRowsToData = function(rows) {
      var keys = rows[0],
          new_row = {},
          new_rows = [],
          i,
          j;
      for (i = 1; i < rows.length; i++) {
        new_row = {};
        for (j = 0; j < rows[i].length; j++) {
          if (isUndefined(rows[i][j])) {
            throw new Error("Source data is missing a component at (" + i + "," + j + ")!");
          }
          new_row[keys[j]] = rows[i][j];
        }
        new_rows.push(new_row);
      }
      return new_rows;
    };
    c3_chart_internal_fn.convertColumnsToData = function(columns) {
      var new_rows = [],
          i,
          j,
          key;
      for (i = 0; i < columns.length; i++) {
        key = columns[i][0];
        for (j = 1; j < columns[i].length; j++) {
          if (isUndefined(new_rows[j - 1])) {
            new_rows[j - 1] = {};
          }
          if (isUndefined(columns[i][j])) {
            throw new Error("Source data is missing a component at (" + i + "," + j + ")!");
          }
          new_rows[j - 1][key] = columns[i][j];
        }
      }
      return new_rows;
    };
    c3_chart_internal_fn.convertDataToTargets = function(data, appendXs) {
      var $$ = this,
          config = $$.config,
          ids = $$.d3.keys(data[0]).filter($$.isNotX, $$),
          xs = $$.d3.keys(data[0]).filter($$.isX, $$),
          targets;
      ids.forEach(function(id) {
        var xKey = $$.getXKey(id);
        if ($$.isCustomX() || $$.isTimeSeries()) {
          if (xs.indexOf(xKey) >= 0) {
            $$.data.xs[id] = (appendXs && $$.data.xs[id] ? $$.data.xs[id] : []).concat(data.map(function(d) {
              return d[xKey];
            }).filter(isValue).map(function(rawX, i) {
              return $$.generateTargetX(rawX, id, i);
            }));
          } else if (config.data_x) {
            $$.data.xs[id] = $$.getOtherTargetXs();
          } else if (notEmpty(config.data_xs)) {
            $$.data.xs[id] = $$.getXValuesOfXKey(xKey, $$.data.targets);
          }
        } else {
          $$.data.xs[id] = data.map(function(d, i) {
            return i;
          });
        }
      });
      ids.forEach(function(id) {
        if (!$$.data.xs[id]) {
          throw new Error('x is not defined for id = "' + id + '".');
        }
      });
      targets = ids.map(function(id, index) {
        var convertedId = config.data_idConverter(id);
        return {
          id: convertedId,
          id_org: id,
          values: data.map(function(d, i) {
            var xKey = $$.getXKey(id),
                rawX = d[xKey],
                x = $$.generateTargetX(rawX, id, i);
            if ($$.isCustomX() && $$.isCategorized() && index === 0 && rawX) {
              if (i === 0) {
                config.axis_x_categories = [];
              }
              config.axis_x_categories.push(rawX);
            }
            if (isUndefined(d[id]) || $$.data.xs[id].length <= i) {
              x = undefined;
            }
            return {
              x: x,
              value: d[id] !== null && !isNaN(d[id]) ? +d[id] : null,
              id: convertedId
            };
          }).filter(function(v) {
            return isDefined(v.x);
          })
        };
      });
      targets.forEach(function(t) {
        var i;
        if (config.data_xSort) {
          t.values = t.values.sort(function(v1, v2) {
            var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,
                x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
            return x1 - x2;
          });
        }
        i = 0;
        t.values.forEach(function(v) {
          v.index = i++;
        });
        $$.data.xs[t.id].sort(function(v1, v2) {
          return v1 - v2;
        });
      });
      if (config.data_type) {
        $$.setTargetType($$.mapToIds(targets).filter(function(id) {
          return !(id in config.data_types);
        }), config.data_type);
      }
      targets.forEach(function(d) {
        $$.addCache(d.id_org, d);
      });
      return targets;
    };
    c3_chart_internal_fn.load = function(targets, args) {
      var $$ = this;
      if (targets) {
        if (args.filter) {
          targets = targets.filter(args.filter);
        }
        if (args.type || args.types) {
          targets.forEach(function(t) {
            var type = args.types && args.types[t.id] ? args.types[t.id] : args.type;
            $$.setTargetType(t.id, type);
          });
        }
        $$.data.targets.forEach(function(d) {
          for (var i = 0; i < targets.length; i++) {
            if (d.id === targets[i].id) {
              d.values = targets[i].values;
              targets.splice(i, 1);
              break;
            }
          }
        });
        $$.data.targets = $$.data.targets.concat(targets);
      }
      $$.updateTargets($$.data.targets);
      $$.redraw({
        withUpdateOrgXDomain: true,
        withUpdateXDomain: true,
        withLegend: true
      });
      if (args.done) {
        args.done();
      }
    };
    c3_chart_internal_fn.loadFromArgs = function(args) {
      var $$ = this;
      if (args.data) {
        $$.load($$.convertDataToTargets(args.data), args);
      } else if (args.url) {
        $$.convertUrlToData(args.url, args.mimeType, args.keys, function(data) {
          $$.load($$.convertDataToTargets(data), args);
        });
      } else if (args.json) {
        $$.load($$.convertDataToTargets($$.convertJsonToData(args.json, args.keys)), args);
      } else if (args.rows) {
        $$.load($$.convertDataToTargets($$.convertRowsToData(args.rows)), args);
      } else if (args.columns) {
        $$.load($$.convertDataToTargets($$.convertColumnsToData(args.columns)), args);
      } else {
        $$.load(null, args);
      }
    };
    c3_chart_internal_fn.unload = function(targetIds, done) {
      var $$ = this;
      if (!done) {
        done = function() {};
      }
      targetIds = targetIds.filter(function(id) {
        return $$.hasTarget($$.data.targets, id);
      });
      if (!targetIds || targetIds.length === 0) {
        done();
        return;
      }
      $$.svg.selectAll(targetIds.map(function(id) {
        return $$.selectorTarget(id);
      })).transition().style('opacity', 0).remove().call($$.endall, done);
      targetIds.forEach(function(id) {
        $$.withoutFadeIn[id] = false;
        if ($$.legend) {
          $$.legend.selectAll('.' + CLASS.legendItem + $$.getTargetSelectorSuffix(id)).remove();
        }
        $$.data.targets = $$.data.targets.filter(function(t) {
          return t.id !== id;
        });
      });
    };
    c3_chart_internal_fn.categoryName = function(i) {
      var config = this.config;
      return i < config.axis_x_categories.length ? config.axis_x_categories[i] : i;
    };
    c3_chart_internal_fn.initEventRect = function() {
      var $$ = this;
      $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.eventRects).style('fill-opacity', 0);
    };
    c3_chart_internal_fn.redrawEventRect = function() {
      var $$ = this,
          config = $$.config,
          eventRectUpdate,
          maxDataCountTarget,
          isMultipleX = $$.isMultipleX();
      var eventRects = $$.main.select('.' + CLASS.eventRects).style('cursor', config.zoom_enabled ? config.axis_rotated ? 'ns-resize' : 'ew-resize' : null).classed(CLASS.eventRectsMultiple, isMultipleX).classed(CLASS.eventRectsSingle, !isMultipleX);
      eventRects.selectAll('.' + CLASS.eventRect).remove();
      $$.eventRect = eventRects.selectAll('.' + CLASS.eventRect);
      if (isMultipleX) {
        eventRectUpdate = $$.eventRect.data([0]);
        $$.generateEventRectsForMultipleXs(eventRectUpdate.enter());
        $$.updateEventRect(eventRectUpdate);
      } else {
        maxDataCountTarget = $$.getMaxDataCountTarget($$.data.targets);
        eventRects.datum(maxDataCountTarget ? maxDataCountTarget.values : []);
        $$.eventRect = eventRects.selectAll('.' + CLASS.eventRect);
        eventRectUpdate = $$.eventRect.data(function(d) {
          return d;
        });
        $$.generateEventRectsForSingleX(eventRectUpdate.enter());
        $$.updateEventRect(eventRectUpdate);
        eventRectUpdate.exit().remove();
      }
    };
    c3_chart_internal_fn.updateEventRect = function(eventRectUpdate) {
      var $$ = this,
          config = $$.config,
          x,
          y,
          w,
          h,
          rectW,
          rectX;
      eventRectUpdate = eventRectUpdate || $$.eventRect.data(function(d) {
        return d;
      });
      if ($$.isMultipleX()) {
        x = 0;
        y = 0;
        w = $$.width;
        h = $$.height;
      } else {
        if (($$.isCustomX() || $$.isTimeSeries()) && !$$.isCategorized()) {
          $$.updateXs();
          rectW = function(d) {
            var prevX = $$.getPrevX(d.index),
                nextX = $$.getNextX(d.index);
            if (prevX === null && nextX === null) {
              return config.axis_rotated ? $$.height : $$.width;
            }
            if (prevX === null) {
              prevX = $$.x.domain()[0];
            }
            if (nextX === null) {
              nextX = $$.x.domain()[1];
            }
            return Math.max(0, ($$.x(nextX) - $$.x(prevX)) / 2);
          };
          rectX = function(d) {
            var prevX = $$.getPrevX(d.index),
                nextX = $$.getNextX(d.index),
                thisX = $$.data.xs[d.id][d.index];
            if (prevX === null && nextX === null) {
              return 0;
            }
            if (prevX === null) {
              prevX = $$.x.domain()[0];
            }
            return ($$.x(thisX) + $$.x(prevX)) / 2;
          };
        } else {
          rectW = $$.getEventRectWidth();
          rectX = function(d) {
            return $$.x(d.x) - (rectW / 2);
          };
        }
        x = config.axis_rotated ? 0 : rectX;
        y = config.axis_rotated ? rectX : 0;
        w = config.axis_rotated ? $$.width : rectW;
        h = config.axis_rotated ? rectW : $$.height;
      }
      eventRectUpdate.attr('class', $$.classEvent.bind($$)).attr("x", x).attr("y", y).attr("width", w).attr("height", h);
    };
    c3_chart_internal_fn.generateEventRectsForSingleX = function(eventRectEnter) {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config;
      eventRectEnter.append("rect").attr("class", $$.classEvent.bind($$)).style("cursor", config.data_selection_enabled && config.data_selection_grouped ? "pointer" : null).on('mouseover', function(d) {
        var index = d.index;
        if ($$.dragging || $$.flowing) {
          return;
        }
        if ($$.hasArcType()) {
          return;
        }
        if (config.point_focus_expand_enabled) {
          $$.expandCircles(index, null, true);
        }
        $$.expandBars(index, null, true);
        $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function(d) {
          config.data_onmouseover.call($$.api, d);
        });
      }).on('mouseout', function(d) {
        var index = d.index;
        if (!$$.config) {
          return;
        }
        if ($$.hasArcType()) {
          return;
        }
        $$.hideXGridFocus();
        $$.hideTooltip();
        $$.unexpandCircles();
        $$.unexpandBars();
        $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function(d) {
          config.data_onmouseout.call($$.api, d);
        });
      }).on('mousemove', function(d) {
        var selectedData,
            index = d.index,
            eventRect = $$.svg.select('.' + CLASS.eventRect + '-' + index);
        if ($$.dragging || $$.flowing) {
          return;
        }
        if ($$.hasArcType()) {
          return;
        }
        if ($$.isStepType(d) && $$.config.line_step_type === 'step-after' && d3.mouse(this)[0] < $$.x($$.getXValue(d.id, index))) {
          index -= 1;
        }
        selectedData = $$.filterTargetsToShow($$.data.targets).map(function(t) {
          return $$.addName($$.getValueOnIndex(t.values, index));
        });
        if (config.tooltip_grouped) {
          $$.showTooltip(selectedData, this);
          $$.showXGridFocus(selectedData);
        }
        if (config.tooltip_grouped && (!config.data_selection_enabled || config.data_selection_grouped)) {
          return;
        }
        $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function() {
          d3.select(this).classed(CLASS.EXPANDED, true);
          if (config.data_selection_enabled) {
            eventRect.style('cursor', config.data_selection_grouped ? 'pointer' : null);
          }
          if (!config.tooltip_grouped) {
            $$.hideXGridFocus();
            $$.hideTooltip();
            if (!config.data_selection_grouped) {
              $$.unexpandCircles(index);
              $$.unexpandBars(index);
            }
          }
        }).filter(function(d) {
          return $$.isWithinShape(this, d);
        }).each(function(d) {
          if (config.data_selection_enabled && (config.data_selection_grouped || config.data_selection_isselectable(d))) {
            eventRect.style('cursor', 'pointer');
          }
          if (!config.tooltip_grouped) {
            $$.showTooltip([d], this);
            $$.showXGridFocus([d]);
            if (config.point_focus_expand_enabled) {
              $$.expandCircles(index, d.id, true);
            }
            $$.expandBars(index, d.id, true);
          }
        });
      }).on('click', function(d) {
        var index = d.index;
        if ($$.hasArcType() || !$$.toggleShape) {
          return;
        }
        if ($$.cancelClick) {
          $$.cancelClick = false;
          return;
        }
        if ($$.isStepType(d) && config.line_step_type === 'step-after' && d3.mouse(this)[0] < $$.x($$.getXValue(d.id, index))) {
          index -= 1;
        }
        $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function(d) {
          if (config.data_selection_grouped || $$.isWithinShape(this, d)) {
            $$.toggleShape(this, d, index);
            $$.config.data_onclick.call($$.api, d, this);
          }
        });
      }).call(config.data_selection_draggable && $$.drag ? (d3.behavior.drag().origin(Object).on('drag', function() {
        $$.drag(d3.mouse(this));
      }).on('dragstart', function() {
        $$.dragstart(d3.mouse(this));
      }).on('dragend', function() {
        $$.dragend();
      })) : function() {});
    };
    c3_chart_internal_fn.generateEventRectsForMultipleXs = function(eventRectEnter) {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config;
      function mouseout() {
        $$.svg.select('.' + CLASS.eventRect).style('cursor', null);
        $$.hideXGridFocus();
        $$.hideTooltip();
        $$.unexpandCircles();
        $$.unexpandBars();
      }
      eventRectEnter.append('rect').attr('x', 0).attr('y', 0).attr('width', $$.width).attr('height', $$.height).attr('class', CLASS.eventRect).on('mouseout', function() {
        if (!$$.config) {
          return;
        }
        if ($$.hasArcType()) {
          return;
        }
        mouseout();
      }).on('mousemove', function() {
        var targetsToShow = $$.filterTargetsToShow($$.data.targets);
        var mouse,
            closest,
            sameXData,
            selectedData;
        if ($$.dragging) {
          return;
        }
        if ($$.hasArcType(targetsToShow)) {
          return;
        }
        mouse = d3.mouse(this);
        closest = $$.findClosestFromTargets(targetsToShow, mouse);
        if ($$.mouseover && (!closest || closest.id !== $$.mouseover.id)) {
          config.data_onmouseout.call($$.api, $$.mouseover);
          $$.mouseover = undefined;
        }
        if (!closest) {
          mouseout();
          return;
        }
        if ($$.isScatterType(closest) || !config.tooltip_grouped) {
          sameXData = [closest];
        } else {
          sameXData = $$.filterByX(targetsToShow, closest.x);
        }
        selectedData = sameXData.map(function(d) {
          return $$.addName(d);
        });
        $$.showTooltip(selectedData, this);
        if (config.point_focus_expand_enabled) {
          $$.expandCircles(closest.index, closest.id, true);
        }
        $$.expandBars(closest.index, closest.id, true);
        $$.showXGridFocus(selectedData);
        if ($$.isBarType(closest.id) || $$.dist(closest, mouse) < 100) {
          $$.svg.select('.' + CLASS.eventRect).style('cursor', 'pointer');
          if (!$$.mouseover) {
            config.data_onmouseover.call($$.api, closest);
            $$.mouseover = closest;
          }
        }
      }).on('click', function() {
        var targetsToShow = $$.filterTargetsToShow($$.data.targets);
        var mouse,
            closest;
        if ($$.hasArcType(targetsToShow)) {
          return;
        }
        mouse = d3.mouse(this);
        closest = $$.findClosestFromTargets(targetsToShow, mouse);
        if (!closest) {
          return;
        }
        if ($$.isBarType(closest.id) || $$.dist(closest, mouse) < 100) {
          $$.main.selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(closest.id)).selectAll('.' + CLASS.shape + '-' + closest.index).each(function() {
            if (config.data_selection_grouped || $$.isWithinShape(this, closest)) {
              $$.toggleShape(this, closest, closest.index);
              $$.config.data_onclick.call($$.api, closest, this);
            }
          });
        }
      }).call(config.data_selection_draggable && $$.drag ? (d3.behavior.drag().origin(Object).on('drag', function() {
        $$.drag(d3.mouse(this));
      }).on('dragstart', function() {
        $$.dragstart(d3.mouse(this));
      }).on('dragend', function() {
        $$.dragend();
      })) : function() {});
    };
    c3_chart_internal_fn.dispatchEvent = function(type, index, mouse) {
      var $$ = this,
          selector = '.' + CLASS.eventRect + (!$$.isMultipleX() ? '-' + index : ''),
          eventRect = $$.main.select(selector).node(),
          box = eventRect.getBoundingClientRect(),
          x = box.left + (mouse ? mouse[0] : 0),
          y = box.top + (mouse ? mouse[1] : 0),
          event = document.createEvent("MouseEvents");
      event.initMouseEvent(type, true, true, window, 0, x, y, x, y, false, false, false, false, 0, null);
      eventRect.dispatchEvent(event);
    };
    c3_chart_internal_fn.getCurrentWidth = function() {
      var $$ = this,
          config = $$.config;
      return config.size_width ? config.size_width : $$.getParentWidth();
    };
    c3_chart_internal_fn.getCurrentHeight = function() {
      var $$ = this,
          config = $$.config,
          h = config.size_height ? config.size_height : $$.getParentHeight();
      return h > 0 ? h : 320 / ($$.hasType('gauge') ? 2 : 1);
    };
    c3_chart_internal_fn.getCurrentPaddingTop = function() {
      var config = this.config;
      return isValue(config.padding_top) ? config.padding_top : 0;
    };
    c3_chart_internal_fn.getCurrentPaddingBottom = function() {
      var config = this.config;
      return isValue(config.padding_bottom) ? config.padding_bottom : 0;
    };
    c3_chart_internal_fn.getCurrentPaddingLeft = function(withoutRecompute) {
      var $$ = this,
          config = $$.config;
      if (isValue(config.padding_left)) {
        return config.padding_left;
      } else if (config.axis_rotated) {
        return !config.axis_x_show ? 1 : Math.max(ceil10($$.getAxisWidthByAxisId('x', withoutRecompute)), 40);
      } else if (!config.axis_y_show || config.axis_y_inner) {
        return $$.axis.getYAxisLabelPosition().isOuter ? 30 : 1;
      } else {
        return ceil10($$.getAxisWidthByAxisId('y', withoutRecompute));
      }
    };
    c3_chart_internal_fn.getCurrentPaddingRight = function() {
      var $$ = this,
          config = $$.config,
          defaultPadding = 10,
          legendWidthOnRight = $$.isLegendRight ? $$.getLegendWidth() + 20 : 0;
      if (isValue(config.padding_right)) {
        return config.padding_right + 1;
      } else if (config.axis_rotated) {
        return defaultPadding + legendWidthOnRight;
      } else if (!config.axis_y2_show || config.axis_y2_inner) {
        return 2 + legendWidthOnRight + ($$.axis.getY2AxisLabelPosition().isOuter ? 20 : 0);
      } else {
        return ceil10($$.getAxisWidthByAxisId('y2')) + legendWidthOnRight;
      }
    };
    c3_chart_internal_fn.getParentRectValue = function(key) {
      var parent = this.selectChart.node(),
          v;
      while (parent && parent.tagName !== 'BODY') {
        try {
          v = parent.getBoundingClientRect()[key];
        } catch (e) {
          if (key === 'width') {
            v = parent.offsetWidth;
          }
        }
        if (v) {
          break;
        }
        parent = parent.parentNode;
      }
      return v;
    };
    c3_chart_internal_fn.getParentWidth = function() {
      return this.getParentRectValue('width');
    };
    c3_chart_internal_fn.getParentHeight = function() {
      var h = this.selectChart.style('height');
      return h.indexOf('px') > 0 ? +h.replace('px', '') : 0;
    };
    c3_chart_internal_fn.getSvgLeft = function(withoutRecompute) {
      var $$ = this,
          config = $$.config,
          hasLeftAxisRect = config.axis_rotated || (!config.axis_rotated && !config.axis_y_inner),
          leftAxisClass = config.axis_rotated ? CLASS.axisX : CLASS.axisY,
          leftAxis = $$.main.select('.' + leftAxisClass).node(),
          svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : {right: 0},
          chartRect = $$.selectChart.node().getBoundingClientRect(),
          hasArc = $$.hasArcType(),
          svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
      return svgLeft > 0 ? svgLeft : 0;
    };
    c3_chart_internal_fn.getAxisWidthByAxisId = function(id, withoutRecompute) {
      var $$ = this,
          position = $$.axis.getLabelPositionById(id);
      return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);
    };
    c3_chart_internal_fn.getHorizontalAxisHeight = function(axisId) {
      var $$ = this,
          config = $$.config,
          h = 30;
      if (axisId === 'x' && !config.axis_x_show) {
        return 8;
      }
      if (axisId === 'x' && config.axis_x_height) {
        return config.axis_x_height;
      }
      if (axisId === 'y' && !config.axis_y_show) {
        return config.legend_show && !$$.isLegendRight && !$$.isLegendInset ? 10 : 1;
      }
      if (axisId === 'y2' && !config.axis_y2_show) {
        return $$.rotated_padding_top;
      }
      if (axisId === 'x' && !config.axis_rotated && config.axis_x_tick_rotate) {
        h = 30 + $$.axis.getMaxTickWidth(axisId) * Math.cos(Math.PI * (90 - config.axis_x_tick_rotate) / 180);
      }
      return h + ($$.axis.getLabelPositionById(axisId).isInner ? 0 : 10) + (axisId === 'y2' ? -10 : 0);
    };
    c3_chart_internal_fn.getEventRectWidth = function() {
      return Math.max(0, this.xAxis.tickInterval());
    };
    c3_chart_internal_fn.getShapeIndices = function(typeFilter) {
      var $$ = this,
          config = $$.config,
          indices = {},
          i = 0,
          j,
          k;
      $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function(d) {
        for (j = 0; j < config.data_groups.length; j++) {
          if (config.data_groups[j].indexOf(d.id) < 0) {
            continue;
          }
          for (k = 0; k < config.data_groups[j].length; k++) {
            if (config.data_groups[j][k] in indices) {
              indices[d.id] = indices[config.data_groups[j][k]];
              break;
            }
          }
        }
        if (isUndefined(indices[d.id])) {
          indices[d.id] = i++;
        }
      });
      indices.__max__ = i - 1;
      return indices;
    };
    c3_chart_internal_fn.getShapeX = function(offset, targetsNum, indices, isSub) {
      var $$ = this,
          scale = isSub ? $$.subX : $$.x;
      return function(d) {
        var index = d.id in indices ? indices[d.id] : 0;
        return d.x || d.x === 0 ? scale(d.x) - offset * (targetsNum / 2 - index) : 0;
      };
    };
    c3_chart_internal_fn.getShapeY = function(isSub) {
      var $$ = this;
      return function(d) {
        var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id);
        return scale(d.value);
      };
    };
    c3_chart_internal_fn.getShapeOffset = function(typeFilter, indices, isSub) {
      var $$ = this,
          targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),
          targetIds = targets.map(function(t) {
            return t.id;
          });
      return function(d, i) {
        var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id),
            y0 = scale(0),
            offset = y0;
        targets.forEach(function(t) {
          var values = $$.isStepType(d) ? $$.convertValuesToStep(t.values) : t.values;
          if (t.id === d.id || indices[t.id] !== indices[d.id]) {
            return;
          }
          if (targetIds.indexOf(t.id) < targetIds.indexOf(d.id)) {
            if (values[i].value * d.value >= 0) {
              offset += scale(values[i].value) - y0;
            }
          }
        });
        return offset;
      };
    };
    c3_chart_internal_fn.isWithinShape = function(that, d) {
      var $$ = this,
          shape = $$.d3.select(that),
          isWithin;
      if (!$$.isTargetToShow(d.id)) {
        isWithin = false;
      } else if (that.nodeName === 'circle') {
        isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value)) : $$.isWithinCircle(that, $$.pointSelectR(d) * 1.5);
      } else if (that.nodeName === 'path') {
        isWithin = shape.classed(CLASS.bar) ? $$.isWithinBar(that) : true;
      }
      return isWithin;
    };
    c3_chart_internal_fn.getInterpolate = function(d) {
      var $$ = this;
      return $$.isSplineType(d) ? "cardinal" : $$.isStepType(d) ? $$.config.line_step_type : "linear";
    };
    c3_chart_internal_fn.initLine = function() {
      var $$ = this;
      $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartLines);
    };
    c3_chart_internal_fn.updateTargetsForLine = function(targets) {
      var $$ = this,
          config = $$.config,
          mainLineUpdate,
          mainLineEnter,
          classChartLine = $$.classChartLine.bind($$),
          classLines = $$.classLines.bind($$),
          classAreas = $$.classAreas.bind($$),
          classCircles = $$.classCircles.bind($$),
          classFocus = $$.classFocus.bind($$);
      mainLineUpdate = $$.main.select('.' + CLASS.chartLines).selectAll('.' + CLASS.chartLine).data(targets).attr('class', function(d) {
        return classChartLine(d) + classFocus(d);
      });
      mainLineEnter = mainLineUpdate.enter().append('g').attr('class', classChartLine).style('opacity', 0).style("pointer-events", "none");
      mainLineEnter.append('g').attr("class", classLines);
      mainLineEnter.append('g').attr('class', classAreas);
      mainLineEnter.append('g').attr("class", function(d) {
        return $$.generateClass(CLASS.selectedCircles, d.id);
      });
      mainLineEnter.append('g').attr("class", classCircles).style("cursor", function(d) {
        return config.data_selection_isselectable(d) ? "pointer" : null;
      });
      targets.forEach(function(t) {
        $$.main.selectAll('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(t.id)).selectAll('.' + CLASS.selectedCircle).each(function(d) {
          d.value = t.values[d.index].value;
        });
      });
    };
    c3_chart_internal_fn.updateLine = function(durationForExit) {
      var $$ = this;
      $$.mainLine = $$.main.selectAll('.' + CLASS.lines).selectAll('.' + CLASS.line).data($$.lineData.bind($$));
      $$.mainLine.enter().append('path').attr('class', $$.classLine.bind($$)).style("stroke", $$.color);
      $$.mainLine.style("opacity", $$.initialOpacity.bind($$)).style('shape-rendering', function(d) {
        return $$.isStepType(d) ? 'crispEdges' : '';
      }).attr('transform', null);
      $$.mainLine.exit().transition().duration(durationForExit).style('opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawLine = function(drawLine, withTransition) {
      return [(withTransition ? this.mainLine.transition() : this.mainLine).attr("d", drawLine).style("stroke", this.color).style("opacity", 1)];
    };
    c3_chart_internal_fn.generateDrawLine = function(lineIndices, isSub) {
      var $$ = this,
          config = $$.config,
          line = $$.d3.svg.line(),
          getPoints = $$.generateGetLinePoints(lineIndices, isSub),
          yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
          xValue = function(d) {
            return (isSub ? $$.subxx : $$.xx).call($$, d);
          },
          yValue = function(d, i) {
            return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)(d.value);
          };
      line = config.axis_rotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue);
      if (!config.line_connectNull) {
        line = line.defined(function(d) {
          return d.value != null;
        });
      }
      return function(d) {
        var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,
            x = isSub ? $$.x : $$.subX,
            y = yScaleGetter.call($$, d.id),
            x0 = 0,
            y0 = 0,
            path;
        if ($$.isLineType(d)) {
          if (config.data_regions[d.id]) {
            path = $$.lineWithRegions(values, x, y, config.data_regions[d.id]);
          } else {
            if ($$.isStepType(d)) {
              values = $$.convertValuesToStep(values);
            }
            path = line.interpolate($$.getInterpolate(d))(values);
          }
        } else {
          if (values[0]) {
            x0 = x(values[0].x);
            y0 = y(values[0].value);
          }
          path = config.axis_rotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;
        }
        return path ? path : "M 0 0";
      };
    };
    c3_chart_internal_fn.generateGetLinePoints = function(lineIndices, isSub) {
      var $$ = this,
          config = $$.config,
          lineTargetsNum = lineIndices.__max__ + 1,
          x = $$.getShapeX(0, lineTargetsNum, lineIndices, !!isSub),
          y = $$.getShapeY(!!isSub),
          lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, !!isSub),
          yScale = isSub ? $$.getSubYScale : $$.getYScale;
      return function(d, i) {
        var y0 = yScale.call($$, d.id)(0),
            offset = lineOffset(d, i) || y0,
            posX = x(d),
            posY = y(d);
        if (config.axis_rotated) {
          if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {
            posY = y0;
          }
        }
        return [[posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)]];
      };
    };
    c3_chart_internal_fn.lineWithRegions = function(d, x, y, _regions) {
      var $$ = this,
          config = $$.config,
          prev = -1,
          i,
          j,
          s = "M",
          sWithRegion,
          xp,
          yp,
          dx,
          dy,
          dd,
          diff,
          diffx2,
          xOffset = $$.isCategorized() ? 0.5 : 0,
          xValue,
          yValue,
          regions = [];
      function isWithinRegions(x, regions) {
        var i;
        for (i = 0; i < regions.length; i++) {
          if (regions[i].start < x && x <= regions[i].end) {
            return true;
          }
        }
        return false;
      }
      if (isDefined(_regions)) {
        for (i = 0; i < _regions.length; i++) {
          regions[i] = {};
          if (isUndefined(_regions[i].start)) {
            regions[i].start = d[0].x;
          } else {
            regions[i].start = $$.isTimeSeries() ? $$.parseDate(_regions[i].start) : _regions[i].start;
          }
          if (isUndefined(_regions[i].end)) {
            regions[i].end = d[d.length - 1].x;
          } else {
            regions[i].end = $$.isTimeSeries() ? $$.parseDate(_regions[i].end) : _regions[i].end;
          }
        }
      }
      xValue = config.axis_rotated ? function(d) {
        return y(d.value);
      } : function(d) {
        return x(d.x);
      };
      yValue = config.axis_rotated ? function(d) {
        return x(d.x);
      } : function(d) {
        return y(d.value);
      };
      function generateM(points) {
        return 'M' + points[0][0] + ' ' + points[0][1] + ' ' + points[1][0] + ' ' + points[1][1];
      }
      if ($$.isTimeSeries()) {
        sWithRegion = function(d0, d1, j, diff) {
          var x0 = d0.x.getTime(),
              x_diff = d1.x - d0.x,
              xv0 = new Date(x0 + x_diff * j),
              xv1 = new Date(x0 + x_diff * (j + diff)),
              points;
          if (config.axis_rotated) {
            points = [[y(yp(j)), x(xv0)], [y(yp(j + diff)), x(xv1)]];
          } else {
            points = [[x(xv0), y(yp(j))], [x(xv1), y(yp(j + diff))]];
          }
          return generateM(points);
        };
      } else {
        sWithRegion = function(d0, d1, j, diff) {
          var points;
          if (config.axis_rotated) {
            points = [[y(yp(j), true), x(xp(j))], [y(yp(j + diff), true), x(xp(j + diff))]];
          } else {
            points = [[x(xp(j), true), y(yp(j))], [x(xp(j + diff), true), y(yp(j + diff))]];
          }
          return generateM(points);
        };
      }
      for (i = 0; i < d.length; i++) {
        if (isUndefined(regions) || !isWithinRegions(d[i].x, regions)) {
          s += " " + xValue(d[i]) + " " + yValue(d[i]);
        } else {
          xp = $$.getScale(d[i - 1].x + xOffset, d[i].x + xOffset, $$.isTimeSeries());
          yp = $$.getScale(d[i - 1].value, d[i].value);
          dx = x(d[i].x) - x(d[i - 1].x);
          dy = y(d[i].value) - y(d[i - 1].value);
          dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          diff = 2 / dd;
          diffx2 = diff * 2;
          for (j = diff; j <= 1; j += diffx2) {
            s += sWithRegion(d[i - 1], d[i], j, diff);
          }
        }
        prev = d[i].x;
      }
      return s;
    };
    c3_chart_internal_fn.updateArea = function(durationForExit) {
      var $$ = this,
          d3 = $$.d3;
      $$.mainArea = $$.main.selectAll('.' + CLASS.areas).selectAll('.' + CLASS.area).data($$.lineData.bind($$));
      $$.mainArea.enter().append('path').attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function() {
        $$.orgAreaOpacity = +d3.select(this).style('opacity');
        return 0;
      });
      $$.mainArea.style("opacity", $$.orgAreaOpacity);
      $$.mainArea.exit().transition().duration(durationForExit).style('opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawArea = function(drawArea, withTransition) {
      return [(withTransition ? this.mainArea.transition() : this.mainArea).attr("d", drawArea).style("fill", this.color).style("opacity", this.orgAreaOpacity)];
    };
    c3_chart_internal_fn.generateDrawArea = function(areaIndices, isSub) {
      var $$ = this,
          config = $$.config,
          area = $$.d3.svg.area(),
          getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
          yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
          xValue = function(d) {
            return (isSub ? $$.subxx : $$.xx).call($$, d);
          },
          value0 = function(d, i) {
            return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.getAreaBaseValue(d.id));
          },
          value1 = function(d, i) {
            return config.data_groups.length > 0 ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)(d.value);
          };
      area = config.axis_rotated ? area.x0(value0).x1(value1).y(xValue) : area.x(xValue).y0(value0).y1(value1);
      if (!config.line_connectNull) {
        area = area.defined(function(d) {
          return d.value !== null;
        });
      }
      return function(d) {
        var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,
            x0 = 0,
            y0 = 0,
            path;
        if ($$.isAreaType(d)) {
          if ($$.isStepType(d)) {
            values = $$.convertValuesToStep(values);
          }
          path = area.interpolate($$.getInterpolate(d))(values);
        } else {
          if (values[0]) {
            x0 = $$.x(values[0].x);
            y0 = $$.getYScale(d.id)(values[0].value);
          }
          path = config.axis_rotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;
        }
        return path ? path : "M 0 0";
      };
    };
    c3_chart_internal_fn.getAreaBaseValue = function() {
      return 0;
    };
    c3_chart_internal_fn.generateGetAreaPoints = function(areaIndices, isSub) {
      var $$ = this,
          config = $$.config,
          areaTargetsNum = areaIndices.__max__ + 1,
          x = $$.getShapeX(0, areaTargetsNum, areaIndices, !!isSub),
          y = $$.getShapeY(!!isSub),
          areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
          yScale = isSub ? $$.getSubYScale : $$.getYScale;
      return function(d, i) {
        var y0 = yScale.call($$, d.id)(0),
            offset = areaOffset(d, i) || y0,
            posX = x(d),
            posY = y(d);
        if (config.axis_rotated) {
          if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {
            posY = y0;
          }
        }
        return [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], [posX, offset]];
      };
    };
    c3_chart_internal_fn.updateCircle = function() {
      var $$ = this;
      $$.mainCircle = $$.main.selectAll('.' + CLASS.circles).selectAll('.' + CLASS.circle).data($$.lineOrScatterData.bind($$));
      $$.mainCircle.enter().append("circle").attr("class", $$.classCircle.bind($$)).attr("r", $$.pointR.bind($$)).style("fill", $$.color);
      $$.mainCircle.style("opacity", $$.initialOpacityForCircle.bind($$));
      $$.mainCircle.exit().remove();
    };
    c3_chart_internal_fn.redrawCircle = function(cx, cy, withTransition) {
      var selectedCircles = this.main.selectAll('.' + CLASS.selectedCircle);
      return [(withTransition ? this.mainCircle.transition() : this.mainCircle).style('opacity', this.opacityForCircle.bind(this)).style("fill", this.color).attr("cx", cx).attr("cy", cy), (withTransition ? selectedCircles.transition() : selectedCircles).attr("cx", cx).attr("cy", cy)];
    };
    c3_chart_internal_fn.circleX = function(d) {
      return d.x || d.x === 0 ? this.x(d.x) : null;
    };
    c3_chart_internal_fn.updateCircleY = function() {
      var $$ = this,
          lineIndices,
          getPoints;
      if ($$.config.data_groups.length > 0) {
        lineIndices = $$.getShapeIndices($$.isLineType), getPoints = $$.generateGetLinePoints(lineIndices);
        $$.circleY = function(d, i) {
          return getPoints(d, i)[0][1];
        };
      } else {
        $$.circleY = function(d) {
          return $$.getYScale(d.id)(d.value);
        };
      }
    };
    c3_chart_internal_fn.getCircles = function(i, id) {
      var $$ = this;
      return (id ? $$.main.selectAll('.' + CLASS.circles + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll('.' + CLASS.circle + (isValue(i) ? '-' + i : ''));
    };
    c3_chart_internal_fn.expandCircles = function(i, id, reset) {
      var $$ = this,
          r = $$.pointExpandedR.bind($$);
      if (reset) {
        $$.unexpandCircles();
      }
      $$.getCircles(i, id).classed(CLASS.EXPANDED, true).attr('r', r);
    };
    c3_chart_internal_fn.unexpandCircles = function(i) {
      var $$ = this,
          r = $$.pointR.bind($$);
      $$.getCircles(i).filter(function() {
        return $$.d3.select(this).classed(CLASS.EXPANDED);
      }).classed(CLASS.EXPANDED, false).attr('r', r);
    };
    c3_chart_internal_fn.pointR = function(d) {
      var $$ = this,
          config = $$.config;
      return $$.isStepType(d) ? 0 : (isFunction(config.point_r) ? config.point_r(d) : config.point_r);
    };
    c3_chart_internal_fn.pointExpandedR = function(d) {
      var $$ = this,
          config = $$.config;
      return config.point_focus_expand_enabled ? (config.point_focus_expand_r ? config.point_focus_expand_r : $$.pointR(d) * 1.75) : $$.pointR(d);
    };
    c3_chart_internal_fn.pointSelectR = function(d) {
      var $$ = this,
          config = $$.config;
      return config.point_select_r ? config.point_select_r : $$.pointR(d) * 4;
    };
    c3_chart_internal_fn.isWithinCircle = function(that, r) {
      var d3 = this.d3,
          mouse = d3.mouse(that),
          d3_this = d3.select(that),
          cx = +d3_this.attr("cx"),
          cy = +d3_this.attr("cy");
      return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < r;
    };
    c3_chart_internal_fn.isWithinStep = function(that, y) {
      return Math.abs(y - this.d3.mouse(that)[1]) < 30;
    };
    c3_chart_internal_fn.initBar = function() {
      var $$ = this;
      $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartBars);
    };
    c3_chart_internal_fn.updateTargetsForBar = function(targets) {
      var $$ = this,
          config = $$.config,
          mainBarUpdate,
          mainBarEnter,
          classChartBar = $$.classChartBar.bind($$),
          classBars = $$.classBars.bind($$),
          classFocus = $$.classFocus.bind($$);
      mainBarUpdate = $$.main.select('.' + CLASS.chartBars).selectAll('.' + CLASS.chartBar).data(targets).attr('class', function(d) {
        return classChartBar(d) + classFocus(d);
      });
      mainBarEnter = mainBarUpdate.enter().append('g').attr('class', classChartBar).style('opacity', 0).style("pointer-events", "none");
      mainBarEnter.append('g').attr("class", classBars).style("cursor", function(d) {
        return config.data_selection_isselectable(d) ? "pointer" : null;
      });
    };
    c3_chart_internal_fn.updateBar = function(durationForExit) {
      var $$ = this,
          barData = $$.barData.bind($$),
          classBar = $$.classBar.bind($$),
          initialOpacity = $$.initialOpacity.bind($$),
          color = function(d) {
            return $$.color(d.id);
          };
      $$.mainBar = $$.main.selectAll('.' + CLASS.bars).selectAll('.' + CLASS.bar).data(barData);
      $$.mainBar.enter().append('path').attr("class", classBar).style("stroke", color).style("fill", color);
      $$.mainBar.style("opacity", initialOpacity);
      $$.mainBar.exit().transition().duration(durationForExit).style('opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawBar = function(drawBar, withTransition) {
      return [(withTransition ? this.mainBar.transition() : this.mainBar).attr('d', drawBar).style("fill", this.color).style("opacity", 1)];
    };
    c3_chart_internal_fn.getBarW = function(axis, barTargetsNum) {
      var $$ = this,
          config = $$.config,
          w = typeof config.bar_width === 'number' ? config.bar_width : barTargetsNum ? (axis.tickInterval() * config.bar_width_ratio) / barTargetsNum : 0;
      return config.bar_width_max && w > config.bar_width_max ? config.bar_width_max : w;
    };
    c3_chart_internal_fn.getBars = function(i, id) {
      var $$ = this;
      return (id ? $$.main.selectAll('.' + CLASS.bars + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll('.' + CLASS.bar + (isValue(i) ? '-' + i : ''));
    };
    c3_chart_internal_fn.expandBars = function(i, id, reset) {
      var $$ = this;
      if (reset) {
        $$.unexpandBars();
      }
      $$.getBars(i, id).classed(CLASS.EXPANDED, true);
    };
    c3_chart_internal_fn.unexpandBars = function(i) {
      var $$ = this;
      $$.getBars(i).classed(CLASS.EXPANDED, false);
    };
    c3_chart_internal_fn.generateDrawBar = function(barIndices, isSub) {
      var $$ = this,
          config = $$.config,
          getPoints = $$.generateGetBarPoints(barIndices, isSub);
      return function(d, i) {
        var points = getPoints(d, i);
        var indexX = config.axis_rotated ? 1 : 0;
        var indexY = config.axis_rotated ? 0 : 1;
        var path = 'M ' + points[0][indexX] + ',' + points[0][indexY] + ' ' + 'L' + points[1][indexX] + ',' + points[1][indexY] + ' ' + 'L' + points[2][indexX] + ',' + points[2][indexY] + ' ' + 'L' + points[3][indexX] + ',' + points[3][indexY] + ' ' + 'z';
        return path;
      };
    };
    c3_chart_internal_fn.generateGetBarPoints = function(barIndices, isSub) {
      var $$ = this,
          axis = isSub ? $$.subXAxis : $$.xAxis,
          barTargetsNum = barIndices.__max__ + 1,
          barW = $$.getBarW(axis, barTargetsNum),
          barX = $$.getShapeX(barW, barTargetsNum, barIndices, !!isSub),
          barY = $$.getShapeY(!!isSub),
          barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),
          yScale = isSub ? $$.getSubYScale : $$.getYScale;
      return function(d, i) {
        var y0 = yScale.call($$, d.id)(0),
            offset = barOffset(d, i) || y0,
            posX = barX(d),
            posY = barY(d);
        if ($$.config.axis_rotated) {
          if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {
            posY = y0;
          }
        }
        return [[posX, offset], [posX, posY - (y0 - offset)], [posX + barW, posY - (y0 - offset)], [posX + barW, offset]];
      };
    };
    c3_chart_internal_fn.isWithinBar = function(that) {
      var mouse = this.d3.mouse(that),
          box = that.getBoundingClientRect(),
          seg0 = that.pathSegList.getItem(0),
          seg1 = that.pathSegList.getItem(1),
          x = Math.min(seg0.x, seg1.x),
          y = Math.min(seg0.y, seg1.y),
          w = box.width,
          h = box.height,
          offset = 2,
          sx = x - offset,
          ex = x + w + offset,
          sy = y + h + offset,
          ey = y - offset;
      return sx < mouse[0] && mouse[0] < ex && ey < mouse[1] && mouse[1] < sy;
    };
    c3_chart_internal_fn.initText = function() {
      var $$ = this;
      $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartTexts);
      $$.mainText = $$.d3.selectAll([]);
    };
    c3_chart_internal_fn.updateTargetsForText = function(targets) {
      var $$ = this,
          mainTextUpdate,
          mainTextEnter,
          classChartText = $$.classChartText.bind($$),
          classTexts = $$.classTexts.bind($$),
          classFocus = $$.classFocus.bind($$);
      mainTextUpdate = $$.main.select('.' + CLASS.chartTexts).selectAll('.' + CLASS.chartText).data(targets).attr('class', function(d) {
        return classChartText(d) + classFocus(d);
      });
      mainTextEnter = mainTextUpdate.enter().append('g').attr('class', classChartText).style('opacity', 0).style("pointer-events", "none");
      mainTextEnter.append('g').attr('class', classTexts);
    };
    c3_chart_internal_fn.updateText = function(durationForExit) {
      var $$ = this,
          config = $$.config,
          barOrLineData = $$.barOrLineData.bind($$),
          classText = $$.classText.bind($$);
      $$.mainText = $$.main.selectAll('.' + CLASS.texts).selectAll('.' + CLASS.text).data(barOrLineData);
      $$.mainText.enter().append('text').attr("class", classText).attr('text-anchor', function(d) {
        return config.axis_rotated ? (d.value < 0 ? 'end' : 'start') : 'middle';
      }).style("stroke", 'none').style("fill", function(d) {
        return $$.color(d);
      }).style("fill-opacity", 0);
      $$.mainText.text(function(d, i, j) {
        return $$.dataLabelFormat(d.id)(d.value, d.id, i, j);
      });
      $$.mainText.exit().transition().duration(durationForExit).style('fill-opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawText = function(xForText, yForText, forFlow, withTransition) {
      return [(withTransition ? this.mainText.transition() : this.mainText).attr('x', xForText).attr('y', yForText).style("fill", this.color).style("fill-opacity", forFlow ? 0 : this.opacityForText.bind(this))];
    };
    c3_chart_internal_fn.getTextRect = function(text, cls) {
      var dummy = this.d3.select('body').append('div').classed('c3', true),
          svg = dummy.append("svg").style('visibility', 'hidden').style('position', 'fixed').style('top', 0).style('left', 0),
          rect;
      svg.selectAll('.dummy').data([text]).enter().append('text').classed(cls ? cls : "", true).text(text).each(function() {
        rect = this.getBoundingClientRect();
      });
      dummy.remove();
      return rect;
    };
    c3_chart_internal_fn.generateXYForText = function(areaIndices, barIndices, lineIndices, forX) {
      var $$ = this,
          getAreaPoints = $$.generateGetAreaPoints(areaIndices, false),
          getBarPoints = $$.generateGetBarPoints(barIndices, false),
          getLinePoints = $$.generateGetLinePoints(lineIndices, false),
          getter = forX ? $$.getXForText : $$.getYForText;
      return function(d, i) {
        var getPoints = $$.isAreaType(d) ? getAreaPoints : $$.isBarType(d) ? getBarPoints : getLinePoints;
        return getter.call($$, getPoints(d, i), d, this);
      };
    };
    c3_chart_internal_fn.getXForText = function(points, d, textElement) {
      var $$ = this,
          box = textElement.getBoundingClientRect(),
          xPos,
          padding;
      if ($$.config.axis_rotated) {
        padding = $$.isBarType(d) ? 4 : 6;
        xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1);
      } else {
        xPos = $$.hasType('bar') ? (points[2][0] + points[0][0]) / 2 : points[0][0];
      }
      if (d.value === null) {
        if (xPos > $$.width) {
          xPos = $$.width - box.width;
        } else if (xPos < 0) {
          xPos = 4;
        }
      }
      return xPos;
    };
    c3_chart_internal_fn.getYForText = function(points, d, textElement) {
      var $$ = this,
          box = textElement.getBoundingClientRect(),
          yPos;
      if ($$.config.axis_rotated) {
        yPos = (points[0][0] + points[2][0] + box.height * 0.6) / 2;
      } else {
        yPos = points[2][1];
        if (d.value < 0) {
          yPos += box.height;
          if ($$.isBarType(d) && $$.isSafari()) {
            yPos -= 3;
          } else if (!$$.isBarType(d) && $$.isChrome()) {
            yPos += 3;
          }
        } else {
          yPos += $$.isBarType(d) ? -3 : -6;
        }
      }
      if (d.value === null && !$$.config.axis_rotated) {
        if (yPos < box.height) {
          yPos = box.height;
        } else if (yPos > this.height) {
          yPos = this.height - 4;
        }
      }
      return yPos;
    };
    c3_chart_internal_fn.setTargetType = function(targetIds, type) {
      var $$ = this,
          config = $$.config;
      $$.mapToTargetIds(targetIds).forEach(function(id) {
        $$.withoutFadeIn[id] = (type === config.data_types[id]);
        config.data_types[id] = type;
      });
      if (!targetIds) {
        config.data_type = type;
      }
    };
    c3_chart_internal_fn.hasType = function(type, targets) {
      var $$ = this,
          types = $$.config.data_types,
          has = false;
      targets = targets || $$.data.targets;
      if (targets && targets.length) {
        targets.forEach(function(target) {
          var t = types[target.id];
          if ((t && t.indexOf(type) >= 0) || (!t && type === 'line')) {
            has = true;
          }
        });
      } else if (Object.keys(types).length) {
        Object.keys(types).forEach(function(id) {
          if (types[id] === type) {
            has = true;
          }
        });
      } else {
        has = $$.config.data_type === type;
      }
      return has;
    };
    c3_chart_internal_fn.hasArcType = function(targets) {
      return this.hasType('pie', targets) || this.hasType('donut', targets) || this.hasType('gauge', targets);
    };
    c3_chart_internal_fn.isLineType = function(d) {
      var config = this.config,
          id = isString(d) ? d : d.id;
      return !config.data_types[id] || ['line', 'spline', 'area', 'area-spline', 'step', 'area-step'].indexOf(config.data_types[id]) >= 0;
    };
    c3_chart_internal_fn.isStepType = function(d) {
      var id = isString(d) ? d : d.id;
      return ['step', 'area-step'].indexOf(this.config.data_types[id]) >= 0;
    };
    c3_chart_internal_fn.isSplineType = function(d) {
      var id = isString(d) ? d : d.id;
      return ['spline', 'area-spline'].indexOf(this.config.data_types[id]) >= 0;
    };
    c3_chart_internal_fn.isAreaType = function(d) {
      var id = isString(d) ? d : d.id;
      return ['area', 'area-spline', 'area-step'].indexOf(this.config.data_types[id]) >= 0;
    };
    c3_chart_internal_fn.isBarType = function(d) {
      var id = isString(d) ? d : d.id;
      return this.config.data_types[id] === 'bar';
    };
    c3_chart_internal_fn.isScatterType = function(d) {
      var id = isString(d) ? d : d.id;
      return this.config.data_types[id] === 'scatter';
    };
    c3_chart_internal_fn.isPieType = function(d) {
      var id = isString(d) ? d : d.id;
      return this.config.data_types[id] === 'pie';
    };
    c3_chart_internal_fn.isGaugeType = function(d) {
      var id = isString(d) ? d : d.id;
      return this.config.data_types[id] === 'gauge';
    };
    c3_chart_internal_fn.isDonutType = function(d) {
      var id = isString(d) ? d : d.id;
      return this.config.data_types[id] === 'donut';
    };
    c3_chart_internal_fn.isArcType = function(d) {
      return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d);
    };
    c3_chart_internal_fn.lineData = function(d) {
      return this.isLineType(d) ? [d] : [];
    };
    c3_chart_internal_fn.arcData = function(d) {
      return this.isArcType(d.data) ? [d] : [];
    };
    c3_chart_internal_fn.barData = function(d) {
      return this.isBarType(d) ? d.values : [];
    };
    c3_chart_internal_fn.lineOrScatterData = function(d) {
      return this.isLineType(d) || this.isScatterType(d) ? d.values : [];
    };
    c3_chart_internal_fn.barOrLineData = function(d) {
      return this.isBarType(d) || this.isLineType(d) ? d.values : [];
    };
    c3_chart_internal_fn.initGrid = function() {
      var $$ = this,
          config = $$.config,
          d3 = $$.d3;
      $$.grid = $$.main.append('g').attr("clip-path", $$.clipPathForGrid).attr('class', CLASS.grid);
      if (config.grid_x_show) {
        $$.grid.append("g").attr("class", CLASS.xgrids);
      }
      if (config.grid_y_show) {
        $$.grid.append('g').attr('class', CLASS.ygrids);
      }
      if (config.grid_focus_show) {
        $$.grid.append('g').attr("class", CLASS.xgridFocus).append('line').attr('class', CLASS.xgridFocus);
      }
      $$.xgrid = d3.selectAll([]);
      if (!config.grid_lines_front) {
        $$.initGridLines();
      }
    };
    c3_chart_internal_fn.initGridLines = function() {
      var $$ = this,
          d3 = $$.d3;
      $$.gridLines = $$.main.append('g').attr("clip-path", $$.clipPathForGrid).attr('class', CLASS.grid + ' ' + CLASS.gridLines);
      $$.gridLines.append('g').attr("class", CLASS.xgridLines);
      $$.gridLines.append('g').attr('class', CLASS.ygridLines);
      $$.xgridLines = d3.selectAll([]);
    };
    c3_chart_internal_fn.updateXGrid = function(withoutUpdate) {
      var $$ = this,
          config = $$.config,
          d3 = $$.d3,
          xgridData = $$.generateGridData(config.grid_x_type, $$.x),
          tickOffset = $$.isCategorized() ? $$.xAxis.tickOffset() : 0;
      $$.xgridAttr = config.axis_rotated ? {
        'x1': 0,
        'x2': $$.width,
        'y1': function(d) {
          return $$.x(d) - tickOffset;
        },
        'y2': function(d) {
          return $$.x(d) - tickOffset;
        }
      } : {
        'x1': function(d) {
          return $$.x(d) + tickOffset;
        },
        'x2': function(d) {
          return $$.x(d) + tickOffset;
        },
        'y1': 0,
        'y2': $$.height
      };
      $$.xgrid = $$.main.select('.' + CLASS.xgrids).selectAll('.' + CLASS.xgrid).data(xgridData);
      $$.xgrid.enter().append('line').attr("class", CLASS.xgrid);
      if (!withoutUpdate) {
        $$.xgrid.attr($$.xgridAttr).style("opacity", function() {
          return +d3.select(this).attr(config.axis_rotated ? 'y1' : 'x1') === (config.axis_rotated ? $$.height : 0) ? 0 : 1;
        });
      }
      $$.xgrid.exit().remove();
    };
    c3_chart_internal_fn.updateYGrid = function() {
      var $$ = this,
          config = $$.config,
          gridValues = $$.yAxis.tickValues() || $$.y.ticks(config.grid_y_ticks);
      $$.ygrid = $$.main.select('.' + CLASS.ygrids).selectAll('.' + CLASS.ygrid).data(gridValues);
      $$.ygrid.enter().append('line').attr('class', CLASS.ygrid);
      $$.ygrid.attr("x1", config.axis_rotated ? $$.y : 0).attr("x2", config.axis_rotated ? $$.y : $$.width).attr("y1", config.axis_rotated ? 0 : $$.y).attr("y2", config.axis_rotated ? $$.height : $$.y);
      $$.ygrid.exit().remove();
      $$.smoothLines($$.ygrid, 'grid');
    };
    c3_chart_internal_fn.gridTextAnchor = function(d) {
      return d.position ? d.position : "end";
    };
    c3_chart_internal_fn.gridTextDx = function(d) {
      return d.position === 'start' ? 4 : d.position === 'middle' ? 0 : -4;
    };
    c3_chart_internal_fn.xGridTextX = function(d) {
      return d.position === 'start' ? -this.height : d.position === 'middle' ? -this.height / 2 : 0;
    };
    c3_chart_internal_fn.yGridTextX = function(d) {
      return d.position === 'start' ? 0 : d.position === 'middle' ? this.width / 2 : this.width;
    };
    c3_chart_internal_fn.updateGrid = function(duration) {
      var $$ = this,
          main = $$.main,
          config = $$.config,
          xgridLine,
          ygridLine,
          yv;
      $$.grid.style('visibility', $$.hasArcType() ? 'hidden' : 'visible');
      main.select('line.' + CLASS.xgridFocus).style("visibility", "hidden");
      if (config.grid_x_show) {
        $$.updateXGrid();
      }
      $$.xgridLines = main.select('.' + CLASS.xgridLines).selectAll('.' + CLASS.xgridLine).data(config.grid_x_lines);
      xgridLine = $$.xgridLines.enter().append('g').attr("class", function(d) {
        return CLASS.xgridLine + (d['class'] ? ' ' + d['class'] : '');
      });
      xgridLine.append('line').style("opacity", 0);
      xgridLine.append('text').attr("text-anchor", $$.gridTextAnchor).attr("transform", config.axis_rotated ? "" : "rotate(-90)").attr('dx', $$.gridTextDx).attr('dy', -5).style("opacity", 0);
      $$.xgridLines.exit().transition().duration(duration).style("opacity", 0).remove();
      if (config.grid_y_show) {
        $$.updateYGrid();
      }
      $$.ygridLines = main.select('.' + CLASS.ygridLines).selectAll('.' + CLASS.ygridLine).data(config.grid_y_lines);
      ygridLine = $$.ygridLines.enter().append('g').attr("class", function(d) {
        return CLASS.ygridLine + (d['class'] ? ' ' + d['class'] : '');
      });
      ygridLine.append('line').style("opacity", 0);
      ygridLine.append('text').attr("text-anchor", $$.gridTextAnchor).attr("transform", config.axis_rotated ? "rotate(-90)" : "").attr('dx', $$.gridTextDx).attr('dy', -5).style("opacity", 0);
      yv = $$.yv.bind($$);
      $$.ygridLines.select('line').transition().duration(duration).attr("x1", config.axis_rotated ? yv : 0).attr("x2", config.axis_rotated ? yv : $$.width).attr("y1", config.axis_rotated ? 0 : yv).attr("y2", config.axis_rotated ? $$.height : yv).style("opacity", 1);
      $$.ygridLines.select('text').transition().duration(duration).attr("x", config.axis_rotated ? $$.xGridTextX.bind($$) : $$.yGridTextX.bind($$)).attr("y", yv).text(function(d) {
        return d.text;
      }).style("opacity", 1);
      $$.ygridLines.exit().transition().duration(duration).style("opacity", 0).remove();
    };
    c3_chart_internal_fn.redrawGrid = function(withTransition) {
      var $$ = this,
          config = $$.config,
          xv = $$.xv.bind($$),
          lines = $$.xgridLines.select('line'),
          texts = $$.xgridLines.select('text');
      return [(withTransition ? lines.transition() : lines).attr("x1", config.axis_rotated ? 0 : xv).attr("x2", config.axis_rotated ? $$.width : xv).attr("y1", config.axis_rotated ? xv : 0).attr("y2", config.axis_rotated ? xv : $$.height).style("opacity", 1), (withTransition ? texts.transition() : texts).attr("x", config.axis_rotated ? $$.yGridTextX.bind($$) : $$.xGridTextX.bind($$)).attr("y", xv).text(function(d) {
        return d.text;
      }).style("opacity", 1)];
    };
    c3_chart_internal_fn.showXGridFocus = function(selectedData) {
      var $$ = this,
          config = $$.config,
          dataToShow = selectedData.filter(function(d) {
            return d && isValue(d.value);
          }),
          focusEl = $$.main.selectAll('line.' + CLASS.xgridFocus),
          xx = $$.xx.bind($$);
      if (!config.tooltip_show) {
        return;
      }
      if ($$.hasType('scatter') || $$.hasArcType()) {
        return;
      }
      focusEl.style("visibility", "visible").data([dataToShow[0]]).attr(config.axis_rotated ? 'y1' : 'x1', xx).attr(config.axis_rotated ? 'y2' : 'x2', xx);
      $$.smoothLines(focusEl, 'grid');
    };
    c3_chart_internal_fn.hideXGridFocus = function() {
      this.main.select('line.' + CLASS.xgridFocus).style("visibility", "hidden");
    };
    c3_chart_internal_fn.updateXgridFocus = function() {
      var $$ = this,
          config = $$.config;
      $$.main.select('line.' + CLASS.xgridFocus).attr("x1", config.axis_rotated ? 0 : -10).attr("x2", config.axis_rotated ? $$.width : -10).attr("y1", config.axis_rotated ? -10 : 0).attr("y2", config.axis_rotated ? -10 : $$.height);
    };
    c3_chart_internal_fn.generateGridData = function(type, scale) {
      var $$ = this,
          gridData = [],
          xDomain,
          firstYear,
          lastYear,
          i,
          tickNum = $$.main.select("." + CLASS.axisX).selectAll('.tick').size();
      if (type === 'year') {
        xDomain = $$.getXDomain();
        firstYear = xDomain[0].getFullYear();
        lastYear = xDomain[1].getFullYear();
        for (i = firstYear; i <= lastYear; i++) {
          gridData.push(new Date(i + '-01-01 00:00:00'));
        }
      } else {
        gridData = scale.ticks(10);
        if (gridData.length > tickNum) {
          gridData = gridData.filter(function(d) {
            return ("" + d).indexOf('.') < 0;
          });
        }
      }
      return gridData;
    };
    c3_chart_internal_fn.getGridFilterToRemove = function(params) {
      return params ? function(line) {
        var found = false;
        [].concat(params).forEach(function(param) {
          if ((('value' in param && line.value === param.value) || ('class' in param && line['class'] === param['class']))) {
            found = true;
          }
        });
        return found;
      } : function() {
        return true;
      };
    };
    c3_chart_internal_fn.removeGridLines = function(params, forX) {
      var $$ = this,
          config = $$.config,
          toRemove = $$.getGridFilterToRemove(params),
          toShow = function(line) {
            return !toRemove(line);
          },
          classLines = forX ? CLASS.xgridLines : CLASS.ygridLines,
          classLine = forX ? CLASS.xgridLine : CLASS.ygridLine;
      $$.main.select('.' + classLines).selectAll('.' + classLine).filter(toRemove).transition().duration(config.transition_duration).style('opacity', 0).remove();
      if (forX) {
        config.grid_x_lines = config.grid_x_lines.filter(toShow);
      } else {
        config.grid_y_lines = config.grid_y_lines.filter(toShow);
      }
    };
    c3_chart_internal_fn.initTooltip = function() {
      var $$ = this,
          config = $$.config,
          i;
      $$.tooltip = $$.selectChart.style("position", "relative").append("div").attr('class', CLASS.tooltipContainer).style("position", "absolute").style("pointer-events", "none").style("display", "none");
      if (config.tooltip_init_show) {
        if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {
          config.tooltip_init_x = $$.parseDate(config.tooltip_init_x);
          for (i = 0; i < $$.data.targets[0].values.length; i++) {
            if (($$.data.targets[0].values[i].x - config.tooltip_init_x) === 0) {
              break;
            }
          }
          config.tooltip_init_x = i;
        }
        $$.tooltip.html(config.tooltip_contents.call($$, $$.data.targets.map(function(d) {
          return $$.addName(d.values[config.tooltip_init_x]);
        }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType()), $$.color));
        $$.tooltip.style("top", config.tooltip_init_position.top).style("left", config.tooltip_init_position.left).style("display", "block");
      }
    };
    c3_chart_internal_fn.getTooltipContent = function(d, defaultTitleFormat, defaultValueFormat, color) {
      var $$ = this,
          config = $$.config,
          titleFormat = config.tooltip_format_title || defaultTitleFormat,
          nameFormat = config.tooltip_format_name || function(name) {
            return name;
          },
          valueFormat = config.tooltip_format_value || defaultValueFormat,
          text,
          i,
          title,
          value,
          name,
          bgcolor;
      for (i = 0; i < d.length; i++) {
        if (!(d[i] && (d[i].value || d[i].value === 0))) {
          continue;
        }
        if (!text) {
          title = titleFormat ? titleFormat(d[i].x) : d[i].x;
          text = "<table class='" + CLASS.tooltip + "'>" + (title || title === 0 ? "<tr><th colspan='2'>" + title + "</th></tr>" : "");
        }
        value = valueFormat(d[i].value, d[i].ratio, d[i].id, d[i].index);
        if (value !== undefined) {
          name = nameFormat(d[i].name, d[i].ratio, d[i].id, d[i].index);
          bgcolor = $$.levelColor ? $$.levelColor(d[i].value) : color(d[i].id);
          text += "<tr class='" + CLASS.tooltipName + "-" + d[i].id + "'>";
          text += "<td class='name'><span style='background-color:" + bgcolor + "'></span>" + name + "</td>";
          text += "<td class='value'>" + value + "</td>";
          text += "</tr>";
        }
      }
      return text + "</table>";
    };
    c3_chart_internal_fn.tooltipPosition = function(dataToShow, tWidth, tHeight, element) {
      var $$ = this,
          config = $$.config,
          d3 = $$.d3;
      var svgLeft,
          tooltipLeft,
          tooltipRight,
          tooltipTop,
          chartRight;
      var forArc = $$.hasArcType(),
          mouse = d3.mouse(element);
      if (forArc) {
        tooltipLeft = (($$.width - ($$.isLegendRight ? $$.getLegendWidth() : 0)) / 2) + mouse[0];
        tooltipTop = ($$.height / 2) + mouse[1] + 20;
      } else {
        svgLeft = $$.getSvgLeft(true);
        if (config.axis_rotated) {
          tooltipLeft = svgLeft + mouse[0] + 100;
          tooltipRight = tooltipLeft + tWidth;
          chartRight = $$.currentWidth - $$.getCurrentPaddingRight();
          tooltipTop = $$.x(dataToShow[0].x) + 20;
        } else {
          tooltipLeft = svgLeft + $$.getCurrentPaddingLeft(true) + $$.x(dataToShow[0].x) + 20;
          tooltipRight = tooltipLeft + tWidth;
          chartRight = svgLeft + $$.currentWidth - $$.getCurrentPaddingRight();
          tooltipTop = mouse[1] + 15;
        }
        if (tooltipRight > chartRight) {
          tooltipLeft -= tooltipRight - chartRight + 20;
        }
        if (tooltipTop + tHeight > $$.currentHeight) {
          tooltipTop -= tHeight + 30;
        }
      }
      if (tooltipTop < 0) {
        tooltipTop = 0;
      }
      return {
        top: tooltipTop,
        left: tooltipLeft
      };
    };
    c3_chart_internal_fn.showTooltip = function(selectedData, element) {
      var $$ = this,
          config = $$.config;
      var tWidth,
          tHeight,
          position;
      var forArc = $$.hasArcType(),
          dataToShow = selectedData.filter(function(d) {
            return d && isValue(d.value);
          }),
          positionFunction = config.tooltip_position || c3_chart_internal_fn.tooltipPosition;
      if (dataToShow.length === 0 || !config.tooltip_show) {
        return;
      }
      $$.tooltip.html(config.tooltip_contents.call($$, selectedData, $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color)).style("display", "block");
      tWidth = $$.tooltip.property('offsetWidth');
      tHeight = $$.tooltip.property('offsetHeight');
      position = positionFunction.call(this, dataToShow, tWidth, tHeight, element);
      $$.tooltip.style("top", position.top + "px").style("left", position.left + 'px');
    };
    c3_chart_internal_fn.hideTooltip = function() {
      this.tooltip.style("display", "none");
    };
    c3_chart_internal_fn.initLegend = function() {
      var $$ = this;
      $$.legendItemTextBox = {};
      $$.legendHasRendered = false;
      $$.legend = $$.svg.append("g").attr("transform", $$.getTranslate('legend'));
      if (!$$.config.legend_show) {
        $$.legend.style('visibility', 'hidden');
        $$.hiddenLegendIds = $$.mapToIds($$.data.targets);
        return;
      }
      $$.updateLegendWithDefaults();
    };
    c3_chart_internal_fn.updateLegendWithDefaults = function() {
      var $$ = this;
      $$.updateLegend($$.mapToIds($$.data.targets), {
        withTransform: false,
        withTransitionForTransform: false,
        withTransition: false
      });
    };
    c3_chart_internal_fn.updateSizeForLegend = function(legendHeight, legendWidth) {
      var $$ = this,
          config = $$.config,
          insetLegendPosition = {
            top: $$.isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : $$.currentHeight - legendHeight - $$.getCurrentPaddingBottom() - config.legend_inset_y,
            left: $$.isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + 0.5 : $$.currentWidth - legendWidth - $$.getCurrentPaddingRight() - config.legend_inset_x + 0.5
          };
      $$.margin3 = {
        top: $$.isLegendRight ? 0 : $$.isLegendInset ? insetLegendPosition.top : $$.currentHeight - legendHeight,
        right: NaN,
        bottom: 0,
        left: $$.isLegendRight ? $$.currentWidth - legendWidth : $$.isLegendInset ? insetLegendPosition.left : 0
      };
    };
    c3_chart_internal_fn.transformLegend = function(withTransition) {
      var $$ = this;
      (withTransition ? $$.legend.transition() : $$.legend).attr("transform", $$.getTranslate('legend'));
    };
    c3_chart_internal_fn.updateLegendStep = function(step) {
      this.legendStep = step;
    };
    c3_chart_internal_fn.updateLegendItemWidth = function(w) {
      this.legendItemWidth = w;
    };
    c3_chart_internal_fn.updateLegendItemHeight = function(h) {
      this.legendItemHeight = h;
    };
    c3_chart_internal_fn.getLegendWidth = function() {
      var $$ = this;
      return $$.config.legend_show ? $$.isLegendRight || $$.isLegendInset ? $$.legendItemWidth * ($$.legendStep + 1) : $$.currentWidth : 0;
    };
    c3_chart_internal_fn.getLegendHeight = function() {
      var $$ = this,
          h = 0;
      if ($$.config.legend_show) {
        if ($$.isLegendRight) {
          h = $$.currentHeight;
        } else {
          h = Math.max(20, $$.legendItemHeight) * ($$.legendStep + 1);
        }
      }
      return h;
    };
    c3_chart_internal_fn.opacityForLegend = function(legendItem) {
      return legendItem.classed(CLASS.legendItemHidden) ? null : 1;
    };
    c3_chart_internal_fn.opacityForUnfocusedLegend = function(legendItem) {
      return legendItem.classed(CLASS.legendItemHidden) ? null : 0.3;
    };
    c3_chart_internal_fn.toggleFocusLegend = function(targetIds, focus) {
      var $$ = this;
      targetIds = $$.mapToTargetIds(targetIds);
      $$.legend.selectAll('.' + CLASS.legendItem).filter(function(id) {
        return targetIds.indexOf(id) >= 0;
      }).classed(CLASS.legendItemFocused, focus).transition().duration(100).style('opacity', function() {
        var opacity = focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend;
        return opacity.call($$, $$.d3.select(this));
      });
    };
    c3_chart_internal_fn.revertLegend = function() {
      var $$ = this,
          d3 = $$.d3;
      $$.legend.selectAll('.' + CLASS.legendItem).classed(CLASS.legendItemFocused, false).transition().duration(100).style('opacity', function() {
        return $$.opacityForLegend(d3.select(this));
      });
    };
    c3_chart_internal_fn.showLegend = function(targetIds) {
      var $$ = this,
          config = $$.config;
      if (!config.legend_show) {
        config.legend_show = true;
        $$.legend.style('visibility', 'visible');
        if (!$$.legendHasRendered) {
          $$.updateLegendWithDefaults();
        }
      }
      $$.removeHiddenLegendIds(targetIds);
      $$.legend.selectAll($$.selectorLegends(targetIds)).style('visibility', 'visible').transition().style('opacity', function() {
        return $$.opacityForLegend($$.d3.select(this));
      });
    };
    c3_chart_internal_fn.hideLegend = function(targetIds) {
      var $$ = this,
          config = $$.config;
      if (config.legend_show && isEmpty(targetIds)) {
        config.legend_show = false;
        $$.legend.style('visibility', 'hidden');
      }
      $$.addHiddenLegendIds(targetIds);
      $$.legend.selectAll($$.selectorLegends(targetIds)).style('opacity', 0).style('visibility', 'hidden');
    };
    c3_chart_internal_fn.clearLegendItemTextBoxCache = function() {
      this.legendItemTextBox = {};
    };
    c3_chart_internal_fn.updateLegend = function(targetIds, options, transitions) {
      var $$ = this,
          config = $$.config;
      var xForLegend,
          xForLegendText,
          xForLegendRect,
          yForLegend,
          yForLegendText,
          yForLegendRect;
      var paddingTop = 4,
          paddingRight = 10,
          maxWidth = 0,
          maxHeight = 0,
          posMin = 10,
          tileWidth = 15;
      var l,
          totalLength = 0,
          offsets = {},
          widths = {},
          heights = {},
          margins = [0],
          steps = {},
          step = 0;
      var withTransition,
          withTransitionForTransform;
      var texts,
          rects,
          tiles,
          background;
      options = options || {};
      withTransition = getOption(options, "withTransition", true);
      withTransitionForTransform = getOption(options, "withTransitionForTransform", true);
      function getTextBox(textElement, id) {
        if (!$$.legendItemTextBox[id]) {
          $$.legendItemTextBox[id] = $$.getTextRect(textElement.textContent, CLASS.legendItem);
        }
        return $$.legendItemTextBox[id];
      }
      function updatePositions(textElement, id, index) {
        var reset = index === 0,
            isLast = index === targetIds.length - 1,
            box = getTextBox(textElement, id),
            itemWidth = box.width + tileWidth + (isLast && !($$.isLegendRight || $$.isLegendInset) ? 0 : paddingRight),
            itemHeight = box.height + paddingTop,
            itemLength = $$.isLegendRight || $$.isLegendInset ? itemHeight : itemWidth,
            areaLength = $$.isLegendRight || $$.isLegendInset ? $$.getLegendHeight() : $$.getLegendWidth(),
            margin,
            maxLength;
        function updateValues(id, withoutStep) {
          if (!withoutStep) {
            margin = (areaLength - totalLength - itemLength) / 2;
            if (margin < posMin) {
              margin = (areaLength - itemLength) / 2;
              totalLength = 0;
              step++;
            }
          }
          steps[id] = step;
          margins[step] = $$.isLegendInset ? 10 : margin;
          offsets[id] = totalLength;
          totalLength += itemLength;
        }
        if (reset) {
          totalLength = 0;
          step = 0;
          maxWidth = 0;
          maxHeight = 0;
        }
        if (config.legend_show && !$$.isLegendToShow(id)) {
          widths[id] = heights[id] = steps[id] = offsets[id] = 0;
          return;
        }
        widths[id] = itemWidth;
        heights[id] = itemHeight;
        if (!maxWidth || itemWidth >= maxWidth) {
          maxWidth = itemWidth;
        }
        if (!maxHeight || itemHeight >= maxHeight) {
          maxHeight = itemHeight;
        }
        maxLength = $$.isLegendRight || $$.isLegendInset ? maxHeight : maxWidth;
        if (config.legend_equally) {
          Object.keys(widths).forEach(function(id) {
            widths[id] = maxWidth;
          });
          Object.keys(heights).forEach(function(id) {
            heights[id] = maxHeight;
          });
          margin = (areaLength - maxLength * targetIds.length) / 2;
          if (margin < posMin) {
            totalLength = 0;
            step = 0;
            targetIds.forEach(function(id) {
              updateValues(id);
            });
          } else {
            updateValues(id, true);
          }
        } else {
          updateValues(id);
        }
      }
      if ($$.isLegendInset) {
        step = config.legend_inset_step ? config.legend_inset_step : targetIds.length;
        $$.updateLegendStep(step);
      }
      if ($$.isLegendRight) {
        xForLegend = function(id) {
          return maxWidth * steps[id];
        };
        yForLegend = function(id) {
          return margins[steps[id]] + offsets[id];
        };
      } else if ($$.isLegendInset) {
        xForLegend = function(id) {
          return maxWidth * steps[id] + 10;
        };
        yForLegend = function(id) {
          return margins[steps[id]] + offsets[id];
        };
      } else {
        xForLegend = function(id) {
          return margins[steps[id]] + offsets[id];
        };
        yForLegend = function(id) {
          return maxHeight * steps[id];
        };
      }
      xForLegendText = function(id, i) {
        return xForLegend(id, i) + 14;
      };
      yForLegendText = function(id, i) {
        return yForLegend(id, i) + 9;
      };
      xForLegendRect = function(id, i) {
        return xForLegend(id, i);
      };
      yForLegendRect = function(id, i) {
        return yForLegend(id, i) - 5;
      };
      l = $$.legend.selectAll('.' + CLASS.legendItem).data(targetIds).enter().append('g').attr('class', function(id) {
        return $$.generateClass(CLASS.legendItem, id);
      }).style('visibility', function(id) {
        return $$.isLegendToShow(id) ? 'visible' : 'hidden';
      }).style('cursor', 'pointer').on('click', function(id) {
        if (config.legend_item_onclick) {
          config.legend_item_onclick.call($$, id);
        } else {
          if ($$.d3.event.altKey) {
            $$.api.hide();
            $$.api.show(id);
          } else {
            $$.api.toggle(id);
            $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert();
          }
        }
      }).on('mouseover', function(id) {
        $$.d3.select(this).classed(CLASS.legendItemFocused, true);
        if (!$$.transiting && $$.isTargetToShow(id)) {
          $$.api.focus(id);
        }
        if (config.legend_item_onmouseover) {
          config.legend_item_onmouseover.call($$, id);
        }
      }).on('mouseout', function(id) {
        $$.d3.select(this).classed(CLASS.legendItemFocused, false);
        $$.api.revert();
        if (config.legend_item_onmouseout) {
          config.legend_item_onmouseout.call($$, id);
        }
      });
      l.append('text').text(function(id) {
        return isDefined(config.data_names[id]) ? config.data_names[id] : id;
      }).each(function(id, i) {
        updatePositions(this, id, i);
      }).style("pointer-events", "none").attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendText : -200).attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendText);
      l.append('rect').attr("class", CLASS.legendItemEvent).style('fill-opacity', 0).attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendRect : -200).attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendRect);
      l.append('rect').attr("class", CLASS.legendItemTile).style("pointer-events", "none").style('fill', $$.color).attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendText : -200).attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegend).attr('width', 10).attr('height', 10);
      background = $$.legend.select('.' + CLASS.legendBackground + ' rect');
      if ($$.isLegendInset && maxWidth > 0 && background.size() === 0) {
        background = $$.legend.insert('g', '.' + CLASS.legendItem).attr("class", CLASS.legendBackground).append('rect');
      }
      texts = $$.legend.selectAll('text').data(targetIds).text(function(id) {
        return isDefined(config.data_names[id]) ? config.data_names[id] : id;
      }).each(function(id, i) {
        updatePositions(this, id, i);
      });
      (withTransition ? texts.transition() : texts).attr('x', xForLegendText).attr('y', yForLegendText);
      rects = $$.legend.selectAll('rect.' + CLASS.legendItemEvent).data(targetIds);
      (withTransition ? rects.transition() : rects).attr('width', function(id) {
        return widths[id];
      }).attr('height', function(id) {
        return heights[id];
      }).attr('x', xForLegendRect).attr('y', yForLegendRect);
      tiles = $$.legend.selectAll('rect.' + CLASS.legendItemTile).data(targetIds);
      (withTransition ? tiles.transition() : tiles).style('fill', $$.color).attr('x', xForLegend).attr('y', yForLegend);
      if (background) {
        (withTransition ? background.transition() : background).attr('height', $$.getLegendHeight() - 12).attr('width', maxWidth * (step + 1) + 10);
      }
      $$.legend.selectAll('.' + CLASS.legendItem).classed(CLASS.legendItemHidden, function(id) {
        return !$$.isTargetToShow(id);
      });
      $$.updateLegendItemWidth(maxWidth);
      $$.updateLegendItemHeight(maxHeight);
      $$.updateLegendStep(step);
      $$.updateSizes();
      $$.updateScales();
      $$.updateSvgSize();
      $$.transformAll(withTransitionForTransform, transitions);
      $$.legendHasRendered = true;
    };
    function Axis(owner) {
      API.call(this, owner);
    }
    inherit(API, Axis);
    Axis.prototype.init = function init() {
      var $$ = this.owner,
          config = $$.config,
          main = $$.main;
      $$.axes.x = main.append("g").attr("class", CLASS.axis + ' ' + CLASS.axisX).attr("clip-path", $$.clipPathForXAxis).attr("transform", $$.getTranslate('x')).style("visibility", config.axis_x_show ? 'visible' : 'hidden');
      $$.axes.x.append("text").attr("class", CLASS.axisXLabel).attr("transform", config.axis_rotated ? "rotate(-90)" : "").style("text-anchor", this.textAnchorForXAxisLabel.bind(this));
      $$.axes.y = main.append("g").attr("class", CLASS.axis + ' ' + CLASS.axisY).attr("clip-path", config.axis_y_inner ? "" : $$.clipPathForYAxis).attr("transform", $$.getTranslate('y')).style("visibility", config.axis_y_show ? 'visible' : 'hidden');
      $$.axes.y.append("text").attr("class", CLASS.axisYLabel).attr("transform", config.axis_rotated ? "" : "rotate(-90)").style("text-anchor", this.textAnchorForYAxisLabel.bind(this));
      $$.axes.y2 = main.append("g").attr("class", CLASS.axis + ' ' + CLASS.axisY2).attr("transform", $$.getTranslate('y2')).style("visibility", config.axis_y2_show ? 'visible' : 'hidden');
      $$.axes.y2.append("text").attr("class", CLASS.axisY2Label).attr("transform", config.axis_rotated ? "" : "rotate(-90)").style("text-anchor", this.textAnchorForY2AxisLabel.bind(this));
    };
    Axis.prototype.getXAxis = function getXAxis(scale, orient, tickFormat, tickValues, withOuterTick, withoutTransition, withoutRotateTickText) {
      var $$ = this.owner,
          config = $$.config,
          axisParams = {
            isCategory: $$.isCategorized(),
            withOuterTick: withOuterTick,
            tickMultiline: config.axis_x_tick_multiline,
            tickWidth: config.axis_x_tick_width,
            tickTextRotate: withoutRotateTickText ? 0 : config.axis_x_tick_rotate,
            withoutTransition: withoutTransition
          },
          axis = c3_axis($$.d3, axisParams).scale(scale).orient(orient);
      if ($$.isTimeSeries() && tickValues) {
        tickValues = tickValues.map(function(v) {
          return $$.parseDate(v);
        });
      }
      axis.tickFormat(tickFormat).tickValues(tickValues);
      if ($$.isCategorized()) {
        axis.tickCentered(config.axis_x_tick_centered);
        if (isEmpty(config.axis_x_tick_culling)) {
          config.axis_x_tick_culling = false;
        }
      }
      return axis;
    };
    Axis.prototype.updateXAxisTickValues = function updateXAxisTickValues(targets, axis) {
      var $$ = this.owner,
          config = $$.config,
          tickValues;
      if (config.axis_x_tick_fit || config.axis_x_tick_count) {
        tickValues = this.generateTickValues($$.mapTargetsToUniqueXs(targets), config.axis_x_tick_count, $$.isTimeSeries());
      }
      if (axis) {
        axis.tickValues(tickValues);
      } else {
        $$.xAxis.tickValues(tickValues);
        $$.subXAxis.tickValues(tickValues);
      }
      return tickValues;
    };
    Axis.prototype.getYAxis = function getYAxis(scale, orient, tickFormat, tickValues, withOuterTick, withoutTransition) {
      var axisParams = {
        withOuterTick: withOuterTick,
        withoutTransition: withoutTransition
      },
          $$ = this.owner,
          d3 = $$.d3,
          config = $$.config,
          axis = c3_axis(d3, axisParams).scale(scale).orient(orient).tickFormat(tickFormat);
      if ($$.isTimeSeriesY()) {
        axis.ticks(d3.time[config.axis_y_tick_time_value], config.axis_y_tick_time_interval);
      } else {
        axis.tickValues(tickValues);
      }
      return axis;
    };
    Axis.prototype.getId = function getId(id) {
      var config = this.owner.config;
      return id in config.data_axes ? config.data_axes[id] : 'y';
    };
    Axis.prototype.getXAxisTickFormat = function getXAxisTickFormat() {
      var $$ = this.owner,
          config = $$.config,
          format = $$.isTimeSeries() ? $$.defaultAxisTimeFormat : $$.isCategorized() ? $$.categoryName : function(v) {
            return v < 0 ? v.toFixed(0) : v;
          };
      if (config.axis_x_tick_format) {
        if (isFunction(config.axis_x_tick_format)) {
          format = config.axis_x_tick_format;
        } else if ($$.isTimeSeries()) {
          format = function(date) {
            return date ? $$.axisTimeFormat(config.axis_x_tick_format)(date) : "";
          };
        }
      }
      return isFunction(format) ? function(v) {
        return format.call($$, v);
      } : format;
    };
    Axis.prototype.getTickValues = function getTickValues(tickValues, axis) {
      return tickValues ? tickValues : axis ? axis.tickValues() : undefined;
    };
    Axis.prototype.getXAxisTickValues = function getXAxisTickValues() {
      return this.getTickValues(this.owner.config.axis_x_tick_values, this.owner.xAxis);
    };
    Axis.prototype.getYAxisTickValues = function getYAxisTickValues() {
      return this.getTickValues(this.owner.config.axis_y_tick_values, this.owner.yAxis);
    };
    Axis.prototype.getY2AxisTickValues = function getY2AxisTickValues() {
      return this.getTickValues(this.owner.config.axis_y2_tick_values, this.owner.y2Axis);
    };
    Axis.prototype.getLabelOptionByAxisId = function getLabelOptionByAxisId(axisId) {
      var $$ = this.owner,
          config = $$.config,
          option;
      if (axisId === 'y') {
        option = config.axis_y_label;
      } else if (axisId === 'y2') {
        option = config.axis_y2_label;
      } else if (axisId === 'x') {
        option = config.axis_x_label;
      }
      return option;
    };
    Axis.prototype.getLabelText = function getLabelText(axisId) {
      var option = this.getLabelOptionByAxisId(axisId);
      return isString(option) ? option : option ? option.text : null;
    };
    Axis.prototype.setLabelText = function setLabelText(axisId, text) {
      var $$ = this.owner,
          config = $$.config,
          option = this.getLabelOptionByAxisId(axisId);
      if (isString(option)) {
        if (axisId === 'y') {
          config.axis_y_label = text;
        } else if (axisId === 'y2') {
          config.axis_y2_label = text;
        } else if (axisId === 'x') {
          config.axis_x_label = text;
        }
      } else if (option) {
        option.text = text;
      }
    };
    Axis.prototype.getLabelPosition = function getLabelPosition(axisId, defaultPosition) {
      var option = this.getLabelOptionByAxisId(axisId),
          position = (option && typeof option === 'object' && option.position) ? option.position : defaultPosition;
      return {
        isInner: position.indexOf('inner') >= 0,
        isOuter: position.indexOf('outer') >= 0,
        isLeft: position.indexOf('left') >= 0,
        isCenter: position.indexOf('center') >= 0,
        isRight: position.indexOf('right') >= 0,
        isTop: position.indexOf('top') >= 0,
        isMiddle: position.indexOf('middle') >= 0,
        isBottom: position.indexOf('bottom') >= 0
      };
    };
    Axis.prototype.getXAxisLabelPosition = function getXAxisLabelPosition() {
      return this.getLabelPosition('x', this.owner.config.axis_rotated ? 'inner-top' : 'inner-right');
    };
    Axis.prototype.getYAxisLabelPosition = function getYAxisLabelPosition() {
      return this.getLabelPosition('y', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top');
    };
    Axis.prototype.getY2AxisLabelPosition = function getY2AxisLabelPosition() {
      return this.getLabelPosition('y2', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top');
    };
    Axis.prototype.getLabelPositionById = function getLabelPositionById(id) {
      return id === 'y2' ? this.getY2AxisLabelPosition() : id === 'y' ? this.getYAxisLabelPosition() : this.getXAxisLabelPosition();
    };
    Axis.prototype.textForXAxisLabel = function textForXAxisLabel() {
      return this.getLabelText('x');
    };
    Axis.prototype.textForYAxisLabel = function textForYAxisLabel() {
      return this.getLabelText('y');
    };
    Axis.prototype.textForY2AxisLabel = function textForY2AxisLabel() {
      return this.getLabelText('y2');
    };
    Axis.prototype.xForAxisLabel = function xForAxisLabel(forHorizontal, position) {
      var $$ = this.owner;
      if (forHorizontal) {
        return position.isLeft ? 0 : position.isCenter ? $$.width / 2 : $$.width;
      } else {
        return position.isBottom ? -$$.height : position.isMiddle ? -$$.height / 2 : 0;
      }
    };
    Axis.prototype.dxForAxisLabel = function dxForAxisLabel(forHorizontal, position) {
      if (forHorizontal) {
        return position.isLeft ? "0.5em" : position.isRight ? "-0.5em" : "0";
      } else {
        return position.isTop ? "-0.5em" : position.isBottom ? "0.5em" : "0";
      }
    };
    Axis.prototype.textAnchorForAxisLabel = function textAnchorForAxisLabel(forHorizontal, position) {
      if (forHorizontal) {
        return position.isLeft ? 'start' : position.isCenter ? 'middle' : 'end';
      } else {
        return position.isBottom ? 'start' : position.isMiddle ? 'middle' : 'end';
      }
    };
    Axis.prototype.xForXAxisLabel = function xForXAxisLabel() {
      return this.xForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());
    };
    Axis.prototype.xForYAxisLabel = function xForYAxisLabel() {
      return this.xForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());
    };
    Axis.prototype.xForY2AxisLabel = function xForY2AxisLabel() {
      return this.xForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());
    };
    Axis.prototype.dxForXAxisLabel = function dxForXAxisLabel() {
      return this.dxForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());
    };
    Axis.prototype.dxForYAxisLabel = function dxForYAxisLabel() {
      return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());
    };
    Axis.prototype.dxForY2AxisLabel = function dxForY2AxisLabel() {
      return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());
    };
    Axis.prototype.dyForXAxisLabel = function dyForXAxisLabel() {
      var $$ = this.owner,
          config = $$.config,
          position = this.getXAxisLabelPosition();
      if (config.axis_rotated) {
        return position.isInner ? "1.2em" : -25 - this.getMaxTickWidth('x');
      } else {
        return position.isInner ? "-0.5em" : config.axis_x_height ? config.axis_x_height - 10 : "3em";
      }
    };
    Axis.prototype.dyForYAxisLabel = function dyForYAxisLabel() {
      var $$ = this.owner,
          position = this.getYAxisLabelPosition();
      if ($$.config.axis_rotated) {
        return position.isInner ? "-0.5em" : "3em";
      } else {
        return position.isInner ? "1.2em" : -10 - ($$.config.axis_y_inner ? 0 : (this.getMaxTickWidth('y') + 10));
      }
    };
    Axis.prototype.dyForY2AxisLabel = function dyForY2AxisLabel() {
      var $$ = this.owner,
          position = this.getY2AxisLabelPosition();
      if ($$.config.axis_rotated) {
        return position.isInner ? "1.2em" : "-2.2em";
      } else {
        return position.isInner ? "-0.5em" : 15 + ($$.config.axis_y2_inner ? 0 : (this.getMaxTickWidth('y2') + 15));
      }
    };
    Axis.prototype.textAnchorForXAxisLabel = function textAnchorForXAxisLabel() {
      var $$ = this.owner;
      return this.textAnchorForAxisLabel(!$$.config.axis_rotated, this.getXAxisLabelPosition());
    };
    Axis.prototype.textAnchorForYAxisLabel = function textAnchorForYAxisLabel() {
      var $$ = this.owner;
      return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getYAxisLabelPosition());
    };
    Axis.prototype.textAnchorForY2AxisLabel = function textAnchorForY2AxisLabel() {
      var $$ = this.owner;
      return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getY2AxisLabelPosition());
    };
    Axis.prototype.getMaxTickWidth = function getMaxTickWidth(id, withoutRecompute) {
      var $$ = this.owner,
          config = $$.config,
          maxWidth = 0,
          targetsToShow,
          scale,
          axis,
          dummy,
          svg;
      if (withoutRecompute && $$.currentMaxTickWidths[id]) {
        return $$.currentMaxTickWidths[id];
      }
      if ($$.svg) {
        targetsToShow = $$.filterTargetsToShow($$.data.targets);
        if (id === 'y') {
          scale = $$.y.copy().domain($$.getYDomain(targetsToShow, 'y'));
          axis = this.getYAxis(scale, $$.yOrient, config.axis_y_tick_format, $$.yAxisTickValues, false, true);
        } else if (id === 'y2') {
          scale = $$.y2.copy().domain($$.getYDomain(targetsToShow, 'y2'));
          axis = this.getYAxis(scale, $$.y2Orient, config.axis_y2_tick_format, $$.y2AxisTickValues, false, true);
        } else {
          scale = $$.x.copy().domain($$.getXDomain(targetsToShow));
          axis = this.getXAxis(scale, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, false, true, true);
          this.updateXAxisTickValues(targetsToShow, axis);
        }
        dummy = $$.d3.select('body').append('div').classed('c3', true);
        svg = dummy.append("svg").style('visibility', 'hidden').style('position', 'fixed').style('top', 0).style('left', 0), svg.append('g').call(axis).each(function() {
          $$.d3.select(this).selectAll('text').each(function() {
            var box = this.getBoundingClientRect();
            if (maxWidth < box.width) {
              maxWidth = box.width;
            }
          });
          dummy.remove();
        });
      }
      $$.currentMaxTickWidths[id] = maxWidth <= 0 ? $$.currentMaxTickWidths[id] : maxWidth;
      return $$.currentMaxTickWidths[id];
    };
    Axis.prototype.updateLabels = function updateLabels(withTransition) {
      var $$ = this.owner;
      var axisXLabel = $$.main.select('.' + CLASS.axisX + ' .' + CLASS.axisXLabel),
          axisYLabel = $$.main.select('.' + CLASS.axisY + ' .' + CLASS.axisYLabel),
          axisY2Label = $$.main.select('.' + CLASS.axisY2 + ' .' + CLASS.axisY2Label);
      (withTransition ? axisXLabel.transition() : axisXLabel).attr("x", this.xForXAxisLabel.bind(this)).attr("dx", this.dxForXAxisLabel.bind(this)).attr("dy", this.dyForXAxisLabel.bind(this)).text(this.textForXAxisLabel.bind(this));
      (withTransition ? axisYLabel.transition() : axisYLabel).attr("x", this.xForYAxisLabel.bind(this)).attr("dx", this.dxForYAxisLabel.bind(this)).attr("dy", this.dyForYAxisLabel.bind(this)).text(this.textForYAxisLabel.bind(this));
      (withTransition ? axisY2Label.transition() : axisY2Label).attr("x", this.xForY2AxisLabel.bind(this)).attr("dx", this.dxForY2AxisLabel.bind(this)).attr("dy", this.dyForY2AxisLabel.bind(this)).text(this.textForY2AxisLabel.bind(this));
    };
    Axis.prototype.getPadding = function getPadding(padding, key, defaultValue, domainLength) {
      if (!isValue(padding[key])) {
        return defaultValue;
      }
      if (padding.unit === 'ratio') {
        return padding[key] * domainLength;
      }
      return this.convertPixelsToAxisPadding(padding[key], domainLength);
    };
    Axis.prototype.convertPixelsToAxisPadding = function convertPixelsToAxisPadding(pixels, domainLength) {
      var $$ = this.owner,
          length = $$.config.axis_rotated ? $$.width : $$.height;
      return domainLength * (pixels / length);
    };
    Axis.prototype.generateTickValues = function generateTickValues(values, tickCount, forTimeSeries) {
      var tickValues = values,
          targetCount,
          start,
          end,
          count,
          interval,
          i,
          tickValue;
      if (tickCount) {
        targetCount = isFunction(tickCount) ? tickCount() : tickCount;
        if (targetCount === 1) {
          tickValues = [values[0]];
        } else if (targetCount === 2) {
          tickValues = [values[0], values[values.length - 1]];
        } else if (targetCount > 2) {
          count = targetCount - 2;
          start = values[0];
          end = values[values.length - 1];
          interval = (end - start) / (count + 1);
          tickValues = [start];
          for (i = 0; i < count; i++) {
            tickValue = +start + interval * (i + 1);
            tickValues.push(forTimeSeries ? new Date(tickValue) : tickValue);
          }
          tickValues.push(end);
        }
      }
      if (!forTimeSeries) {
        tickValues = tickValues.sort(function(a, b) {
          return a - b;
        });
      }
      return tickValues;
    };
    Axis.prototype.generateTransitions = function generateTransitions(duration) {
      var $$ = this.owner,
          axes = $$.axes;
      return {
        axisX: duration ? axes.x.transition().duration(duration) : axes.x,
        axisY: duration ? axes.y.transition().duration(duration) : axes.y,
        axisY2: duration ? axes.y2.transition().duration(duration) : axes.y2,
        axisSubX: duration ? axes.subx.transition().duration(duration) : axes.subx
      };
    };
    Axis.prototype.redraw = function redraw(transitions, isHidden) {
      var $$ = this.owner;
      $$.axes.x.style("opacity", isHidden ? 0 : 1);
      $$.axes.y.style("opacity", isHidden ? 0 : 1);
      $$.axes.y2.style("opacity", isHidden ? 0 : 1);
      $$.axes.subx.style("opacity", isHidden ? 0 : 1);
      transitions.axisX.call($$.xAxis);
      transitions.axisY.call($$.yAxis);
      transitions.axisY2.call($$.y2Axis);
      transitions.axisSubX.call($$.subXAxis);
    };
    c3_chart_internal_fn.getClipPath = function(id) {
      var isIE9 = window.navigator.appVersion.toLowerCase().indexOf("msie 9.") >= 0;
      return "url(" + (isIE9 ? "" : document.URL.split('#')[0]) + "#" + id + ")";
    };
    c3_chart_internal_fn.appendClip = function(parent, id) {
      return parent.append("clipPath").attr("id", id).append("rect");
    };
    c3_chart_internal_fn.getAxisClipX = function(forHorizontal) {
      var left = Math.max(30, this.margin.left);
      return forHorizontal ? -(1 + left) : -(left - 1);
    };
    c3_chart_internal_fn.getAxisClipY = function(forHorizontal) {
      return forHorizontal ? -20 : -this.margin.top;
    };
    c3_chart_internal_fn.getXAxisClipX = function() {
      var $$ = this;
      return $$.getAxisClipX(!$$.config.axis_rotated);
    };
    c3_chart_internal_fn.getXAxisClipY = function() {
      var $$ = this;
      return $$.getAxisClipY(!$$.config.axis_rotated);
    };
    c3_chart_internal_fn.getYAxisClipX = function() {
      var $$ = this;
      return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
    };
    c3_chart_internal_fn.getYAxisClipY = function() {
      var $$ = this;
      return $$.getAxisClipY($$.config.axis_rotated);
    };
    c3_chart_internal_fn.getAxisClipWidth = function(forHorizontal) {
      var $$ = this,
          left = Math.max(30, $$.margin.left),
          right = Math.max(30, $$.margin.right);
      return forHorizontal ? $$.width + 2 + left + right : $$.margin.left + 20;
    };
    c3_chart_internal_fn.getAxisClipHeight = function(forHorizontal) {
      return (forHorizontal ? this.margin.bottom : (this.margin.top + this.height)) + 20;
    };
    c3_chart_internal_fn.getXAxisClipWidth = function() {
      var $$ = this;
      return $$.getAxisClipWidth(!$$.config.axis_rotated);
    };
    c3_chart_internal_fn.getXAxisClipHeight = function() {
      var $$ = this;
      return $$.getAxisClipHeight(!$$.config.axis_rotated);
    };
    c3_chart_internal_fn.getYAxisClipWidth = function() {
      var $$ = this;
      return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);
    };
    c3_chart_internal_fn.getYAxisClipHeight = function() {
      var $$ = this;
      return $$.getAxisClipHeight($$.config.axis_rotated);
    };
    c3_chart_internal_fn.initPie = function() {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config;
      $$.pie = d3.layout.pie().value(function(d) {
        return d.values.reduce(function(a, b) {
          return a + b.value;
        }, 0);
      });
      if (!config.data_order) {
        $$.pie.sort(null);
      }
    };
    c3_chart_internal_fn.updateRadius = function() {
      var $$ = this,
          config = $$.config,
          w = config.gauge_width || config.donut_width;
      $$.radiusExpanded = Math.min($$.arcWidth, $$.arcHeight) / 2;
      $$.radius = $$.radiusExpanded * 0.95;
      $$.innerRadiusRatio = w ? ($$.radius - w) / $$.radius : 0.6;
      $$.innerRadius = $$.hasType('donut') || $$.hasType('gauge') ? $$.radius * $$.innerRadiusRatio : 0;
    };
    c3_chart_internal_fn.updateArc = function() {
      var $$ = this;
      $$.svgArc = $$.getSvgArc();
      $$.svgArcExpanded = $$.getSvgArcExpanded();
      $$.svgArcExpandedSub = $$.getSvgArcExpanded(0.98);
    };
    c3_chart_internal_fn.updateAngle = function(d) {
      var $$ = this,
          config = $$.config,
          found = false,
          index = 0,
          gMin = config.gauge_min,
          gMax = config.gauge_max,
          gTic,
          gValue;
      $$.pie($$.filterTargetsToShow($$.data.targets)).forEach(function(t) {
        if (!found && t.data.id === d.data.id) {
          found = true;
          d = t;
          d.index = index;
        }
        index++;
      });
      if (isNaN(d.startAngle)) {
        d.startAngle = 0;
      }
      if (isNaN(d.endAngle)) {
        d.endAngle = d.startAngle;
      }
      if ($$.isGaugeType(d.data)) {
        gTic = (Math.PI) / (gMax - gMin);
        gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : (gMax - gMin);
        d.startAngle = -1 * (Math.PI / 2);
        d.endAngle = d.startAngle + gTic * gValue;
      }
      return found ? d : null;
    };
    c3_chart_internal_fn.getSvgArc = function() {
      var $$ = this,
          arc = $$.d3.svg.arc().outerRadius($$.radius).innerRadius($$.innerRadius),
          newArc = function(d, withoutUpdate) {
            var updated;
            if (withoutUpdate) {
              return arc(d);
            }
            updated = $$.updateAngle(d);
            return updated ? arc(updated) : "M 0 0";
          };
      newArc.centroid = arc.centroid;
      return newArc;
    };
    c3_chart_internal_fn.getSvgArcExpanded = function(rate) {
      var $$ = this,
          arc = $$.d3.svg.arc().outerRadius($$.radiusExpanded * (rate ? rate : 1)).innerRadius($$.innerRadius);
      return function(d) {
        var updated = $$.updateAngle(d);
        return updated ? arc(updated) : "M 0 0";
      };
    };
    c3_chart_internal_fn.getArc = function(d, withoutUpdate, force) {
      return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : "M 0 0";
    };
    c3_chart_internal_fn.transformForArcLabel = function(d) {
      var $$ = this,
          updated = $$.updateAngle(d),
          c,
          x,
          y,
          h,
          ratio,
          translate = "";
      if (updated && !$$.hasType('gauge')) {
        c = this.svgArc.centroid(updated);
        x = isNaN(c[0]) ? 0 : c[0];
        y = isNaN(c[1]) ? 0 : c[1];
        h = Math.sqrt(x * x + y * y);
        ratio = $$.radius && h ? (36 / $$.radius > 0.375 ? 1.175 - 36 / $$.radius : 0.8) * $$.radius / h : 0;
        translate = "translate(" + (x * ratio) + ',' + (y * ratio) + ")";
      }
      return translate;
    };
    c3_chart_internal_fn.getArcRatio = function(d) {
      var $$ = this,
          whole = $$.hasType('gauge') ? Math.PI : (Math.PI * 2);
      return d ? (d.endAngle - d.startAngle) / whole : null;
    };
    c3_chart_internal_fn.convertToArcData = function(d) {
      return this.addName({
        id: d.data.id,
        value: d.value,
        ratio: this.getArcRatio(d),
        index: d.index
      });
    };
    c3_chart_internal_fn.textForArcLabel = function(d) {
      var $$ = this,
          updated,
          value,
          ratio,
          id,
          format;
      if (!$$.shouldShowArcLabel()) {
        return "";
      }
      updated = $$.updateAngle(d);
      value = updated ? updated.value : null;
      ratio = $$.getArcRatio(updated);
      id = d.data.id;
      if (!$$.hasType('gauge') && !$$.meetsArcLabelThreshold(ratio)) {
        return "";
      }
      format = $$.getArcLabelFormat();
      return format ? format(value, ratio, id) : $$.defaultArcValueFormat(value, ratio);
    };
    c3_chart_internal_fn.expandArc = function(targetIds) {
      var $$ = this,
          interval;
      if ($$.transiting) {
        interval = window.setInterval(function() {
          if (!$$.transiting) {
            window.clearInterval(interval);
            if ($$.legend.selectAll('.c3-legend-item-focused').size() > 0) {
              $$.expandArc(targetIds);
            }
          }
        }, 10);
        return;
      }
      targetIds = $$.mapToTargetIds(targetIds);
      $$.svg.selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc)).each(function(d) {
        if (!$$.shouldExpand(d.data.id)) {
          return;
        }
        $$.d3.select(this).selectAll('path').transition().duration(50).attr("d", $$.svgArcExpanded).transition().duration(100).attr("d", $$.svgArcExpandedSub).each(function(d) {
          if ($$.isDonutType(d.data)) {}
        });
      });
    };
    c3_chart_internal_fn.unexpandArc = function(targetIds) {
      var $$ = this;
      if ($$.transiting) {
        return;
      }
      targetIds = $$.mapToTargetIds(targetIds);
      $$.svg.selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc)).selectAll('path').transition().duration(50).attr("d", $$.svgArc);
      $$.svg.selectAll('.' + CLASS.arc).style("opacity", 1);
    };
    c3_chart_internal_fn.shouldExpand = function(id) {
      var $$ = this,
          config = $$.config;
      return ($$.isDonutType(id) && config.donut_expand) || ($$.isGaugeType(id) && config.gauge_expand) || ($$.isPieType(id) && config.pie_expand);
    };
    c3_chart_internal_fn.shouldShowArcLabel = function() {
      var $$ = this,
          config = $$.config,
          shouldShow = true;
      if ($$.hasType('donut')) {
        shouldShow = config.donut_label_show;
      } else if ($$.hasType('pie')) {
        shouldShow = config.pie_label_show;
      }
      return shouldShow;
    };
    c3_chart_internal_fn.meetsArcLabelThreshold = function(ratio) {
      var $$ = this,
          config = $$.config,
          threshold = $$.hasType('donut') ? config.donut_label_threshold : config.pie_label_threshold;
      return ratio >= threshold;
    };
    c3_chart_internal_fn.getArcLabelFormat = function() {
      var $$ = this,
          config = $$.config,
          format = config.pie_label_format;
      if ($$.hasType('gauge')) {
        format = config.gauge_label_format;
      } else if ($$.hasType('donut')) {
        format = config.donut_label_format;
      }
      return format;
    };
    c3_chart_internal_fn.getArcTitle = function() {
      var $$ = this;
      return $$.hasType('donut') ? $$.config.donut_title : "";
    };
    c3_chart_internal_fn.updateTargetsForArc = function(targets) {
      var $$ = this,
          main = $$.main,
          mainPieUpdate,
          mainPieEnter,
          classChartArc = $$.classChartArc.bind($$),
          classArcs = $$.classArcs.bind($$),
          classFocus = $$.classFocus.bind($$);
      mainPieUpdate = main.select('.' + CLASS.chartArcs).selectAll('.' + CLASS.chartArc).data($$.pie(targets)).attr("class", function(d) {
        return classChartArc(d) + classFocus(d.data);
      });
      mainPieEnter = mainPieUpdate.enter().append("g").attr("class", classChartArc);
      mainPieEnter.append('g').attr('class', classArcs);
      mainPieEnter.append("text").attr("dy", $$.hasType('gauge') ? "-.1em" : ".35em").style("opacity", 0).style("text-anchor", "middle").style("pointer-events", "none");
    };
    c3_chart_internal_fn.initArc = function() {
      var $$ = this;
      $$.arcs = $$.main.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartArcs).attr("transform", $$.getTranslate('arc'));
      $$.arcs.append('text').attr('class', CLASS.chartArcsTitle).style("text-anchor", "middle").text($$.getArcTitle());
    };
    c3_chart_internal_fn.redrawArc = function(duration, durationForExit, withTransform) {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config,
          main = $$.main,
          mainArc;
      mainArc = main.selectAll('.' + CLASS.arcs).selectAll('.' + CLASS.arc).data($$.arcData.bind($$));
      mainArc.enter().append('path').attr("class", $$.classArc.bind($$)).style("fill", function(d) {
        return $$.color(d.data);
      }).style("cursor", function(d) {
        return config.interaction_enabled && config.data_selection_isselectable(d) ? "pointer" : null;
      }).style("opacity", 0).each(function(d) {
        if ($$.isGaugeType(d.data)) {
          d.startAngle = d.endAngle = -1 * (Math.PI / 2);
        }
        this._current = d;
      });
      mainArc.attr("transform", function(d) {
        return !$$.isGaugeType(d.data) && withTransform ? "scale(0)" : "";
      }).style("opacity", function(d) {
        return d === this._current ? 0 : 1;
      }).on('mouseover', config.interaction_enabled ? function(d) {
        var updated,
            arcData;
        if ($$.transiting) {
          return;
        }
        updated = $$.updateAngle(d);
        arcData = $$.convertToArcData(updated);
        $$.expandArc(updated.data.id);
        $$.api.focus(updated.data.id);
        $$.toggleFocusLegend(updated.data.id, true);
        $$.config.data_onmouseover(arcData, this);
      } : null).on('mousemove', config.interaction_enabled ? function(d) {
        var updated = $$.updateAngle(d),
            arcData = $$.convertToArcData(updated),
            selectedData = [arcData];
        $$.showTooltip(selectedData, this);
      } : null).on('mouseout', config.interaction_enabled ? function(d) {
        var updated,
            arcData;
        if ($$.transiting) {
          return;
        }
        updated = $$.updateAngle(d);
        arcData = $$.convertToArcData(updated);
        $$.unexpandArc(updated.data.id);
        $$.api.revert();
        $$.revertLegend();
        $$.hideTooltip();
        $$.config.data_onmouseout(arcData, this);
      } : null).on('click', config.interaction_enabled ? function(d, i) {
        var updated = $$.updateAngle(d),
            arcData = $$.convertToArcData(updated);
        if ($$.toggleShape) {
          $$.toggleShape(this, arcData, i);
        }
        $$.config.data_onclick.call($$.api, arcData, this);
      } : null).each(function() {
        $$.transiting = true;
      }).transition().duration(duration).attrTween("d", function(d) {
        var updated = $$.updateAngle(d),
            interpolate;
        if (!updated) {
          return function() {
            return "M 0 0";
          };
        }
        if (isNaN(this._current.startAngle)) {
          this._current.startAngle = 0;
        }
        if (isNaN(this._current.endAngle)) {
          this._current.endAngle = this._current.startAngle;
        }
        interpolate = d3.interpolate(this._current, updated);
        this._current = interpolate(0);
        return function(t) {
          var interpolated = interpolate(t);
          interpolated.data = d.data;
          return $$.getArc(interpolated, true);
        };
      }).attr("transform", withTransform ? "scale(1)" : "").style("fill", function(d) {
        return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data.id);
      }).style("opacity", 1).call($$.endall, function() {
        $$.transiting = false;
      });
      mainArc.exit().transition().duration(durationForExit).style('opacity', 0).remove();
      main.selectAll('.' + CLASS.chartArc).select('text').style("opacity", 0).attr('class', function(d) {
        return $$.isGaugeType(d.data) ? CLASS.gaugeValue : '';
      }).text($$.textForArcLabel.bind($$)).attr("transform", $$.transformForArcLabel.bind($$)).style('font-size', function(d) {
        return $$.isGaugeType(d.data) ? Math.round($$.radius / 5) + 'px' : '';
      }).transition().duration(duration).style("opacity", function(d) {
        return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? 1 : 0;
      });
      main.select('.' + CLASS.chartArcsTitle).style("opacity", $$.hasType('donut') || $$.hasType('gauge') ? 1 : 0);
      if ($$.hasType('gauge')) {
        $$.arcs.select('.' + CLASS.chartArcsBackground).attr("d", function() {
          var d = {
            data: [{value: config.gauge_max}],
            startAngle: -1 * (Math.PI / 2),
            endAngle: Math.PI / 2
          };
          return $$.getArc(d, true, true);
        });
        $$.arcs.select('.' + CLASS.chartArcsGaugeUnit).attr("dy", ".75em").text(config.gauge_label_show ? config.gauge_units : '');
        $$.arcs.select('.' + CLASS.chartArcsGaugeMin).attr("dx", -1 * ($$.innerRadius + (($$.radius - $$.innerRadius) / 2)) + "px").attr("dy", "1.2em").text(config.gauge_label_show ? config.gauge_min : '');
        $$.arcs.select('.' + CLASS.chartArcsGaugeMax).attr("dx", $$.innerRadius + (($$.radius - $$.innerRadius) / 2) + "px").attr("dy", "1.2em").text(config.gauge_label_show ? config.gauge_max : '');
      }
    };
    c3_chart_internal_fn.initGauge = function() {
      var arcs = this.arcs;
      if (this.hasType('gauge')) {
        arcs.append('path').attr("class", CLASS.chartArcsBackground);
        arcs.append("text").attr("class", CLASS.chartArcsGaugeUnit).style("text-anchor", "middle").style("pointer-events", "none");
        arcs.append("text").attr("class", CLASS.chartArcsGaugeMin).style("text-anchor", "middle").style("pointer-events", "none");
        arcs.append("text").attr("class", CLASS.chartArcsGaugeMax).style("text-anchor", "middle").style("pointer-events", "none");
      }
    };
    c3_chart_internal_fn.getGaugeLabelHeight = function() {
      return this.config.gauge_label_show ? 20 : 0;
    };
    c3_chart_internal_fn.initRegion = function() {
      var $$ = this;
      $$.region = $$.main.append('g').attr("clip-path", $$.clipPath).attr("class", CLASS.regions);
    };
    c3_chart_internal_fn.updateRegion = function(duration) {
      var $$ = this,
          config = $$.config;
      $$.region.style('visibility', $$.hasArcType() ? 'hidden' : 'visible');
      $$.mainRegion = $$.main.select('.' + CLASS.regions).selectAll('.' + CLASS.region).data(config.regions);
      $$.mainRegion.enter().append('g').attr('class', $$.classRegion.bind($$)).append('rect').style("fill-opacity", 0);
      $$.mainRegion.exit().transition().duration(duration).style("opacity", 0).remove();
    };
    c3_chart_internal_fn.redrawRegion = function(withTransition) {
      var $$ = this,
          regions = $$.mainRegion.selectAll('rect'),
          x = $$.regionX.bind($$),
          y = $$.regionY.bind($$),
          w = $$.regionWidth.bind($$),
          h = $$.regionHeight.bind($$);
      return [(withTransition ? regions.transition() : regions).attr("x", x).attr("y", y).attr("width", w).attr("height", h).style("fill-opacity", function(d) {
        return isValue(d.opacity) ? d.opacity : 0.1;
      })];
    };
    c3_chart_internal_fn.regionX = function(d) {
      var $$ = this,
          config = $$.config,
          xPos,
          yScale = d.axis === 'y' ? $$.y : $$.y2;
      if (d.axis === 'y' || d.axis === 'y2') {
        xPos = config.axis_rotated ? ('start' in d ? yScale(d.start) : 0) : 0;
      } else {
        xPos = config.axis_rotated ? 0 : ('start' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0);
      }
      return xPos;
    };
    c3_chart_internal_fn.regionY = function(d) {
      var $$ = this,
          config = $$.config,
          yPos,
          yScale = d.axis === 'y' ? $$.y : $$.y2;
      if (d.axis === 'y' || d.axis === 'y2') {
        yPos = config.axis_rotated ? 0 : ('end' in d ? yScale(d.end) : 0);
      } else {
        yPos = config.axis_rotated ? ('start' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0) : 0;
      }
      return yPos;
    };
    c3_chart_internal_fn.regionWidth = function(d) {
      var $$ = this,
          config = $$.config,
          start = $$.regionX(d),
          end,
          yScale = d.axis === 'y' ? $$.y : $$.y2;
      if (d.axis === 'y' || d.axis === 'y2') {
        end = config.axis_rotated ? ('end' in d ? yScale(d.end) : $$.width) : $$.width;
      } else {
        end = config.axis_rotated ? $$.width : ('end' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end) : $$.width);
      }
      return end < start ? 0 : end - start;
    };
    c3_chart_internal_fn.regionHeight = function(d) {
      var $$ = this,
          config = $$.config,
          start = this.regionY(d),
          end,
          yScale = d.axis === 'y' ? $$.y : $$.y2;
      if (d.axis === 'y' || d.axis === 'y2') {
        end = config.axis_rotated ? $$.height : ('start' in d ? yScale(d.start) : $$.height);
      } else {
        end = config.axis_rotated ? ('end' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end) : $$.height) : $$.height;
      }
      return end < start ? 0 : end - start;
    };
    c3_chart_internal_fn.isRegionOnX = function(d) {
      return !d.axis || d.axis === 'x';
    };
    c3_chart_internal_fn.drag = function(mouse) {
      var $$ = this,
          config = $$.config,
          main = $$.main,
          d3 = $$.d3;
      var sx,
          sy,
          mx,
          my,
          minX,
          maxX,
          minY,
          maxY;
      if ($$.hasArcType()) {
        return;
      }
      if (!config.data_selection_enabled) {
        return;
      }
      if (config.zoom_enabled && !$$.zoom.altDomain) {
        return;
      }
      if (!config.data_selection_multiple) {
        return;
      }
      sx = $$.dragStart[0];
      sy = $$.dragStart[1];
      mx = mouse[0];
      my = mouse[1];
      minX = Math.min(sx, mx);
      maxX = Math.max(sx, mx);
      minY = (config.data_selection_grouped) ? $$.margin.top : Math.min(sy, my);
      maxY = (config.data_selection_grouped) ? $$.height : Math.max(sy, my);
      main.select('.' + CLASS.dragarea).attr('x', minX).attr('y', minY).attr('width', maxX - minX).attr('height', maxY - minY);
      main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).filter(function(d) {
        return config.data_selection_isselectable(d);
      }).each(function(d, i) {
        var shape = d3.select(this),
            isSelected = shape.classed(CLASS.SELECTED),
            isIncluded = shape.classed(CLASS.INCLUDED),
            _x,
            _y,
            _w,
            _h,
            toggle,
            isWithin = false,
            box;
        if (shape.classed(CLASS.circle)) {
          _x = shape.attr("cx") * 1;
          _y = shape.attr("cy") * 1;
          toggle = $$.togglePoint;
          isWithin = minX < _x && _x < maxX && minY < _y && _y < maxY;
        } else if (shape.classed(CLASS.bar)) {
          box = getPathBox(this);
          _x = box.x;
          _y = box.y;
          _w = box.width;
          _h = box.height;
          toggle = $$.togglePath;
          isWithin = !(maxX < _x || _x + _w < minX) && !(maxY < _y || _y + _h < minY);
        } else {
          return;
        }
        if (isWithin ^ isIncluded) {
          shape.classed(CLASS.INCLUDED, !isIncluded);
          shape.classed(CLASS.SELECTED, !isSelected);
          toggle.call($$, !isSelected, shape, d, i);
        }
      });
    };
    c3_chart_internal_fn.dragstart = function(mouse) {
      var $$ = this,
          config = $$.config;
      if ($$.hasArcType()) {
        return;
      }
      if (!config.data_selection_enabled) {
        return;
      }
      $$.dragStart = mouse;
      $$.main.select('.' + CLASS.chart).append('rect').attr('class', CLASS.dragarea).style('opacity', 0.1);
      $$.dragging = true;
    };
    c3_chart_internal_fn.dragend = function() {
      var $$ = this,
          config = $$.config;
      if ($$.hasArcType()) {
        return;
      }
      if (!config.data_selection_enabled) {
        return;
      }
      $$.main.select('.' + CLASS.dragarea).transition().duration(100).style('opacity', 0).remove();
      $$.main.selectAll('.' + CLASS.shape).classed(CLASS.INCLUDED, false);
      $$.dragging = false;
    };
    c3_chart_internal_fn.selectPoint = function(target, d, i) {
      var $$ = this,
          config = $$.config,
          cx = (config.axis_rotated ? $$.circleY : $$.circleX).bind($$),
          cy = (config.axis_rotated ? $$.circleX : $$.circleY).bind($$),
          r = $$.pointSelectR.bind($$);
      config.data_onselected.call($$.api, d, target.node());
      $$.main.select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll('.' + CLASS.selectedCircle + '-' + i).data([d]).enter().append('circle').attr("class", function() {
        return $$.generateClass(CLASS.selectedCircle, i);
      }).attr("cx", cx).attr("cy", cy).attr("stroke", function() {
        return $$.color(d);
      }).attr("r", function(d) {
        return $$.pointSelectR(d) * 1.4;
      }).transition().duration(100).attr("r", r);
    };
    c3_chart_internal_fn.unselectPoint = function(target, d, i) {
      var $$ = this;
      $$.config.data_onunselected(d, target.node());
      $$.main.select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll('.' + CLASS.selectedCircle + '-' + i).transition().duration(100).attr('r', 0).remove();
    };
    c3_chart_internal_fn.togglePoint = function(selected, target, d, i) {
      selected ? this.selectPoint(target, d, i) : this.unselectPoint(target, d, i);
    };
    c3_chart_internal_fn.selectPath = function(target, d) {
      var $$ = this;
      $$.config.data_onselected.call($$, d, target.node());
      target.transition().duration(100).style("fill", function() {
        return $$.d3.rgb($$.color(d)).brighter(0.75);
      });
    };
    c3_chart_internal_fn.unselectPath = function(target, d) {
      var $$ = this;
      $$.config.data_onunselected.call($$, d, target.node());
      target.transition().duration(100).style("fill", function() {
        return $$.color(d);
      });
    };
    c3_chart_internal_fn.togglePath = function(selected, target, d, i) {
      selected ? this.selectPath(target, d, i) : this.unselectPath(target, d, i);
    };
    c3_chart_internal_fn.getToggle = function(that, d) {
      var $$ = this,
          toggle;
      if (that.nodeName === 'circle') {
        if ($$.isStepType(d)) {
          toggle = function() {};
        } else {
          toggle = $$.togglePoint;
        }
      } else if (that.nodeName === 'path') {
        toggle = $$.togglePath;
      }
      return toggle;
    };
    c3_chart_internal_fn.toggleShape = function(that, d, i) {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config,
          shape = d3.select(that),
          isSelected = shape.classed(CLASS.SELECTED),
          toggle = $$.getToggle(that, d).bind($$);
      if (config.data_selection_enabled && config.data_selection_isselectable(d)) {
        if (!config.data_selection_multiple) {
          $$.main.selectAll('.' + CLASS.shapes + (config.data_selection_grouped ? $$.getTargetSelectorSuffix(d.id) : "")).selectAll('.' + CLASS.shape).each(function(d, i) {
            var shape = d3.select(this);
            if (shape.classed(CLASS.SELECTED)) {
              toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
            }
          });
        }
        shape.classed(CLASS.SELECTED, !isSelected);
        toggle(!isSelected, shape, d, i);
      }
    };
    c3_chart_internal_fn.initBrush = function() {
      var $$ = this,
          d3 = $$.d3;
      $$.brush = d3.svg.brush().on("brush", function() {
        $$.redrawForBrush();
      });
      $$.brush.update = function() {
        if ($$.context) {
          $$.context.select('.' + CLASS.brush).call(this);
        }
        return this;
      };
      $$.brush.scale = function(scale) {
        return $$.config.axis_rotated ? this.y(scale) : this.x(scale);
      };
    };
    c3_chart_internal_fn.initSubchart = function() {
      var $$ = this,
          config = $$.config,
          context = $$.context = $$.svg.append("g").attr("transform", $$.getTranslate('context'));
      context.style('visibility', config.subchart_show ? 'visible' : 'hidden');
      context.append('g').attr("clip-path", $$.clipPathForSubchart).attr('class', CLASS.chart);
      context.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartBars);
      context.select('.' + CLASS.chart).append("g").attr("class", CLASS.chartLines);
      context.append("g").attr("clip-path", $$.clipPath).attr("class", CLASS.brush).call($$.brush);
      $$.axes.subx = context.append("g").attr("class", CLASS.axisX).attr("transform", $$.getTranslate('subx')).attr("clip-path", config.axis_rotated ? "" : $$.clipPathForXAxis);
    };
    c3_chart_internal_fn.updateTargetsForSubchart = function(targets) {
      var $$ = this,
          context = $$.context,
          config = $$.config,
          contextLineEnter,
          contextLineUpdate,
          contextBarEnter,
          contextBarUpdate,
          classChartBar = $$.classChartBar.bind($$),
          classBars = $$.classBars.bind($$),
          classChartLine = $$.classChartLine.bind($$),
          classLines = $$.classLines.bind($$),
          classAreas = $$.classAreas.bind($$);
      if (config.subchart_show) {
        contextBarUpdate = context.select('.' + CLASS.chartBars).selectAll('.' + CLASS.chartBar).data(targets).attr('class', classChartBar);
        contextBarEnter = contextBarUpdate.enter().append('g').style('opacity', 0).attr('class', classChartBar);
        contextBarEnter.append('g').attr("class", classBars);
        contextLineUpdate = context.select('.' + CLASS.chartLines).selectAll('.' + CLASS.chartLine).data(targets).attr('class', classChartLine);
        contextLineEnter = contextLineUpdate.enter().append('g').style('opacity', 0).attr('class', classChartLine);
        contextLineEnter.append("g").attr("class", classLines);
        contextLineEnter.append("g").attr("class", classAreas);
        context.selectAll('.' + CLASS.brush + ' rect').attr(config.axis_rotated ? "width" : "height", config.axis_rotated ? $$.width2 : $$.height2);
      }
    };
    c3_chart_internal_fn.updateBarForSubchart = function(durationForExit) {
      var $$ = this;
      $$.contextBar = $$.context.selectAll('.' + CLASS.bars).selectAll('.' + CLASS.bar).data($$.barData.bind($$));
      $$.contextBar.enter().append('path').attr("class", $$.classBar.bind($$)).style("stroke", 'none').style("fill", $$.color);
      $$.contextBar.style("opacity", $$.initialOpacity.bind($$));
      $$.contextBar.exit().transition().duration(durationForExit).style('opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawBarForSubchart = function(drawBarOnSub, withTransition, duration) {
      (withTransition ? this.contextBar.transition().duration(duration) : this.contextBar).attr('d', drawBarOnSub).style('opacity', 1);
    };
    c3_chart_internal_fn.updateLineForSubchart = function(durationForExit) {
      var $$ = this;
      $$.contextLine = $$.context.selectAll('.' + CLASS.lines).selectAll('.' + CLASS.line).data($$.lineData.bind($$));
      $$.contextLine.enter().append('path').attr('class', $$.classLine.bind($$)).style('stroke', $$.color);
      $$.contextLine.style("opacity", $$.initialOpacity.bind($$));
      $$.contextLine.exit().transition().duration(durationForExit).style('opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawLineForSubchart = function(drawLineOnSub, withTransition, duration) {
      (withTransition ? this.contextLine.transition().duration(duration) : this.contextLine).attr("d", drawLineOnSub).style('opacity', 1);
    };
    c3_chart_internal_fn.updateAreaForSubchart = function(durationForExit) {
      var $$ = this,
          d3 = $$.d3;
      $$.contextArea = $$.context.selectAll('.' + CLASS.areas).selectAll('.' + CLASS.area).data($$.lineData.bind($$));
      $$.contextArea.enter().append('path').attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function() {
        $$.orgAreaOpacity = +d3.select(this).style('opacity');
        return 0;
      });
      $$.contextArea.style("opacity", 0);
      $$.contextArea.exit().transition().duration(durationForExit).style('opacity', 0).remove();
    };
    c3_chart_internal_fn.redrawAreaForSubchart = function(drawAreaOnSub, withTransition, duration) {
      (withTransition ? this.contextArea.transition().duration(duration) : this.contextArea).attr("d", drawAreaOnSub).style("fill", this.color).style("opacity", this.orgAreaOpacity);
    };
    c3_chart_internal_fn.redrawSubchart = function(withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices) {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config,
          drawAreaOnSub,
          drawBarOnSub,
          drawLineOnSub;
      $$.context.style('visibility', config.subchart_show ? 'visible' : 'hidden');
      if (config.subchart_show) {
        if (d3.event && d3.event.type === 'zoom') {
          $$.brush.extent($$.x.orgDomain()).update();
        }
        if (withSubchart) {
          if (!$$.brush.empty()) {
            $$.brush.extent($$.x.orgDomain()).update();
          }
          drawAreaOnSub = $$.generateDrawArea(areaIndices, true);
          drawBarOnSub = $$.generateDrawBar(barIndices, true);
          drawLineOnSub = $$.generateDrawLine(lineIndices, true);
          $$.updateBarForSubchart(duration);
          $$.updateLineForSubchart(duration);
          $$.updateAreaForSubchart(duration);
          $$.redrawBarForSubchart(drawBarOnSub, duration, duration);
          $$.redrawLineForSubchart(drawLineOnSub, duration, duration);
          $$.redrawAreaForSubchart(drawAreaOnSub, duration, duration);
        }
      }
    };
    c3_chart_internal_fn.redrawForBrush = function() {
      var $$ = this,
          x = $$.x;
      $$.redraw({
        withTransition: false,
        withY: $$.config.zoom_rescale,
        withSubchart: false,
        withUpdateXDomain: true,
        withDimension: false
      });
      $$.config.subchart_onbrush.call($$.api, x.orgDomain());
    };
    c3_chart_internal_fn.transformContext = function(withTransition, transitions) {
      var $$ = this,
          subXAxis;
      if (transitions && transitions.axisSubX) {
        subXAxis = transitions.axisSubX;
      } else {
        subXAxis = $$.context.select('.' + CLASS.axisX);
        if (withTransition) {
          subXAxis = subXAxis.transition();
        }
      }
      $$.context.attr("transform", $$.getTranslate('context'));
      subXAxis.attr("transform", $$.getTranslate('subx'));
    };
    c3_chart_internal_fn.getDefaultExtent = function() {
      var $$ = this,
          config = $$.config,
          extent = isFunction(config.axis_x_extent) ? config.axis_x_extent($$.getXDomain($$.data.targets)) : config.axis_x_extent;
      if ($$.isTimeSeries()) {
        extent = [$$.parseDate(extent[0]), $$.parseDate(extent[1])];
      }
      return extent;
    };
    c3_chart_internal_fn.initZoom = function() {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config,
          startEvent;
      $$.zoom = d3.behavior.zoom().on("zoomstart", function() {
        startEvent = d3.event.sourceEvent;
        $$.zoom.altDomain = d3.event.sourceEvent.altKey ? $$.x.orgDomain() : null;
        config.zoom_onzoomstart.call($$.api, d3.event.sourceEvent);
      }).on("zoom", function() {
        $$.redrawForZoom.call($$);
      }).on('zoomend', function() {
        var event = d3.event.sourceEvent;
        if (event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY) {
          return;
        }
        $$.redrawEventRect();
        $$.updateZoom();
        config.zoom_onzoomend.call($$.api, $$.x.orgDomain());
      });
      $$.zoom.scale = function(scale) {
        return config.axis_rotated ? this.y(scale) : this.x(scale);
      };
      $$.zoom.orgScaleExtent = function() {
        var extent = config.zoom_extent ? config.zoom_extent : [1, 10];
        return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];
      };
      $$.zoom.updateScaleExtent = function() {
        var ratio = diffDomain($$.x.orgDomain()) / diffDomain($$.orgXDomain),
            extent = this.orgScaleExtent();
        this.scaleExtent([extent[0] * ratio, extent[1] * ratio]);
        return this;
      };
    };
    c3_chart_internal_fn.updateZoom = function() {
      var $$ = this,
          z = $$.config.zoom_enabled ? $$.zoom : function() {};
      $$.main.select('.' + CLASS.zoomRect).call(z).on("dblclick.zoom", null);
      $$.main.selectAll('.' + CLASS.eventRect).call(z).on("dblclick.zoom", null);
    };
    c3_chart_internal_fn.redrawForZoom = function() {
      var $$ = this,
          d3 = $$.d3,
          config = $$.config,
          zoom = $$.zoom,
          x = $$.x;
      if (!config.zoom_enabled) {
        return;
      }
      if ($$.filterTargetsToShow($$.data.targets).length === 0) {
        return;
      }
      if (d3.event.sourceEvent.type === 'mousemove' && zoom.altDomain) {
        x.domain(zoom.altDomain);
        zoom.scale(x).updateScaleExtent();
        return;
      }
      if ($$.isCategorized() && x.orgDomain()[0] === $$.orgXDomain[0]) {
        x.domain([$$.orgXDomain[0] - 1e-10, x.orgDomain()[1]]);
      }
      $$.redraw({
        withTransition: false,
        withY: config.zoom_rescale,
        withSubchart: false,
        withEventRect: false,
        withDimension: false
      });
      if (d3.event.sourceEvent.type === 'mousemove') {
        $$.cancelClick = true;
      }
      config.zoom_onzoom.call($$.api, x.orgDomain());
    };
    c3_chart_internal_fn.generateColor = function() {
      var $$ = this,
          config = $$.config,
          d3 = $$.d3,
          colors = config.data_colors,
          pattern = notEmpty(config.color_pattern) ? config.color_pattern : d3.scale.category10().range(),
          callback = config.data_color,
          ids = [];
      return function(d) {
        var id = d.id || (d.data && d.data.id) || d,
            color;
        if (colors[id] instanceof Function) {
          color = colors[id](d);
        } else if (colors[id]) {
          color = colors[id];
        } else {
          if (ids.indexOf(id) < 0) {
            ids.push(id);
          }
          color = pattern[ids.indexOf(id) % pattern.length];
          colors[id] = color;
        }
        return callback instanceof Function ? callback(color, d) : color;
      };
    };
    c3_chart_internal_fn.generateLevelColor = function() {
      var $$ = this,
          config = $$.config,
          colors = config.color_pattern,
          threshold = config.color_threshold,
          asValue = threshold.unit === 'value',
          values = threshold.values && threshold.values.length ? threshold.values : [],
          max = threshold.max || 100;
      return notEmpty(config.color_threshold) ? function(value) {
        var i,
            v,
            color = colors[colors.length - 1];
        for (i = 0; i < values.length; i++) {
          v = asValue ? value : (value * 100 / max);
          if (v < values[i]) {
            color = colors[i];
            break;
          }
        }
        return color;
      } : null;
    };
    c3_chart_internal_fn.getYFormat = function(forArc) {
      var $$ = this,
          formatForY = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.yFormat,
          formatForY2 = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.y2Format;
      return function(v, ratio, id) {
        var format = $$.axis.getId(id) === 'y2' ? formatForY2 : formatForY;
        return format.call($$, v, ratio);
      };
    };
    c3_chart_internal_fn.yFormat = function(v) {
      var $$ = this,
          config = $$.config,
          format = config.axis_y_tick_format ? config.axis_y_tick_format : $$.defaultValueFormat;
      return format(v);
    };
    c3_chart_internal_fn.y2Format = function(v) {
      var $$ = this,
          config = $$.config,
          format = config.axis_y2_tick_format ? config.axis_y2_tick_format : $$.defaultValueFormat;
      return format(v);
    };
    c3_chart_internal_fn.defaultValueFormat = function(v) {
      return isValue(v) ? +v : "";
    };
    c3_chart_internal_fn.defaultArcValueFormat = function(v, ratio) {
      return (ratio * 100).toFixed(1) + '%';
    };
    c3_chart_internal_fn.dataLabelFormat = function(targetId) {
      var $$ = this,
          data_labels = $$.config.data_labels,
          format,
          defaultFormat = function(v) {
            return isValue(v) ? +v : "";
          };
      if (typeof data_labels.format === 'function') {
        format = data_labels.format;
      } else if (typeof data_labels.format === 'object') {
        if (data_labels.format[targetId]) {
          format = data_labels.format[targetId] === true ? defaultFormat : data_labels.format[targetId];
        } else {
          format = function() {
            return '';
          };
        }
      } else {
        format = defaultFormat;
      }
      return format;
    };
    c3_chart_internal_fn.hasCaches = function(ids) {
      for (var i = 0; i < ids.length; i++) {
        if (!(ids[i] in this.cache)) {
          return false;
        }
      }
      return true;
    };
    c3_chart_internal_fn.addCache = function(id, target) {
      this.cache[id] = this.cloneTarget(target);
    };
    c3_chart_internal_fn.getCaches = function(ids) {
      var targets = [],
          i;
      for (i = 0; i < ids.length; i++) {
        if (ids[i] in this.cache) {
          targets.push(this.cloneTarget(this.cache[ids[i]]));
        }
      }
      return targets;
    };
    var CLASS = c3_chart_internal_fn.CLASS = {
      target: 'c3-target',
      chart: 'c3-chart',
      chartLine: 'c3-chart-line',
      chartLines: 'c3-chart-lines',
      chartBar: 'c3-chart-bar',
      chartBars: 'c3-chart-bars',
      chartText: 'c3-chart-text',
      chartTexts: 'c3-chart-texts',
      chartArc: 'c3-chart-arc',
      chartArcs: 'c3-chart-arcs',
      chartArcsTitle: 'c3-chart-arcs-title',
      chartArcsBackground: 'c3-chart-arcs-background',
      chartArcsGaugeUnit: 'c3-chart-arcs-gauge-unit',
      chartArcsGaugeMax: 'c3-chart-arcs-gauge-max',
      chartArcsGaugeMin: 'c3-chart-arcs-gauge-min',
      selectedCircle: 'c3-selected-circle',
      selectedCircles: 'c3-selected-circles',
      eventRect: 'c3-event-rect',
      eventRects: 'c3-event-rects',
      eventRectsSingle: 'c3-event-rects-single',
      eventRectsMultiple: 'c3-event-rects-multiple',
      zoomRect: 'c3-zoom-rect',
      brush: 'c3-brush',
      focused: 'c3-focused',
      defocused: 'c3-defocused',
      region: 'c3-region',
      regions: 'c3-regions',
      tooltipContainer: 'c3-tooltip-container',
      tooltip: 'c3-tooltip',
      tooltipName: 'c3-tooltip-name',
      shape: 'c3-shape',
      shapes: 'c3-shapes',
      line: 'c3-line',
      lines: 'c3-lines',
      bar: 'c3-bar',
      bars: 'c3-bars',
      circle: 'c3-circle',
      circles: 'c3-circles',
      arc: 'c3-arc',
      arcs: 'c3-arcs',
      area: 'c3-area',
      areas: 'c3-areas',
      empty: 'c3-empty',
      text: 'c3-text',
      texts: 'c3-texts',
      gaugeValue: 'c3-gauge-value',
      grid: 'c3-grid',
      gridLines: 'c3-grid-lines',
      xgrid: 'c3-xgrid',
      xgrids: 'c3-xgrids',
      xgridLine: 'c3-xgrid-line',
      xgridLines: 'c3-xgrid-lines',
      xgridFocus: 'c3-xgrid-focus',
      ygrid: 'c3-ygrid',
      ygrids: 'c3-ygrids',
      ygridLine: 'c3-ygrid-line',
      ygridLines: 'c3-ygrid-lines',
      axis: 'c3-axis',
      axisX: 'c3-axis-x',
      axisXLabel: 'c3-axis-x-label',
      axisY: 'c3-axis-y',
      axisYLabel: 'c3-axis-y-label',
      axisY2: 'c3-axis-y2',
      axisY2Label: 'c3-axis-y2-label',
      legendBackground: 'c3-legend-background',
      legendItem: 'c3-legend-item',
      legendItemEvent: 'c3-legend-item-event',
      legendItemTile: 'c3-legend-item-tile',
      legendItemHidden: 'c3-legend-item-hidden',
      legendItemFocused: 'c3-legend-item-focused',
      dragarea: 'c3-dragarea',
      EXPANDED: '_expanded_',
      SELECTED: '_selected_',
      INCLUDED: '_included_'
    };
    c3_chart_internal_fn.generateClass = function(prefix, targetId) {
      return " " + prefix + " " + prefix + this.getTargetSelectorSuffix(targetId);
    };
    c3_chart_internal_fn.classText = function(d) {
      return this.generateClass(CLASS.text, d.index);
    };
    c3_chart_internal_fn.classTexts = function(d) {
      return this.generateClass(CLASS.texts, d.id);
    };
    c3_chart_internal_fn.classShape = function(d) {
      return this.generateClass(CLASS.shape, d.index);
    };
    c3_chart_internal_fn.classShapes = function(d) {
      return this.generateClass(CLASS.shapes, d.id);
    };
    c3_chart_internal_fn.classLine = function(d) {
      return this.classShape(d) + this.generateClass(CLASS.line, d.id);
    };
    c3_chart_internal_fn.classLines = function(d) {
      return this.classShapes(d) + this.generateClass(CLASS.lines, d.id);
    };
    c3_chart_internal_fn.classCircle = function(d) {
      return this.classShape(d) + this.generateClass(CLASS.circle, d.index);
    };
    c3_chart_internal_fn.classCircles = function(d) {
      return this.classShapes(d) + this.generateClass(CLASS.circles, d.id);
    };
    c3_chart_internal_fn.classBar = function(d) {
      return this.classShape(d) + this.generateClass(CLASS.bar, d.index);
    };
    c3_chart_internal_fn.classBars = function(d) {
      return this.classShapes(d) + this.generateClass(CLASS.bars, d.id);
    };
    c3_chart_internal_fn.classArc = function(d) {
      return this.classShape(d.data) + this.generateClass(CLASS.arc, d.data.id);
    };
    c3_chart_internal_fn.classArcs = function(d) {
      return this.classShapes(d.data) + this.generateClass(CLASS.arcs, d.data.id);
    };
    c3_chart_internal_fn.classArea = function(d) {
      return this.classShape(d) + this.generateClass(CLASS.area, d.id);
    };
    c3_chart_internal_fn.classAreas = function(d) {
      return this.classShapes(d) + this.generateClass(CLASS.areas, d.id);
    };
    c3_chart_internal_fn.classRegion = function(d, i) {
      return this.generateClass(CLASS.region, i) + ' ' + ('class' in d ? d['class'] : '');
    };
    c3_chart_internal_fn.classEvent = function(d) {
      return this.generateClass(CLASS.eventRect, d.index);
    };
    c3_chart_internal_fn.classTarget = function(id) {
      var $$ = this;
      var additionalClassSuffix = $$.config.data_classes[id],
          additionalClass = '';
      if (additionalClassSuffix) {
        additionalClass = ' ' + CLASS.target + '-' + additionalClassSuffix;
      }
      return $$.generateClass(CLASS.target, id) + additionalClass;
    };
    c3_chart_internal_fn.classFocus = function(d) {
      return this.classFocused(d) + this.classDefocused(d);
    };
    c3_chart_internal_fn.classFocused = function(d) {
      return ' ' + (this.focusedTargetIds.indexOf(d.id) >= 0 ? CLASS.focused : '');
    };
    c3_chart_internal_fn.classDefocused = function(d) {
      return ' ' + (this.defocusedTargetIds.indexOf(d.id) >= 0 ? CLASS.defocused : '');
    };
    c3_chart_internal_fn.classChartText = function(d) {
      return CLASS.chartText + this.classTarget(d.id);
    };
    c3_chart_internal_fn.classChartLine = function(d) {
      return CLASS.chartLine + this.classTarget(d.id);
    };
    c3_chart_internal_fn.classChartBar = function(d) {
      return CLASS.chartBar + this.classTarget(d.id);
    };
    c3_chart_internal_fn.classChartArc = function(d) {
      return CLASS.chartArc + this.classTarget(d.data.id);
    };
    c3_chart_internal_fn.getTargetSelectorSuffix = function(targetId) {
      return targetId || targetId === 0 ? ('-' + targetId).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, '-') : '';
    };
    c3_chart_internal_fn.selectorTarget = function(id, prefix) {
      return (prefix || '') + '.' + CLASS.target + this.getTargetSelectorSuffix(id);
    };
    c3_chart_internal_fn.selectorTargets = function(ids, prefix) {
      var $$ = this;
      ids = ids || [];
      return ids.length ? ids.map(function(id) {
        return $$.selectorTarget(id, prefix);
      }) : null;
    };
    c3_chart_internal_fn.selectorLegend = function(id) {
      return '.' + CLASS.legendItem + this.getTargetSelectorSuffix(id);
    };
    c3_chart_internal_fn.selectorLegends = function(ids) {
      var $$ = this;
      return ids && ids.length ? ids.map(function(id) {
        return $$.selectorLegend(id);
      }) : null;
    };
    var isValue = c3_chart_internal_fn.isValue = function(v) {
      return v || v === 0;
    },
        isFunction = c3_chart_internal_fn.isFunction = function(o) {
          return typeof o === 'function';
        },
        isString = c3_chart_internal_fn.isString = function(o) {
          return typeof o === 'string';
        },
        isUndefined = c3_chart_internal_fn.isUndefined = function(v) {
          return typeof v === 'undefined';
        },
        isDefined = c3_chart_internal_fn.isDefined = function(v) {
          return typeof v !== 'undefined';
        },
        ceil10 = c3_chart_internal_fn.ceil10 = function(v) {
          return Math.ceil(v / 10) * 10;
        },
        asHalfPixel = c3_chart_internal_fn.asHalfPixel = function(n) {
          return Math.ceil(n) + 0.5;
        },
        diffDomain = c3_chart_internal_fn.diffDomain = function(d) {
          return d[1] - d[0];
        },
        isEmpty = c3_chart_internal_fn.isEmpty = function(o) {
          return !o || (isString(o) && o.length === 0) || (typeof o === 'object' && Object.keys(o).length === 0);
        },
        notEmpty = c3_chart_internal_fn.notEmpty = function(o) {
          return Object.keys(o).length > 0;
        },
        getOption = c3_chart_internal_fn.getOption = function(options, key, defaultValue) {
          return isDefined(options[key]) ? options[key] : defaultValue;
        },
        hasValue = c3_chart_internal_fn.hasValue = function(dict, value) {
          var found = false;
          Object.keys(dict).forEach(function(key) {
            if (dict[key] === value) {
              found = true;
            }
          });
          return found;
        },
        getPathBox = c3_chart_internal_fn.getPathBox = function(path) {
          var box = path.getBoundingClientRect(),
              items = [path.pathSegList.getItem(0), path.pathSegList.getItem(1)],
              minX = items[0].x,
              minY = Math.min(items[0].y, items[1].y);
          return {
            x: minX,
            y: minY,
            width: box.width,
            height: box.height
          };
        };
    c3_chart_fn.focus = function(targetIds) {
      var $$ = this.internal,
          candidates;
      targetIds = $$.mapToTargetIds(targetIds);
      candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$))), this.revert();
      this.defocus();
      candidates.classed(CLASS.focused, true).classed(CLASS.defocused, false);
      if ($$.hasArcType()) {
        $$.expandArc(targetIds);
      }
      $$.toggleFocusLegend(targetIds, true);
      $$.focusedTargetIds = targetIds;
      $$.defocusedTargetIds = $$.defocusedTargetIds.filter(function(id) {
        return targetIds.indexOf(id) < 0;
      });
    };
    c3_chart_fn.defocus = function(targetIds) {
      var $$ = this.internal,
          candidates;
      targetIds = $$.mapToTargetIds(targetIds);
      candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$))), candidates.classed(CLASS.focused, false).classed(CLASS.defocused, true);
      if ($$.hasArcType()) {
        $$.unexpandArc(targetIds);
      }
      $$.toggleFocusLegend(targetIds, false);
      $$.focusedTargetIds = $$.focusedTargetIds.filter(function(id) {
        return targetIds.indexOf(id) < 0;
      });
      $$.defocusedTargetIds = targetIds;
    };
    c3_chart_fn.revert = function(targetIds) {
      var $$ = this.internal,
          candidates;
      targetIds = $$.mapToTargetIds(targetIds);
      candidates = $$.svg.selectAll($$.selectorTargets(targetIds));
      candidates.classed(CLASS.focused, false).classed(CLASS.defocused, false);
      if ($$.hasArcType()) {
        $$.unexpandArc(targetIds);
      }
      if ($$.config.legend_show) {
        $$.showLegend(targetIds.filter($$.isLegendToShow.bind($$)));
        $$.legend.selectAll($$.selectorLegends(targetIds)).filter(function() {
          return $$.d3.select(this).classed(CLASS.legendItemFocused);
        }).classed(CLASS.legendItemFocused, false);
      }
      $$.focusedTargetIds = [];
      $$.defocusedTargetIds = [];
    };
    c3_chart_fn.show = function(targetIds, options) {
      var $$ = this.internal,
          targets;
      targetIds = $$.mapToTargetIds(targetIds);
      options = options || {};
      $$.removeHiddenTargetIds(targetIds);
      targets = $$.svg.selectAll($$.selectorTargets(targetIds));
      targets.transition().style('opacity', 1, 'important').call($$.endall, function() {
        targets.style('opacity', null).style('opacity', 1);
      });
      if (options.withLegend) {
        $$.showLegend(targetIds);
      }
      $$.redraw({
        withUpdateOrgXDomain: true,
        withUpdateXDomain: true,
        withLegend: true
      });
    };
    c3_chart_fn.hide = function(targetIds, options) {
      var $$ = this.internal,
          targets;
      targetIds = $$.mapToTargetIds(targetIds);
      options = options || {};
      $$.addHiddenTargetIds(targetIds);
      targets = $$.svg.selectAll($$.selectorTargets(targetIds));
      targets.transition().style('opacity', 0, 'important').call($$.endall, function() {
        targets.style('opacity', null).style('opacity', 0);
      });
      if (options.withLegend) {
        $$.hideLegend(targetIds);
      }
      $$.redraw({
        withUpdateOrgXDomain: true,
        withUpdateXDomain: true,
        withLegend: true
      });
    };
    c3_chart_fn.toggle = function(targetIds, options) {
      var that = this,
          $$ = this.internal;
      $$.mapToTargetIds(targetIds).forEach(function(targetId) {
        $$.isTargetToShow(targetId) ? that.hide(targetId, options) : that.show(targetId, options);
      });
    };
    c3_chart_fn.zoom = function(domain) {
      var $$ = this.internal;
      if (domain) {
        if ($$.isTimeSeries()) {
          domain = domain.map(function(x) {
            return $$.parseDate(x);
          });
        }
        $$.brush.extent(domain);
        $$.redraw({
          withUpdateXDomain: true,
          withY: $$.config.zoom_rescale
        });
        $$.config.zoom_onzoom.call(this, $$.x.orgDomain());
      }
      return $$.brush.extent();
    };
    c3_chart_fn.zoom.enable = function(enabled) {
      var $$ = this.internal;
      $$.config.zoom_enabled = enabled;
      $$.updateAndRedraw();
    };
    c3_chart_fn.unzoom = function() {
      var $$ = this.internal;
      $$.brush.clear().update();
      $$.redraw({withUpdateXDomain: true});
    };
    c3_chart_fn.load = function(args) {
      var $$ = this.internal,
          config = $$.config;
      if (args.xs) {
        $$.addXs(args.xs);
      }
      if ('classes' in args) {
        Object.keys(args.classes).forEach(function(id) {
          config.data_classes[id] = args.classes[id];
        });
      }
      if ('categories' in args && $$.isCategorized()) {
        config.axis_x_categories = args.categories;
      }
      if ('axes' in args) {
        Object.keys(args.axes).forEach(function(id) {
          config.data_axes[id] = args.axes[id];
        });
      }
      if ('colors' in args) {
        Object.keys(args.colors).forEach(function(id) {
          config.data_colors[id] = args.colors[id];
        });
      }
      if ('cacheIds' in args && $$.hasCaches(args.cacheIds)) {
        $$.load($$.getCaches(args.cacheIds), args.done);
        return;
      }
      if ('unload' in args) {
        $$.unload($$.mapToTargetIds((typeof args.unload === 'boolean' && args.unload) ? null : args.unload), function() {
          $$.loadFromArgs(args);
        });
      } else {
        $$.loadFromArgs(args);
      }
    };
    c3_chart_fn.unload = function(args) {
      var $$ = this.internal;
      args = args || {};
      if (args instanceof Array) {
        args = {ids: args};
      } else if (typeof args === 'string') {
        args = {ids: [args]};
      }
      $$.unload($$.mapToTargetIds(args.ids), function() {
        $$.redraw({
          withUpdateOrgXDomain: true,
          withUpdateXDomain: true,
          withLegend: true
        });
        if (args.done) {
          args.done();
        }
      });
    };
    c3_chart_fn.flow = function(args) {
      var $$ = this.internal,
          targets,
          data,
          notfoundIds = [],
          orgDataCount = $$.getMaxDataCount(),
          dataCount,
          domain,
          baseTarget,
          baseValue,
          length = 0,
          tail = 0,
          diff,
          to;
      if (args.json) {
        data = $$.convertJsonToData(args.json, args.keys);
      } else if (args.rows) {
        data = $$.convertRowsToData(args.rows);
      } else if (args.columns) {
        data = $$.convertColumnsToData(args.columns);
      } else {
        return;
      }
      targets = $$.convertDataToTargets(data, true);
      $$.data.targets.forEach(function(t) {
        var found = false,
            i,
            j;
        for (i = 0; i < targets.length; i++) {
          if (t.id === targets[i].id) {
            found = true;
            if (t.values[t.values.length - 1]) {
              tail = t.values[t.values.length - 1].index + 1;
            }
            length = targets[i].values.length;
            for (j = 0; j < length; j++) {
              targets[i].values[j].index = tail + j;
              if (!$$.isTimeSeries()) {
                targets[i].values[j].x = tail + j;
              }
            }
            t.values = t.values.concat(targets[i].values);
            targets.splice(i, 1);
            break;
          }
        }
        if (!found) {
          notfoundIds.push(t.id);
        }
      });
      $$.data.targets.forEach(function(t) {
        var i,
            j;
        for (i = 0; i < notfoundIds.length; i++) {
          if (t.id === notfoundIds[i]) {
            tail = t.values[t.values.length - 1].index + 1;
            for (j = 0; j < length; j++) {
              t.values.push({
                id: t.id,
                index: tail + j,
                x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + j) : tail + j,
                value: null
              });
            }
          }
        }
      });
      if ($$.data.targets.length) {
        targets.forEach(function(t) {
          var i,
              missing = [];
          for (i = $$.data.targets[0].values[0].index; i < tail; i++) {
            missing.push({
              id: t.id,
              index: i,
              x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,
              value: null
            });
          }
          t.values.forEach(function(v) {
            v.index += tail;
            if (!$$.isTimeSeries()) {
              v.x += tail;
            }
          });
          t.values = missing.concat(t.values);
        });
      }
      $$.data.targets = $$.data.targets.concat(targets);
      dataCount = $$.getMaxDataCount();
      baseTarget = $$.data.targets[0];
      baseValue = baseTarget.values[0];
      if (isDefined(args.to)) {
        length = 0;
        to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to;
        baseTarget.values.forEach(function(v) {
          if (v.x < to) {
            length++;
          }
        });
      } else if (isDefined(args.length)) {
        length = args.length;
      }
      if (!orgDataCount) {
        if ($$.isTimeSeries()) {
          if (baseTarget.values.length > 1) {
            diff = baseTarget.values[baseTarget.values.length - 1].x - baseValue.x;
          } else {
            diff = baseValue.x - $$.getXDomain($$.data.targets)[0];
          }
        } else {
          diff = 1;
        }
        domain = [baseValue.x - diff, baseValue.x];
        $$.updateXDomain(null, true, true, false, domain);
      } else if (orgDataCount === 1) {
        if ($$.isTimeSeries()) {
          diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2;
          domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)];
          $$.updateXDomain(null, true, true, false, domain);
        }
      }
      $$.updateTargets($$.data.targets);
      $$.redraw({
        flow: {
          index: baseValue.index,
          length: length,
          duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,
          done: args.done,
          orgDataCount: orgDataCount
        },
        withLegend: true,
        withTransition: orgDataCount > 1,
        withTrimXDomain: false,
        withUpdateXAxis: true
      });
    };
    c3_chart_internal_fn.generateFlow = function(args) {
      var $$ = this,
          config = $$.config,
          d3 = $$.d3;
      return function() {
        var targets = args.targets,
            flow = args.flow,
            drawBar = args.drawBar,
            drawLine = args.drawLine,
            drawArea = args.drawArea,
            cx = args.cx,
            cy = args.cy,
            xv = args.xv,
            xForText = args.xForText,
            yForText = args.yForText,
            duration = args.duration;
        var translateX,
            scaleX = 1,
            transform,
            flowIndex = flow.index,
            flowLength = flow.length,
            flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex),
            flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength),
            orgDomain = $$.x.domain(),
            domain,
            durationForFlow = flow.duration || duration,
            done = flow.done || function() {},
            wait = $$.generateWait();
        var xgrid = $$.xgrid || d3.selectAll([]),
            xgridLines = $$.xgridLines || d3.selectAll([]),
            mainRegion = $$.mainRegion || d3.selectAll([]),
            mainText = $$.mainText || d3.selectAll([]),
            mainBar = $$.mainBar || d3.selectAll([]),
            mainLine = $$.mainLine || d3.selectAll([]),
            mainArea = $$.mainArea || d3.selectAll([]),
            mainCircle = $$.mainCircle || d3.selectAll([]);
        $$.flowing = true;
        $$.data.targets.forEach(function(d) {
          d.values.splice(0, flowLength);
        });
        domain = $$.updateXDomain(targets, true, true);
        if ($$.updateXGrid) {
          $$.updateXGrid(true);
        }
        if (!flow.orgDataCount) {
          if ($$.data.targets[0].values.length !== 1) {
            translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
          } else {
            if ($$.isTimeSeries()) {
              flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0);
              flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1);
              translateX = $$.x(flowStart.x) - $$.x(flowEnd.x);
            } else {
              translateX = diffDomain(domain) / 2;
            }
          }
        } else if (flow.orgDataCount === 1 || flowStart.x === flowEnd.x) {
          translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);
        } else {
          if ($$.isTimeSeries()) {
            translateX = ($$.x(orgDomain[0]) - $$.x(domain[0]));
          } else {
            translateX = ($$.x(flowStart.x) - $$.x(flowEnd.x));
          }
        }
        scaleX = (diffDomain(orgDomain) / diffDomain(domain));
        transform = 'translate(' + translateX + ',0) scale(' + scaleX + ',1)';
        $$.hideXGridFocus();
        $$.hideTooltip();
        d3.transition().ease('linear').duration(durationForFlow).each(function() {
          wait.add($$.axes.x.transition().call($$.xAxis));
          wait.add(mainBar.transition().attr('transform', transform));
          wait.add(mainLine.transition().attr('transform', transform));
          wait.add(mainArea.transition().attr('transform', transform));
          wait.add(mainCircle.transition().attr('transform', transform));
          wait.add(mainText.transition().attr('transform', transform));
          wait.add(mainRegion.filter($$.isRegionOnX).transition().attr('transform', transform));
          wait.add(xgrid.transition().attr('transform', transform));
          wait.add(xgridLines.transition().attr('transform', transform));
        }).call(wait, function() {
          var i,
              shapes = [],
              texts = [],
              eventRects = [];
          if (flowLength) {
            for (i = 0; i < flowLength; i++) {
              shapes.push('.' + CLASS.shape + '-' + (flowIndex + i));
              texts.push('.' + CLASS.text + '-' + (flowIndex + i));
              eventRects.push('.' + CLASS.eventRect + '-' + (flowIndex + i));
            }
            $$.svg.selectAll('.' + CLASS.shapes).selectAll(shapes).remove();
            $$.svg.selectAll('.' + CLASS.texts).selectAll(texts).remove();
            $$.svg.selectAll('.' + CLASS.eventRects).selectAll(eventRects).remove();
            $$.svg.select('.' + CLASS.xgrid).remove();
          }
          xgrid.attr('transform', null).attr($$.xgridAttr);
          xgridLines.attr('transform', null);
          xgridLines.select('line').attr("x1", config.axis_rotated ? 0 : xv).attr("x2", config.axis_rotated ? $$.width : xv);
          xgridLines.select('text').attr("x", config.axis_rotated ? $$.width : 0).attr("y", xv);
          mainBar.attr('transform', null).attr("d", drawBar);
          mainLine.attr('transform', null).attr("d", drawLine);
          mainArea.attr('transform', null).attr("d", drawArea);
          mainCircle.attr('transform', null).attr("cx", cx).attr("cy", cy);
          mainText.attr('transform', null).attr('x', xForText).attr('y', yForText).style('fill-opacity', $$.opacityForText.bind($$));
          mainRegion.attr('transform', null);
          mainRegion.select('rect').filter($$.isRegionOnX).attr("x", $$.regionX.bind($$)).attr("width", $$.regionWidth.bind($$));
          if (config.interaction_enabled) {
            $$.redrawEventRect();
          }
          done();
          $$.flowing = false;
        });
      };
    };
    c3_chart_fn.selected = function(targetId) {
      var $$ = this.internal,
          d3 = $$.d3;
      return d3.merge($$.main.selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(targetId)).selectAll('.' + CLASS.shape).filter(function() {
        return d3.select(this).classed(CLASS.SELECTED);
      }).map(function(d) {
        return d.map(function(d) {
          var data = d.__data__;
          return data.data ? data.data : data;
        });
      }));
    };
    c3_chart_fn.select = function(ids, indices, resetOther) {
      var $$ = this.internal,
          d3 = $$.d3,
          config = $$.config;
      if (!config.data_selection_enabled) {
        return;
      }
      $$.main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).each(function(d, i) {
        var shape = d3.select(this),
            id = d.data ? d.data.id : d.id,
            toggle = $$.getToggle(this, d).bind($$),
            isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
            isTargetIndex = !indices || indices.indexOf(i) >= 0,
            isSelected = shape.classed(CLASS.SELECTED);
        if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {
          return;
        }
        if (isTargetId && isTargetIndex) {
          if (config.data_selection_isselectable(d) && !isSelected) {
            toggle(true, shape.classed(CLASS.SELECTED, true), d, i);
          }
        } else if (isDefined(resetOther) && resetOther) {
          if (isSelected) {
            toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
          }
        }
      });
    };
    c3_chart_fn.unselect = function(ids, indices) {
      var $$ = this.internal,
          d3 = $$.d3,
          config = $$.config;
      if (!config.data_selection_enabled) {
        return;
      }
      $$.main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).each(function(d, i) {
        var shape = d3.select(this),
            id = d.data ? d.data.id : d.id,
            toggle = $$.getToggle(this, d).bind($$),
            isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
            isTargetIndex = !indices || indices.indexOf(i) >= 0,
            isSelected = shape.classed(CLASS.SELECTED);
        if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {
          return;
        }
        if (isTargetId && isTargetIndex) {
          if (config.data_selection_isselectable(d)) {
            if (isSelected) {
              toggle(false, shape.classed(CLASS.SELECTED, false), d, i);
            }
          }
        }
      });
    };
    c3_chart_fn.transform = function(type, targetIds) {
      var $$ = this.internal,
          options = ['pie', 'donut'].indexOf(type) >= 0 ? {withTransform: true} : null;
      $$.transformTo(targetIds, type, options);
    };
    c3_chart_internal_fn.transformTo = function(targetIds, type, optionsForRedraw) {
      var $$ = this,
          withTransitionForAxis = !$$.hasArcType(),
          options = optionsForRedraw || {withTransitionForAxis: withTransitionForAxis};
      options.withTransitionForTransform = false;
      $$.transiting = false;
      $$.setTargetType(targetIds, type);
      $$.updateTargets($$.data.targets);
      $$.updateAndRedraw(options);
    };
    c3_chart_fn.groups = function(groups) {
      var $$ = this.internal,
          config = $$.config;
      if (isUndefined(groups)) {
        return config.data_groups;
      }
      config.data_groups = groups;
      $$.redraw();
      return config.data_groups;
    };
    c3_chart_fn.xgrids = function(grids) {
      var $$ = this.internal,
          config = $$.config;
      if (!grids) {
        return config.grid_x_lines;
      }
      config.grid_x_lines = grids;
      $$.redrawWithoutRescale();
      return config.grid_x_lines;
    };
    c3_chart_fn.xgrids.add = function(grids) {
      var $$ = this.internal;
      return this.xgrids($$.config.grid_x_lines.concat(grids ? grids : []));
    };
    c3_chart_fn.xgrids.remove = function(params) {
      var $$ = this.internal;
      $$.removeGridLines(params, true);
    };
    c3_chart_fn.ygrids = function(grids) {
      var $$ = this.internal,
          config = $$.config;
      if (!grids) {
        return config.grid_y_lines;
      }
      config.grid_y_lines = grids;
      $$.redrawWithoutRescale();
      return config.grid_y_lines;
    };
    c3_chart_fn.ygrids.add = function(grids) {
      var $$ = this.internal;
      return this.ygrids($$.config.grid_y_lines.concat(grids ? grids : []));
    };
    c3_chart_fn.ygrids.remove = function(params) {
      var $$ = this.internal;
      $$.removeGridLines(params, false);
    };
    c3_chart_fn.regions = function(regions) {
      var $$ = this.internal,
          config = $$.config;
      if (!regions) {
        return config.regions;
      }
      config.regions = regions;
      $$.redrawWithoutRescale();
      return config.regions;
    };
    c3_chart_fn.regions.add = function(regions) {
      var $$ = this.internal,
          config = $$.config;
      if (!regions) {
        return config.regions;
      }
      config.regions = config.regions.concat(regions);
      $$.redrawWithoutRescale();
      return config.regions;
    };
    c3_chart_fn.regions.remove = function(options) {
      var $$ = this.internal,
          config = $$.config,
          duration,
          classes,
          regions;
      options = options || {};
      duration = $$.getOption(options, "duration", config.transition_duration);
      classes = $$.getOption(options, "classes", [CLASS.region]);
      regions = $$.main.select('.' + CLASS.regions).selectAll(classes.map(function(c) {
        return '.' + c;
      }));
      (duration ? regions.transition().duration(duration) : regions).style('opacity', 0).remove();
      config.regions = config.regions.filter(function(region) {
        var found = false;
        if (!region['class']) {
          return true;
        }
        region['class'].split(' ').forEach(function(c) {
          if (classes.indexOf(c) >= 0) {
            found = true;
          }
        });
        return !found;
      });
      return config.regions;
    };
    c3_chart_fn.data = function(targetIds) {
      var targets = this.internal.data.targets;
      return typeof targetIds === 'undefined' ? targets : targets.filter(function(t) {
        return [].concat(targetIds).indexOf(t.id) >= 0;
      });
    };
    c3_chart_fn.data.shown = function(targetIds) {
      return this.internal.filterTargetsToShow(this.data(targetIds));
    };
    c3_chart_fn.data.values = function(targetId) {
      var targets,
          values = null;
      if (targetId) {
        targets = this.data(targetId);
        values = targets[0] ? targets[0].values.map(function(d) {
          return d.value;
        }) : null;
      }
      return values;
    };
    c3_chart_fn.data.names = function(names) {
      this.internal.clearLegendItemTextBoxCache();
      return this.internal.updateDataAttributes('names', names);
    };
    c3_chart_fn.data.colors = function(colors) {
      return this.internal.updateDataAttributes('colors', colors);
    };
    c3_chart_fn.data.axes = function(axes) {
      return this.internal.updateDataAttributes('axes', axes);
    };
    c3_chart_fn.category = function(i, category) {
      var $$ = this.internal,
          config = $$.config;
      if (arguments.length > 1) {
        config.axis_x_categories[i] = category;
        $$.redraw();
      }
      return config.axis_x_categories[i];
    };
    c3_chart_fn.categories = function(categories) {
      var $$ = this.internal,
          config = $$.config;
      if (!arguments.length) {
        return config.axis_x_categories;
      }
      config.axis_x_categories = categories;
      $$.redraw();
      return config.axis_x_categories;
    };
    c3_chart_fn.color = function(id) {
      var $$ = this.internal;
      return $$.color(id);
    };
    c3_chart_fn.x = function(x) {
      var $$ = this.internal;
      if (arguments.length) {
        $$.updateTargetX($$.data.targets, x);
        $$.redraw({
          withUpdateOrgXDomain: true,
          withUpdateXDomain: true
        });
      }
      return $$.data.xs;
    };
    c3_chart_fn.xs = function(xs) {
      var $$ = this.internal;
      if (arguments.length) {
        $$.updateTargetXs($$.data.targets, xs);
        $$.redraw({
          withUpdateOrgXDomain: true,
          withUpdateXDomain: true
        });
      }
      return $$.data.xs;
    };
    c3_chart_fn.axis = function() {};
    c3_chart_fn.axis.labels = function(labels) {
      var $$ = this.internal;
      if (arguments.length) {
        Object.keys(labels).forEach(function(axisId) {
          $$.axis.setLabelText(axisId, labels[axisId]);
        });
        $$.axis.updateLabels();
      }
    };
    c3_chart_fn.axis.max = function(max) {
      var $$ = this.internal,
          config = $$.config;
      if (arguments.length) {
        if (typeof max === 'object') {
          if (isValue(max.x)) {
            config.axis_x_max = max.x;
          }
          if (isValue(max.y)) {
            config.axis_y_max = max.y;
          }
          if (isValue(max.y2)) {
            config.axis_y2_max = max.y2;
          }
        } else {
          config.axis_y_max = config.axis_y2_max = max;
        }
        $$.redraw({
          withUpdateOrgXDomain: true,
          withUpdateXDomain: true
        });
      } else {
        return {
          x: config.axis_x_max,
          y: config.axis_y_max,
          y2: config.axis_y2_max
        };
      }
    };
    c3_chart_fn.axis.min = function(min) {
      var $$ = this.internal,
          config = $$.config;
      if (arguments.length) {
        if (typeof min === 'object') {
          if (isValue(min.x)) {
            config.axis_x_min = min.x;
          }
          if (isValue(min.y)) {
            config.axis_y_min = min.y;
          }
          if (isValue(min.y2)) {
            config.axis_y2_min = min.y2;
          }
        } else {
          config.axis_y_min = config.axis_y2_min = min;
        }
        $$.redraw({
          withUpdateOrgXDomain: true,
          withUpdateXDomain: true
        });
      } else {
        return {
          x: config.axis_x_min,
          y: config.axis_y_min,
          y2: config.axis_y2_min
        };
      }
    };
    c3_chart_fn.axis.range = function(range) {
      if (arguments.length) {
        if (isDefined(range.max)) {
          this.axis.max(range.max);
        }
        if (isDefined(range.min)) {
          this.axis.min(range.min);
        }
      } else {
        return {
          max: this.axis.max(),
          min: this.axis.min()
        };
      }
    };
    c3_chart_fn.legend = function() {};
    c3_chart_fn.legend.show = function(targetIds) {
      var $$ = this.internal;
      $$.showLegend($$.mapToTargetIds(targetIds));
      $$.updateAndRedraw({withLegend: true});
    };
    c3_chart_fn.legend.hide = function(targetIds) {
      var $$ = this.internal;
      $$.hideLegend($$.mapToTargetIds(targetIds));
      $$.updateAndRedraw({withLegend: true});
    };
    c3_chart_fn.resize = function(size) {
      var $$ = this.internal,
          config = $$.config;
      config.size_width = size ? size.width : null;
      config.size_height = size ? size.height : null;
      this.flush();
    };
    c3_chart_fn.flush = function() {
      var $$ = this.internal;
      $$.updateAndRedraw({
        withLegend: true,
        withTransition: false,
        withTransitionForTransform: false
      });
    };
    c3_chart_fn.destroy = function() {
      var $$ = this.internal;
      window.clearInterval($$.intervalForObserveInserted);
      window.onresize = null;
      $$.selectChart.classed('c3', false).html("");
      Object.keys($$).forEach(function(key) {
        $$[key] = null;
      });
      return null;
    };
    c3_chart_fn.tooltip = function() {};
    c3_chart_fn.tooltip.show = function(args) {
      var $$ = this.internal,
          index,
          mouse;
      if (args.mouse) {
        mouse = args.mouse;
      }
      if (args.data) {
        if ($$.isMultipleX()) {
          mouse = [$$.x(args.data.x), $$.getYScale(args.data.id)(args.data.value)];
          index = null;
        } else {
          index = isValue(args.data.index) ? args.data.index : $$.getIndexByX(args.data.x);
        }
      } else if (typeof args.x !== 'undefined') {
        index = $$.getIndexByX(args.x);
      } else if (typeof args.index !== 'undefined') {
        index = args.index;
      }
      $$.dispatchEvent('mouseover', index, mouse);
      $$.dispatchEvent('mousemove', index, mouse);
    };
    c3_chart_fn.tooltip.hide = function() {
      this.internal.dispatchEvent('mouseout', 0);
    };
    var tickTextCharSize;
    function c3_axis(d3, params) {
      var scale = d3.scale.linear(),
          orient = "bottom",
          innerTickSize = 6,
          outerTickSize,
          tickPadding = 3,
          tickValues = null,
          tickFormat,
          tickArguments;
      var tickOffset = 0,
          tickCulling = true,
          tickCentered;
      params = params || {};
      outerTickSize = params.withOuterTick ? 6 : 0;
      function axisX(selection, x) {
        selection.attr("transform", function(d) {
          return "translate(" + Math.ceil(x(d) + tickOffset) + ", 0)";
        });
      }
      function axisY(selection, y) {
        selection.attr("transform", function(d) {
          return "translate(0," + Math.ceil(y(d)) + ")";
        });
      }
      function scaleExtent(domain) {
        var start = domain[0],
            stop = domain[domain.length - 1];
        return start < stop ? [start, stop] : [stop, start];
      }
      function generateTicks(scale) {
        var i,
            domain,
            ticks = [];
        if (scale.ticks) {
          return scale.ticks.apply(scale, tickArguments);
        }
        domain = scale.domain();
        for (i = Math.ceil(domain[0]); i < domain[1]; i++) {
          ticks.push(i);
        }
        if (ticks.length > 0 && ticks[0] > 0) {
          ticks.unshift(ticks[0] - (ticks[1] - ticks[0]));
        }
        return ticks;
      }
      function copyScale() {
        var newScale = scale.copy(),
            domain;
        if (params.isCategory) {
          domain = scale.domain();
          newScale.domain([domain[0], domain[1] - 1]);
        }
        return newScale;
      }
      function textFormatted(v) {
        var formatted = tickFormat ? tickFormat(v) : v;
        return typeof formatted !== 'undefined' ? formatted : '';
      }
      function getSizeFor1Char(tick) {
        if (tickTextCharSize) {
          return tickTextCharSize;
        }
        var size = {
          h: 11.5,
          w: 5.5
        };
        tick.select('text').text(textFormatted).each(function(d) {
          var box = this.getBoundingClientRect(),
              text = textFormatted(d),
              h = box.height,
              w = text ? (box.width / text.length) : undefined;
          if (h && w) {
            size.h = h;
            size.w = w;
          }
        }).text('');
        tickTextCharSize = size;
        return size;
      }
      function transitionise(selection) {
        return params.withoutTransition ? selection : d3.transition(selection);
      }
      function axis(g) {
        g.each(function() {
          var g = axis.g = d3.select(this);
          var scale0 = this.__chart__ || scale,
              scale1 = this.__chart__ = copyScale();
          var ticks = tickValues ? tickValues : generateTicks(scale1),
              tick = g.selectAll(".tick").data(ticks, scale1),
              tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", 1e-6),
              tickExit = tick.exit().remove(),
              tickUpdate = transitionise(tick).style("opacity", 1),
              tickTransform,
              tickX,
              tickY;
          var range = scale.rangeExtent ? scale.rangeExtent() : scaleExtent(scale.range()),
              path = g.selectAll(".domain").data([0]),
              pathUpdate = (path.enter().append("path").attr("class", "domain"), transitionise(path));
          tickEnter.append("line");
          tickEnter.append("text");
          var lineEnter = tickEnter.select("line"),
              lineUpdate = tickUpdate.select("line"),
              textEnter = tickEnter.select("text"),
              textUpdate = tickUpdate.select("text");
          if (params.isCategory) {
            tickOffset = Math.ceil((scale1(1) - scale1(0)) / 2);
            tickX = tickCentered ? 0 : tickOffset;
            tickY = tickCentered ? tickOffset : 0;
          } else {
            tickOffset = tickX = 0;
          }
          var text,
              tspan,
              sizeFor1Char = getSizeFor1Char(g.select('.tick')),
              counts = [];
          var tickLength = Math.max(innerTickSize, 0) + tickPadding,
              isVertical = orient === 'left' || orient === 'right';
          function splitTickText(d, maxWidth) {
            var tickText = textFormatted(d),
                subtext,
                spaceIndex,
                textWidth,
                splitted = [];
            if (Object.prototype.toString.call(tickText) === "[object Array]") {
              return tickText;
            }
            if (!maxWidth || maxWidth <= 0) {
              maxWidth = isVertical ? 95 : params.isCategory ? (Math.ceil(scale1(ticks[1]) - scale1(ticks[0])) - 12) : 110;
            }
            function split(splitted, text) {
              spaceIndex = undefined;
              for (var i = 1; i < text.length; i++) {
                if (text.charAt(i) === ' ') {
                  spaceIndex = i;
                }
                subtext = text.substr(0, i + 1);
                textWidth = sizeFor1Char.w * subtext.length;
                if (maxWidth < textWidth) {
                  return split(splitted.concat(text.substr(0, spaceIndex ? spaceIndex : i)), text.slice(spaceIndex ? spaceIndex + 1 : i));
                }
              }
              return splitted.concat(text);
            }
            return split(splitted, tickText + "");
          }
          function tspanDy(d, i) {
            var dy = sizeFor1Char.h;
            if (i === 0) {
              if (orient === 'left' || orient === 'right') {
                dy = -((counts[d.index] - 1) * (sizeFor1Char.h / 2) - 3);
              } else {
                dy = ".71em";
              }
            }
            return dy;
          }
          function tickSize(d) {
            var tickPosition = scale(d) + (tickCentered ? 0 : tickOffset);
            return range[0] < tickPosition && tickPosition < range[1] ? innerTickSize : 0;
          }
          text = tick.select("text");
          tspan = text.selectAll('tspan').data(function(d, i) {
            var splitted = params.tickMultiline ? splitTickText(d, params.tickWidth) : [].concat(textFormatted(d));
            counts[i] = splitted.length;
            return splitted.map(function(s) {
              return {
                index: i,
                splitted: s
              };
            });
          });
          tspan.enter().append('tspan');
          tspan.exit().remove();
          tspan.text(function(d) {
            return d.splitted;
          });
          var rotate = params.tickTextRotate;
          function textAnchorForText(rotate) {
            if (!rotate) {
              return 'middle';
            }
            return rotate > 0 ? "start" : "end";
          }
          function textTransform(rotate) {
            if (!rotate) {
              return '';
            }
            return "rotate(" + rotate + ")";
          }
          function dxForText(rotate) {
            if (!rotate) {
              return 0;
            }
            return 8 * Math.sin(Math.PI * (rotate / 180));
          }
          function yForText(rotate) {
            if (!rotate) {
              return tickLength;
            }
            return 11.5 - 2.5 * (rotate / 15) * (rotate > 0 ? 1 : -1);
          }
          switch (orient) {
            case "bottom":
              {
                tickTransform = axisX;
                lineEnter.attr("y2", innerTickSize);
                textEnter.attr("y", tickLength);
                lineUpdate.attr("x1", tickX).attr("x2", tickX).attr("y2", tickSize);
                textUpdate.attr("x", 0).attr("y", yForText(rotate)).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate));
                tspan.attr('x', 0).attr("dy", tspanDy).attr('dx', dxForText(rotate));
                pathUpdate.attr("d", "M" + range[0] + "," + outerTickSize + "V0H" + range[1] + "V" + outerTickSize);
                break;
              }
            case "top":
              {
                tickTransform = axisX;
                lineEnter.attr("y2", -innerTickSize);
                textEnter.attr("y", -tickLength);
                lineUpdate.attr("x2", 0).attr("y2", -innerTickSize);
                textUpdate.attr("x", 0).attr("y", -tickLength);
                text.style("text-anchor", "middle");
                tspan.attr('x', 0).attr("dy", "0em");
                pathUpdate.attr("d", "M" + range[0] + "," + -outerTickSize + "V0H" + range[1] + "V" + -outerTickSize);
                break;
              }
            case "left":
              {
                tickTransform = axisY;
                lineEnter.attr("x2", -innerTickSize);
                textEnter.attr("x", -tickLength);
                lineUpdate.attr("x2", -innerTickSize).attr("y1", tickY).attr("y2", tickY);
                textUpdate.attr("x", -tickLength).attr("y", tickOffset);
                text.style("text-anchor", "end");
                tspan.attr('x', -tickLength).attr("dy", tspanDy);
                pathUpdate.attr("d", "M" + -outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + -outerTickSize);
                break;
              }
            case "right":
              {
                tickTransform = axisY;
                lineEnter.attr("x2", innerTickSize);
                textEnter.attr("x", tickLength);
                lineUpdate.attr("x2", innerTickSize).attr("y2", 0);
                textUpdate.attr("x", tickLength).attr("y", 0);
                text.style("text-anchor", "start");
                tspan.attr('x', tickLength).attr("dy", tspanDy);
                pathUpdate.attr("d", "M" + outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + outerTickSize);
                break;
              }
          }
          if (scale1.rangeBand) {
            var x = scale1,
                dx = x.rangeBand() / 2;
            scale0 = scale1 = function(d) {
              return x(d) + dx;
            };
          } else if (scale0.rangeBand) {
            scale0 = scale1;
          } else {
            tickExit.call(tickTransform, scale1);
          }
          tickEnter.call(tickTransform, scale0);
          tickUpdate.call(tickTransform, scale1);
        });
      }
      axis.scale = function(x) {
        if (!arguments.length) {
          return scale;
        }
        scale = x;
        return axis;
      };
      axis.orient = function(x) {
        if (!arguments.length) {
          return orient;
        }
        orient = x in {
          top: 1,
          right: 1,
          bottom: 1,
          left: 1
        } ? x + "" : "bottom";
        return axis;
      };
      axis.tickFormat = function(format) {
        if (!arguments.length) {
          return tickFormat;
        }
        tickFormat = format;
        return axis;
      };
      axis.tickCentered = function(isCentered) {
        if (!arguments.length) {
          return tickCentered;
        }
        tickCentered = isCentered;
        return axis;
      };
      axis.tickOffset = function() {
        return tickOffset;
      };
      axis.tickInterval = function() {
        var interval,
            length;
        if (params.isCategory) {
          interval = tickOffset * 2;
        } else {
          length = axis.g.select('path.domain').node().getTotalLength() - outerTickSize * 2;
          interval = length / axis.g.selectAll('line').size();
        }
        return interval === Infinity ? 0 : interval;
      };
      axis.ticks = function() {
        if (!arguments.length) {
          return tickArguments;
        }
        tickArguments = arguments;
        return axis;
      };
      axis.tickCulling = function(culling) {
        if (!arguments.length) {
          return tickCulling;
        }
        tickCulling = culling;
        return axis;
      };
      axis.tickValues = function(x) {
        if (typeof x === 'function') {
          tickValues = function() {
            return x(scale.domain());
          };
        } else {
          if (!arguments.length) {
            return tickValues;
          }
          tickValues = x;
        }
        return axis;
      };
      return axis;
    }
    c3_chart_internal_fn.isSafari = function() {
      var ua = window.navigator.userAgent;
      return ua.indexOf('Safari') >= 0 && ua.indexOf('Chrome') < 0;
    };
    c3_chart_internal_fn.isChrome = function() {
      var ua = window.navigator.userAgent;
      return ua.indexOf('Chrome') >= 0;
    };
    if (!Function.prototype.bind) {
      Function.prototype.bind = function(oThis) {
        if (typeof this !== 'function') {
          throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }
        var aArgs = Array.prototype.slice.call(arguments, 1),
            fToBind = this,
            fNOP = function() {},
            fBound = function() {
              return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
            };
        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        return fBound;
      };
    }
    if (typeof define === 'function' && define.amd) {
      define("c3", ["d3"], c3);
    } else if ('undefined' !== typeof exports && 'undefined' !== typeof module) {
      module.exports = c3;
    } else {
      window.c3 = c3;
    }
  })(window);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("41", ["40"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('40');
  global.define = __define;
  return module.exports;
});

$__System.register('42', ['5', '41', '43', '3e', '1c'], function (_export) {
  /* */

  /**
   * Displays a popup with an interactive plot showing the data
   * of the vertical profile coverage.
   * 
   * @example
   * layer.bindPopup(new VerticalProfilePlot(coverage))
   * 
   * @example <caption>Non-module access</caption>
   * L.coverage.popup.VerticalProfilePlot
   */
  'use strict';

  var L, c3, i18n, getReferenceObject, VerticalProfilePlot;

  function zip(a, b) {
    return a.map(function (e, i) {
      return [a[i], b[i]];
    });
  }
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_2) {
      c3 = _2['default'];
    }, function (_3) {
      i18n = _3;
    }, function (_e) {}, function (_c) {
      getReferenceObject = _c.getReferenceObject;
    }],
    execute: function () {
      VerticalProfilePlot = (function (_L$Popup) {
        babelHelpers.inherits(VerticalProfilePlot, _L$Popup);

        /**
         * Creates a vertical profile plot popup.
         * 
         * @param {Coverage|Array<Coverage>} coverage The vertical profile coverage to visualize.
         *   If an array of vertical profile coverages is given, then the vertical reference systems
         *   are assumed to be identical.
         * @param {object} [options] Popup options. See also http://leafletjs.com/reference.html#popup-options.
         * @param {Array|Array<Array>} [options.keys] The parameters to display.
         *   For a single coverage, an array of parameter keys, each parameter is accessible in a drop down.
         *   The default for a single coverage is to display all parameters.
         *   For multiple coverages, an array of parameter key groups, each group is accessible in a drop down.
         *   Each group array is ordered as the coverage array and determines which parameter of each coverage
         *   is displayed in a single plot. In each group, at least one item must be defined.
         *   The default for multiple coverages is to display all parameters and treat each one as a separate group.
         * @param {string} [options.language] A language tag, indicating the preferred language to use for labels.
         * @param {string} [options.precision=4] The number of significant digits to display.
         */

        function VerticalProfilePlot(coverage) {
          var _this = this;

          var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
          babelHelpers.classCallCheck(this, VerticalProfilePlot);

          options.maxWidth = options.maxWidth || 350;
          babelHelpers.get(Object.getPrototypeOf(VerticalProfilePlot.prototype), 'constructor', this).call(this, options);
          this._covs = Array.isArray(coverage) ? coverage : [coverage];
          this._language = options.language;
          this._precision = options.precision || 4;

          this._labels = options.labels ? options.labels : new Array(this._covs.length);

          var keyGroups = [];
          if (!options.keys) {
            // treat all parameters of all coverages as separate
            for (var i = 0; i < this._covs.length; i++) {
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = this._covs[i].parameters.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var key = _step.value;

                  var group = new Array(this._covs.length);
                  group[i] = key;
                  keyGroups.push(group);
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator['return']) {
                    _iterator['return']();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }
            }
          } else if (!Array.isArray(options.keys[0])) {
            // short-cut for a single coverage, acts as parameter selector
            keyGroups = options.keys.map(function (key) {
              return [key];
            });
          } else {
            // user defines which parameters to display and how to group them
            keyGroups = options.keys;
          }

          // filter out groups which only contain null/undefined keys
          keyGroups = keyGroups.filter(function (group) {
            return !group.every(function (key) {
              return !key;
            });
          });

          if (keyGroups.some(function (group) {
            return group.length !== _this._covs.length;
          })) {
            throw new Error('Length of each parameter group must match number of coverages');
          }

          // 2D array of parameter key groups, where each inner array is ordered like the coverages array
          this._paramKeyGroups = keyGroups;

          // Map from coverage to param keys
          this._paramKeys = new Map();

          var _loop = function (i) {
            var keys = _this._paramKeyGroups.map(function (group) {
              return group[i];
            }).filter(function (key) {
              return key;
            });
            _this._paramKeys.set(_this._covs[i], keys);
          };

          for (var i = 0; i < this._covs.length; i++) {
            _loop(i);
          }
        }

        /**
         * @ignore
         */
        babelHelpers.createClass(VerticalProfilePlot, [{
          key: 'onAdd',
          value: function onAdd(map) {
            var _this2 = this;

            map.fire('dataloading');
            var domainPromise = Promise.all(this._covs.map(function (cov) {
              return cov.loadDomain();
            }));
            var rangePromise = Promise.all(this._covs.map(function (cov) {
              return cov.loadRanges(_this2._paramKeys.get(cov));
            }));
            Promise.all([domainPromise, rangePromise]).then(function (_ref) {
              var _ref2 = babelHelpers.slicedToArray(_ref, 2);

              var domains = _ref2[0];
              var ranges = _ref2[1];

              _this2._domains = domains;
              _this2._ranges = ranges;
              _this2._addPlotToPopup();
              babelHelpers.get(Object.getPrototypeOf(VerticalProfilePlot.prototype), 'onAdd', _this2).call(_this2, map);
              _this2.fire('add');
              map.fire('dataload');
            })['catch'](function (e) {
              console.error(e);
              _this2.fire('error', e);
              map.fire('dataload');
            });
          }
        }, {
          key: '_addPlotToPopup',
          value: function _addPlotToPopup() {
            var _this3 = this;

            // TODO transform if necessary
            if (!this.getLatLng()) {
              // in case bindPopup is not used and the caller did not set a position
              var x = this._domains[0].axes.get('x');
              var y = this._domains[0].axes.get('y');
              this.setLatLng(L.latLng(y.values[0], x.values[0]));
            }

            // display first parameter group
            var paramKeyGroup = this._paramKeyGroups[0];
            var plot = this._getPlotElement(paramKeyGroup);

            var el = document.createElement('span');

            // display dropdown if multiple parameter groups
            if (this._paramKeyGroups.length > 1) {
              var _iteratorNormalCompletion2;

              var _didIteratorError2;

              var _iteratorError2;

              var _iterator2, _step2;

              (function () {
                var select = document.createElement('select');

                _iteratorNormalCompletion2 = true;
                _didIteratorError2 = false;
                _iteratorError2 = undefined;

                try {
                  for (_iterator2 = _this3._paramKeyGroups.map(function (v, i) {
                    return [v, i];
                  })[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var _step2$value = babelHelpers.slicedToArray(_step2.value, 2);

                    var _paramKeyGroup = _step2$value[0];
                    var i = _step2$value[1];

                    var refParam = _this3._getRefParam(_paramKeyGroup);
                    var option = document.createElement('option');
                    option.value = i;
                    option.text = i18n.getLanguageString(refParam.observedProperty.label, _this3._language);
                    select.appendChild(option);
                  }
                } catch (err) {
                  _didIteratorError2 = true;
                  _iteratorError2 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                      _iterator2['return']();
                    }
                  } finally {
                    if (_didIteratorError2) {
                      throw _iteratorError2;
                    }
                  }
                }

                select.addEventListener('change', function () {
                  el.removeChild(plot);
                  var group = _this3._paramKeyGroups[parseInt(select.value)];
                  plot = _this3._getPlotElement(group);
                  el.appendChild(plot);
                });

                el.appendChild(select);
              })();
            }

            el.appendChild(plot);
            this.setContent(el);
          }
        }, {
          key: '_getRefParam',
          value: function _getRefParam(paramKeyGroup) {
            // use first defined parameter as representative for the group
            var covsWithParamKey = zip(this._covs, paramKeyGroup);

            var _covsWithParamKey$filter$0 = babelHelpers.slicedToArray(covsWithParamKey.filter(function (_ref3) {
              var _ref32 = babelHelpers.slicedToArray(_ref3, 2);

              var key = _ref32[1];
              return key;
            })[0], 2);

            var refCov = _covsWithParamKey$filter$0[0];
            var refParamKey = _covsWithParamKey$filter$0[1];

            var refParam = refCov.parameters.get(refParamKey);
            return refParam;
          }

          // TODO move this into a reusable unit-formatting module
          // TODO code duplication with ContinuousLegend
        }, {
          key: '_getUnitString',
          value: function _getUnitString(param, language) {
            if (!param.unit) {
              return '';
            }
            if (param.unit.symbol) {
              var unit = param.unit.symbol.value || param.unit.symbol;
              var scheme = param.unit.symbol.type;
              if (scheme === 'http://www.opengis.net/def/uom/UCUM/') {
                if (unit === 'Cel') {
                  unit = '°C';
                } else if (unit === '1') {
                  unit = '';
                }
              }
              return unit;
            } else {
              return i18n.getLanguageString(param.unit.label, language);
            }
          }
        }, {
          key: '_getPlotElement',
          value: function _getPlotElement(paramKeyGroup) {
            var _this4 = this;

            var refDomain = this._domains[0];
            var covsWithParamKey = zip(this._covs, paramKeyGroup);

            var refParam = this._getRefParam(paramKeyGroup);

            // axis labels
            var zName = 'Vertical';
            var zUnit = '';

            var vertRef = getReferenceObject(refDomain, 'z');
            if (vertRef && vertRef.components.length === 1) {
              var vertSrs = vertRef.system;
              if (vertSrs.cs && (vertSrs.cs.axes || vertSrs.cs.csAxes)) {
                var ax = vertSrs.cs.axes ? vertSrs.cs.axes[0] : vertSrs.cs.csAxes[0];
                zUnit = this._getUnitString(ax, this._language);
                if (ax.name) {
                  zName = i18n.getLanguageString(ax.name, this._language);
                }
              }
            }

            var xLabel = zName;
            if (zUnit) {
              xLabel += ' (' + zUnit + ')';
            }

            var unit = this._getUnitString(refParam, this._language);
            var obsPropLabel = i18n.getLanguageString(refParam.observedProperty.label, this._language);

            // http://c3js.org/samples/simple_xy_multiple.html

            // axis values
            var xs = {};
            var columns = [];
            var names = {};

            for (var i = 0; i < this._covs.length; i++) {
              var paramKey = covsWithParamKey[i][1];
              if (!paramKey) {
                continue;
              }

              var xname = 'x' + i;
              var yname = refParam.key + i;

              names[yname] = this._labels[i] ? this._labels[i] : obsPropLabel;

              xs[yname] = xname;

              var zVals = this._domains[i].axes.get('z').values;
              var vals = this._ranges[i].get(paramKey);
              var x = [xname];
              var y = [yname];
              for (var j = 0; j < zVals.length; j++) {
                var val = vals.get({ z: j });
                if (val === null) {
                  continue;
                }
                var z = zVals[j];
                x.push(z);
                y.push(val);
              }

              columns.push(x);
              columns.push(y);
            }

            var el = document.createElement('div');
            c3.generate({
              bindto: el,
              data: {
                xs: xs,
                columns: columns,
                names: names
              },
              axis: {
                rotated: true,
                x: {
                  tick: {
                    count: 10,
                    format: function format(x) {
                      return x.toPrecision(_this4._precision);
                    }
                  },
                  label: {
                    text: xLabel,
                    position: 'outer-center'
                  }
                },
                y: {
                  tick: {
                    count: 7,
                    format: function format(x) {
                      return x.toPrecision(_this4._precision);
                    }
                  },
                  label: {
                    text: obsPropLabel + (unit ? ' (' + unit + ')' : ''),
                    position: 'outer-middle'
                  }
                }
              },
              grid: {
                x: {
                  show: true
                },
                y: {
                  show: true
                }
              },
              legend: {
                show: this._covs.length > 1 ? true : false
              },
              tooltip: {
                format: {
                  title: function title(d) {
                    return zName + ': ' + d.toPrecision(_this4._precision) + ' ' + zUnit;
                  },
                  value: function value(_value, ratio, id) {
                    return _value.toPrecision(_this4._precision) + ' ' + unit;
                  }
                }
              },
              zoom: {
                enabled: true,
                rescale: true
              },
              size: {
                height: 300,
                width: 350
              }
            });

            return el;
          }
        }]);
        return VerticalProfilePlot;
      })(L.Popup);

      _export('default', VerticalProfilePlot);
    }
  };
});

$__System.registerDynamic("20", ["44"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.toAscii = toAscii;
  var _i18n = req('44');
  function toAscii(unit, language) {
    if (!unit) {
      return '';
    }
    if (unit.symbol) {
      var symbol = unit.symbol.value || unit.symbol;
      var scheme = unit.symbol.type;
      if (scheme === 'http://www.opengis.net/def/uom/UCUM/') {
        if (symbol === 'Cel') {
          symbol = '°C';
        } else if (unit === '1') {
          symbol = '';
        }
      }
      return symbol;
    } else {
      return (0, _i18n.getLanguageString)(unit.label, language);
    }
  }
  global.define = __define;
  return module.exports;
});

$__System.register('1f', ['5', '8', '45'], function (_export) {
  /* */
  'use strict';

  var L, $, HTML, EventMixin, TEMPLATE, Dropdown;
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_2) {
      $ = _2.$;
      HTML = _2.HTML;
    }, function (_3) {
      EventMixin = _3['default'];
    }],
    execute: function () {
      TEMPLATE = '<div class="info" style="clear:none">\n  <strong class="select-title"></strong><br>\n  <select></select>\n</div>';

      Dropdown = (function (_EventMixin) {
        babelHelpers.inherits(Dropdown, _EventMixin);

        function Dropdown(choices, options) {
          babelHelpers.classCallCheck(this, Dropdown);

          babelHelpers.get(Object.getPrototypeOf(Dropdown.prototype), 'constructor', this).call(this, options.position ? { position: options.position } : { position: 'topleft' });
          this._title = options.title || '';
          this._choices = choices;
          this._value = options.value || choices[0].value;
        }

        babelHelpers.createClass(Dropdown, [{
          key: 'onAdd',
          value: function onAdd(map) {
            var _this = this;

            var el = HTML(TEMPLATE)[0];
            this._el = el;

            L.DomEvent.disableClickPropagation(el);

            $('.select-title', el).fill(this._title);

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = this._choices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _step$value = _step.value;
                var value = _step$value.value;
                var label = _step$value.label;

                $('select', el).add(HTML('<option value="' + value + '">' + label + '</option>'));
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            $('select', el)[0].disabled = this._choices.length <= 1;
            this.value = this._value;

            $('select', el).on('change', function (event) {
              _this._value = event.target.value;
              _this.fire('change', { value: event.target.value });
            });

            return el;
          }
        }, {
          key: 'value',
          get: function get() {
            return this._value;
          },
          set: function set(val) {
            $('select', this._el)[0].value = val;
          }
        }]);
        return Dropdown;
      })(EventMixin(L.Control));

      _export('default', Dropdown);
    }
  };
});

$__System.register('46', ['5', '20', '43', '45', '1f'], function (_export) {
  /* */

  /**
   * Displays a simple vertical coordinate dropdown selector for a coverage data layer.
   * 
   * @example <caption>Coverage data layer</caption>
   * new VerticalAxis(covLayer).addTo(map)
   * // Selecting a vertical coordinate automatically sets the 'vertical' property in the layer.
   * // Similarly, when the layer fires an 'axisChange' event with {axis: 'vertical'}
   * // the control reflects that change.
   * 
   * @example <caption>Fake layer</caption>
   * var heights = [0,10,20,50,100,500,1000]
   * var fakeLayer = {
   *   verticalSlices: heights,
   *   vertical: heights[1], // select the second height step initially
   *   crsVerticalAxis: {
   *     name: { 
   *       en: 'Gravity-related height'
   *     },
   *     unit: {
   *       symbol: 'm'
   *     }
   *   }
   * }
   * var verticalAxis = new VerticalAxis(fakeLayer).addTo(map)
   * 
   * // change the height and trigger a manual update
   * fakeLayer.vertical = heights[0]
   * verticalAxis.update()
   * 
   * @example <caption>Non-module access</caption>
   * L.coverage.control.VerticalAxis
   */
  'use strict';

  var L, unitUtil, i18n, EventMixin, Dropdown, VerticalAxis;
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_4) {
      unitUtil = _4;
    }, function (_3) {
      i18n = _3;
    }, function (_2) {
      EventMixin = _2['default'];
    }, function (_f) {
      Dropdown = _f['default'];
    }],
    execute: function () {
      VerticalAxis = (function (_EventMixin) {
        babelHelpers.inherits(VerticalAxis, _EventMixin);

        /**
         * Creates a time axis control.
         * 
         * @param {object} covLayer 
         *   The coverage data layer, or any object with <code>verticalSlices</code>
         *   and <code>vertical</code> properties, optionally <code>crsVerticalAxis</code> property.
         *   If the object has <code>on</code>/<code>off</code> methods, then the control will
         *   listen for <code>"axisChange"</code> events with <code>{axis: 'vertical'}</code>
         *   and update itself automatically.
         *   If the layer fires a <code>"remove"</code> event, then the control will remove itself
         *   from the map.
         * @param {object} [options] Control options.
         * @param {string} [options.position='topleft'] The initial position of the control (see Leaflet docs).
         * @param {string} [options.title='Vertical'] 
         *   The label to show above the control if <code>covLayer.crsVerticalAxis.name</code> is missing.
         * 
         */

        function VerticalAxis(covLayer) {
          var _this = this;

          var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
          babelHelpers.classCallCheck(this, VerticalAxis);

          babelHelpers.get(Object.getPrototypeOf(VerticalAxis.prototype), 'constructor', this).call(this);
          this._covLayer = covLayer;
          this._title = options.title || 'Vertical';
          this._position = options.position || 'topleft';

          if (covLayer.on) {
            this._remove = function () {
              return _this.removeFrom(_this._map);
            };
            covLayer.on('remove', this._remove);

            this._axisListener = function (e) {
              if (e.axis === 'vertical') _this.update();
            };
          }
        }

        /**
         * @ignore
         */
        babelHelpers.createClass(VerticalAxis, [{
          key: 'onAdd',
          value: function onAdd(map) {
            var _this2 = this;

            this._map = map;

            if (this._covLayer.on) {
              this._covLayer.on('axisChange', this._axisListener);
            }

            var crsVertAxis = this._covLayer.crsVerticalAxis || {};
            var title = crsVertAxis.name ? i18n.getLanguageString(crsVertAxis.name) : this._title;
            var unit = unitUtil.toAscii(crsVertAxis.unit);
            if (unit) {
              unit = ' ' + unit;
            }

            var choices = [];
            var vals = this._covLayer.verticalSlices;
            for (var i = 0; i < vals.length; i++) {
              choices.push({
                value: i.toString(),
                label: vals[i] + unit
              });
            }

            this._dropdown = new Dropdown(choices, {
              position: this._position,
              title: title,
              value: this._getVerticalIndex().toString()
            }).on('change', function (event) {
              var i = parseInt(event.value);
              var val = _this2._covLayer.verticalSlices[i];
              _this2._covLayer.vertical = val;
              _this2.fire('change', { vertical: val });
            }).addTo(map);
          }

          /**
           * @ignore
           */
        }, {
          key: 'onRemove',
          value: function onRemove(map) {
            this._dropdown.removeFrom(map);
            if (this._covLayer.off) {
              this._covLayer.off('remove', this._remove);
              this._covLayer.off('axisChange', this._axisListener);
            }
          }
        }, {
          key: 'addTo',
          value: function addTo(map) {
            map.addLayer(this);
            return this;
          }
        }, {
          key: 'removeFrom',
          value: function removeFrom(map) {
            this.onRemove(map);
            return this;
          }
        }, {
          key: '_getVerticalIndex',
          value: function _getVerticalIndex() {
            var vals = this._covLayer.verticalSlices;
            var i = vals.indexOf(this._covLayer.vertical);
            return i;
          }

          /**
           * Triggers a manual update of the vertical axis control based on the
           * <code>vertical</code> property of the layer.
           * 
           * Useful if the supplied coverage data layer is not a real layer
           * and won't fire the necessary events for automatic updates.
           */
        }, {
          key: 'update',
          value: function update() {
            var i = this._getVerticalIndex();
            this._dropdown.value = i.toString();
          }
        }]);
        return VerticalAxis;
      })(EventMixin(L.Class));

      _export('default', VerticalAxis);
    }
  };
});

$__System.register('1e', ['5', '8', '45'], function (_export) {
  /* */
  'use strict';

  var L, $, HTML, EventMixin, TEMPLATE, TimeAxis;

  function getUTCTimestampDateOnly(dateStr) {
    var year = parseInt(dateStr.substr(0, 4));
    var month = parseInt(dateStr.substr(5, 2));
    var day = parseInt(dateStr.substr(8, 2));
    return Date.UTC(year, month - 1, day);
  }

  function getUTCDateString(timestamp) {
    var iso = new Date(timestamp).toISOString();
    var date = iso.substr(0, 10);
    return date;
  }
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_2) {
      $ = _2.$;
      HTML = _2.HTML;
    }, function (_3) {
      EventMixin = _3['default'];
    }],
    execute: function () {
      TEMPLATE = '<div class="info" style="clear:none">\n  <strong class="title">Time</strong><br>\n  <select name="date" class="date"></select>\n  <select name="time" class="time"></select>\n</div>';

      /**
       * Displays a simple date/time picker for a coverage data layer by grouping
       * time steps into dates and times.
       * 
       * @example <caption>Coverage data layer</caption>
       * new TimeAxis(covLayer).addTo(map)
       * // Selecting a date/time automatically sets the 'time' property in the layer.
       * // Similarly, when the layer fires an 'axisChange' event with {axis: 'time'}
       * // the control reflects that change.
       * 
       * @example <caption>Fake layer</caption>
       * var times = ['2000-01-01T00:00:00Z','2000-01-01T05:00:00Z'].map(s => new Date(s))
       * var fakeLayer = {
       *   timeSlices: times,
       *   time: times[1] // select the second time step initially
       * }
       * var timeAxis = new TimeAxis(fakeLayer).addTo(map)
       * 
       * // change the time and trigger a manual update
       * fakeLayer.time = times[0]
       * timeAxis.update()
       * 
       * @example <caption>Non-module access</caption>
       * L.coverage.control.TimeAxis
       */

      TimeAxis = (function (_EventMixin) {
        babelHelpers.inherits(TimeAxis, _EventMixin);

        /**
         * Creates a time axis control.
         * 
         * @param {object} covLayer 
         *   The coverage data layer, or any object with <code>timeSlices</code>
         *   and <code>time</code> properties.
         *   If the object has <code>on</code>/<code>off</code> methods, then the control will
         *   listen for <code>"axisChange"</code> events with <code>{axis: 'time'}</code>
         *   and update itself automatically.
         *   If the layer fires a <code>"remove"</code> event, then the control will remove itself
         *   from the map.
         * @param {object} [options] Control options.
         * @param {string} [options.position='topleft'] The initial position of the control (see Leaflet docs).
         * @param {string} [options.title='Time'] The label to show above the date/time picker.
         */

        function TimeAxis(covLayer) {
          var _this = this;

          var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
          babelHelpers.classCallCheck(this, TimeAxis);

          babelHelpers.get(Object.getPrototypeOf(TimeAxis.prototype), 'constructor', this).call(this, { position: options.position || 'topleft' });
          this._title = options.title || 'Time';
          this._covLayer = covLayer;

          if (covLayer.on) {
            this._remove = function () {
              return _this.removeFrom(_this._map);
            };
            covLayer.on('remove', this._remove);

            this._axisListener = function (e) {
              if (e.axis === 'time') _this.update();
            };
          }

          var timeSlices = this._covLayer.timeSlices;
          var dateMap = new Map(); // UTC timestamp (representing the date only) -> array of Date objects
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = timeSlices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var t = _step.value;

              var dateTimestamp = new Date(Date.UTC(t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate())).getTime();
              if (!dateMap.has(dateTimestamp)) {
                dateMap.set(dateTimestamp, []);
              }
              dateMap.get(dateTimestamp).push(t);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator['return']) {
                _iterator['return']();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          this._dateMap = dateMap;
        }

        /**
         * @ignore
         */
        babelHelpers.createClass(TimeAxis, [{
          key: 'onAdd',
          value: function onAdd(map) {
            var _this2 = this;

            this._map = map;

            if (this._covLayer.on) {
              this._covLayer.on('axisChange', this._axisListener);
            }

            var el = HTML(TEMPLATE)[0];
            this._el = el;
            L.DomEvent.disableClickPropagation(el);

            if (this._title) {
              $('.title', el).fill(this._title);
            }

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = this._dateMap.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var dateTimestamp = _step2.value;

                var dateStr = getUTCDateString(dateTimestamp);
                $('.date', el).add(HTML('<option value="' + dateStr + '">' + dateStr + '</option>'));
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                  _iterator2['return']();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }

            $('.date', el)[0].disabled = this._dateMap.size === 1;

            $('.date', el).on('change', function (event) {
              var dateTimestamp = getUTCTimestampDateOnly(event.target.value);
              var timeSlice = _this2._dateMap.get(dateTimestamp)[0];
              _this2._covLayer.time = timeSlice;
              _this2._initTimeSelect(dateTimestamp);
              _this2.fire('change', { time: timeSlice });
            });
            $('.time', el).on('change', function (event) {
              var dateStr = $('.date', el)[0].value;
              var timeStr = event.target.value;
              var time = new Date(dateStr + 'T' + timeStr);
              _this2._covLayer.time = time;
              _this2.fire('change', { time: time });
            });

            this.update();

            return el;
          }

          /**
           * @ignore
           */
        }, {
          key: 'onRemove',
          value: function onRemove() {
            if (this._covLayer.off) {
              this._covLayer.off('remove', this._remove);
              this._covLayer.off('axisChange', this._axisListener);
            }
          }

          /**
           * Triggers a manual update of the date/time picker based on the
           * <code>time</code> property of the layer.
           * 
           * Useful if the supplied coverage data layer is not a real layer
           * and won't fire the necessary events for automatic updates.
           */
        }, {
          key: 'update',
          value: function update() {
            var covTime = this._covLayer.time;
            if (!covTime) return;
            var el = this._el;
            // selects the date set in the cov layer, populates the time select, and selects the time
            var dateTimestamp = getUTCTimestampDateOnly(covTime.toISOString());
            var dateStr = getUTCDateString(dateTimestamp);
            $('.date', el)[0].value = dateStr;

            this._initTimeSelect(dateTimestamp);

            var timeStr = covTime.toISOString().substr(11);
            $('.time', el)[0].value = timeStr;
          }
        }, {
          key: '_initTimeSelect',
          value: function _initTimeSelect(dateTimestamp) {
            var el = this._el;
            var timeSelect = $('.time', el);
            timeSelect.fill();
            var times = this._dateMap.get(dateTimestamp);
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = times[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var timeSlice = _step3.value;

                var timeStr = timeSlice.toISOString().substr(11);
                timeSelect.add(HTML('<option value="' + timeStr + '">' + timeStr + '</option>'));
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                  _iterator3['return']();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            timeSelect[0].disabled = times.length === 1;
          }
        }]);
        return TimeAxis;
      })(EventMixin(L.Control));

      _export('default', TimeAxis);
    }
  };
});

$__System.register('47', ['5', '8', '43', '48'], function (_export) {
  /* */

  // TODO the default template should be moved outside this module so that it can be easily skipped
  'use strict';

  var L, $, i18n, inject, fromTemplate, DEFAULT_TEMPLATE_ID, DEFAULT_TEMPLATE, DEFAULT_TEMPLATE_CSS, ContinuousLegend;
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_2) {
      $ = _2.$;
    }, function (_4) {
      i18n = _4;
    }, function (_3) {
      inject = _3.inject;
      fromTemplate = _3.fromTemplate;
    }],
    execute: function () {
      DEFAULT_TEMPLATE_ID = 'template-coverage-parameter-continuous-legend';
      DEFAULT_TEMPLATE = '\n<template id="' + DEFAULT_TEMPLATE_ID + '">\n  <div class="info legend continuous-legend">\n    <div style="margin-bottom:3px" class="legend-title-container">\n      <strong class="legend-title"></strong>\n    </div>\n    <div style="display: inline-block; height: 144px; float:left">\n      <span style="height: 136px; width: 18px; display: block; margin-top: 9px;" class="legend-palette"></span>\n    </div>\n    <div style="display: inline-block; float:left; height:153px">\n      <table style="height: 100%;">\n        <tr><td style="vertical-align:top"><span class="legend-max"></span> <span class="legend-uom"></span></td></tr>\n        <tr><td><span class="legend-current"></span></td></tr>\n        <tr><td style="vertical-align:bottom"><span class="legend-min"></span> <span class="legend-uom"></span></td></tr>\n      </table>\n    </div>\n  </div>\n</template>\n';
      DEFAULT_TEMPLATE_CSS = '\n.legend {\n  color: #555;\n}\n.legend-title {\n  word-wrap: break-word;\n}\n.legend-title-container {\n  max-width: 120px;\n}\n';

      /**
       * Displays a continuous legend for the parameter displayed by the given
       * coverage data layer.
       * 
       * Note that this class should only be used if the palette is continuous
       * by nature, typically having at least 100-200 color steps.
       * If there are only a few color steps (e.g. 10), then this class
       * will still show a continuous legend due to its rendering technique
       * (CSS gradient based).
       * 
       * @example <caption>Coverage data layer</caption>
       * new ContinuousLegend(covLayer).addTo(map)
       * // changing the palette of the layer automatically updates the legend 
       * covLayer.palette = linearPalette(['blue', 'red'])
       * 
       * @example <caption>Fake layer</caption>
       * var fakeLayer = {
       *   parameter: {
       *     observedProperty: {
       *       label: { en: 'Temperature' }
       *     },
       *     unit: {
       *       symbol: { value: 'K' },
       *       label: { en: 'Kelvin' }
       *     }
       *   },
       *   palette: linearPalette(['#FFFFFF', '#000000']),
       *   paletteExtent: [0, 10]
       * }
       * var legend = new ContinuousLegend(fakeLayer).addTo(map)
       * 
       * // change the palette and trigger a manual update
       * fakeLayer.palette = linearPalette(['blue', 'red'])
       * legend.update()
       * 
       * @example <caption>Non-module access</caption>
       * L.coverage.control.ContinuousLegend
       */

      ContinuousLegend = (function (_L$Control) {
        babelHelpers.inherits(ContinuousLegend, _L$Control);

        /**
         * Creates a continuous legend control.
         * 
         * @param {object} covLayer 
         *   The coverage data layer, or any object with <code>palette</code>,
         *   <code>paletteExtent</code>, and <code>parameter</code> properties.
         *   If the object has <code>on</code>/<code>off</code> methods, then the legend will
         *   listen for <code>"paletteChange"</code> and <code>"paletteExtentChange"</code>
         *   events and update itself automatically.
         *   If the layer fires a <code>"remove"</code> event, then the legend will remove itself
         *   from the map. 
         * @param {object} [options] Legend options.
         * @param {string} [options.position='bottomright'] The initial position of the control (see Leaflet docs).
         * @param {string} [options.language] A language tag, indicating the preferred language to use for labels.
         * @param {string} [options.id] Uses the HTML element with the given id as template.
         */

        function ContinuousLegend(covLayer) {
          var _this = this;

          var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
          babelHelpers.classCallCheck(this, ContinuousLegend);

          babelHelpers.get(Object.getPrototypeOf(ContinuousLegend.prototype), 'constructor', this).call(this, { position: options.position || 'bottomright' });
          this._covLayer = covLayer;
          this._id = options.id || DEFAULT_TEMPLATE_ID;
          this._language = options.language;

          if (!options.id && document.getElementById(DEFAULT_TEMPLATE_ID) === null) {
            inject(DEFAULT_TEMPLATE, DEFAULT_TEMPLATE_CSS);
          }

          if (covLayer.on) {
            this._remove = function () {
              return _this.removeFrom(_this._map);
            };
            this._update = function () {
              return _this._doUpdate(false);
            };
            covLayer.on('remove', this._remove);
          }
        }

        /**
         * Triggers a manual update of the legend.
         * 
         * Useful if the supplied coverage data layer is not a real layer
         * and won't fire the necessary events for automatic updates.
         */
        babelHelpers.createClass(ContinuousLegend, [{
          key: 'update',
          value: function update() {
            this._doUpdate(true);
          }

          // TODO move this into a reusable unit-formatting module
        }, {
          key: '_getUnitString',
          value: function _getUnitString(param, language) {
            if (!param.unit) {
              return '';
            }
            if (param.unit.symbol) {
              var unit = param.unit.symbol.value || param.unit.symbol;
              var scheme = param.unit.symbol.type;
              if (scheme === 'http://www.opengis.net/def/uom/UCUM/') {
                if (unit === 'Cel') {
                  unit = '°C';
                } else if (unit === '1') {
                  unit = '';
                }
              }
              return unit;
            } else {
              return i18n.getLanguageString(param.unit.label, language);
            }
          }
        }, {
          key: '_doUpdate',
          value: function _doUpdate(fullUpdate) {
            var el = this._el;

            if (fullUpdate) {
              var param = this._covLayer.parameter;
              // if requested language doesn't exist, use the returned one for all other labels
              var language = i18n.getLanguageTag(param.observedProperty.label, this._language);
              var title = i18n.getLanguageString(param.observedProperty.label, language);
              var unit = this._getUnitString(param, language);
              $('.legend-title', el).fill(title);
              $('.legend-uom', el).fill(unit);
            }

            var palette = this._covLayer.palette;

            var _covLayer$paletteExtent = babelHelpers.slicedToArray(this._covLayer.paletteExtent, 2);

            var low = _covLayer$paletteExtent[0];
            var high = _covLayer$paletteExtent[1];

            $('.legend-min', el).fill(low.toFixed(2));
            $('.legend-max', el).fill(high.toFixed(2));

            var gradient = '';
            for (var i = 0; i < palette.steps; i++) {
              if (i > 0) gradient += ',';
              gradient += 'rgb(' + palette.red[i] + ',' + palette.green[i] + ',' + palette.blue[i] + ')';
            }

            $('.legend-palette', el).set('$background', 'transparent linear-gradient(to top, ' + gradient + ') repeat scroll 0% 0%');
          }

          /**
           * @ignore
           */
        }, {
          key: 'onAdd',
          value: function onAdd(map) {
            this._map = map;

            if (this._covLayer.on) {
              this._covLayer.on('paletteChange', this._update);
              this._covLayer.on('paletteExtentChange', this._update);
            }

            this._el = fromTemplate(this._id);
            this.update();
            return this._el;
          }

          /**
           * @ignore
           */
        }, {
          key: 'onRemove',
          value: function onRemove() {
            if (this._covLayer.off) {
              this._covLayer.off('remove', this._remove);
              this._covLayer.off('paletteChange', this._update);
              this._covLayer.off('paletteExtentChange', this._update);
            }
          }
        }]);
        return ContinuousLegend;
      })(L.Control);

      _export('default', ContinuousLegend);
    }
  };
});

$__System.register('43', ['44'], function (_export) {
  /* */
  'use strict';

  return {
    setters: [function (_) {
      var _exportObj = {};
      _exportObj['getLanguageTag'] = _.getLanguageTag;
      _exportObj['getLanguageString'] = _.getLanguageString;

      _export(_exportObj);
    }],
    execute: function () {}
  };
});

$__System.register('48', ['8'], function (_export) {
  /* */

  /**
   * Inject HTML and CSS into the DOM.
   * 
   * @param html The html to inject at the end of the body element.
   * @param css The CSS styles to inject at the end of the head element.
   * 
   * @ignore
   */
  'use strict';

  var $, HTML;

  /**
   * @ignore
   */

  _export('inject', inject);

  _export('fromTemplate', fromTemplate);

  function inject(html, css) {
    // inject default template and CSS into DOM
    if (html) {
      $('body').add(HTML(html));
    }

    if (css) {
      var style = document.createElement('style');
      style.type = 'text/css';
      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(document.createTextNode(css));
      }
      document.head.appendChild(style);
    }
  }

  function fromTemplate(id) {
    var node = $('#' + id)[0];
    // browsers without <template> support don't wrap everything in .content
    if ('content' in node) {
      node = node.content;
    }
    return document.importNode(node, true).children[0];
  }

  return {
    setters: [function (_) {
      $ = _.$;
      HTML = _.HTML;
    }],
    execute: function () {}
  };
});

$__System.register('49', ['5', '8', '43', '48'], function (_export) {
  /* */

  // TODO the default template should be moved outside this module so that it can be easily skipped
  'use strict';

  var L, $, HTML, i18n, inject, fromTemplate, DEFAULT_TEMPLATE_ID, DEFAULT_TEMPLATE, DEFAULT_TEMPLATE_CSS, DiscreteLegend;
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_2) {
      $ = _2.$;
      HTML = _2.HTML;
    }, function (_4) {
      i18n = _4;
    }, function (_3) {
      inject = _3.inject;
      fromTemplate = _3.fromTemplate;
    }],
    execute: function () {
      DEFAULT_TEMPLATE_ID = 'template-coverage-parameter-discrete-legend';
      DEFAULT_TEMPLATE = '\n<template id="' + DEFAULT_TEMPLATE_ID + '">\n  <div class="info legend discrete-legend">\n    <div class="legend-title-container"><strong class="legend-title"></strong></div>\n    <div class="legend-palette discrete-legend-palette"></div>\n  </div>\n</template>\n';
      DEFAULT_TEMPLATE_CSS = '\n.legend {\n  color: #555;\n}\n.legend-title-container {\n  max-width: 120px;\n}\n.legend-title {\n  word-wrap: break-word;\n}\n.discrete-legend-palette {\n  padding: 2px 1px;\n  line-height: 18px;\n}\n.discrete-legend-palette i {\n  float: left;\n  height: 18px;\n  margin-right: 8px;\n  width: 18px;\n}\n';

      /**
       * Displays a discrete palette legend for the parameter displayed by the given
       * Coverage layer. Supports category parameters only at the moment.
       * 
       * @example <caption>Coverage data layer</caption>
       * new DiscreteLegend(covLayer).addTo(map)
       * // changing the palette of the layer automatically updates the legend 
       * covLayer.palette = discretePalette(['red', 'blue'])
       * 
       * @example <caption>Fake layer</caption>
       * var fakeLayer = {
       *   parameter: {
       *     observedProperty: {
       *       label: { en: 'Land cover' },
       *       categories: [{
       *         label: { en: 'Land' }
       *       }, {
       *         label: { en: 'Water' }
       *       }]
       *     }
       *   },
       *   palette: directPalette(['gray', 'blue']) // CSS colors in category order
       * }
       * var legend = new DiscreteLegend(fakeLayer).addTo(map)
       * 
       * // change the palette and trigger a manual update
       * fakeLayer.palette = discretePalette(['red', 'blue'])
       * legend.update()
       * 
       * @example <caption>Non-module access</caption>
       * L.coverage.control.DiscreteLegend
       */

      DiscreteLegend = (function (_L$Control) {
        babelHelpers.inherits(DiscreteLegend, _L$Control);

        /**
         * Creates a discrete legend control.
         * 
         * @param {object} covLayer 
         *   The coverage data layer, or any object with <code>palette</code>
         *   and <code>parameter</code> properties.
         *   If the object has <code>on</code>/<code>off</code> methods, then the legend will
         *   listen for <code>"paletteChange"</code> events and update itself automatically.
         *   If the layer fires a <code>"remove"</code> event, then the legend will remove itself
         *   from the map. 
         * @param {object} [options] Legend options.
         * @param {string} [options.position='bottomright'] The initial position of the control (see Leaflet docs).
         * @param {string} [options.language] A language tag, indicating the preferred language to use for labels.
         * @param {string} [options.id] Uses the HTML element with the given id as template.
         */

        function DiscreteLegend(covLayer) {
          var _this = this;

          var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
          babelHelpers.classCallCheck(this, DiscreteLegend);

          babelHelpers.get(Object.getPrototypeOf(DiscreteLegend.prototype), 'constructor', this).call(this, { position: options.position || 'bottomright' });
          this._covLayer = covLayer;
          this._id = options.id || DEFAULT_TEMPLATE_ID;
          this._language = options.language;

          if (!options.id && document.getElementById(DEFAULT_TEMPLATE_ID) === null) {
            inject(DEFAULT_TEMPLATE, DEFAULT_TEMPLATE_CSS);
          }

          if (covLayer.on) {
            this._remove = function () {
              return _this.removeFrom(_this._map);
            };
            this._update = function () {
              return _this._doUpdate(false);
            };
            covLayer.on('remove', this._remove);
          }
        }

        /**
         * Triggers a manual update of the legend.
         * 
         * Useful if the supplied coverage data layer is not a real layer
         * and won't fire the necessary events for automatic updates.
         */
        babelHelpers.createClass(DiscreteLegend, [{
          key: 'update',
          value: function update() {
            this._doUpdate(true);
          }
        }, {
          key: '_doUpdate',
          value: function _doUpdate(fullUpdate) {
            var el = this._el;

            if (fullUpdate) {
              var _param = this._covLayer.parameter;
              // if requested language doesn't exist, use the returned one for all other labels
              this._language = i18n.getLanguageTag(_param.observedProperty.label, this._language);
              var title = i18n.getLanguageString(_param.observedProperty.label, this._language);
              $('.legend-title', el).fill(title);
            }

            var palette = this._covLayer.palette;
            var param = this._covLayer.parameter;

            var html = '';

            for (var i = 0; i < palette.steps; i++) {
              var cat = i18n.getLanguageString(param.observedProperty.categories[i].label, this._language);
              html += '\n        <i style="background:rgb(' + palette.red[i] + ', ' + palette.green[i] + ', ' + palette.blue[i] + ')"></i>\n        ' + cat + '\n        <br>';
            }

            $('.legend-palette', el).fill(HTML(html));
          }

          /**
           * @ignore
           */
        }, {
          key: 'onAdd',
          value: function onAdd(map) {
            this._map = map;

            if (this._covLayer.on) {
              this._covLayer.on('paletteChange', this._update);
            }

            this._el = fromTemplate(this._id);
            this.update();
            return this._el;
          }

          /**
           * @ignore
           */
        }, {
          key: 'onRemove',
          value: function onRemove() {
            if (this._covLayer.off) {
              this._covLayer.off('remove', this._remove);
              this._covLayer.off('paletteChange', this._update);
            }
          }
        }]);
        return DiscreteLegend;
      })(L.Control);

      _export('default', DiscreteLegend);
    }
  };
});

$__System.register('4a', ['47', '49'], function (_export) {
  /* */

  /**
   * Convenience function that returns a legend control
   * based on the coverage parameter type.
   * For categorical parameters this returns a {@link DiscreteLegend},
   * otherwise a {@link ContinuousLegend} instance.
   * 
   * Note that custom HTML templates cannot be used with this function.
   * If this is necessary, consider using the individual legend classes
   * instead. 
   * 
   * @example <caption>Coverage data layer</caption>
   * var legend = Legend(covLayer).addTo(map)
   * 
   * @example <caption>Fake layer</caption>
   * // see DiscreteLegend and ContinuousLegend docs
   * 
   * @example <caption>Non-module access</caption>
   * L.coverage.control.Legend
   * 
   * @param {object} covLayer The coverage data layer.
   * @param {object} [options] Legend options.
   * @param {string} [options.position='bottomright'] The initial position of the control (see Leaflet docs).
   * @param {string} [options.language] A language tag, indicating the preferred language to use for labels.
   * @return {DiscreteLegend|ContinuousLegend}
   */
  'use strict';

  var ContinuousLegend, DiscreteLegend;
  return {
    setters: [function (_2) {
      ContinuousLegend = _2['default'];
    }, function (_) {
      DiscreteLegend = _['default'];
    }],
    execute: function () {
      _export('default', function (layer) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        options.position = options.position || 'bottomright';
        if (layer.parameter.observedProperty.categories) {
          return new DiscreteLegend(layer, options);
        } else {
          return new ContinuousLegend(layer, options);
        }
      });
    }
  };
});

$__System.register('4b', ['5'], function (_export) {
  /* */

  /**
   * Default function that checks if two Parameter objects describe
   * the same thing. No magic is applied here. Exact match or nothing.
   */
  'use strict';

  var L, ParameterSync, SyncLayer;
  function defaultMatch(p1, p2) {
    if (p1.id && p2.id && p1.id === p2.id) {
      return true;
    }
    if (!p1.observedProperty.id || !p2.observedProperty.id) {
      return false;
    }
    if (p1.observedProperty.id !== p2.observedProperty.id) {
      return false;
    }
    if (p1.unit && p2.unit) {
      if (p1.unit.id && p2.unit.id && p1.unit.id !== p2.unit.id) {
        return false;
      }
      if (p1.unit.symbol && p2.unit.symbol && p1.unit.symbol !== p2.unit.symbol) {
        return false;
      }
    } else if (p1.unit || p2.unit) {
      // only one of both has units
      return false;
    }
    if (p1.categories && p2.categories) {
      if (p1.categories.length !== p2.categories.length) {
        return false;
      }
      var idMissing = function idMissing(cat) {
        return !cat.id;
      };
      if (p1.categories.some(idMissing) || p2.categories.some(idMissing)) {
        return false;
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        var _loop = function () {
          var cat1 = _step.value;

          if (!p2.categories.some(function (cat2) {
            return cat1.id === cat2.id;
          })) {
            return {
              v: false
            };
          }
        };

        for (var _iterator = p1.categories[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _ret = _loop();

          if (typeof _ret === 'object') return _ret.v;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } else if (p1.categories || p2.categories) {
      // only one of both has categories
      return false;
    }
    return true;
  }

  /**
   * Synchronizes visualization options of multiple renderer layers with matching Parameter
   * and exposes a combined view of those options in form of a virtual layer object.
   * 
   * A common use case for this is to have equal palettes and only a single legend
   * for multiple layers describing the same parameter.
   * 
   * Synchronizing visualization options means synchronizing certain common properties
   * of the layer instances. For example, the palette extents of two layers can be
   * synchronized by merging the extents of both. The logic for doing that has to
   * be specified in terms of binary functions supplied in the constructor.
   * 
   * By default, a simple algorithm determines if two Parameter objects are equivalent
   * by checking whether things like observedPropery have the same ID, units are the same,
   * etc. This default algorithm can be replaced with a custom one. Such a custom
   * algorithm could relate different vocabularies with each other or perform other checks.
   * 
   * @example <caption>Common palettes</caption>
   * let paramSync = new ParameterSync({
   *   syncProperties: {
   *     palette: (p1, p2) => p1,
   *     paletteExtent: (e1, e2) => e1 && e2 ? [Math.min(e1[0], e2[0]), Math.max(e1[1], e2[1])] : null
   *   }
   * }).on('parameterAdd', e => {
   *   // The virtual sync layer proxies the synced palette, paletteExtent, and parameter.
   *   // The sync layer will fire a 'remove' event once all real layers for that parameter were removed.
   *   let layer = e.syncLayer
   *   if (layer.palette) {
   *     new Legend(layer, {
   *       position: 'bottomright'
   *     }).addTo(map)
   *   }
   * })
   * let layer = layerFactory(cov).on('add', e => {
   *   // Only add the layer to the ParameterSync instance once it has initialized.
   *   // We can use the 'add' event for that.
   *   paramSync.addLayer(e.target)
   * })
   */
  return {
    setters: [function (_) {
      L = _['default'];
    }],
    execute: function () {
      ParameterSync = (function (_L$Class) {
        babelHelpers.inherits(ParameterSync, _L$Class);

        /**
         * @param {Object} options
         * @param {Object} options.syncProperties - 
         *   An object that defines which properties shall be synchronized and how.
         *   Each key is a property name where the value is a binary function that merges
         *   the values of two such properties.
         * @param {Function} [options.match] - 
         *   Custom function that checks if two Parameter objects shall be equivalent.
         *   The default function is simple and checks for identity of several properties.
         */

        function ParameterSync(options) {
          babelHelpers.classCallCheck(this, ParameterSync);

          babelHelpers.get(Object.getPrototypeOf(ParameterSync.prototype), 'constructor', this).call(this);
          this._syncProps = options.syncProperties || {};
          this._match = options.match || defaultMatch;
          this._paramLayers = new Map(); // Map (Parameter -> Set(Layer))
          this._layerListeners = new Map(); // Map (Layer -> Map(type -> listener))
          this._propSyncing = new Set(); // Set (property name)
        }

        /**
         * Adds a layer that will be synchronized.
         * 
         * Synchronization stops automatically when the layer fires a 'remove' event.
         * 
         * @param {ILayer} layer - The layer to synchronize.
         * @fires ParameterSync#parameterAdd - When a layer with a new parameter was added.
         */
        babelHelpers.createClass(ParameterSync, [{
          key: 'addLayer',
          value: function addLayer(layer) {
            var _this = this;

            if (!layer.parameter) {
              console.log('layer has no parameter, skipping parameter sync');
              return;
            }
            var params = Array.from(this._paramLayers.keys());
            var match = params.find(function (p) {
              return _this._match(p, layer.parameter);
            });

            var param = undefined;
            if (!match) {
              param = layer.parameter;
              this._paramLayers.set(param, new Set([layer]));
            } else {
              param = match;
              this._paramLayers.get(param).add(layer);
              this._syncProperties(param);
            }

            this._registerLayerListeners(layer, param);

            if (!match) {
              /**
               * Parameter Add event.
               * 
               * @event ParameterSync#parameterAdd
               * @type {object}
               * @property {SyncLayer} syncLayer - 
               *   A virtual layer that proxies the synchronized properties for a single parameter.
               *   If all layers of that parameter are removed, this layer fires a 'remove' event,
               *   signalling that the parameter is not present anymore.
               */
              this.fire('parameterAdd', { syncLayer: new SyncLayer(param, this) });
            }
          }

          /**
           * Pause synchronization. This is useful when a property of
           * many layers has to be set manually (like paletteExtent = 'fov') and
           * the synchronization shall happen afterwards (see resume()).
           */
        }, {
          key: 'pause',
          value: function pause() {
            this.paused = true;
          }

          /**
           * Resumes synchronization.
           * 
           * @param {bool} [sync] If true, then all layers will be synchronized immediately.
           */
        }, {
          key: 'resume',
          value: function resume(sync) {
            this.paused = false;
            if (sync) {
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = this._paramLayers.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var param = _step2.value;

                  this._syncProperties(param);
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                    _iterator2['return']();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            }
          }
        }, {
          key: '_removeLayer',
          value: function _removeLayer(layer, param) {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = this._layerListeners.get(layer)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var _step3$value = babelHelpers.slicedToArray(_step3.value, 2);

                var type = _step3$value[0];
                var fn = _step3$value[1];

                layer.off(type, fn);
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                  _iterator3['return']();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            this._layerListeners['delete'](layer);
            this._paramLayers.get(param)['delete'](layer);
            if (this._paramLayers.get(param).size === 0) {
              this._paramLayers['delete'](param);
              // underscore since the 'remove' event of the syncLayer should be used
              // from the outside
              this.fire('_parameterRemove', { param: param });
            }
          }
        }, {
          key: '_registerLayerListeners',
          value: function _registerLayerListeners(layer, param) {
            var _this2 = this;

            var listeners = new Map([['remove', function () {
              return _this2._removeLayer(layer, param);
            }]]);
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              var _loop2 = function () {
                var prop = _step4.value;

                var type = prop + 'Change'; // our convention is camel case
                // TODO does it make sense to unify again, or should it just propagate unchanged?
                listeners.set(type, function () {
                  return _this2._syncProperty(param, prop);
                });
              };

              for (var _iterator4 = Object.keys(this._syncProps)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                _loop2();
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                  _iterator4['return']();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
              for (var _iterator5 = listeners[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var _step5$value = babelHelpers.slicedToArray(_step5.value, 2);

                var type = _step5$value[0];
                var fn = _step5$value[1];

                layer.on(type, fn);
              }
            } catch (err) {
              _didIteratorError5 = true;
              _iteratorError5 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion5 && _iterator5['return']) {
                  _iterator5['return']();
                }
              } finally {
                if (_didIteratorError5) {
                  throw _iteratorError5;
                }
              }
            }

            this._layerListeners.set(layer, listeners);
          }
        }, {
          key: '_syncProperties',
          value: function _syncProperties(param) {
            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = undefined;

            try {
              for (var _iterator6 = Object.keys(this._syncProps)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                var prop = _step6.value;

                this._syncProperty(param, prop);
              }
            } catch (err) {
              _didIteratorError6 = true;
              _iteratorError6 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion6 && _iterator6['return']) {
                  _iterator6['return']();
                }
              } finally {
                if (_didIteratorError6) {
                  throw _iteratorError6;
                }
              }
            }
          }
        }, {
          key: '_syncProperty',
          value: function _syncProperty(param, prop) {
            if (this.paused || this._propSyncing.has(prop)) {
              return;
            }
            var propreduce = this._syncProps[prop];
            var unified = [].concat(babelHelpers.toConsumableArray(this._paramLayers.get(param))).map(function (l) {
              return l[prop];
            }).reduce(propreduce);
            // While we unify properties, stop listening for changes to prevent a cycle.
            this._propSyncing.add(prop);
            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
              for (var _iterator7 = this._paramLayers.get(param)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var layer_ = _step7.value;

                layer_[prop] = unified;
              }
            } catch (err) {
              _didIteratorError7 = true;
              _iteratorError7 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion7 && _iterator7['return']) {
                  _iterator7['return']();
                }
              } finally {
                if (_didIteratorError7) {
                  throw _iteratorError7;
                }
              }
            }

            this._propSyncing['delete'](prop);
            this.fire('_syncPropChange', { param: param, prop: prop });
          }
        }]);
        return ParameterSync;
      })(L.Class);

      ParameterSync.include(L.Mixin.Events);

      SyncLayer = (function (_L$Class2) {
        babelHelpers.inherits(SyncLayer, _L$Class2);

        function SyncLayer(param, paramSync) {
          var _this3 = this;

          babelHelpers.classCallCheck(this, SyncLayer);

          babelHelpers.get(Object.getPrototypeOf(SyncLayer.prototype), 'constructor', this).call(this);
          this._param = param;
          paramSync.on('_parameterRemove', function (e) {
            if (e.param === param) {
              _this3.fire('remove');
            }
          });
          paramSync.on('_syncPropChange', function (e) {
            if (e.param === param) {
              _this3.fire(e.prop + 'Change');
            }
          });
          var layers = function layers() {
            return paramSync._paramLayers.get(param);
          };
          var _iteratorNormalCompletion8 = true;
          var _didIteratorError8 = false;
          var _iteratorError8 = undefined;

          try {
            var _loop3 = function () {
              var prop = _step8.value;

              Object.defineProperty(_this3, prop, {
                get: function get() {
                  return layers().values().next().value[prop];
                },
                set: function set(v) {
                  paramSync._propSyncing.add(prop);
                  var _iteratorNormalCompletion9 = true;
                  var _didIteratorError9 = false;
                  var _iteratorError9 = undefined;

                  try {
                    for (var _iterator9 = layers()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                      var layer = _step9.value;

                      layer[prop] = v;
                    }
                  } catch (err) {
                    _didIteratorError9 = true;
                    _iteratorError9 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion9 && _iterator9['return']) {
                        _iterator9['return']();
                      }
                    } finally {
                      if (_didIteratorError9) {
                        throw _iteratorError9;
                      }
                    }
                  }

                  paramSync._propSyncing['delete'](prop);
                  _this3.fire(prop + 'Change');
                },
                enumerable: true
              });
            };

            for (var _iterator8 = Object.keys(paramSync._syncProps)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              _loop3();
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8['return']) {
                _iterator8['return']();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }
        }

        babelHelpers.createClass(SyncLayer, [{
          key: 'parameter',
          get: function get() {
            return this._param;
          }
        }]);
        return SyncLayer;
      })(L.Class);

      SyncLayer.include(L.Mixin.Events);

      // work-around for Babel bug, otherwise ParameterSync cannot be referenced above for mixins

      _export('default', ParameterSync);
    }
  };
});

$__System.register('1d', ['28'], function (_export) {
  /* */
  'use strict';

  var COVJSON_PREFIX, COVJSON_POINT, COVJSON_POINTSERIES, COVJSON_VERTICALPROFILE, COVJSON_GRID, COVJSON_TRAJECTORY, COVJSON_POLYGONSERIES, COVJSON_MULTIPOLYGON, COVJSON_DATATYPE_TUPLE, COVJSON_DATATYPE_POLYGON;
  return {
    setters: [function (_) {
      var _exportObj = {};

      // JS API object types
      _exportObj['COVERAGE'] = _.COVERAGE;
      _exportObj['COVERAGECOLLECTION'] = _.COVERAGECOLLECTION;
      _exportObj['DOMAIN'] = _.DOMAIN;

      _export(_exportObj);
    }],
    execute: function () {
      COVJSON_PREFIX = 'http://coveragejson.org/def#';
      COVJSON_POINT = COVJSON_PREFIX + 'Point';

      _export('COVJSON_POINT', COVJSON_POINT);

      COVJSON_POINTSERIES = COVJSON_PREFIX + 'PointSeries';

      _export('COVJSON_POINTSERIES', COVJSON_POINTSERIES);

      COVJSON_VERTICALPROFILE = COVJSON_PREFIX + 'VerticalProfile';

      _export('COVJSON_VERTICALPROFILE', COVJSON_VERTICALPROFILE);

      COVJSON_GRID = COVJSON_PREFIX + 'Grid';

      _export('COVJSON_GRID', COVJSON_GRID);

      COVJSON_TRAJECTORY = COVJSON_PREFIX + 'Trajectory';

      _export('COVJSON_TRAJECTORY', COVJSON_TRAJECTORY);

      COVJSON_POLYGONSERIES = COVJSON_PREFIX + 'PolygonSeries';

      _export('COVJSON_POLYGONSERIES', COVJSON_POLYGONSERIES);

      COVJSON_MULTIPOLYGON = COVJSON_PREFIX + 'MultiPolygon';

      _export('COVJSON_MULTIPOLYGON', COVJSON_MULTIPOLYGON);

      // FIXME these should maybe live under a different namespace (Polygon collides with the same-named profile)
      // alternatively, profile URIs should live somewhere else
      COVJSON_DATATYPE_TUPLE = COVJSON_PREFIX + 'Tuple';

      _export('COVJSON_DATATYPE_TUPLE', COVJSON_DATATYPE_TUPLE);

      COVJSON_DATATYPE_POLYGON = COVJSON_PREFIX + 'Polygon';

      _export('COVJSON_DATATYPE_POLYGON', COVJSON_DATATYPE_POLYGON);
    }
  };
});

$__System.register('4c', ['5', '25', '35', '36', '37', '45', '50', '4d', '1b', '4e', '4f'], function (_export) {
  /* */

  // TODO nearly identical to VerticalProfile

  /**
   * Renderer for Coverages with domain type Profile.
   * 
   * This will simply display a dot on the map and fire a click
   * event when a user clicks on it.
   * The dot either has a defined standard color, or it uses
   * a palette together with a target depth if a parameter is chosen.
   */
  'use strict';

  var L, rangeutil, isDomain, ensureClockwisePolygon, getPointInPolygonsFn, fromDomain, EventMixin, DEFAULT_COLOR, enlargeExtentIfEqual, arrays, CoverageMixin, PaletteMixin, PolygonSeries;
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_2) {
      rangeutil = _2;
    }, function (_4) {
      isDomain = _4.isDomain;
    }, function (_6) {
      ensureClockwisePolygon = _6.ensureClockwisePolygon;
      getPointInPolygonsFn = _6.getPointInPolygonsFn;
    }, function (_5) {
      fromDomain = _5.fromDomain;
    }, function (_3) {
      EventMixin = _3['default'];
    }, function (_7) {
      DEFAULT_COLOR = _7.DEFAULT_COLOR;
    }, function (_d) {
      enlargeExtentIfEqual = _d.enlargeExtentIfEqual;
    }, function (_b) {
      arrays = _b;
    }, function (_e) {
      CoverageMixin = _e['default'];
    }, function (_f) {
      PaletteMixin = _f['default'];
    }],
    execute: function () {
      PolygonSeries = (function (_PaletteMixin) {
        babelHelpers.inherits(PolygonSeries, _PaletteMixin);

        function PolygonSeries(cov, options) {
          babelHelpers.classCallCheck(this, PolygonSeries);

          babelHelpers.get(Object.getPrototypeOf(PolygonSeries.prototype), 'constructor', this).call(this);

          if (isDomain(cov)) {
            cov = fromDomain(cov);
            delete options.keys;
          }

          if (!options.paletteExtent) {
            options.paletteExtent = 'full';
          }

          L.Util.setOptions(this, options);

          this.cov = cov;
          this.param = options.keys ? cov.parameters.get(options.keys[0]) : null;
          this._axesSubset = {
            t: { coordPref: options.time }
          };
          this.defaultColor = options.color ? options.color : DEFAULT_COLOR;
        }

        babelHelpers.createClass(PolygonSeries, [{
          key: 'onAdd',
          value: function onAdd(map) {
            var _this = this;

            this._map = map;

            this.load().then(function () {
              return _this.initializePalette();
            }).then(function () {
              _this._addPolygon();
              _this._pointInPolygonPreprocess();
              _this.fire('add');
            });
          }
        }, {
          key: '_loadCoverageSubset',
          value: function _loadCoverageSubset() {
            // adapted from Grid.js
            var t = this._axesSubset.t;
            if (t.coordPref == undefined) {
              t.idx = t.coord = undefined;
            } else {
              var vals = this.domain.axes.get('t').values.map(function (v) {
                return v.getTime();
              });
              t.idx = arrays.indexOfNearest(vals, t.coordPref.getTime());
              t.coord = vals[t.idx];
            }

            // Note that we don't subset the coverage currently, since there is no real need for it
          }
        }, {
          key: 'onRemove',
          value: function onRemove() {
            this.fire('remove');
            this._removePolygon();
          }
        }, {
          key: 'getBounds',
          value: function getBounds() {
            return this._geojson.getBounds();
          }
        }, {
          key: 'getLatLng',
          value: function getLatLng() {
            return this.getBounds().getCenter();
          }
        }, {
          key: 'bindPopup',
          value: function bindPopup() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            this._popup = args;
            if (this._geojson) {
              var _geojson;

              (_geojson = this._geojson).bindPopup.apply(_geojson, args);
            }
            return this;
          }
        }, {
          key: 'openPopup',
          value: function openPopup() {
            this._geojson.openPopup();
            return this;
          }
        }, {
          key: 'closePopup',
          value: function closePopup() {
            this._geojson.closePopup();
            return this;
          }
        }, {
          key: 'canUsePalette',
          value: function canUsePalette() {
            return this.time !== undefined;
          }
        }, {
          key: 'computePaletteExtent',
          value: function computePaletteExtent(extent) {
            if (extent === 'full') {
              if (!this.parameter) {
                throw new Error('palette extent cannot be computed when no parameter has been chosen');
              }

              extent = rangeutil.minMax(this.range);
              extent = enlargeExtentIfEqual(extent);
              return Promise.resolve(extent);
            } else {
              throw new Error('Unknown extent specification: ' + extent);
            }
          }
        }, {
          key: '_pointInPolygonPreprocess',
          value: function _pointInPolygonPreprocess() {
            var polygon = this.domain.axes.get('composite').values[0];
            // TODO we assume spherical coordinates for now
            var isCartesian = false;
            // A bit evil since this modifies in-place, but nothing bad should happen.
            ensureClockwisePolygon(polygon, isCartesian);
            var pointInPolygons = getPointInPolygonsFn([polygon]);
            this._pointInPolygon = function (point) {
              return pointInPolygons(point) !== -1;
            };
          }
        }, {
          key: '_addPolygon',
          value: function _addPolygon() {
            var _this2 = this;

            // TODO do coordinate transformation to lat/lon if necessary

            var polygon = this.domain.axes.get('composite').values[0];

            var geojson = {
              "type": "Feature",
              "properties": {
                "color": this._getColor(this.getValue())
              },
              "geometry": {
                "type": "Polygon",
                "coordinates": polygon
              }
            };

            this._geojson = L.geoJson(geojson, {
              style: function style(feature) {
                return {
                  color: feature.properties.color,
                  fillOpacity: 1,
                  stroke: false
                };
              },
              onEachFeature: function onEachFeature(feature, layer) {
                layer.on('click', function (e) {
                  return _this2.fire('click', e);
                });
              }
            });

            if (this._popup) {
              var _geojson2;

              (_geojson2 = this._geojson).bindPopup.apply(_geojson2, babelHelpers.toConsumableArray(this._popup));
            }

            this._geojson.addTo(this._map);
          }
        }, {
          key: '_removePolygon',
          value: function _removePolygon() {
            this._map.removeLayer(this._geojson);
            delete this._geojson;
          }

          /**
           * Return the displayed value (number, or null for no-data),
           * or undefined if not fixed to a t-coordinate or parameter.
           */
        }, {
          key: 'getValue',
          value: function getValue() {
            if (this.param && this._axesSubset.t.coord !== undefined) {
              var val = this.range.get({ t: this._axesSubset.t.idx });
              return val;
            }
          }
        }, {
          key: 'getValueAt',
          value: function getValueAt(latlng) {
            if (!latlng) throw new Error('latlng parameter missing');

            // TODO longitude wrapping
            if (this._pointInPolygon([latlng.lng, latlng.lat])) {
              return this.getValue();
            }
          }

          // NOTE: this returns a string, not an {r,g,b} object as in other classes!
        }, {
          key: '_getColor',
          value: function _getColor(val) {
            if (val === null) {
              // no-data
              return this.defaultColor;
            } else if (val === undefined) {
              // not fixed to a param or z-coordinate
              return this.defaultColor;
            } else {
              // use a palette
              var idx = this.getPaletteIndex(val);
              var _palette = this.palette;
              var red = _palette.red;
              var green = _palette.green;
              var blue = _palette.blue;

              return 'rgb(' + red[idx] + ', ' + green[idx] + ', ' + blue[idx] + ')';
            }
          }
        }, {
          key: '_updatePolygon',
          value: function _updatePolygon() {
            this._removePolygon();
            this._addPolygon();
          }
        }, {
          key: 'redraw',
          value: function redraw() {
            this._updatePolygon();
            this._geojson.redraw();
          }
        }, {
          key: 'coverage',
          get: function get() {
            return this.cov;
          }
        }, {
          key: 'parameter',
          get: function get() {
            return this.param;
          }

          /**
           * Sets the currently active time to the one closest to the given Date object.
           * Throws an exception if there is no time axis.
           */
        }, {
          key: 'time',
          set: function set(val) {
            var _this3 = this;

            var old = this.time;
            this._axesSubset.t.coordPref = val.toISOString();

            this._loadCoverageSubset().then(function () {
              if (old === _this3.time) return;
              _this3.redraw();
              _this3.fire('axisChange', { axis: 'time' });
            });
          },

          /**
           * The currently active time on the temporal axis as Date object, 
           * or undefined if the grid has no time axis.
           */
          get: function get() {
            if (!this._axesSubset.t.coord) {
              return;
            }
            var time = this.domain.axes.get('t').values[this._axesSubset.t.idx];
            return new Date(time);
          }
        }, {
          key: 'timeSlices',
          get: function get() {
            return this.domain.axes.get('t').values.map(function (t) {
              return new Date(t);
            });
          }
        }]);
        return PolygonSeries;
      })(PaletteMixin(CoverageMixin(EventMixin(L.Class))));

      _export('default', PolygonSeries);
    }
  };
});

$__System.registerDynamic("51", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.name = "cartesian";
  exports.formatDistance = formatDistance;
  exports.ringArea = ringArea;
  exports.absoluteArea = Math.abs;
  exports.triangleArea = triangleArea;
  exports.distance = distance;
  function formatDistance(d) {
    return d.toString();
  }
  function ringArea(ring) {
    var i = -1,
        n = ring.length,
        a,
        b = ring[n - 1],
        area = 0;
    while (++i < n) {
      a = b;
      b = ring[i];
      area += a[0] * b[1] - a[1] * b[0];
    }
    return area * .5;
  }
  function triangleArea(triangle) {
    return Math.abs((triangle[0][0] - triangle[2][0]) * (triangle[1][1] - triangle[0][1]) - (triangle[0][0] - triangle[1][0]) * (triangle[2][1] - triangle[0][1]));
  }
  function distance(x0, y0, x1, y1) {
    var dx = x0 - x1,
        dy = y0 - y1;
    return Math.sqrt(dx * dx + dy * dy);
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("52", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var π = Math.PI,
      π_4 = π / 4,
      radians = π / 180;
  exports.name = "spherical";
  exports.formatDistance = formatDistance;
  exports.ringArea = ringArea;
  exports.absoluteArea = absoluteArea;
  exports.triangleArea = triangleArea;
  exports.distance = haversinDistance;
  function formatDistance(k) {
    var km = k * radians * 6371;
    return (km > 1 ? km.toFixed(3) + "km" : (km * 1000).toPrecision(3) + "m") + " (" + k.toPrecision(3) + "°)";
  }
  function ringArea(ring) {
    if (!ring.length)
      return 0;
    var area = 0,
        p = ring[0],
        λ = p[0] * radians,
        φ = p[1] * radians / 2 + π_4,
        λ0 = λ,
        cosφ0 = Math.cos(φ),
        sinφ0 = Math.sin(φ);
    for (var i = 1,
        n = ring.length; i < n; ++i) {
      p = ring[i], λ = p[0] * radians, φ = p[1] * radians / 2 + π_4;
      var dλ = λ - λ0,
          cosφ = Math.cos(φ),
          sinφ = Math.sin(φ),
          k = sinφ0 * sinφ,
          u = cosφ0 * cosφ + k * Math.cos(dλ),
          v = k * Math.sin(dλ);
      area += Math.atan2(v, u);
      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
    }
    return 2 * (area > π ? area - 2 * π : area < -π ? area + 2 * π : area);
  }
  function absoluteArea(a) {
    return a < 0 ? a + 4 * π : a;
  }
  function triangleArea(t) {
    var a = distance(t[0], t[1]),
        b = distance(t[1], t[2]),
        c = distance(t[2], t[0]),
        s = (a + b + c) / 2;
    return 4 * Math.atan(Math.sqrt(Math.max(0, Math.tan(s / 2) * Math.tan((s - a) / 2) * Math.tan((s - b) / 2) * Math.tan((s - c) / 2))));
  }
  function distance(a, b) {
    var Δλ = (b[0] - a[0]) * radians,
        sinΔλ = Math.sin(Δλ),
        cosΔλ = Math.cos(Δλ),
        sinφ0 = Math.sin(a[1] * radians),
        cosφ0 = Math.cos(a[1] * radians),
        sinφ1 = Math.sin(b[1] * radians),
        cosφ1 = Math.cos(b[1] * radians),
        _;
    return Math.atan2(Math.sqrt((_ = cosφ1 * sinΔλ) * _ + (_ = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * _), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
  }
  function haversinDistance(x0, y0, x1, y1) {
    x0 *= radians, y0 *= radians, x1 *= radians, y1 *= radians;
    return 2 * Math.asin(Math.sqrt(haversin(y1 - y0) + Math.cos(y0) * Math.cos(y1) * haversin(x1 - x0)));
  }
  function haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("53", ["54"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var bounds = req('54');
  var NOT_FOUND = 0;
  var SUCCESS = 1;
  var EMPTY = 2;
  module.exports = createWrapper;
  function IntervalTreeNode(mid, left, right, leftPoints, rightPoints) {
    this.mid = mid;
    this.left = left;
    this.right = right;
    this.leftPoints = leftPoints;
    this.rightPoints = rightPoints;
    this.count = (left ? left.count : 0) + (right ? right.count : 0) + leftPoints.length;
  }
  var proto = IntervalTreeNode.prototype;
  function copy(a, b) {
    a.mid = b.mid;
    a.left = b.left;
    a.right = b.right;
    a.leftPoints = b.leftPoints;
    a.rightPoints = b.rightPoints;
    a.count = b.count;
  }
  function rebuild(node, intervals) {
    var ntree = createIntervalTree(intervals);
    node.mid = ntree.mid;
    node.left = ntree.left;
    node.right = ntree.right;
    node.leftPoints = ntree.leftPoints;
    node.rightPoints = ntree.rightPoints;
    node.count = ntree.count;
  }
  function rebuildWithInterval(node, interval) {
    var intervals = node.intervals([]);
    intervals.push(interval);
    rebuild(node, intervals);
  }
  function rebuildWithoutInterval(node, interval) {
    var intervals = node.intervals([]);
    var idx = intervals.indexOf(interval);
    if (idx < 0) {
      return NOT_FOUND;
    }
    intervals.splice(idx, 1);
    rebuild(node, intervals);
    return SUCCESS;
  }
  proto.intervals = function(result) {
    result.push.apply(result, this.leftPoints);
    if (this.left) {
      this.left.intervals(result);
    }
    if (this.right) {
      this.right.intervals(result);
    }
    return result;
  };
  proto.insert = function(interval) {
    var weight = this.count - this.leftPoints.length;
    this.count += 1;
    if (interval[1] < this.mid) {
      if (this.left) {
        if (4 * (this.left.count + 1) > 3 * (weight + 1)) {
          rebuildWithInterval(this, interval);
        } else {
          this.left.insert(interval);
        }
      } else {
        this.left = createIntervalTree([interval]);
      }
    } else if (interval[0] > this.mid) {
      if (this.right) {
        if (4 * (this.right.count + 1) > 3 * (weight + 1)) {
          rebuildWithInterval(this, interval);
        } else {
          this.right.insert(interval);
        }
      } else {
        this.right = createIntervalTree([interval]);
      }
    } else {
      var l = bounds.ge(this.leftPoints, interval, compareBegin);
      var r = bounds.ge(this.rightPoints, interval, compareEnd);
      this.leftPoints.splice(l, 0, interval);
      this.rightPoints.splice(r, 0, interval);
    }
  };
  proto.remove = function(interval) {
    var weight = this.count - this.leftPoints;
    if (interval[1] < this.mid) {
      if (!this.left) {
        return NOT_FOUND;
      }
      var rw = this.right ? this.right.count : 0;
      if (4 * rw > 3 * (weight - 1)) {
        return rebuildWithoutInterval(this, interval);
      }
      var r = this.left.remove(interval);
      if (r === EMPTY) {
        this.left = null;
        this.count -= 1;
        return SUCCESS;
      } else if (r === SUCCESS) {
        this.count -= 1;
      }
      return r;
    } else if (interval[0] > this.mid) {
      if (!this.right) {
        return NOT_FOUND;
      }
      var lw = this.left ? this.left.count : 0;
      if (4 * lw > 3 * (weight - 1)) {
        return rebuildWithoutInterval(this, interval);
      }
      var r = this.right.remove(interval);
      if (r === EMPTY) {
        this.right = null;
        this.count -= 1;
        return SUCCESS;
      } else if (r === SUCCESS) {
        this.count -= 1;
      }
      return r;
    } else {
      if (this.count === 1) {
        if (this.leftPoints[0] === interval) {
          return EMPTY;
        } else {
          return NOT_FOUND;
        }
      }
      if (this.leftPoints.length === 1 && this.leftPoints[0] === interval) {
        if (this.left && this.right) {
          var p = this;
          var n = this.left;
          while (n.right) {
            p = n;
            n = n.right;
          }
          if (p === this) {
            n.right = this.right;
          } else {
            var l = this.left;
            var r = this.right;
            p.count -= n.count;
            p.right = n.left;
            n.left = l;
            n.right = r;
          }
          copy(this, n);
          this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
        } else if (this.left) {
          copy(this, this.left);
        } else {
          copy(this, this.right);
        }
        return SUCCESS;
      }
      for (var l = bounds.ge(this.leftPoints, interval, compareBegin); l < this.leftPoints.length; ++l) {
        if (this.leftPoints[l][0] !== interval[0]) {
          break;
        }
        if (this.leftPoints[l] === interval) {
          this.count -= 1;
          this.leftPoints.splice(l, 1);
          for (var r = bounds.ge(this.rightPoints, interval, compareEnd); r < this.rightPoints.length; ++r) {
            if (this.rightPoints[r][1] !== interval[1]) {
              break;
            } else if (this.rightPoints[r] === interval) {
              this.rightPoints.splice(r, 1);
              return SUCCESS;
            }
          }
        }
      }
      return NOT_FOUND;
    }
  };
  function reportLeftRange(arr, hi, cb) {
    for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {
      var r = cb(arr[i]);
      if (r) {
        return r;
      }
    }
  }
  function reportRightRange(arr, lo, cb) {
    for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {
      var r = cb(arr[i]);
      if (r) {
        return r;
      }
    }
  }
  function reportRange(arr, cb) {
    for (var i = 0; i < arr.length; ++i) {
      var r = cb(arr[i]);
      if (r) {
        return r;
      }
    }
  }
  proto.queryPoint = function(x, cb) {
    if (x < this.mid) {
      if (this.left) {
        var r = this.left.queryPoint(x, cb);
        if (r) {
          return r;
        }
      }
      return reportLeftRange(this.leftPoints, x, cb);
    } else if (x > this.mid) {
      if (this.right) {
        var r = this.right.queryPoint(x, cb);
        if (r) {
          return r;
        }
      }
      return reportRightRange(this.rightPoints, x, cb);
    } else {
      return reportRange(this.leftPoints, cb);
    }
  };
  proto.queryInterval = function(lo, hi, cb) {
    if (lo < this.mid && this.left) {
      var r = this.left.queryInterval(lo, hi, cb);
      if (r) {
        return r;
      }
    }
    if (hi > this.mid && this.right) {
      var r = this.right.queryInterval(lo, hi, cb);
      if (r) {
        return r;
      }
    }
    if (hi < this.mid) {
      return reportLeftRange(this.leftPoints, hi, cb);
    } else if (lo > this.mid) {
      return reportRightRange(this.rightPoints, lo, cb);
    } else {
      return reportRange(this.leftPoints, cb);
    }
  };
  function compareNumbers(a, b) {
    return a - b;
  }
  function compareBegin(a, b) {
    var d = a[0] - b[0];
    if (d) {
      return d;
    }
    return a[1] - b[1];
  }
  function compareEnd(a, b) {
    var d = a[1] - b[1];
    if (d) {
      return d;
    }
    return a[0] - b[0];
  }
  function createIntervalTree(intervals) {
    if (intervals.length === 0) {
      return null;
    }
    var pts = [];
    for (var i = 0; i < intervals.length; ++i) {
      pts.push(intervals[i][0], intervals[i][1]);
    }
    pts.sort(compareNumbers);
    var mid = pts[pts.length >> 1];
    var leftIntervals = [];
    var rightIntervals = [];
    var centerIntervals = [];
    for (var i = 0; i < intervals.length; ++i) {
      var s = intervals[i];
      if (s[1] < mid) {
        leftIntervals.push(s);
      } else if (mid < s[0]) {
        rightIntervals.push(s);
      } else {
        centerIntervals.push(s);
      }
    }
    var leftPoints = centerIntervals;
    var rightPoints = centerIntervals.slice();
    leftPoints.sort(compareBegin);
    rightPoints.sort(compareEnd);
    return new IntervalTreeNode(mid, createIntervalTree(leftIntervals), createIntervalTree(rightIntervals), leftPoints, rightPoints);
  }
  function IntervalTree(root) {
    this.root = root;
  }
  var tproto = IntervalTree.prototype;
  tproto.insert = function(interval) {
    if (this.root) {
      this.root.insert(interval);
    } else {
      this.root = new IntervalTreeNode(interval[0], null, null, [interval], [interval]);
    }
  };
  tproto.remove = function(interval) {
    if (this.root) {
      var r = this.root.remove(interval);
      if (r === EMPTY) {
        this.root = null;
      }
      return r !== NOT_FOUND;
    }
    return false;
  };
  tproto.queryPoint = function(p, cb) {
    if (this.root) {
      return this.root.queryPoint(p, cb);
    }
  };
  tproto.queryInterval = function(lo, hi, cb) {
    if (lo <= hi && this.root) {
      return this.root.queryInterval(lo, hi, cb);
    }
  };
  Object.defineProperty(tproto, "count", {get: function() {
      if (this.root) {
        return this.root.count;
      }
      return 0;
    }});
  Object.defineProperty(tproto, "intervals", {get: function() {
      if (this.root) {
        return this.root.intervals([]);
      }
      return [];
    }});
  function createWrapper(intervals) {
    if (!intervals || intervals.length === 0) {
      return new IntervalTree(null);
    }
    return new IntervalTree(createIntervalTree(intervals));
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("55", ["53"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('53');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("56", ["57"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  module.exports = orderSegments;
  var orient = req('57');
  function horizontalOrder(a, b) {
    var bl,
        br;
    if (b[0][0] < b[1][0]) {
      bl = b[0];
      br = b[1];
    } else if (b[0][0] > b[1][0]) {
      bl = b[1];
      br = b[0];
    } else {
      var alo = Math.min(a[0][1], a[1][1]);
      var ahi = Math.max(a[0][1], a[1][1]);
      var blo = Math.min(b[0][1], b[1][1]);
      var bhi = Math.max(b[0][1], b[1][1]);
      if (ahi < blo) {
        return ahi - blo;
      }
      if (alo > bhi) {
        return alo - bhi;
      }
      return ahi - bhi;
    }
    var al,
        ar;
    if (a[0][1] < a[1][1]) {
      al = a[0];
      ar = a[1];
    } else {
      al = a[1];
      ar = a[0];
    }
    var d = orient(br, bl, al);
    if (d) {
      return d;
    }
    d = orient(br, bl, ar);
    if (d) {
      return d;
    }
    return ar - br;
  }
  function orderSegments(b, a) {
    var al,
        ar;
    if (a[0][0] < a[1][0]) {
      al = a[0];
      ar = a[1];
    } else if (a[0][0] > a[1][0]) {
      al = a[1];
      ar = a[0];
    } else {
      return horizontalOrder(a, b);
    }
    var bl,
        br;
    if (b[0][0] < b[1][0]) {
      bl = b[0];
      br = b[1];
    } else if (b[0][0] > b[1][0]) {
      bl = b[1];
      br = b[0];
    } else {
      return -horizontalOrder(b, a);
    }
    var d1 = orient(al, ar, br);
    var d2 = orient(al, ar, bl);
    if (d1 < 0) {
      if (d2 <= 0) {
        return d1;
      }
    } else if (d1 > 0) {
      if (d2 >= 0) {
        return d1;
      }
    } else if (d2) {
      return d2;
    }
    d1 = orient(br, bl, ar);
    d2 = orient(br, bl, al);
    if (d1 < 0) {
      if (d2 <= 0) {
        return d1;
      }
    } else if (d1 > 0) {
      if (d2 >= 0) {
        return d1;
      }
    } else if (d2) {
      return d2;
    }
    return ar[0] - br[0];
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("58", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  module.exports = createRBTree;
  var RED = 0;
  var BLACK = 1;
  function RBNode(color, key, value, left, right, count) {
    this._color = color;
    this.key = key;
    this.value = value;
    this.left = left;
    this.right = right;
    this._count = count;
  }
  function cloneNode(node) {
    return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count);
  }
  function repaint(color, node) {
    return new RBNode(color, node.key, node.value, node.left, node.right, node._count);
  }
  function recount(node) {
    node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0);
  }
  function RedBlackTree(compare, root) {
    this._compare = compare;
    this.root = root;
  }
  var proto = RedBlackTree.prototype;
  Object.defineProperty(proto, "keys", {get: function() {
      var result = [];
      this.forEach(function(k, v) {
        result.push(k);
      });
      return result;
    }});
  Object.defineProperty(proto, "values", {get: function() {
      var result = [];
      this.forEach(function(k, v) {
        result.push(v);
      });
      return result;
    }});
  Object.defineProperty(proto, "length", {get: function() {
      if (this.root) {
        return this.root._count;
      }
      return 0;
    }});
  proto.insert = function(key, value) {
    var cmp = this._compare;
    var n = this.root;
    var n_stack = [];
    var d_stack = [];
    while (n) {
      var d = cmp(key, n.key);
      n_stack.push(n);
      d_stack.push(d);
      if (d <= 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    n_stack.push(new RBNode(RED, key, value, null, null, 1));
    for (var s = n_stack.length - 2; s >= 0; --s) {
      var n = n_stack[s];
      if (d_stack[s] <= 0) {
        n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s + 1], n.right, n._count + 1);
      } else {
        n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s + 1], n._count + 1);
      }
    }
    for (var s = n_stack.length - 1; s > 1; --s) {
      var p = n_stack[s - 1];
      var n = n_stack[s];
      if (p._color === BLACK || n._color === BLACK) {
        break;
      }
      var pp = n_stack[s - 2];
      if (pp.left === p) {
        if (p.left === n) {
          var y = pp.right;
          if (y && y._color === RED) {
            p._color = BLACK;
            pp.right = repaint(BLACK, y);
            pp._color = RED;
            s -= 1;
          } else {
            pp._color = RED;
            pp.left = p.right;
            p._color = BLACK;
            p.right = pp;
            n_stack[s - 2] = p;
            n_stack[s - 1] = n;
            recount(pp);
            recount(p);
            if (s >= 3) {
              var ppp = n_stack[s - 3];
              if (ppp.left === pp) {
                ppp.left = p;
              } else {
                ppp.right = p;
              }
            }
            break;
          }
        } else {
          var y = pp.right;
          if (y && y._color === RED) {
            p._color = BLACK;
            pp.right = repaint(BLACK, y);
            pp._color = RED;
            s -= 1;
          } else {
            p.right = n.left;
            pp._color = RED;
            pp.left = n.right;
            n._color = BLACK;
            n.left = p;
            n.right = pp;
            n_stack[s - 2] = n;
            n_stack[s - 1] = p;
            recount(pp);
            recount(p);
            recount(n);
            if (s >= 3) {
              var ppp = n_stack[s - 3];
              if (ppp.left === pp) {
                ppp.left = n;
              } else {
                ppp.right = n;
              }
            }
            break;
          }
        }
      } else {
        if (p.right === n) {
          var y = pp.left;
          if (y && y._color === RED) {
            p._color = BLACK;
            pp.left = repaint(BLACK, y);
            pp._color = RED;
            s -= 1;
          } else {
            pp._color = RED;
            pp.right = p.left;
            p._color = BLACK;
            p.left = pp;
            n_stack[s - 2] = p;
            n_stack[s - 1] = n;
            recount(pp);
            recount(p);
            if (s >= 3) {
              var ppp = n_stack[s - 3];
              if (ppp.right === pp) {
                ppp.right = p;
              } else {
                ppp.left = p;
              }
            }
            break;
          }
        } else {
          var y = pp.left;
          if (y && y._color === RED) {
            p._color = BLACK;
            pp.left = repaint(BLACK, y);
            pp._color = RED;
            s -= 1;
          } else {
            p.left = n.right;
            pp._color = RED;
            pp.right = n.left;
            n._color = BLACK;
            n.right = p;
            n.left = pp;
            n_stack[s - 2] = n;
            n_stack[s - 1] = p;
            recount(pp);
            recount(p);
            recount(n);
            if (s >= 3) {
              var ppp = n_stack[s - 3];
              if (ppp.right === pp) {
                ppp.right = n;
              } else {
                ppp.left = n;
              }
            }
            break;
          }
        }
      }
    }
    n_stack[0]._color = BLACK;
    return new RedBlackTree(cmp, n_stack[0]);
  };
  function doVisitFull(visit, node) {
    if (node.left) {
      var v = doVisitFull(visit, node.left);
      if (v) {
        return v;
      }
    }
    var v = visit(node.key, node.value);
    if (v) {
      return v;
    }
    if (node.right) {
      return doVisitFull(visit, node.right);
    }
  }
  function doVisitHalf(lo, compare, visit, node) {
    var l = compare(lo, node.key);
    if (l <= 0) {
      if (node.left) {
        var v = doVisitHalf(lo, compare, visit, node.left);
        if (v) {
          return v;
        }
      }
      var v = visit(node.key, node.value);
      if (v) {
        return v;
      }
    }
    if (node.right) {
      return doVisitHalf(lo, compare, visit, node.right);
    }
  }
  function doVisit(lo, hi, compare, visit, node) {
    var l = compare(lo, node.key);
    var h = compare(hi, node.key);
    var v;
    if (l <= 0) {
      if (node.left) {
        v = doVisit(lo, hi, compare, visit, node.left);
        if (v) {
          return v;
        }
      }
      if (h > 0) {
        v = visit(node.key, node.value);
        if (v) {
          return v;
        }
      }
    }
    if (h > 0 && node.right) {
      return doVisit(lo, hi, compare, visit, node.right);
    }
  }
  proto.forEach = function rbTreeForEach(visit, lo, hi) {
    if (!this.root) {
      return;
    }
    switch (arguments.length) {
      case 1:
        return doVisitFull(visit, this.root);
        break;
      case 2:
        return doVisitHalf(lo, this._compare, visit, this.root);
        break;
      case 3:
        if (this._compare(lo, hi) >= 0) {
          return;
        }
        return doVisit(lo, hi, this._compare, visit, this.root);
        break;
    }
  };
  Object.defineProperty(proto, "begin", {get: function() {
      var stack = [];
      var n = this.root;
      while (n) {
        stack.push(n);
        n = n.left;
      }
      return new RedBlackTreeIterator(this, stack);
    }});
  Object.defineProperty(proto, "end", {get: function() {
      var stack = [];
      var n = this.root;
      while (n) {
        stack.push(n);
        n = n.right;
      }
      return new RedBlackTreeIterator(this, stack);
    }});
  proto.at = function(idx) {
    if (idx < 0) {
      return new RedBlackTreeIterator(this, []);
    }
    var n = this.root;
    var stack = [];
    while (true) {
      stack.push(n);
      if (n.left) {
        if (idx < n.left._count) {
          n = n.left;
          continue;
        }
        idx -= n.left._count;
      }
      if (!idx) {
        return new RedBlackTreeIterator(this, stack);
      }
      idx -= 1;
      if (n.right) {
        if (idx >= n.right._count) {
          break;
        }
        n = n.right;
      } else {
        break;
      }
    }
    return new RedBlackTreeIterator(this, []);
  };
  proto.ge = function(key) {
    var cmp = this._compare;
    var n = this.root;
    var stack = [];
    var last_ptr = 0;
    while (n) {
      var d = cmp(key, n.key);
      stack.push(n);
      if (d <= 0) {
        last_ptr = stack.length;
      }
      if (d <= 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    stack.length = last_ptr;
    return new RedBlackTreeIterator(this, stack);
  };
  proto.gt = function(key) {
    var cmp = this._compare;
    var n = this.root;
    var stack = [];
    var last_ptr = 0;
    while (n) {
      var d = cmp(key, n.key);
      stack.push(n);
      if (d < 0) {
        last_ptr = stack.length;
      }
      if (d < 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    stack.length = last_ptr;
    return new RedBlackTreeIterator(this, stack);
  };
  proto.lt = function(key) {
    var cmp = this._compare;
    var n = this.root;
    var stack = [];
    var last_ptr = 0;
    while (n) {
      var d = cmp(key, n.key);
      stack.push(n);
      if (d > 0) {
        last_ptr = stack.length;
      }
      if (d <= 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    stack.length = last_ptr;
    return new RedBlackTreeIterator(this, stack);
  };
  proto.le = function(key) {
    var cmp = this._compare;
    var n = this.root;
    var stack = [];
    var last_ptr = 0;
    while (n) {
      var d = cmp(key, n.key);
      stack.push(n);
      if (d >= 0) {
        last_ptr = stack.length;
      }
      if (d < 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    stack.length = last_ptr;
    return new RedBlackTreeIterator(this, stack);
  };
  proto.find = function(key) {
    var cmp = this._compare;
    var n = this.root;
    var stack = [];
    while (n) {
      var d = cmp(key, n.key);
      stack.push(n);
      if (d === 0) {
        return new RedBlackTreeIterator(this, stack);
      }
      if (d <= 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    return new RedBlackTreeIterator(this, []);
  };
  proto.remove = function(key) {
    var iter = this.find(key);
    if (iter) {
      return iter.remove();
    }
    return this;
  };
  proto.get = function(key) {
    var cmp = this._compare;
    var n = this.root;
    while (n) {
      var d = cmp(key, n.key);
      if (d === 0) {
        return n.value;
      }
      if (d <= 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    return;
  };
  function RedBlackTreeIterator(tree, stack) {
    this.tree = tree;
    this._stack = stack;
  }
  var iproto = RedBlackTreeIterator.prototype;
  Object.defineProperty(iproto, "valid", {get: function() {
      return this._stack.length > 0;
    }});
  Object.defineProperty(iproto, "node", {
    get: function() {
      if (this._stack.length > 0) {
        return this._stack[this._stack.length - 1];
      }
      return null;
    },
    enumerable: true
  });
  iproto.clone = function() {
    return new RedBlackTreeIterator(this.tree, this._stack.slice());
  };
  function swapNode(n, v) {
    n.key = v.key;
    n.value = v.value;
    n.left = v.left;
    n.right = v.right;
    n._color = v._color;
    n._count = v._count;
  }
  function fixDoubleBlack(stack) {
    var n,
        p,
        s,
        z;
    for (var i = stack.length - 1; i >= 0; --i) {
      n = stack[i];
      if (i === 0) {
        n._color = BLACK;
        return;
      }
      p = stack[i - 1];
      if (p.left === n) {
        s = p.right;
        if (s.right && s.right._color === RED) {
          s = p.right = cloneNode(s);
          z = s.right = cloneNode(s.right);
          p.right = s.left;
          s.left = p;
          s.right = z;
          s._color = p._color;
          n._color = BLACK;
          p._color = BLACK;
          z._color = BLACK;
          recount(p);
          recount(s);
          if (i > 1) {
            var pp = stack[i - 2];
            if (pp.left === p) {
              pp.left = s;
            } else {
              pp.right = s;
            }
          }
          stack[i - 1] = s;
          return;
        } else if (s.left && s.left._color === RED) {
          s = p.right = cloneNode(s);
          z = s.left = cloneNode(s.left);
          p.right = z.left;
          s.left = z.right;
          z.left = p;
          z.right = s;
          z._color = p._color;
          p._color = BLACK;
          s._color = BLACK;
          n._color = BLACK;
          recount(p);
          recount(s);
          recount(z);
          if (i > 1) {
            var pp = stack[i - 2];
            if (pp.left === p) {
              pp.left = z;
            } else {
              pp.right = z;
            }
          }
          stack[i - 1] = z;
          return;
        }
        if (s._color === BLACK) {
          if (p._color === RED) {
            p._color = BLACK;
            p.right = repaint(RED, s);
            return;
          } else {
            p.right = repaint(RED, s);
            continue;
          }
        } else {
          s = cloneNode(s);
          p.right = s.left;
          s.left = p;
          s._color = p._color;
          p._color = RED;
          recount(p);
          recount(s);
          if (i > 1) {
            var pp = stack[i - 2];
            if (pp.left === p) {
              pp.left = s;
            } else {
              pp.right = s;
            }
          }
          stack[i - 1] = s;
          stack[i] = p;
          if (i + 1 < stack.length) {
            stack[i + 1] = n;
          } else {
            stack.push(n);
          }
          i = i + 2;
        }
      } else {
        s = p.left;
        if (s.left && s.left._color === RED) {
          s = p.left = cloneNode(s);
          z = s.left = cloneNode(s.left);
          p.left = s.right;
          s.right = p;
          s.left = z;
          s._color = p._color;
          n._color = BLACK;
          p._color = BLACK;
          z._color = BLACK;
          recount(p);
          recount(s);
          if (i > 1) {
            var pp = stack[i - 2];
            if (pp.right === p) {
              pp.right = s;
            } else {
              pp.left = s;
            }
          }
          stack[i - 1] = s;
          return;
        } else if (s.right && s.right._color === RED) {
          s = p.left = cloneNode(s);
          z = s.right = cloneNode(s.right);
          p.left = z.right;
          s.right = z.left;
          z.right = p;
          z.left = s;
          z._color = p._color;
          p._color = BLACK;
          s._color = BLACK;
          n._color = BLACK;
          recount(p);
          recount(s);
          recount(z);
          if (i > 1) {
            var pp = stack[i - 2];
            if (pp.right === p) {
              pp.right = z;
            } else {
              pp.left = z;
            }
          }
          stack[i - 1] = z;
          return;
        }
        if (s._color === BLACK) {
          if (p._color === RED) {
            p._color = BLACK;
            p.left = repaint(RED, s);
            return;
          } else {
            p.left = repaint(RED, s);
            continue;
          }
        } else {
          s = cloneNode(s);
          p.left = s.right;
          s.right = p;
          s._color = p._color;
          p._color = RED;
          recount(p);
          recount(s);
          if (i > 1) {
            var pp = stack[i - 2];
            if (pp.right === p) {
              pp.right = s;
            } else {
              pp.left = s;
            }
          }
          stack[i - 1] = s;
          stack[i] = p;
          if (i + 1 < stack.length) {
            stack[i + 1] = n;
          } else {
            stack.push(n);
          }
          i = i + 2;
        }
      }
    }
  }
  iproto.remove = function() {
    var stack = this._stack;
    if (stack.length === 0) {
      return this.tree;
    }
    var cstack = new Array(stack.length);
    var n = stack[stack.length - 1];
    cstack[cstack.length - 1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count);
    for (var i = stack.length - 2; i >= 0; --i) {
      var n = stack[i];
      if (n.left === stack[i + 1]) {
        cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
      } else {
        cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
      }
    }
    n = cstack[cstack.length - 1];
    if (n.left && n.right) {
      var split = cstack.length;
      n = n.left;
      while (n.right) {
        cstack.push(n);
        n = n.right;
      }
      var v = cstack[split - 1];
      cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count));
      cstack[split - 1].key = n.key;
      cstack[split - 1].value = n.value;
      for (var i = cstack.length - 2; i >= split; --i) {
        n = cstack[i];
        cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
      }
      cstack[split - 1].left = cstack[split];
    }
    n = cstack[cstack.length - 1];
    if (n._color === RED) {
      var p = cstack[cstack.length - 2];
      if (p.left === n) {
        p.left = null;
      } else if (p.right === n) {
        p.right = null;
      }
      cstack.pop();
      for (var i = 0; i < cstack.length; ++i) {
        cstack[i]._count--;
      }
      return new RedBlackTree(this.tree._compare, cstack[0]);
    } else {
      if (n.left || n.right) {
        if (n.left) {
          swapNode(n, n.left);
        } else if (n.right) {
          swapNode(n, n.right);
        }
        n._color = BLACK;
        for (var i = 0; i < cstack.length - 1; ++i) {
          cstack[i]._count--;
        }
        return new RedBlackTree(this.tree._compare, cstack[0]);
      } else if (cstack.length === 1) {
        return new RedBlackTree(this.tree._compare, null);
      } else {
        for (var i = 0; i < cstack.length; ++i) {
          cstack[i]._count--;
        }
        var parent = cstack[cstack.length - 2];
        fixDoubleBlack(cstack);
        if (parent.left === n) {
          parent.left = null;
        } else {
          parent.right = null;
        }
      }
    }
    return new RedBlackTree(this.tree._compare, cstack[0]);
  };
  Object.defineProperty(iproto, "key", {
    get: function() {
      if (this._stack.length > 0) {
        return this._stack[this._stack.length - 1].key;
      }
      return;
    },
    enumerable: true
  });
  Object.defineProperty(iproto, "value", {
    get: function() {
      if (this._stack.length > 0) {
        return this._stack[this._stack.length - 1].value;
      }
      return;
    },
    enumerable: true
  });
  Object.defineProperty(iproto, "index", {
    get: function() {
      var idx = 0;
      var stack = this._stack;
      if (stack.length === 0) {
        var r = this.tree.root;
        if (r) {
          return r._count;
        }
        return 0;
      } else if (stack[stack.length - 1].left) {
        idx = stack[stack.length - 1].left._count;
      }
      for (var s = stack.length - 2; s >= 0; --s) {
        if (stack[s + 1] === stack[s].right) {
          ++idx;
          if (stack[s].left) {
            idx += stack[s].left._count;
          }
        }
      }
      return idx;
    },
    enumerable: true
  });
  iproto.next = function() {
    var stack = this._stack;
    if (stack.length === 0) {
      return;
    }
    var n = stack[stack.length - 1];
    if (n.right) {
      n = n.right;
      while (n) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  };
  Object.defineProperty(iproto, "hasNext", {get: function() {
      var stack = this._stack;
      if (stack.length === 0) {
        return false;
      }
      if (stack[stack.length - 1].right) {
        return true;
      }
      for (var s = stack.length - 1; s > 0; --s) {
        if (stack[s - 1].left === stack[s]) {
          return true;
        }
      }
      return false;
    }});
  iproto.update = function(value) {
    var stack = this._stack;
    if (stack.length === 0) {
      throw new Error("Can't update empty node!");
    }
    var cstack = new Array(stack.length);
    var n = stack[stack.length - 1];
    cstack[cstack.length - 1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count);
    for (var i = stack.length - 2; i >= 0; --i) {
      n = stack[i];
      if (n.left === stack[i + 1]) {
        cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
      } else {
        cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
      }
    }
    return new RedBlackTree(this.tree._compare, cstack[0]);
  };
  iproto.prev = function() {
    var stack = this._stack;
    if (stack.length === 0) {
      return;
    }
    var n = stack[stack.length - 1];
    if (n.left) {
      n = n.left;
      while (n) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  };
  Object.defineProperty(iproto, "hasPrev", {get: function() {
      var stack = this._stack;
      if (stack.length === 0) {
        return false;
      }
      if (stack[stack.length - 1].left) {
        return true;
      }
      for (var s = stack.length - 1; s > 0; --s) {
        if (stack[s - 1].right === stack[s]) {
          return true;
        }
      }
      return false;
    }});
  function defaultCompare(a, b) {
    if (a < b) {
      return -1;
    }
    if (a > b) {
      return 1;
    }
    return 0;
  }
  function createRBTree(compare) {
    return new RedBlackTree(compare || defaultCompare, null);
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("59", ["58"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('58');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5a", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function compileSearch(funcName, predicate, reversed, extraArgs, useNdarray, earlyOut) {
    var code = ["function ", funcName, "(a,l,h,", extraArgs.join(","), "){", earlyOut ? "" : "var i=", (reversed ? "l-1" : "h+1"), ";while(l<=h){\
var m=(l+h)>>>1,x=a", useNdarray ? ".get(m)" : "[m]"];
    if (earlyOut) {
      if (predicate.indexOf("c") < 0) {
        code.push(";if(x===y){return m}else if(x<=y){");
      } else {
        code.push(";var p=c(x,y);if(p===0){return m}else if(p<=0){");
      }
    } else {
      code.push(";if(", predicate, "){i=m;");
    }
    if (reversed) {
      code.push("l=m+1}else{h=m-1}");
    } else {
      code.push("h=m-1}else{l=m+1}");
    }
    code.push("}");
    if (earlyOut) {
      code.push("return -1};");
    } else {
      code.push("return i};");
    }
    return code.join("");
  }
  function compileBoundsSearch(predicate, reversed, suffix, earlyOut) {
    var result = new Function([compileSearch("A", "x" + predicate + "y", reversed, ["y"], false, earlyOut), compileSearch("B", "x" + predicate + "y", reversed, ["y"], true, earlyOut), compileSearch("P", "c(x,y)" + predicate + "0", reversed, ["y", "c"], false, earlyOut), compileSearch("Q", "c(x,y)" + predicate + "0", reversed, ["y", "c"], true, earlyOut), "function dispatchBsearch", suffix, "(a,y,c,l,h){\
if(a.shape){\
if(typeof(c)==='function'){\
return Q(a,(l===undefined)?0:l|0,(h===undefined)?a.shape[0]-1:h|0,y,c)\
}else{\
return B(a,(c===undefined)?0:c|0,(l===undefined)?a.shape[0]-1:l|0,y)\
}}else{\
if(typeof(c)==='function'){\
return P(a,(l===undefined)?0:l|0,(h===undefined)?a.length-1:h|0,y,c)\
}else{\
return A(a,(c===undefined)?0:c|0,(l===undefined)?a.length-1:l|0,y)\
}}}\
return dispatchBsearch", suffix].join(""));
    return result();
  }
  module.exports = {
    ge: compileBoundsSearch(">=", false, "GE"),
    gt: compileBoundsSearch(">", false, "GT"),
    lt: compileBoundsSearch("<", true, "LT"),
    le: compileBoundsSearch("<=", true, "LE"),
    eq: compileBoundsSearch("-", true, "EQ", true)
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("54", ["5a"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('5a');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5b", ["54", "59", "57", "56"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  module.exports = createSlabDecomposition;
  var bounds = req('54');
  var createRBTree = req('59');
  var orient = req('57');
  var orderSegments = req('56');
  function SlabDecomposition(slabs, coordinates, horizontal) {
    this.slabs = slabs;
    this.coordinates = coordinates;
    this.horizontal = horizontal;
  }
  var proto = SlabDecomposition.prototype;
  function compareHorizontal(e, y) {
    return e.y - y;
  }
  function searchBucket(root, p) {
    var lastNode = null;
    while (root) {
      var seg = root.key;
      var l,
          r;
      if (seg[0][0] < seg[1][0]) {
        l = seg[0];
        r = seg[1];
      } else {
        l = seg[1];
        r = seg[0];
      }
      var o = orient(l, r, p);
      if (o < 0) {
        root = root.left;
      } else if (o > 0) {
        if (p[0] !== seg[1][0]) {
          lastNode = root;
          root = root.right;
        } else {
          var val = searchBucket(root.right, p);
          if (val) {
            return val;
          }
          root = root.left;
        }
      } else {
        if (p[0] !== seg[1][0]) {
          return root;
        } else {
          var val = searchBucket(root.right, p);
          if (val) {
            return val;
          }
          root = root.left;
        }
      }
    }
    return lastNode;
  }
  proto.castUp = function(p) {
    var bucket = bounds.le(this.coordinates, p[0]);
    if (bucket < 0) {
      return -1;
    }
    var root = this.slabs[bucket];
    var hitNode = searchBucket(this.slabs[bucket], p);
    var lastHit = -1;
    if (hitNode) {
      lastHit = hitNode.value;
    }
    if (this.coordinates[bucket] === p[0]) {
      var lastSegment = null;
      if (hitNode) {
        lastSegment = hitNode.key;
      }
      if (bucket > 0) {
        var otherHitNode = searchBucket(this.slabs[bucket - 1], p);
        if (otherHitNode) {
          if (lastSegment) {
            if (orderSegments(otherHitNode.key, lastSegment) > 0) {
              lastSegment = otherHitNode.key;
              lastHit = otherHitNode.value;
            }
          } else {
            lastHit = otherHitNode.value;
            lastSegment = otherHitNode.key;
          }
        }
      }
      var horiz = this.horizontal[bucket];
      if (horiz.length > 0) {
        var hbucket = bounds.ge(horiz, p[1], compareHorizontal);
        if (hbucket < horiz.length) {
          var e = horiz[hbucket];
          if (p[1] === e.y) {
            if (e.closed) {
              return e.index;
            } else {
              while (hbucket < horiz.length - 1 && horiz[hbucket + 1].y === p[1]) {
                hbucket = hbucket + 1;
                e = horiz[hbucket];
                if (e.closed) {
                  return e.index;
                }
              }
              if (e.y === p[1] && !e.start) {
                hbucket = hbucket + 1;
                if (hbucket >= horiz.length) {
                  return lastHit;
                }
                e = horiz[hbucket];
              }
            }
          }
          if (e.start) {
            if (lastSegment) {
              var o = orient(lastSegment[0], lastSegment[1], [p[0], e.y]);
              if (lastSegment[0][0] > lastSegment[1][0]) {
                o = -o;
              }
              if (o > 0) {
                lastHit = e.index;
              }
            } else {
              lastHit = e.index;
            }
          } else if (e.y !== p[1]) {
            lastHit = e.index;
          }
        }
      }
    }
    return lastHit;
  };
  function IntervalSegment(y, index, start, closed) {
    this.y = y;
    this.index = index;
    this.start = start;
    this.closed = closed;
  }
  function Event(x, segment, create, index) {
    this.x = x;
    this.segment = segment;
    this.create = create;
    this.index = index;
  }
  function createSlabDecomposition(segments) {
    var numSegments = segments.length;
    var numEvents = 2 * numSegments;
    var events = new Array(numEvents);
    for (var i = 0; i < numSegments; ++i) {
      var s = segments[i];
      var f = s[0][0] < s[1][0];
      events[2 * i] = new Event(s[0][0], s, f, i);
      events[2 * i + 1] = new Event(s[1][0], s, !f, i);
    }
    events.sort(function(a, b) {
      var d = a.x - b.x;
      if (d) {
        return d;
      }
      d = a.create - b.create;
      if (d) {
        return d;
      }
      return Math.min(a.segment[0][1], a.segment[1][1]) - Math.min(b.segment[0][1], b.segment[1][1]);
    });
    var tree = createRBTree(orderSegments);
    var slabs = [];
    var lines = [];
    var horizontal = [];
    var lastX = -Infinity;
    for (var i = 0; i < numEvents; ) {
      var x = events[i].x;
      var horiz = [];
      while (i < numEvents) {
        var e = events[i];
        if (e.x !== x) {
          break;
        }
        i += 1;
        if (e.segment[0][0] === e.x && e.segment[1][0] === e.x) {
          if (e.create) {
            if (e.segment[0][1] < e.segment[1][1]) {
              horiz.push(new IntervalSegment(e.segment[0][1], e.index, true, true));
              horiz.push(new IntervalSegment(e.segment[1][1], e.index, false, false));
            } else {
              horiz.push(new IntervalSegment(e.segment[1][1], e.index, true, false));
              horiz.push(new IntervalSegment(e.segment[0][1], e.index, false, true));
            }
          }
        } else {
          if (e.create) {
            tree = tree.insert(e.segment, e.index);
          } else {
            tree = tree.remove(e.segment);
          }
        }
      }
      slabs.push(tree.root);
      lines.push(x);
      horizontal.push(horiz);
    }
    return new SlabDecomposition(slabs, lines, horizontal);
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5c", ["5b"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('5b');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5d", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  module.exports = robustSubtract;
  function scalarScalar(a, b) {
    var x = a + b;
    var bv = x - a;
    var av = x - bv;
    var br = b - bv;
    var ar = a - av;
    var y = ar + br;
    if (y) {
      return [y, x];
    }
    return [x];
  }
  function robustSubtract(e, f) {
    var ne = e.length | 0;
    var nf = f.length | 0;
    if (ne === 1 && nf === 1) {
      return scalarScalar(e[0], -f[0]);
    }
    var n = ne + nf;
    var g = new Array(n);
    var count = 0;
    var eptr = 0;
    var fptr = 0;
    var abs = Math.abs;
    var ei = e[eptr];
    var ea = abs(ei);
    var fi = -f[fptr];
    var fa = abs(fi);
    var a,
        b;
    if (ea < fa) {
      b = ei;
      eptr += 1;
      if (eptr < ne) {
        ei = e[eptr];
        ea = abs(ei);
      }
    } else {
      b = fi;
      fptr += 1;
      if (fptr < nf) {
        fi = -f[fptr];
        fa = abs(fi);
      }
    }
    if ((eptr < ne && ea < fa) || (fptr >= nf)) {
      a = ei;
      eptr += 1;
      if (eptr < ne) {
        ei = e[eptr];
        ea = abs(ei);
      }
    } else {
      a = fi;
      fptr += 1;
      if (fptr < nf) {
        fi = -f[fptr];
        fa = abs(fi);
      }
    }
    var x = a + b;
    var bv = x - a;
    var y = b - bv;
    var q0 = y;
    var q1 = x;
    var _x,
        _bv,
        _av,
        _br,
        _ar;
    while (eptr < ne && fptr < nf) {
      if (ea < fa) {
        a = ei;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        a = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = -f[fptr];
          fa = abs(fi);
        }
      }
      b = q0;
      x = a + b;
      bv = x - a;
      y = b - bv;
      if (y) {
        g[count++] = y;
      }
      _x = q1 + x;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
    }
    while (eptr < ne) {
      a = ei;
      b = q0;
      x = a + b;
      bv = x - a;
      y = b - bv;
      if (y) {
        g[count++] = y;
      }
      _x = q1 + x;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
      eptr += 1;
      if (eptr < ne) {
        ei = e[eptr];
      }
    }
    while (fptr < nf) {
      a = fi;
      b = q0;
      x = a + b;
      bv = x - a;
      y = b - bv;
      if (y) {
        g[count++] = y;
      }
      _x = q1 + x;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
      fptr += 1;
      if (fptr < nf) {
        fi = -f[fptr];
      }
    }
    if (q0) {
      g[count++] = q0;
    }
    if (q1) {
      g[count++] = q1;
    }
    if (!count) {
      g[count++] = 0.0;
    }
    g.length = count;
    return g;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5e", ["5d"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('5d');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5f", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  module.exports = fastTwoSum;
  function fastTwoSum(a, b, result) {
    var x = a + b;
    var bv = x - a;
    var av = x - bv;
    var br = b - bv;
    var ar = a - av;
    if (result) {
      result[0] = ar + br;
      result[1] = x;
      return result;
    }
    return [ar + br, x];
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("60", ["5f"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('5f');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("61", ["62", "60"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var twoProduct = req('62');
  var twoSum = req('60');
  module.exports = scaleLinearExpansion;
  function scaleLinearExpansion(e, scale) {
    var n = e.length;
    if (n === 1) {
      var ts = twoProduct(e[0], scale);
      if (ts[0]) {
        return ts;
      }
      return [ts[1]];
    }
    var g = new Array(2 * n);
    var q = [0.1, 0.1];
    var t = [0.1, 0.1];
    var count = 0;
    twoProduct(e[0], scale, q);
    if (q[0]) {
      g[count++] = q[0];
    }
    for (var i = 1; i < n; ++i) {
      twoProduct(e[i], scale, t);
      var pq = q[1];
      twoSum(pq, t[0], q);
      if (q[0]) {
        g[count++] = q[0];
      }
      var a = t[1];
      var b = q[1];
      var x = a + b;
      var bv = x - a;
      var y = b - bv;
      q[1] = x;
      if (y) {
        g[count++] = y;
      }
    }
    if (q[1]) {
      g[count++] = q[1];
    }
    if (count === 0) {
      g[count++] = 0.0;
    }
    g.length = count;
    return g;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("63", ["61"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('61');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("64", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  module.exports = linearExpansionSum;
  function scalarScalar(a, b) {
    var x = a + b;
    var bv = x - a;
    var av = x - bv;
    var br = b - bv;
    var ar = a - av;
    var y = ar + br;
    if (y) {
      return [y, x];
    }
    return [x];
  }
  function linearExpansionSum(e, f) {
    var ne = e.length | 0;
    var nf = f.length | 0;
    if (ne === 1 && nf === 1) {
      return scalarScalar(e[0], f[0]);
    }
    var n = ne + nf;
    var g = new Array(n);
    var count = 0;
    var eptr = 0;
    var fptr = 0;
    var abs = Math.abs;
    var ei = e[eptr];
    var ea = abs(ei);
    var fi = f[fptr];
    var fa = abs(fi);
    var a,
        b;
    if (ea < fa) {
      b = ei;
      eptr += 1;
      if (eptr < ne) {
        ei = e[eptr];
        ea = abs(ei);
      }
    } else {
      b = fi;
      fptr += 1;
      if (fptr < nf) {
        fi = f[fptr];
        fa = abs(fi);
      }
    }
    if ((eptr < ne && ea < fa) || (fptr >= nf)) {
      a = ei;
      eptr += 1;
      if (eptr < ne) {
        ei = e[eptr];
        ea = abs(ei);
      }
    } else {
      a = fi;
      fptr += 1;
      if (fptr < nf) {
        fi = f[fptr];
        fa = abs(fi);
      }
    }
    var x = a + b;
    var bv = x - a;
    var y = b - bv;
    var q0 = y;
    var q1 = x;
    var _x,
        _bv,
        _av,
        _br,
        _ar;
    while (eptr < ne && fptr < nf) {
      if (ea < fa) {
        a = ei;
        eptr += 1;
        if (eptr < ne) {
          ei = e[eptr];
          ea = abs(ei);
        }
      } else {
        a = fi;
        fptr += 1;
        if (fptr < nf) {
          fi = f[fptr];
          fa = abs(fi);
        }
      }
      b = q0;
      x = a + b;
      bv = x - a;
      y = b - bv;
      if (y) {
        g[count++] = y;
      }
      _x = q1 + x;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
    }
    while (eptr < ne) {
      a = ei;
      b = q0;
      x = a + b;
      bv = x - a;
      y = b - bv;
      if (y) {
        g[count++] = y;
      }
      _x = q1 + x;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
      eptr += 1;
      if (eptr < ne) {
        ei = e[eptr];
      }
    }
    while (fptr < nf) {
      a = fi;
      b = q0;
      x = a + b;
      bv = x - a;
      y = b - bv;
      if (y) {
        g[count++] = y;
      }
      _x = q1 + x;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
      fptr += 1;
      if (fptr < nf) {
        fi = f[fptr];
      }
    }
    if (q0) {
      g[count++] = q0;
    }
    if (q1) {
      g[count++] = q1;
    }
    if (!count) {
      g[count++] = 0.0;
    }
    g.length = count;
    return g;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("65", ["64"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('64');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("66", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  module.exports = twoProduct;
  var SPLITTER = +(Math.pow(2, 27) + 1.0);
  function twoProduct(a, b, result) {
    var x = a * b;
    var c = SPLITTER * a;
    var abig = c - a;
    var ahi = c - abig;
    var alo = a - ahi;
    var d = SPLITTER * b;
    var bbig = d - b;
    var bhi = d - bbig;
    var blo = b - bhi;
    var err1 = x - (ahi * bhi);
    var err2 = err1 - (alo * bhi);
    var err3 = err2 - (ahi * blo);
    var y = alo * blo - err3;
    if (result) {
      result[0] = y;
      result[1] = x;
      return result;
    }
    return [y, x];
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("62", ["66"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('66');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("67", ["62", "65", "63", "5e"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var twoProduct = req('62');
  var robustSum = req('65');
  var robustScale = req('63');
  var robustSubtract = req('5e');
  var NUM_EXPAND = 5;
  var EPSILON = 1.1102230246251565e-16;
  var ERRBOUND3 = (3.0 + 16.0 * EPSILON) * EPSILON;
  var ERRBOUND4 = (7.0 + 56.0 * EPSILON) * EPSILON;
  function cofactor(m, c) {
    var result = new Array(m.length - 1);
    for (var i = 1; i < m.length; ++i) {
      var r = result[i - 1] = new Array(m.length - 1);
      for (var j = 0,
          k = 0; j < m.length; ++j) {
        if (j === c) {
          continue;
        }
        r[k++] = m[i][j];
      }
    }
    return result;
  }
  function matrix(n) {
    var result = new Array(n);
    for (var i = 0; i < n; ++i) {
      result[i] = new Array(n);
      for (var j = 0; j < n; ++j) {
        result[i][j] = ["m", j, "[", (n - i - 1), "]"].join("");
      }
    }
    return result;
  }
  function sign(n) {
    if (n & 1) {
      return "-";
    }
    return "";
  }
  function generateSum(expr) {
    if (expr.length === 1) {
      return expr[0];
    } else if (expr.length === 2) {
      return ["sum(", expr[0], ",", expr[1], ")"].join("");
    } else {
      var m = expr.length >> 1;
      return ["sum(", generateSum(expr.slice(0, m)), ",", generateSum(expr.slice(m)), ")"].join("");
    }
  }
  function determinant(m) {
    if (m.length === 2) {
      return [["sum(prod(", m[0][0], ",", m[1][1], "),prod(-", m[0][1], ",", m[1][0], "))"].join("")];
    } else {
      var expr = [];
      for (var i = 0; i < m.length; ++i) {
        expr.push(["scale(", generateSum(determinant(cofactor(m, i))), ",", sign(i), m[0][i], ")"].join(""));
      }
      return expr;
    }
  }
  function orientation(n) {
    var pos = [];
    var neg = [];
    var m = matrix(n);
    var args = [];
    for (var i = 0; i < n; ++i) {
      if ((i & 1) === 0) {
        pos.push.apply(pos, determinant(cofactor(m, i)));
      } else {
        neg.push.apply(neg, determinant(cofactor(m, i)));
      }
      args.push("m" + i);
    }
    var posExpr = generateSum(pos);
    var negExpr = generateSum(neg);
    var funcName = "orientation" + n + "Exact";
    var code = ["function ", funcName, "(", args.join(), "){var p=", posExpr, ",n=", negExpr, ",d=sub(p,n);\
return d[d.length-1];};return ", funcName].join("");
    var proc = new Function("sum", "prod", "scale", "sub", code);
    return proc(robustSum, twoProduct, robustScale, robustSubtract);
  }
  var orientation3Exact = orientation(3);
  var orientation4Exact = orientation(4);
  var CACHED = [function orientation0() {
    return 0;
  }, function orientation1() {
    return 0;
  }, function orientation2(a, b) {
    return b[0] - a[0];
  }, function orientation3(a, b, c) {
    var l = (a[1] - c[1]) * (b[0] - c[0]);
    var r = (a[0] - c[0]) * (b[1] - c[1]);
    var det = l - r;
    var s;
    if (l > 0) {
      if (r <= 0) {
        return det;
      } else {
        s = l + r;
      }
    } else if (l < 0) {
      if (r >= 0) {
        return det;
      } else {
        s = -(l + r);
      }
    } else {
      return det;
    }
    var tol = ERRBOUND3 * s;
    if (det >= tol || det <= -tol) {
      return det;
    }
    return orientation3Exact(a, b, c);
  }, function orientation4(a, b, c, d) {
    var adx = a[0] - d[0];
    var bdx = b[0] - d[0];
    var cdx = c[0] - d[0];
    var ady = a[1] - d[1];
    var bdy = b[1] - d[1];
    var cdy = c[1] - d[1];
    var adz = a[2] - d[2];
    var bdz = b[2] - d[2];
    var cdz = c[2] - d[2];
    var bdxcdy = bdx * cdy;
    var cdxbdy = cdx * bdy;
    var cdxady = cdx * ady;
    var adxcdy = adx * cdy;
    var adxbdy = adx * bdy;
    var bdxady = bdx * ady;
    var det = adz * (bdxcdy - cdxbdy) + bdz * (cdxady - adxcdy) + cdz * (adxbdy - bdxady);
    var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz) + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz) + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz);
    var tol = ERRBOUND4 * permanent;
    if ((det > tol) || (-det > tol)) {
      return det;
    }
    return orientation4Exact(a, b, c, d);
  }];
  function slowOrient(args) {
    var proc = CACHED[args.length];
    if (!proc) {
      proc = CACHED[args.length] = orientation(args.length);
    }
    return proc.apply(undefined, args);
  }
  function generateOrientationProc() {
    while (CACHED.length <= NUM_EXPAND) {
      CACHED.push(orientation(CACHED.length));
    }
    var args = [];
    var procArgs = ["slow"];
    for (var i = 0; i <= NUM_EXPAND; ++i) {
      args.push("a" + i);
      procArgs.push("o" + i);
    }
    var code = ["function getOrientation(", args.join(), "){switch(arguments.length){case 0:case 1:return 0;"];
    for (var i = 2; i <= NUM_EXPAND; ++i) {
      code.push("case ", i, ":return o", i, "(", args.slice(0, i).join(), ");");
    }
    code.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation");
    procArgs.push(code.join(""));
    var proc = Function.apply(undefined, procArgs);
    module.exports = proc.apply(undefined, [slowOrient].concat(CACHED));
    for (var i = 0; i <= NUM_EXPAND; ++i) {
      module.exports[i] = CACHED[i];
    }
  }
  generateOrientationProc();
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("57", ["67"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('67');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("68", ["57", "5c", "55", "54"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = preprocessPolygon;
  var orient = req('57')[3];
  var makeSlabs = req('5c');
  var makeIntervalTree = req('55');
  var bsearch = req('54');
  function visitInterval() {
    return true;
  }
  function intervalSearch(table) {
    return function(x, y) {
      var tree = table[x];
      if (tree) {
        return !!tree.queryPoint(y, visitInterval);
      }
      return false;
    };
  }
  function buildVerticalIndex(segments) {
    var table = {};
    for (var i = 0; i < segments.length; ++i) {
      var s = segments[i];
      var x = s[0][0];
      var y0 = s[0][1];
      var y1 = s[1][1];
      var p = [Math.min(y0, y1), Math.max(y0, y1)];
      if (x in table) {
        table[x].push(p);
      } else {
        table[x] = [p];
      }
    }
    var intervalTable = {};
    var keys = Object.keys(table);
    for (var i = 0; i < keys.length; ++i) {
      var segs = table[keys[i]];
      intervalTable[keys[i]] = makeIntervalTree(segs);
    }
    return intervalSearch(intervalTable);
  }
  function buildSlabSearch(slabs, coordinates) {
    return function(p) {
      var bucket = bsearch.le(coordinates, p[0]);
      if (bucket < 0) {
        return 1;
      }
      var root = slabs[bucket];
      if (!root) {
        if (bucket > 0 && coordinates[bucket] === p[0]) {
          root = slabs[bucket - 1];
        } else {
          return 1;
        }
      }
      var lastOrientation = 1;
      while (root) {
        var s = root.key;
        var o = orient(p, s[0], s[1]);
        if (s[0][0] < s[1][0]) {
          if (o < 0) {
            root = root.left;
          } else if (o > 0) {
            lastOrientation = -1;
            root = root.right;
          } else {
            return 0;
          }
        } else {
          if (o > 0) {
            root = root.left;
          } else if (o < 0) {
            lastOrientation = 1;
            root = root.right;
          } else {
            return 0;
          }
        }
      }
      return lastOrientation;
    };
  }
  function classifyEmpty(p) {
    return 1;
  }
  function createClassifyVertical(testVertical) {
    return function classify(p) {
      if (testVertical(p[0], p[1])) {
        return 0;
      }
      return 1;
    };
  }
  function createClassifyPointDegen(testVertical, testNormal) {
    return function classify(p) {
      if (testVertical(p[0], p[1])) {
        return 0;
      }
      return testNormal(p);
    };
  }
  function preprocessPolygon(loops) {
    var numLoops = loops.length;
    var segments = [];
    var vsegments = [];
    var ptr = 0;
    for (var i = 0; i < numLoops; ++i) {
      var loop = loops[i];
      var numVertices = loop.length;
      for (var s = numVertices - 1,
          t = 0; t < numVertices; s = (t++)) {
        var a = loop[s];
        var b = loop[t];
        if (a[0] === b[0]) {
          vsegments.push([a, b]);
        } else {
          segments.push([a, b]);
        }
      }
    }
    if (segments.length === 0) {
      if (vsegments.length === 0) {
        return classifyEmpty;
      } else {
        return createClassifyVertical(buildVerticalIndex(vsegments));
      }
    }
    var slabs = makeSlabs(segments);
    var testSlab = buildSlabSearch(slabs.slabs, slabs.coordinates);
    if (vsegments.length === 0) {
      return testSlab;
    } else {
      return createClassifyPointDegen(buildVerticalIndex(vsegments), testSlab);
    }
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("69", ["68"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('68');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("36", ["69", "52", "51"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.ensureClockwisePolygon = ensureClockwisePolygon;
  exports.getPointInPolygonsFn = getPointInPolygonsFn;
  var _pointInBigPolygon = req('69');
  var _pointInBigPolygon2 = _interopRequireDefault(_pointInBigPolygon);
  var _spherical = req('52');
  var _cartesian = req('51');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function ensureClockwisePolygon(rings) {
    var isCartesian = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
    var ringAreaFn = isCartesian ? _cartesian.ringArea : _spherical.ringArea;
    for (var i = 0; i < rings.length; i++) {
      var area = ringAreaFn(rings[i]);
      if (i === 0 && area < 0 || i > 0 && area > 0) {
        rings[i].reverse();
      }
    }
  }
  function getPointInPolygonsFn(polygons) {
    var classifiers = polygons.map(_pointInBigPolygon2.default);
    var npolys = polygons.length;
    return function(point) {
      for (var i = 0; i < npolys; i++) {
        if (classifiers[i](point) <= 0) {
          return i;
        }
      }
      return -1;
    };
  }
  global.define = __define;
  return module.exports;
});

$__System.register('6a', ['5', '25', '35', '36', '37', '45', '4d', '4f', '4e'], function (_export) {
  /* */

  /** @ignore */
  'use strict';

  var L, rangeutil, isDomain, ensureClockwisePolygon, getPointInPolygonsFn, fromDomain, EventMixin, enlargeExtentIfEqual, PaletteMixin, CoverageMixin, DEFAULT_COLOR, MultiPolygon;
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_2) {
      rangeutil = _2;
    }, function (_4) {
      isDomain = _4.isDomain;
    }, function (_6) {
      ensureClockwisePolygon = _6.ensureClockwisePolygon;
      getPointInPolygonsFn = _6.getPointInPolygonsFn;
    }, function (_5) {
      fromDomain = _5.fromDomain;
    }, function (_3) {
      EventMixin = _3['default'];
    }, function (_d) {
      enlargeExtentIfEqual = _d.enlargeExtentIfEqual;
    }, function (_f) {
      PaletteMixin = _f['default'];
    }, function (_e) {
      CoverageMixin = _e['default'];
    }],
    execute: function () {
      DEFAULT_COLOR = 'black';

      _export('DEFAULT_COLOR', DEFAULT_COLOR);

      /**
       * Renderer for Coverages and Domains with (domain) profile MultiPolygon.
       */

      MultiPolygon = (function (_PaletteMixin) {
        babelHelpers.inherits(MultiPolygon, _PaletteMixin);

        function MultiPolygon(cov, options) {
          babelHelpers.classCallCheck(this, MultiPolygon);

          babelHelpers.get(Object.getPrototypeOf(MultiPolygon.prototype), 'constructor', this).call(this);

          if (isDomain(cov)) {
            cov = fromDomain(cov);
            options.keys = [cov.parameters.keys().next.value];
          }

          if (!options.paletteExtent) {
            options.paletteExtent = 'full';
          }

          L.Util.setOptions(this, options);

          this.cov = cov;
          this.param = options.keys ? cov.parameters.get(options.keys[0]) : null;
          this.defaultColor = options.color || DEFAULT_COLOR;
        }

        babelHelpers.createClass(MultiPolygon, [{
          key: 'onAdd',
          value: function onAdd(map) {
            var _this = this;

            this._map = map;

            this.load().then(function () {
              return _this.initializePalette();
            }).then(function () {
              _this._addPolygons();
              _this._pointInPolygonPreprocess();
              _this.fire('add');
            });
          }
        }, {
          key: 'onRemove',
          value: function onRemove(map) {
            this.fire('remove');
            this._removePolygons();
          }
        }, {
          key: 'getBounds',
          value: function getBounds() {
            return this._geojson.getBounds();
          }
        }, {
          key: 'getLatLng',
          value: function getLatLng() {
            return this.getBounds().getCenter();
          }
        }, {
          key: 'computePaletteExtent',
          value: function computePaletteExtent(extent) {
            if (extent === 'full') {
              if (!this.parameter) {
                throw new Error('palette extent cannot be computed when no parameter has been chosen');
              }

              extent = rangeutil.minMax(this.range);
              extent = enlargeExtentIfEqual(extent);
              return Promise.resolve(extent);
            } else {
              throw new Error('Unknown extent specification: ' + extent);
            }
          }
        }, {
          key: '_pointInPolygonPreprocess',
          value: function _pointInPolygonPreprocess() {
            var polygons = this.domain.axes.get('composite').values;
            // TODO we assume spherical coordinates for now
            var isCartesian = false;
            // A bit evil since this modifies in-place, but nothing bad should happen.
            polygons.forEach(function (p) {
              return ensureClockwisePolygon(p, isCartesian);
            });
            this._pointInPolygons = getPointInPolygonsFn(polygons);
          }
        }, {
          key: '_addPolygons',
          value: function _addPolygons() {
            var _this2 = this;

            // TODO do coordinate transformation to lat/lon if necessary

            var polygons = this.domain.axes.get('composite').values;

            var geojson = [];
            for (var i = 0; i < polygons.length; i++) {
              geojson.push({
                "type": "Feature",
                "properties": {
                  "index": i,
                  "color": this._getColor(this._getValue(i))
                },
                "geometry": {
                  "type": "Polygon",
                  "coordinates": polygons[i]
                }
              });
            }

            this._geojson = L.geoJson(geojson, {
              style: function style(feature) {
                return {
                  color: feature.properties.color,
                  fillOpacity: 1,
                  stroke: false
                };
              },
              onEachFeature: function onEachFeature(feature, layer) {
                layer.on('click', function (e) {
                  e.index = feature.properties.index;
                  _this2.fire('click', e);
                });
              }
            });

            this._geojson.addTo(this._map);
          }
        }, {
          key: '_removePolygons',
          value: function _removePolygons() {
            this._map.removeLayer(this._geojson);
            delete this._geojson;
          }
        }, {
          key: '_getValue',
          value: function _getValue(index) {
            if (this.param) {
              return this.range.get({ composite: index });
            }
          }
        }, {
          key: 'getValueAt',
          value: function getValueAt(latlng) {
            // TODO longitude wrapping
            var i = this._pointInPolygons([latlng.lng, latlng.lat]);
            if (i >= 0) {
              return this._getValue(i);
            }
          }

          // NOTE: this returns a string, not an {r,g,b} object as in other classes!
        }, {
          key: '_getColor',
          value: function _getColor(val) {
            if (val === null) {
              // no-data
              return this.defaultColor;
            } else if (val === undefined) {
              // not fixed to a param
              return this.defaultColor;
            } else {
              // use a palette
              var idx = this.getPaletteIndex(val);
              var _palette = this.palette;
              var red = _palette.red;
              var green = _palette.green;
              var blue = _palette.blue;

              return 'rgb(' + red[idx] + ', ' + green[idx] + ', ' + blue[idx] + ')';
            }
          }
        }, {
          key: '_updatePolygons',
          value: function _updatePolygons() {
            this._removePolygons();
            this._addPolygons();
          }
        }, {
          key: 'redraw',
          value: function redraw() {
            this._updatePolygons();
            this._geojson.redraw();
          }
        }, {
          key: 'coverage',
          get: function get() {
            return this.cov;
          }
        }, {
          key: 'parameter',
          get: function get() {
            return this.param;
          }
        }]);
        return MultiPolygon;
      })(PaletteMixin(CoverageMixin(EventMixin(L.Class))));

      _export('default', MultiPolygon);
    }
  };
});

$__System.register('6b', ['6c', '6d'], function (_export) {
  /* */

  /**
   * A collection of vertical profiles sharing the same parameters / referencing.
   * 
   */
  'use strict';

  var PointCollection, VerticalProfile, VerticalProfileCollection;
  return {
    setters: [function (_c) {
      PointCollection = _c['default'];
    }, function (_d) {
      VerticalProfile = _d['default'];
    }],
    execute: function () {
      VerticalProfileCollection = (function (_PointCollection) {
        babelHelpers.inherits(VerticalProfileCollection, _PointCollection);

        function VerticalProfileCollection(covcoll, options) {
          var _this = this;

          babelHelpers.classCallCheck(this, VerticalProfileCollection);

          babelHelpers.get(Object.getPrototypeOf(VerticalProfileCollection.prototype), 'constructor', this).call(this, covcoll, options);

          // set some options for PointCollection
          this.pointClass = VerticalProfile;
          this.pointOptionsFn = function () {
            return {
              vertical: _this._vertical
            };
          };

          this._vertical = options.vertical;
        }

        babelHelpers.createClass(VerticalProfileCollection, [{
          key: 'canUsePalette',
          value: function canUsePalette() {
            return this._vertical !== undefined;
          }
        }, {
          key: 'vertical',
          set: function set(val) {
            this._vertical = val;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = this._layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var layer = _step.value;

                layer.vertical = val;
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
        }]);
        return VerticalProfileCollection;
      })(PointCollection);

      _export('default', VerticalProfileCollection);
    }
  };
});

$__System.register('6d', ['5', '25', '35', '37', '45', '50', '4d', '1b', '4e', '6e', '4f'], function (_export) {
  /* */

  /**
   * Renderer for Coverages with domain type Profile.
   * 
   * This will simply display a dot on the map and fire a click
   * event when a user clicks on it.
   * The dot either has a defined standard color, or it uses
   * a palette together with a target depth if a parameter is chosen.
   */
  'use strict';

  var L, rangeutil, isDomain, fromDomain, EventMixin, DEFAULT_COLOR, enlargeExtentIfEqual, arrays, CoverageMixin, CircleMarkerMixin, PaletteMixin, VerticalProfile;
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_2) {
      rangeutil = _2;
    }, function (_4) {
      isDomain = _4.isDomain;
    }, function (_5) {
      fromDomain = _5.fromDomain;
    }, function (_3) {
      EventMixin = _3['default'];
    }, function (_6) {
      DEFAULT_COLOR = _6.DEFAULT_COLOR;
    }, function (_d) {
      enlargeExtentIfEqual = _d.enlargeExtentIfEqual;
    }, function (_b) {
      arrays = _b;
    }, function (_e) {
      CoverageMixin = _e['default'];
    }, function (_e2) {
      CircleMarkerMixin = _e2['default'];
    }, function (_f) {
      PaletteMixin = _f['default'];
    }],
    execute: function () {
      VerticalProfile = (function (_PaletteMixin) {
        babelHelpers.inherits(VerticalProfile, _PaletteMixin);

        function VerticalProfile(cov, options) {
          babelHelpers.classCallCheck(this, VerticalProfile);

          babelHelpers.get(Object.getPrototypeOf(VerticalProfile.prototype), 'constructor', this).call(this);

          if (isDomain(cov)) {
            cov = fromDomain(cov);
            delete options.keys;
          }

          if (!options.paletteExtent) {
            options.paletteExtent = 'full';
          }

          L.Util.setOptions(this, options);

          this.cov = cov;
          this.param = options.keys ? cov.parameters.get(options.keys[0]) : null;
          this._axesSubset = {
            z: { coordPref: options.vertical }
          };
          this.defaultColor = options.color ? options.color : DEFAULT_COLOR;
          this.showNoData = options.showNoData; // if true, draw with default color
        }

        babelHelpers.createClass(VerticalProfile, [{
          key: 'onAdd',
          value: function onAdd(map) {
            var _this = this;

            this._map = map;

            this.load().then(function () {
              return _this.initializePalette();
            }).then(function () {
              _this._addMarker();
              _this.fire('add');
            });
          }
        }, {
          key: '_loadCoverageSubset',
          value: function _loadCoverageSubset() {
            // adapted from Grid.js
            var z = this._axesSubset.z;
            if (z.coordPref == undefined) {
              z.idx = z.coord = undefined;
            } else {
              var vals = this.domain.axes.get('z').values;
              z.idx = arrays.indexOfNearest(vals, z.coordPref);
              z.coord = vals[z.idx];
            }

            // Note that we don't subset the coverage currently, since there is no real need for it
          }
        }, {
          key: 'onRemove',
          value: function onRemove() {
            this.fire('remove');
            this._removeMarker();
          }
        }, {
          key: 'getBounds',
          value: function getBounds() {
            return L.latLngBounds([this.getLatLng()]);
          }
        }, {
          key: 'getLatLng',
          value: function getLatLng() {
            // TODO convert coordinates to lat/lon if necessary
            var x = this.domain.axes.get('x').values[0];
            var y = this.domain.axes.get('y').values[0];
            return L.latLng(y, x);
          }
        }, {
          key: 'canUsePalette',
          value: function canUsePalette() {
            return this.vertical !== undefined;
          }
        }, {
          key: 'computePaletteExtent',
          value: function computePaletteExtent(extent) {
            if (extent === 'full') {
              if (!this.parameter) {
                throw new Error('palette extent cannot be set when no parameter has been chosen');
              }

              extent = rangeutil.minMax(this.range);
              extent = enlargeExtentIfEqual(extent);
              return Promise.resolve(extent);
            } else {
              throw new Error('Unknown extent specification: ' + extent);
            }
          }

          /**
           * Return the displayed value (number, or null for no-data),
           * or undefined if not fixed to a z-coordinate or parameter.
           */
        }, {
          key: 'getValue',
          value: function getValue() {
            if (this.param && this._axesSubset.z.coord !== undefined) {
              var val = this.range.get({ z: this._axesSubset.z.idx });
              return val;
            }
          }
        }, {
          key: 'getValueAt',
          value: function getValueAt(latlng, maxDistance) {
            var point = this.getLatLng();
            if (point.distanceTo(latlng) <= maxDistance) {
              return this.getValue();
            }
          }
        }, {
          key: '_getColor',
          value: function _getColor(val) {
            if (val === null) {
              // no-data
              return this.defaultColor;
            } else if (val === undefined) {
              // not fixed to a param or z-coordinate
              return this.defaultColor;
            } else {
              // use a palette
              var idx = this.getPaletteIndex(val);
              var _palette = this.palette;
              var red = _palette.red;
              var green = _palette.green;
              var blue = _palette.blue;

              return { r: red[idx], g: green[idx], b: blue[idx] };
            }
          }
        }, {
          key: 'coverage',
          get: function get() {
            return this.cov;
          }
        }, {
          key: 'parameter',
          get: function get() {
            return this.param;
          }
        }, {
          key: 'vertical',
          get: function get() {
            return this._axesSubset.z.coord;
          },
          set: function set(val) {
            this._axesSubset.z.coordPref = val;
            this._loadCoverageSubset();
            this.redraw();
            this.fire('axisChange', { axis: 'vertical' });
          }
        }, {
          key: 'verticalSlices',
          get: function get() {
            var vals = this.domain.axes.get('z').values;
            if (ArrayBuffer.isView(vals)) {
              // convert to plain Array to allow easier use
              vals = [].concat(babelHelpers.toConsumableArray(vals));
            }
            return vals;
          }
        }]);
        return VerticalProfile;
      })(PaletteMixin(CircleMarkerMixin(CoverageMixin(EventMixin(L.Class)))));

      _export('default', VerticalProfile);
    }
  };
});

$__System.register("6f", [], function (_export) {
  // 2016-02-23 Maik Riechert - adjust boilerplate to make it node compatible

  /**
   * k-d Tree JavaScript - V 1.01
   *
   * https://github.com/ubilabs/kd-tree-javascript
   *
   * @author Mircea Pricop <pricop@ubilabs.net>, 2012
   * @author Martin Kleppe <kleppe@ubilabs.net>, 2012
   * @author Ubilabs http://ubilabs.net, 2012
   * @license MIT License <http://www.opensource.org/licenses/mit-license.php>
   */

  "use strict";

  function Node(obj, dimension, parent) {
    this.obj = obj;
    this.left = null;
    this.right = null;
    this.parent = parent;
    this.dimension = dimension;
  }

  function kdTree(points, metric, dimensions) {

    var self = this;

    function buildTree(points, depth, parent) {
      var dim = depth % dimensions.length,
          median,
          node;

      if (points.length === 0) {
        return null;
      }
      if (points.length === 1) {
        return new Node(points[0], dim, parent);
      }

      points.sort(function (a, b) {
        return a[dimensions[dim]] - b[dimensions[dim]];
      });

      median = Math.floor(points.length / 2);
      node = new Node(points[median], dim, parent);
      node.left = buildTree(points.slice(0, median), depth + 1, node);
      node.right = buildTree(points.slice(median + 1), depth + 1, node);

      return node;
    }

    // Reloads a serialied tree
    function loadTree(data) {
      // Just need to restore the `parent` parameter
      self.root = data;

      function restoreParent(root) {
        if (root.left) {
          root.left.parent = root;
          restoreParent(root.left);
        }

        if (root.right) {
          root.right.parent = root;
          restoreParent(root.right);
        }
      }

      restoreParent(self.root);
    }

    // If points is not an array, assume we're loading a pre-built tree
    if (!Array.isArray(points)) loadTree(points, metric, dimensions);else this.root = buildTree(points, 0, null);

    // Convert to a JSON serializable structure; this just requires removing
    // the `parent` property
    this.toJSON = function (src) {
      if (!src) src = this.root;
      var dest = new Node(src.obj, src.dimension, null);
      if (src.left) dest.left = self.toJSON(src.left);
      if (src.right) dest.right = self.toJSON(src.right);
      return dest;
    };

    this.insert = function (point) {
      function innerSearch(_x, _x2) {
        var _again = true;

        _function: while (_again) {
          var node = _x,
              parent = _x2;
          _again = false;

          if (node === null) {
            return parent;
          }

          var dimension = dimensions[node.dimension];
          if (point[dimension] < node.obj[dimension]) {
            _x = node.left;
            _x2 = node;
            _again = true;
            dimension = undefined;
            continue _function;
          } else {
            _x = node.right;
            _x2 = node;
            _again = true;
            dimension = undefined;
            continue _function;
          }
        }
      }

      var insertPosition = innerSearch(this.root, null),
          newNode,
          dimension;

      if (insertPosition === null) {
        this.root = new Node(point, 0, null);
        return;
      }

      newNode = new Node(point, (insertPosition.dimension + 1) % dimensions.length, insertPosition);
      dimension = dimensions[insertPosition.dimension];

      if (point[dimension] < insertPosition.obj[dimension]) {
        insertPosition.left = newNode;
      } else {
        insertPosition.right = newNode;
      }
    };

    this.remove = function (point) {
      var node;

      function nodeSearch(_x3) {
        var _again2 = true;

        _function2: while (_again2) {
          var node = _x3;
          _again2 = false;

          if (node === null) {
            return null;
          }

          if (node.obj === point) {
            return node;
          }

          var dimension = dimensions[node.dimension];

          if (point[dimension] < node.obj[dimension]) {
            _x3 = node.left;
            _again2 = true;
            dimension = undefined;
            continue _function2;
          } else {
            _x3 = node.right;
            _again2 = true;
            dimension = undefined;
            continue _function2;
          }
        }
      }

      function removeNode(node) {
        var nextNode, nextObj, pDimension;

        function findMin(_x4, _x5) {
          var _again3 = true;

          _function3: while (_again3) {
            var node = _x4,
                dim = _x5;
            _again3 = false;

            var dimension, own, left, right, min;

            if (node === null) {
              return null;
            }

            dimension = dimensions[dim];

            if (node.dimension === dim) {
              if (node.left !== null) {
                _x4 = node.left;
                _x5 = dim;
                _again3 = true;
                dimension = own = left = right = min = undefined;
                continue _function3;
              }
              return node;
            }

            own = node.obj[dimension];
            left = findMin(node.left, dim);
            right = findMin(node.right, dim);
            min = node;

            if (left !== null && left.obj[dimension] < own) {
              min = left;
            }
            if (right !== null && right.obj[dimension] < min.obj[dimension]) {
              min = right;
            }
            return min;
          }
        }

        if (node.left === null && node.right === null) {
          if (node.parent === null) {
            self.root = null;
            return;
          }

          pDimension = dimensions[node.parent.dimension];

          if (node.obj[pDimension] < node.parent.obj[pDimension]) {
            node.parent.left = null;
          } else {
            node.parent.right = null;
          }
          return;
        }

        // If the right subtree is not empty, swap with the minimum element on the
        // node's dimension. If it is empty, we swap the left and right subtrees and
        // do the same.
        if (node.right !== null) {
          nextNode = findMin(node.right, node.dimension);
          nextObj = nextNode.obj;
          removeNode(nextNode);
          node.obj = nextObj;
        } else {
          nextNode = findMin(node.left, node.dimension);
          nextObj = nextNode.obj;
          removeNode(nextNode);
          node.right = node.left;
          node.left = null;
          node.obj = nextObj;
        }
      }

      node = nodeSearch(self.root);

      if (node === null) {
        return;
      }

      removeNode(node);
    };

    this.nearest = function (point, maxNodes, maxDistance) {
      var i, result, bestNodes;

      bestNodes = new BinaryHeap(function (e) {
        return -e[1];
      });

      function nearestSearch(node) {
        var bestChild,
            dimension = dimensions[node.dimension],
            ownDistance = metric(point, node.obj),
            linearPoint = {},
            linearDistance,
            otherChild,
            i;

        function saveNode(node, distance) {
          bestNodes.push([node, distance]);
          if (bestNodes.size() > maxNodes) {
            bestNodes.pop();
          }
        }

        for (i = 0; i < dimensions.length; i += 1) {
          if (i === node.dimension) {
            linearPoint[dimensions[i]] = point[dimensions[i]];
          } else {
            linearPoint[dimensions[i]] = node.obj[dimensions[i]];
          }
        }

        linearDistance = metric(linearPoint, node.obj);

        if (node.right === null && node.left === null) {
          if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
            saveNode(node, ownDistance);
          }
          return;
        }

        if (node.right === null) {
          bestChild = node.left;
        } else if (node.left === null) {
          bestChild = node.right;
        } else {
          if (point[dimension] < node.obj[dimension]) {
            bestChild = node.left;
          } else {
            bestChild = node.right;
          }
        }

        nearestSearch(bestChild);

        if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {
          saveNode(node, ownDistance);
        }

        if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {
          if (bestChild === node.left) {
            otherChild = node.right;
          } else {
            otherChild = node.left;
          }
          if (otherChild !== null) {
            nearestSearch(otherChild);
          }
        }
      }

      if (maxDistance) {
        for (i = 0; i < maxNodes; i += 1) {
          bestNodes.push([null, maxDistance]);
        }
      }

      if (self.root) nearestSearch(self.root);

      result = [];

      for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {
        if (bestNodes.content[i][0]) {
          result.push([bestNodes.content[i][0].obj, bestNodes.content[i][1]]);
        }
      }
      return result;
    };

    this.balanceFactor = function () {
      function height(node) {
        if (node === null) {
          return 0;
        }
        return Math.max(height(node.left), height(node.right)) + 1;
      }

      function count(node) {
        if (node === null) {
          return 0;
        }
        return count(node.left) + count(node.right) + 1;
      }

      return height(self.root) / (Math.log(count(self.root)) / Math.log(2));
    };
  }

  // Binary heap implementation from:
  // http://eloquentjavascript.net/appendix2.html

  function BinaryHeap(scoreFunction) {
    this.content = [];
    this.scoreFunction = scoreFunction;
  }

  return {
    setters: [],
    execute: function () {
      BinaryHeap.prototype = {
        push: function push(element) {
          // Add the new element to the end of the array.
          this.content.push(element);
          // Allow it to bubble up.
          this.bubbleUp(this.content.length - 1);
        },

        pop: function pop() {
          // Store the first element so we can return it later.
          var result = this.content[0];
          // Get the element at the end of the array.
          var end = this.content.pop();
          // If there are any elements left, put the end element at the
          // start, and let it sink down.
          if (this.content.length > 0) {
            this.content[0] = end;
            this.sinkDown(0);
          }
          return result;
        },

        peek: function peek() {
          return this.content[0];
        },

        remove: function remove(node) {
          var len = this.content.length;
          // To remove a value, we must search through the array to find
          // it.
          for (var i = 0; i < len; i++) {
            if (this.content[i] == node) {
              // When it is found, the process seen in 'pop' is repeated
              // to fill up the hole.
              var end = this.content.pop();
              if (i != len - 1) {
                this.content[i] = end;
                if (this.scoreFunction(end) < this.scoreFunction(node)) this.bubbleUp(i);else this.sinkDown(i);
              }
              return;
            }
          }
          throw new Error("Node not found.");
        },

        size: function size() {
          return this.content.length;
        },

        bubbleUp: function bubbleUp(n) {
          // Fetch the element that has to be moved.
          var element = this.content[n];
          // When at 0, an element can not go up any further.
          while (n > 0) {
            // Compute the parent element's index, and fetch it.
            var parentN = Math.floor((n + 1) / 2) - 1,
                parent = this.content[parentN];
            // Swap the elements if the parent is greater.
            if (this.scoreFunction(element) < this.scoreFunction(parent)) {
              this.content[parentN] = element;
              this.content[n] = parent;
              // Update 'n' to continue at the new position.
              n = parentN;
            }
            // Found a parent that is less, no need to move it further.
            else {
                break;
              }
          }
        },

        sinkDown: function sinkDown(n) {
          // Look up the target element and its score.
          var length = this.content.length,
              element = this.content[n],
              elemScore = this.scoreFunction(element);

          while (true) {
            // Compute the indices of the child elements.
            var child2N = (n + 1) * 2,
                child1N = child2N - 1;
            // This is used to store the new position of the element,
            // if any.
            var swap = null;
            // If the first child exists (is inside the array)...
            if (child1N < length) {
              // Look it up and compute its score.
              var child1 = this.content[child1N],
                  child1Score = this.scoreFunction(child1);
              // If the score is less than our element's, we need to swap.
              if (child1Score < elemScore) swap = child1N;
            }
            // Do the same checks for the other child.
            if (child2N < length) {
              var child2 = this.content[child2N],
                  child2Score = this.scoreFunction(child2);
              if (child2Score < (swap == null ? elemScore : child1Score)) {
                swap = child2N;
              }
            }

            // If the element needs to be moved, swap it, and continue.
            if (swap != null) {
              this.content[n] = this.content[swap];
              this.content[swap] = element;
              n = swap;
            }
            // Otherwise, we are done.
            else {
                break;
              }
          }
        }
      };

      _export("kdTree", kdTree);

      _export("BinaryHeap", BinaryHeap);
    }
  };
});

$__System.register('6c', ['5', '45', '50', '4f', '4d', '6f'], function (_export) {
  /* */

  /**
   * A collection of points sharing the same parameters / referencing.
   * 
   */
  'use strict';

  var L, EventMixin, Point, DEFAULT_COLOR, PaletteMixin, enlargeExtentIfEqual, kdTree, PointCollection;
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_2) {
      EventMixin = _2['default'];
    }, function (_3) {
      Point = _3['default'];
      DEFAULT_COLOR = _3.DEFAULT_COLOR;
    }, function (_f) {
      PaletteMixin = _f['default'];
    }, function (_d) {
      enlargeExtentIfEqual = _d.enlargeExtentIfEqual;
    }, function (_f2) {
      kdTree = _f2.kdTree;
    }],
    execute: function () {
      PointCollection = (function (_PaletteMixin) {
        babelHelpers.inherits(PointCollection, _PaletteMixin);

        function PointCollection(covcoll, options) {
          var _this = this;

          babelHelpers.classCallCheck(this, PointCollection);

          babelHelpers.get(Object.getPrototypeOf(PointCollection.prototype), 'constructor', this).call(this);

          // TODO how should we handle collection paging?

          if (!options.paletteExtent) {
            options.paletteExtent = 'full';
          }

          L.Util.setOptions(this, options);

          this.covcoll = covcoll;
          this.param = options.keys ? covcoll.parameters.get(options.keys[0]) : null;
          this.defaultColor = options.color || DEFAULT_COLOR;
          this.pointClass = options.pointClass || Point;
          this.pointOptionsFn = options.pointOptionsFn;

          this._layerGroup = L.layerGroup();
          this._layers = [];
          this._kdtree = undefined;

          this.on('paletteChange', function () {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = _this._layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var layer = _step.value;

                layer.palette = _this.palette;
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          });
          this.on('paletteExtentChange', function () {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = _this._layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var layer = _step2.value;

                layer.paletteExtent = _this.paletteExtent;
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                  _iterator2['return']();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          });
        }

        babelHelpers.createClass(PointCollection, [{
          key: 'onAdd',
          value: function onAdd(map) {
            this._map = map;
            this._layerLoadCount = 0;
            this._layerErrors = [];

            var options = {
              keys: this.param ? [this.param.key] : undefined,
              color: this.defaultColor,
              palette: this.palette,
              paletteExtent: this.paletteExtent
            };
            if (this.pointOptionsFn) {
              var opts = this.pointOptionsFn();
              for (var key in opts) {
                options[key] = opts[key];
              }
            }
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = this.covcoll.coverages[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var cov = _step3.value;

                var layer = new this.pointClass(cov, options);
                this._attachListeners(layer, cov);
                this._layerGroup.addLayer(layer);
                this._layers.push(layer);
                layer.load();
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                  _iterator3['return']();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          }
        }, {
          key: 'onRemove',
          value: function onRemove(map) {
            map.removeLayer(this._layerGroup);
            this._layerGroup = L.layerGroup();
            this._layers = [];
            this.fire('remove');
          }
        }, {
          key: 'bindPopupEach',
          value: function bindPopupEach(fn) {
            var _this2 = this;

            if (this._clickListenerPopup) {
              this.off('click', this._clickListenerPopup);
              this.off('remove', this._removeListenerPopup);
            }
            this._clickListenerPopup = function (e) {
              var popup = fn(e.coverage);
              _this2._map.openPopup(popup);
              _this2._popup = popup;
            };
            this._removeListenerPopup = function () {
              _this2._map.closePopup(_this2._popup);
            };
            this.on('click', this._clickListenerPopup);
            this.on('remove', this._removeListenerPopup);
          }
        }, {
          key: '_attachListeners',
          value: function _attachListeners(layer, cov) {
            var _this3 = this;

            layer.once('dataLoad', function () {
              ++_this3._layerLoadCount;
              _this3._fireIfOnAddDone();
            }).once('error', function (e) {
              _this3._layerErrors.push(e);
            }).on('click', function (e) {
              e.coverage = cov;
              _this3.fire('click', e);
            });
          }
        }, {
          key: '_fireIfOnAddDone',
          value: function _fireIfOnAddDone() {
            var _this4 = this;

            if (this._layerLoadCount === this._layers.length) {
              if (this._layerErrors.length > 0) {
                this.fire('error', { errors: this._layerErrors });
              } else {
                this._initKdtree();
                this.initializePalette().then(function () {
                  _this4._layerGroup.addTo(_this4._map);
                  _this4.fire('add');
                });
              }
            }
          }
        }, {
          key: '_initKdtree',
          value: function _initKdtree() {
            var points = this._layers.map(function (layer) {
              var point = layer.getLatLng();
              point.layer = layer;
              return point;
            });
            var distance = function distance(point1, point2) {
              return L.LatLng.prototype.distanceTo.call(point1, point2);
            };
            var dimensions = ['lat', 'lng'];
            this._kdtree = new kdTree(points, distance, dimensions);
          }
        }, {
          key: 'getBounds',
          value: function getBounds() {
            return L.latLngBounds(this._layers.map(function (layer) {
              return layer.getLatLng();
            }));
          }

          /**
           * Return the displayed value of the point coverage closest to
           * the given position and within the given maximum distance.
           * If no coverage is found, undefined is returned, otherwise
           * a number or null (no-data).
           * 
           * @param {number} maxDistance
           *   Maximum distance in meters that the point coverage may be
           *   apart from the given position.
           */
        }, {
          key: 'getValueAt',
          value: function getValueAt(latlng, maxDistance) {
            var points = this._kdtree.nearest(latlng, 1, maxDistance);
            if (points.length > 0) {
              var point = points[0][0];
              var val = point.layer.getValue();
              return val;
            }
          }
        }, {
          key: 'computePaletteExtent',
          value: function computePaletteExtent(extent) {
            var _this5 = this;

            if (!this.param) {
              throw new Error('palette extent cannot be set when no parameter has been chosen');
            }

            var layers = undefined;
            if (extent === 'full') {
              layers = this._layers;
            } else if (extent === 'fov') {
              (function () {
                var bounds = _this5._map.getBounds();
                layers = _this5._layers.filter(function (layer) {
                  return bounds.contains(layer.getLatLng());
                });
              })();
            } else {
              throw new Error('Unsupported: ' + extent);
            }

            var min = Infinity;
            var max = -Infinity;
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = layers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var layer = _step4.value;

                var val = layer.getValue();
                if (val != null) {
                  min = Math.min(min, val);
                  max = Math.max(max, val);
                }
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                  _iterator4['return']();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            extent = enlargeExtentIfEqual([min, max]);
            return Promise.resolve(extent);
          }
        }, {
          key: 'redraw',
          value: function redraw() {
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
              for (var _iterator5 = this._layers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var layer = _step5.value;

                layer.redraw();
              }
            } catch (err) {
              _didIteratorError5 = true;
              _iteratorError5 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion5 && _iterator5['return']) {
                  _iterator5['return']();
                }
              } finally {
                if (_didIteratorError5) {
                  throw _iteratorError5;
                }
              }
            }
          }
        }, {
          key: 'parameter',
          get: function get() {
            return this.param;
          }
        }]);
        return PointCollection;
      })(PaletteMixin(EventMixin(L.Class)));

      _export('default', PointCollection);
    }
  };
});

$__System.register('70', ['5', '25', '35', '37', '45', '50', '4d', '1b', '4e', '6e', '4f'], function (_export) {
  /* */

  // TODO nearly identical to VerticalProfile

  /**
   * Renderer for Coverages with domain type Profile.
   * 
   * This will simply display a dot on the map and fire a click
   * event when a user clicks on it.
   * The dot either has a defined standard color, or it uses
   * a palette together with a target depth if a parameter is chosen.
   */
  'use strict';

  var L, rangeutil, isDomain, fromDomain, EventMixin, DEFAULT_COLOR, enlargeExtentIfEqual, arrays, CoverageMixin, CircleMarkerMixin, PaletteMixin, PointSeries;
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_2) {
      rangeutil = _2;
    }, function (_4) {
      isDomain = _4.isDomain;
    }, function (_5) {
      fromDomain = _5.fromDomain;
    }, function (_3) {
      EventMixin = _3['default'];
    }, function (_6) {
      DEFAULT_COLOR = _6.DEFAULT_COLOR;
    }, function (_d) {
      enlargeExtentIfEqual = _d.enlargeExtentIfEqual;
    }, function (_b) {
      arrays = _b;
    }, function (_e) {
      CoverageMixin = _e['default'];
    }, function (_e2) {
      CircleMarkerMixin = _e2['default'];
    }, function (_f) {
      PaletteMixin = _f['default'];
    }],
    execute: function () {
      PointSeries = (function (_PaletteMixin) {
        babelHelpers.inherits(PointSeries, _PaletteMixin);

        function PointSeries(cov, options) {
          babelHelpers.classCallCheck(this, PointSeries);

          babelHelpers.get(Object.getPrototypeOf(PointSeries.prototype), 'constructor', this).call(this);

          if (isDomain(cov)) {
            cov = fromDomain(cov);
            delete options.keys;
          }

          if (!options.paletteExtent) {
            options.paletteExtent = 'full';
          }

          L.Util.setOptions(this, options);

          this.cov = cov;
          this.param = options.keys ? cov.parameters.get(options.keys[0]) : null;
          this._axesSubset = {
            t: { coordPref: options.time }
          };
          this.defaultColor = options.color ? options.color : DEFAULT_COLOR;
          this.showNoData = options.showNoData; // if true, draw with default color
        }

        babelHelpers.createClass(PointSeries, [{
          key: 'onAdd',
          value: function onAdd(map) {
            var _this = this;

            this._map = map;

            this.load().then(function () {
              return _this.initializePalette();
            }).then(function () {
              _this._addMarker();
              _this.fire('add');
            });
          }
        }, {
          key: '_loadCoverageSubset',
          value: function _loadCoverageSubset() {
            // adapted from Grid.js
            var t = this._axesSubset.t;
            if (t.coordPref == undefined) {
              t.idx = t.coord = undefined;
            } else {
              var vals = this.domain.axes.get('t').values.map(function (v) {
                return v.getTime();
              });
              t.idx = arrays.indexOfNearest(vals, t.coordPref.getTime());
              t.coord = vals[t.idx];
            }

            // Note that we don't subset the coverage currently, since there is no real need for it
          }
        }, {
          key: 'onRemove',
          value: function onRemove() {
            this.fire('remove');
            this._removeMarker();
          }
        }, {
          key: 'getBounds',
          value: function getBounds() {
            return L.latLngBounds([this.getLatLng()]);
          }
        }, {
          key: 'getLatLng',
          value: function getLatLng() {
            // TODO convert coordinates to lat/lon if necessary
            var x = this.domain.axes.get('x').values[0];
            var y = this.domain.axes.get('y').values[0];
            return L.latLng(y, x);
          }
        }, {
          key: 'canUsePalette',
          value: function canUsePalette() {
            return this.time !== undefined;
          }
        }, {
          key: 'computePaletteExtent',
          value: function computePaletteExtent(extent) {
            if (extent === 'full') {
              if (!this.parameter) {
                throw new Error('palette extent cannot be set when no parameter has been chosen');
              }

              extent = rangeutil.minMax(this.range);
              extent = enlargeExtentIfEqual(extent);
              return Promise.resolve(extent);
            } else {
              throw new Error('Unknown extent specification: ' + extent);
            }
          }

          /**
           * Return the displayed value (number, or null for no-data),
           * or undefined if not fixed to a t-coordinate or parameter.
           */
        }, {
          key: 'getValue',
          value: function getValue() {
            if (this.param && this._axesSubset.t.coord !== undefined) {
              var val = this.range.get({ t: this._axesSubset.t.idx });
              return val;
            }
          }
        }, {
          key: 'getValueAt',
          value: function getValueAt(latlng, maxDistance) {
            var point = this.getLatLng();
            if (point.distanceTo(latlng) <= maxDistance) {
              return this.getValue();
            }
          }
        }, {
          key: '_getColor',
          value: function _getColor() {
            var val = this.getValue();
            if (val === null) {
              // no-data
              return this.defaultColor;
            } else if (val === undefined) {
              // not fixed to a param or z-coordinate
              return this.defaultColor;
            } else {
              // use a palette
              var idx = this.getPaletteIndex(val);
              var _palette = this.palette;
              var red = _palette.red;
              var green = _palette.green;
              var blue = _palette.blue;

              return { r: red[idx], g: green[idx], b: blue[idx] };
            }
          }
        }, {
          key: 'coverage',
          get: function get() {
            return this.cov;
          }
        }, {
          key: 'parameter',
          get: function get() {
            return this.param;
          }

          /**
           * Sets the currently active time to the one closest to the given Date object.
           * Throws an exception if there is no time axis.
           */
        }, {
          key: 'time',
          set: function set(val) {
            var _this2 = this;

            var old = this.time;
            this._axesSubset.t.coordPref = val.toISOString();

            this._loadCoverageSubset().then(function () {
              if (old === _this2.time) return;
              _this2.redraw();
              _this2.fire('axisChange', { axis: 'time' });
            });
          },

          /**
           * The currently active time on the temporal axis as Date object, 
           * or undefined if the grid has no time axis.
           */
          get: function get() {
            if (!this._axesSubset.t.coord) {
              return;
            }
            var time = this.domain.axes.get('t').values[this._axesSubset.t.idx];
            return new Date(time);
          }
        }, {
          key: 'timeSlices',
          get: function get() {
            return this.domain.axes.get('t').values.map(function (t) {
              return new Date(t);
            });
          }
        }]);
        return PointSeries;
      })(PaletteMixin(CircleMarkerMixin(CoverageMixin(EventMixin(L.Class)))));

      _export('default', PointSeries);
    }
  };
});

$__System.register('45', ['5'], function (_export) {
  /* */

  /**
   * Wraps Leaflet's L.Mixin.Events for use within class expressions.
   * 
   * @see http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/
   * 
   * @param {class} base The base class.
   * @return {class} The base class with EventMixin.
   */
  'use strict';

  var L;

  _export('default', EventMixin);

  function EventMixin(base) {
    return (function (_base) {
      babelHelpers.inherits(_class, _base);

      function _class() {
        babelHelpers.classCallCheck(this, _class);
        babelHelpers.get(Object.getPrototypeOf(_class.prototype), 'constructor', this).apply(this, arguments);
      }

      babelHelpers.createClass(_class, [{
        key: 'on',
        value: function on() {
          var _L$Mixin$Events$on;

          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return (_L$Mixin$Events$on = L.Mixin.Events.on).call.apply(_L$Mixin$Events$on, [this].concat(args));
        }
      }, {
        key: 'off',
        value: function off() {
          var _L$Mixin$Events$off;

          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return (_L$Mixin$Events$off = L.Mixin.Events.off).call.apply(_L$Mixin$Events$off, [this].concat(args));
        }
      }, {
        key: 'once',
        value: function once() {
          var _L$Mixin$Events$once;

          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          return (_L$Mixin$Events$once = L.Mixin.Events.once).call.apply(_L$Mixin$Events$once, [this].concat(args));
        }
      }, {
        key: 'fire',
        value: function fire() {
          var _L$Mixin$Events$fire;

          for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }

          return (_L$Mixin$Events$fire = L.Mixin.Events.fire).call.apply(_L$Mixin$Events$fire, [this].concat(args));
        }
      }, {
        key: 'hasEventListeners',
        value: function hasEventListeners() {
          var _L$Mixin$Events$hasEventListeners;

          for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
          }

          return (_L$Mixin$Events$hasEventListeners = L.Mixin.Events.hasEventListeners).call.apply(_L$Mixin$Events$hasEventListeners, [this].concat(args));
        }

        // aliases
      }, {
        key: 'addEventListener',
        value: function addEventListener() {
          var _L$Mixin$Events$addEventListener;

          for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args[_key6] = arguments[_key6];
          }

          return (_L$Mixin$Events$addEventListener = L.Mixin.Events.addEventListener).call.apply(_L$Mixin$Events$addEventListener, [this].concat(args));
        }
      }, {
        key: 'removeEventListener',
        value: function removeEventListener() {
          var _L$Mixin$Events$removeEventListener;

          for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
            args[_key7] = arguments[_key7];
          }

          return (_L$Mixin$Events$removeEventListener = L.Mixin.Events.removeEventListener).call.apply(_L$Mixin$Events$removeEventListener, [this].concat(args));
        }
      }, {
        key: 'addOneTimeEventListener',
        value: function addOneTimeEventListener() {
          var _L$Mixin$Events$addOneTimeEventListener;

          for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
            args[_key8] = arguments[_key8];
          }

          return (_L$Mixin$Events$addOneTimeEventListener = L.Mixin.Events.addOneTimeEventListener).call.apply(_L$Mixin$Events$addOneTimeEventListener, [this].concat(args));
        }
      }, {
        key: 'fireEvent',
        value: function fireEvent() {
          var _L$Mixin$Events$fireEvent;

          for (var _len9 = arguments.length, args = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
            args[_key9] = arguments[_key9];
          }

          return (_L$Mixin$Events$fireEvent = L.Mixin.Events.fireEvent).call.apply(_L$Mixin$Events$fireEvent, [this].concat(args));
        }
      }]);
      return _class;
    })(base);
  }

  return {
    setters: [function (_) {
      L = _['default'];
    }],
    execute: function () {}
  };
});

$__System.register('6e', ['5'], function (_export) {
  /* */

  /**
   * A mixin that encapsulates the creation, update, and removal
   * of a CircleMarker.
   * 
   * See Point and VerticalProfile for usage.
   * 
   * @param {class} base The base class.
   * @return {class} The base class with CircleMarkerMixin.
   */
  'use strict';

  var L;

  _export('default', CircleMarkerMixin);

  function CircleMarkerMixin(base) {
    return (function (_base) {
      babelHelpers.inherits(_class, _base);

      function _class() {
        babelHelpers.classCallCheck(this, _class);
        babelHelpers.get(Object.getPrototypeOf(_class.prototype), 'constructor', this).apply(this, arguments);
      }

      babelHelpers.createClass(_class, [{
        key: '_addMarker',

        /*
         * The base class must supply the following functions/properties:
         * 
         * getValue()
         * _getColor(val)
         * getLatLng()
         * coverage
         * showNoData (default: false)
         */

        value: function _addMarker() {
          var _this = this;

          // TODO do coordinate transformation to lat/lon if necessary

          var val = this.getValue();
          if (val === null && !this.showNoData) {
            return;
          }

          var _getColor = this._getColor(val);

          var r = _getColor.r;
          var g = _getColor.g;
          var b = _getColor.b;

          var latlng = this.getLatLng();

          var strokeBrightness = 0.7;

          this._marker = L.circleMarker(latlng, {
            fillColor: 'rgb(' + r + ',' + g + ',' + b + ')',
            fillOpacity: 1,
            radius: 5,
            stroke: true,
            opacity: 1,
            weight: 1,
            color: 'rgb(' + Math.round(r * strokeBrightness) + ',' + Math.round(g * strokeBrightness) + ',' + Math.round(b * strokeBrightness) + ')'
          }).on('click', function (e) {
            e.coverage = _this.coverage;
            _this.fire('click', e);
          }).addTo(this._map);

          if (this._popup) {
            var _marker;

            (_marker = this._marker).bindPopup.apply(_marker, babelHelpers.toConsumableArray(this._popup));
          }
        }
      }, {
        key: '_removeMarker',
        value: function _removeMarker() {
          if (this._marker) {
            this._map.removeLayer(this._marker);
            delete this._marker;
          }
        }
      }, {
        key: '__updateMarker',
        value: function __updateMarker() {
          this._marker.options.color = this._getColor();
        }
      }, {
        key: 'bindPopup',
        value: function bindPopup() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          this._popup = args;
          if (this._marker) {
            var _marker2;

            (_marker2 = this._marker).bindPopup.apply(_marker2, args);
          }
        }
      }, {
        key: 'openPopup',
        value: function openPopup() {
          this._marker.openPopup();
          return this;
        }
      }, {
        key: 'closePopup',
        value: function closePopup() {
          this._marker.closePopup();
          return this;
        }
      }, {
        key: 'redraw',
        value: function redraw() {
          if (this._marker) {
            this.__updateMarker();
            this._marker.redraw();
          }
        }
      }]);
      return _class;
    })(base);
  }

  return {
    setters: [function (_) {
      L = _['default'];
    }],
    execute: function () {}
  };
});

$__System.register('50', ['5', '35', '37', '45', '4d', '4e', '6e', '4f'], function (_export) {
  /* */

  /** @ignore */
  'use strict';

  var L, isDomain, fromDomain, EventMixin, enlargeExtentIfEqual, CoverageMixin, CircleMarkerMixin, PaletteMixin, DEFAULT_COLOR, Point;
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_3) {
      isDomain = _3.isDomain;
    }, function (_4) {
      fromDomain = _4.fromDomain;
    }, function (_2) {
      EventMixin = _2['default'];
    }, function (_d) {
      enlargeExtentIfEqual = _d.enlargeExtentIfEqual;
    }, function (_e) {
      CoverageMixin = _e['default'];
    }, function (_e2) {
      CircleMarkerMixin = _e2['default'];
    }, function (_f) {
      PaletteMixin = _f['default'];
    }],
    execute: function () {
      DEFAULT_COLOR = 'black';

      _export('DEFAULT_COLOR', DEFAULT_COLOR);

      /**
       * Renderer for Coverages and Domains with (domain) profile Point.
       * 
       * This will simply display a dot on the map and fire a click
       * event when a user clicks on it.
       * The dot either has a defined standard color, or it uses
       * a palette if a parameter is chosen.
       */

      Point = (function (_PaletteMixin) {
        babelHelpers.inherits(Point, _PaletteMixin);

        function Point(cov, options) {
          babelHelpers.classCallCheck(this, Point);

          babelHelpers.get(Object.getPrototypeOf(Point.prototype), 'constructor', this).call(this);

          if (isDomain(cov)) {
            cov = fromDomain(cov);
            delete options.keys;
          }

          if (!options.paletteExtent) {
            options.paletteExtent = 'full';
          }

          L.Util.setOptions(this, options);

          this.cov = cov;
          this.param = options.keys ? cov.parameters.get(options.keys[0]) : null;
          this.defaultColor = options.color || DEFAULT_COLOR;
          this.showNoData = options.showNoData; // if true, draw with default color
        }

        babelHelpers.createClass(Point, [{
          key: 'onAdd',
          value: function onAdd(map) {
            var _this = this;

            this._map = map;

            this.load().then(function () {
              return _this.initializePalette();
            }).then(function () {
              _this._addMarker();
              _this.fire('add');
            });
          }
        }, {
          key: 'onRemove',
          value: function onRemove() {
            this.fire('remove');
            this._removeMarker();
          }
        }, {
          key: 'getBounds',
          value: function getBounds() {
            return L.latLngBounds([this.getLatLng()]);
          }
        }, {
          key: 'getLatLng',
          value: function getLatLng() {
            // TODO convert coordinates to lat/lon if necessary
            var x = this.domain.axes.get('x').values[0];
            var y = this.domain.axes.get('y').values[0];
            return L.latLng(y, x);
          }
        }, {
          key: 'computePaletteExtent',
          value: function computePaletteExtent(extent) {
            if (extent === 'full') {
              if (!this.parameter) {
                throw new Error('palette extent cannot be computed when no parameter has been chosen');
              }

              var val = this.getValue();
              extent = enlargeExtentIfEqual([val, val]);
              return Promise.resolve(extent);
            } else {
              throw new Error('Unknown extent specification: ' + extent);
            }
          }

          /**
           * Return the displayed value (number, or null for no-data),
           * or undefined if not fixed to a z-coordinate or parameter.
           */
        }, {
          key: 'getValue',
          value: function getValue() {
            if (this.param) {
              return this.range.get({});
            }
          }
        }, {
          key: 'getValueAt',
          value: function getValueAt(latlng, maxDistance) {
            var point = this.getLatLng();
            if (point.distanceTo(latlng) <= maxDistance) {
              return this.getValue();
            }
          }
        }, {
          key: '_getColor',
          value: function _getColor(val) {
            if (val === null) {
              // no-data
              return this.defaultColor;
            } else if (val === undefined) {
              // not fixed to a param
              return this.defaultColor;
            } else {
              // use a palette
              var idx = this.getPaletteIndex(val);
              var _palette = this.palette;
              var red = _palette.red;
              var green = _palette.green;
              var blue = _palette.blue;

              return { r: red[idx], g: green[idx], b: blue[idx] };
            }
          }
        }, {
          key: 'coverage',
          get: function get() {
            return this.cov;
          }
        }, {
          key: 'parameter',
          get: function get() {
            return this.param;
          }
        }]);
        return Point;
      })(PaletteMixin(CircleMarkerMixin(CoverageMixin(EventMixin(L.Class)))));

      _export('default', Point);
    }
  };
});

$__System.register('71', ['5', '25', '35', '37', '50', '4d', '4e', '4f'], function (_export) {
  /* */

  /**
   * Renderer for Coverages and Domains with (domain) profile Trajectory.
   * 
   * Displays the trajectory as a path with coloured points using
   * a given palette for a given parameter.
   * 
   * Events:
   * "add" - Layer is initialized and is about to be added to the map
   * "remove" - Layer is removed from the map
   * "dataLoading" - Data loading has started
   * "dataLoad" - Data loading has finished (also in case of errors)
   * "error" - Error when loading data
   * "paletteChange" - Palette has changed
   * "paletteExtentChange" - Palette extent has changed
   * 
   */
  'use strict';

  var L, rangeutil, isDomain, fromDomain, DEFAULT_COLOR, enlargeExtentIfEqual, CoverageMixin, PaletteMixin, Trajectory;
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_2) {
      rangeutil = _2;
    }, function (_3) {
      isDomain = _3.isDomain;
    }, function (_4) {
      fromDomain = _4.fromDomain;
    }, function (_5) {
      DEFAULT_COLOR = _5.DEFAULT_COLOR;
    }, function (_d) {
      enlargeExtentIfEqual = _d.enlargeExtentIfEqual;
    }, function (_e) {
      CoverageMixin = _e['default'];
    }, function (_f) {
      PaletteMixin = _f['default'];
    }],
    execute: function () {
      Trajectory = (function (_PaletteMixin) {
        babelHelpers.inherits(Trajectory, _PaletteMixin);

        // TODO FeatureGroup is not ideal since click events etc should not be blindly propagated
        //    (we use it for now to have getBounds() which LayerGroup misses)

        function Trajectory(cov, options) {
          babelHelpers.classCallCheck(this, Trajectory);

          babelHelpers.get(Object.getPrototypeOf(Trajectory.prototype), 'constructor', this).call(this);

          if (isDomain(cov)) {
            cov = fromDomain(cov);
            options.keys = [cov.parameters.keys().next.value];
          }

          if (!options.paletteExtent) {
            options.paletteExtent = 'full';
          }

          L.Util.setOptions(this, options);

          this.cov = cov;
          this.param = options.keys ? cov.parameters.get(options.keys[0]) : null;
          this.defaultColor = options.color || DEFAULT_COLOR;
        }

        babelHelpers.createClass(Trajectory, [{
          key: 'onAdd',
          value: function onAdd(map) {
            var _this = this;

            this._map = map;

            this.load().then(function () {
              return _this.initializePalette();
            }).then(function () {
              _this._addTrajectoryLayers();
              _this.fire('add');
            });
          }
        }, {
          key: 'onRemove',
          value: function onRemove(map) {
            this.fire('remove');
            babelHelpers.get(Object.getPrototypeOf(Trajectory.prototype), 'onRemove', this).call(this, map);
          }
        }, {
          key: 'computePaletteExtent',
          value: function computePaletteExtent(extent) {
            var range = this.range;

            if (extent === 'full') {
              // scan the whole range for min/max values

            } else if (extent === 'fov') {
                // scan the values that are currently in field of view on the map for min/max
                var bounds = this._map.getBounds();

                // TODO implement
                throw new Error('NOT IMPLEMENTED YET');
              } else {
                throw new Error('Unknown extent specification: ' + extent);
              }

            extent = rangeutil.minMax(range);
            extent = enlargeExtentIfEqual(extent);
            return Promise.resolve(extent);
          }
        }, {
          key: '_addTrajectoryLayers',
          value: function _addTrajectoryLayers() {
            // add a Polyline in black, and coloured CircleMarker's for each domain point
            var points = this.getLatLngs();
            for (var i = 0; i < points.length; i++) {
              var marker = new L.CircleMarker(points[i], {
                color: this._getColor(this._getValue(i)),
                opacity: 1,
                fillOpacity: 1
              });
              this.addLayer(marker);
            }

            var polyline = L.polyline(points, {
              color: 'black',
              weight: 3
            });

            this.addLayer(polyline);
          }

          /**
           * Returns the trajectory points as LatLng objects in the order they appear in the composite domain axis.
           */
        }, {
          key: 'getLatLngs',
          value: function getLatLngs() {
            var composite = this.domain.axes.get('composite').values;
            var coords = [];
            for (var i = 0; i < composite.length; i++) {
              // this always has to be lat/lon, no matter which map projection is used
              var x = composite[i][1];
              var y = composite[i][2];
              var coord = new L.LatLng(y, x);
              coords.push(coord);
            }
            return coords;
          }

          /**
           * Return the displayed value closest to the circle centre.
           * If no point exists within the circle, undefined is returned,
           * otherwise a number or null (for no-data).
           */
        }, {
          key: 'getValueAt',
          value: function getValueAt(latlng, maxDistance) {
            var points = this.getLatLngs();
            var distances = points.map(function (p) {
              return p.distanceTo(latlng);
            });
            var minDistance = Infinity;
            var minIdx = undefined;
            for (var i = 0; i < points.length; i++) {
              var distance = distances[i];
              if (distance <= maxDistance && distance < minDistance) {
                minDistance = distance;
                minIdx = i;
              }
            }
            if (minIdx !== undefined) {
              return this._getValue(minIdx);
            }
          }
        }, {
          key: '_getValue',
          value: function _getValue(index) {
            if (this.param) {
              return this.range.get({ composite: index });
            }
          }

          // NOTE: this returns a string, not an {r,g,b} object as in other classes!
        }, {
          key: '_getColor',
          value: function _getColor(val) {
            if (val === null) {
              // no-data
              return this.defaultColor;
            } else if (val === undefined) {
              // not fixed to a param
              return this.defaultColor;
            } else {
              // use a palette
              var idx = this.getPaletteIndex(val);
              var _palette = this.palette;
              var red = _palette.red;
              var green = _palette.green;
              var blue = _palette.blue;

              return 'rgb(' + red[idx] + ', ' + green[idx] + ', ' + blue[idx] + ')';
            }
          }
        }, {
          key: 'redraw',
          value: function redraw() {
            this.clearLayers();
            this._addTrajectoryLayers();
          }
        }, {
          key: 'coverage',
          get: function get() {
            return this.cov;
          }
        }, {
          key: 'parameter',
          get: function get() {
            return this.param;
          }
        }]);
        return Trajectory;
      })(PaletteMixin(CoverageMixin(L.FeatureGroup)));

      _export('default', Trajectory);
    }
  };
});

$__System.registerDynamic("37", ["28", "35", "2b"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, "__esModule", {value: true});
  var _slicedToArray = function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  exports.fromDomain = fromDomain;
  exports.fromXndarray = fromXndarray;
  exports.addSubsetFunctions = addSubsetFunctions;
  exports.addLoadRangesFunction = addLoadRangesFunction;
  var _constants = req('28');
  var _validate = req('35');
  var _subset = req('2b');
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0,
          arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  function fromDomain(domain) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    (0, _validate.checkDomain)(domain);
    var _options$gridAxes = options.gridAxes;
    _options$gridAxes = _options$gridAxes === undefined ? ['x', 'y'] : _options$gridAxes;
    var _options$gridAxes2 = _slicedToArray(_options$gridAxes, 2);
    var x = _options$gridAxes2[0];
    var y = _options$gridAxes2[1];
    var dummyKey = 'domain';
    var dummyLabel = 'Domain';
    var assumeGrid = domain.axes.has(x) && domain.axes.has(y) && (domain.axes.get(x).values.length > 1 || domain.axes.get(y).values.length > 1);
    var categories = void 0;
    var categoryEncoding = void 0;
    var a = 'a';
    var av = 0;
    var b = 'b';
    var bv = 1;
    if (assumeGrid) {
      categories = [{
        id: a,
        label: {en: 'A'}
      }, {
        id: b,
        label: {en: 'B'}
      }];
      categoryEncoding = new Map([[a, [av]], [b, [bv]]]);
    } else {
      categories = [{
        id: a,
        label: {en: 'X'}
      }];
      categoryEncoding = new Map([[a, [av]]]);
    }
    var parameters = new Map();
    parameters.set(dummyKey, {
      key: dummyKey,
      observedProperty: {
        label: {en: dummyLabel},
        categories: categories
      },
      categoryEncoding: categoryEncoding
    });
    var shape = new Map([].concat(_toConsumableArray(domain.axes)).map(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2);
      var name = _ref2[0];
      var axis = _ref2[1];
      return [name, axis.values.length];
    }));
    var get = void 0;
    if (assumeGrid) {
      (function() {
        var isOdd = function isOdd(n) {
          return n % 2;
        };
        get = function get(_ref3) {
          var _ref3$x = _ref3.x;
          var x = _ref3$x === undefined ? 0 : _ref3$x;
          var _ref3$y = _ref3.y;
          var y = _ref3$y === undefined ? 0 : _ref3$y;
          return isOdd(x + y) ? av : bv;
        };
      })();
    } else {
      get = function get() {
        return av;
      };
    }
    var loadRange = function loadRange() {
      return Promise.resolve({
        shape: shape,
        dataType: 'integer',
        get: get
      });
    };
    var cov = {
      type: _constants.COVERAGE,
      domainType: domain.domainType,
      parameters: parameters,
      loadDomain: function loadDomain() {
        return Promise.resolve(domain);
      },
      loadRange: loadRange
    };
    addLoadRangesFunction(cov);
    addSubsetFunctions(cov);
    return cov;
  }
  function fromXndarray(xndarr) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var _options$parameter = options.parameter;
    var parameter = _options$parameter === undefined ? {
      key: 'p1',
      observedProperty: {label: {en: 'Parameter 1'}}
    } : _options$parameter;
    var referencing = options.referencing;
    var domainType = options.domainType;
    var parameters = new Map();
    parameters.set(parameter.key, parameter);
    if (!referencing) {
      referencing = [];
      if (xndarr.coords.has('x') && xndarr.coords.has('y')) {
        referencing.push({
          components: ['x', 'y'],
          system: {
            type: 'GeodeticCRS',
            id: 'http://www.opengis.net/def/crs/OGC/1.3/CRS84'
          }
        });
      }
      if (xndarr.coords.has('t')) {
        referencing.push({
          components: ['t'],
          system: {
            type: 'TemporalRS',
            calendar: 'Gregorian'
          }
        });
      }
    }
    var axes = new Map();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;
    try {
      for (var _iterator = xndarr.coords[Symbol.iterator](),
          _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = _slicedToArray(_step.value, 2);
        var axisName = _step$value[0];
        var vals1Dnd = _step$value[1];
        var values = new Array(vals1Dnd.size);
        for (var i = 0; i < vals1Dnd.size; i++) {
          values[i] = vals1Dnd.get(i);
        }
        axes.set(axisName, {
          key: axisName,
          components: [axisName],
          values: values
        });
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    var domain = {
      type: _constants.DOMAIN,
      domainType: domainType,
      referencing: referencing,
      axes: axes
    };
    var shape = new Map([].concat(_toConsumableArray(domain.axes)).map(function(_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2);
      var name = _ref5[0];
      var axis = _ref5[1];
      return [name, axis.values.length];
    }));
    var dataType = xndarr.dtype.indexOf('int') !== -1 ? 'integer' : 'float';
    var loadRange = function loadRange() {
      return Promise.resolve({
        shape: shape,
        dataType: dataType,
        get: xndarr.xget.bind(xndarr)
      });
    };
    var cov = {
      type: _constants.COVERAGE,
      domainType: domainType,
      parameters: parameters,
      loadDomain: function loadDomain() {
        return Promise.resolve(domain);
      },
      loadRange: loadRange
    };
    addLoadRangesFunction(cov);
    addSubsetFunctions(cov);
    return cov;
  }
  function addSubsetFunctions(cov) {
    (0, _validate.checkCoverage)(cov);
    cov.subsetByIndex = _subset.subsetByIndex.bind(null, cov);
    cov.subsetByValue = _subset.subsetByValue.bind(null, cov);
  }
  function addLoadRangesFunction(cov) {
    (0, _validate.checkCoverage)(cov);
    function loadRanges(keys) {
      if (!keys) {
        keys = cov.parameters.keys();
      }
      return Promise.all([].concat(_toConsumableArray(keys)).map(cov.loadRange)).then(function(ranges) {
        return new Map(keys.map(function(key, i) {
          return [key, ranges[i]];
        }));
      });
    }
    cov.loadRanges = loadRanges;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("35", ["28"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.isCoverage = isCoverage;
  exports.checkCoverage = checkCoverage;
  exports.isDomain = isDomain;
  exports.checkDomain = checkDomain;
  var _constants = req('28');
  function isCoverage(obj) {
    return obj.type === _constants.COVERAGE;
  }
  function checkCoverage(obj) {
    if (!isCoverage(obj)) {
      throw new Error('must be a Coverage');
    }
  }
  function isDomain(obj) {
    return obj.type === _constants.DOMAIN;
  }
  function checkDomain(obj) {
    if (!isDomain(obj)) {
      throw new Error('must be a Domain');
    }
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("72", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  'use strict';
  Object.defineProperty(exports, "__esModule", {value: true});
  var _slicedToArray = function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  exports.minMax = minMax;
  exports.reduce = reduce;
  exports.iterate = iterate;
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0,
          arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  function minMax(range) {
    var min = Infinity;
    var max = -Infinity;
    var fn = function fn(val) {
      if (val === null)
        return;
      if (val < min)
        min = val;
      if (val > max)
        max = val;
    };
    iterate(range, fn);
    return min === Infinity ? [undefined, undefined] : [min, max];
  }
  function reduce(range, callback, start) {
    var v1 = start;
    var iterFn = function iterFn(v2) {
      v1 = callback(v1, v2);
    };
    iterate(range, iterFn);
    return v1;
  }
  function iterate(range, fn) {
    var shape = [].concat(_toConsumableArray(range.shape));
    shape.sort(function(_ref, _ref2) {
      var _ref4 = _slicedToArray(_ref, 2);
      var size1 = _ref4[1];
      var _ref3 = _slicedToArray(_ref2, 2);
      var size2 = _ref3[1];
      return size1 - size2;
    });
    var begin = 'var obj = {}';
    var end = '';
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;
    try {
      for (var _iterator = shape[Symbol.iterator](),
          _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = _slicedToArray(_step.value, 2);
        var axis = _step$value[0];
        var size = _step$value[1];
        begin += '\n      for (var i' + axis + '=0; i' + axis + ' < ' + size + '; ++i' + axis + ') {\n        obj[\'' + axis + '\'] = i' + axis + '\n    ';
        end += '}';
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    begin += '\n    fn(get(obj))\n  ';
    var iterateLoop = new Function('return function iterateRange (get, fn) { ' + begin + ' ' + end + ' }')();
    iterateLoop(range.get, fn);
  }
  global.define = __define;
  return module.exports;
});

$__System.register('25', ['72'], function (_export) {
  /* */
  'use strict';

  return {
    setters: [function (_) {
      var _exportObj = {};
      _exportObj['minMax'] = _.minMax;
      _exportObj['reduce'] = _.reduce;
      _exportObj['iterate'] = _.iterate;

      _export(_exportObj);
    }],
    execute: function () {}
  };
});

$__System.register('1b', ['73'], function (_export) {
  /* */
  'use strict';

  return {
    setters: [function (_) {
      var _exportObj = {};
      _exportObj['indicesOfNearest'] = _.indicesOfNearest;
      _exportObj['indexOfNearest'] = _.indexOfNearest;

      _export(_exportObj);
    }],
    execute: function () {}
  };
});

$__System.register('1c', ['29'], function (_export) {
  /* */
  'use strict';

  return {
    setters: [function (_) {
      var _exportObj = {};
      _exportObj['isEllipsoidalCRS'] = _.isEllipsoidalCRS;
      _exportObj['getHorizontalCRSReferenceObject'] = _.getHorizontalCRSReferenceObject;
      _exportObj['getReferenceObject'] = _.getReferenceObject;
      _exportObj['getProjection'] = _.getProjection;
      _exportObj['reproject'] = _.reproject;

      _export(_exportObj);
    }],
    execute: function () {}
  };
});

$__System.register('4e', ['1c'], function (_export) {
  /* */

  /**
   * A mixin that encapsulates loading of a single coverage for use in layers.
   * 
   * The base class must supply the following functions/properties:
   * 
   * .coverage
   * .parameter (optional)
   * ._loadCoverageSubset() (optional)
   * 
   * The following functions/properties are supplied:
   * 
   * .domain (after calling load())
   * .range (after calling load(); only if .parameter is set and ._loadCoverageSubset is undefined)
   * 
   * @param {class} base The base class.
   * @return {class} The base class with CoverageMixin.
   */
  'use strict';

  var isEllipsoidalCRS;

  _export('default', CoverageMixin);

  function CoverageMixin(base) {
    return (function (_base) {
      babelHelpers.inherits(_class, _base);

      function _class() {
        babelHelpers.classCallCheck(this, _class);
        babelHelpers.get(Object.getPrototypeOf(_class.prototype), 'constructor', this).apply(this, arguments);
      }

      babelHelpers.createClass(_class, [{
        key: 'load',

        /**
         * Load all data without adding anything to the map.
         * After loading is done, all functions and properties can be accessed (like getLatLng()).
         */
        value: function load() {
          var _this = this;

          this.fire('dataLoading'); // for supporting loading spinners

          function checkWGS84(domain) {
            if (!domain.referencing.some(function (ref) {
              return isEllipsoidalCRS(ref.system);
            })) {
              throw new Error('Unsupported CRS, must be WGS84');
            }
          }

          var promise = this.coverage.loadDomain().then(function (domain) {
            checkWGS84(domain);
            _this.domain = domain;
          });
          if (this._loadCoverageSubset) {
            promise = promise.then(function () {
              return _this._loadCoverageSubset();
            });
          } else if (this.parameter) {
            promise = promise.then(function () {
              return _this.coverage.loadRange(_this.parameter.key);
            }).then(function (range) {
              _this.range = range;
            });
          }

          promise = promise.then(function () {
            _this.fire('dataLoad');
          })['catch'](function (e) {
            console.error(e);
            _this.fire('error', e);
            _this.fire('dataLoad');
          });
          return promise;
        }
      }]);
      return _class;
    })(base);
  }

  return {
    setters: [function (_c) {
      isEllipsoidalCRS = _c.isEllipsoidalCRS;
    }],
    execute: function () {}
  };
});

$__System.register('4f', ['4d'], function (_export) {
  /* */
  'use strict';

  var linearPalette, directPalette, createPalette, scale, DEFAULT_CONTINUOUS_PALETTE, DEFAULT_CATEGORICAL_PALETTE;

  _export('default', PaletteMixin);

  /**
   * A mixin that encapsulates the palette logic of a coverage layer,
   * supporting categorical and continuous coverage parameters.
   * 
   * The base class must supply the following functions/properties:
   * 
   * options.palette (optional)
   * options.paletteExtent (optional) - initial value that computePaletteExtent is called with
   * parameter
   * redraw()
   * computePaletteExtent(extent) - returns a Promise with the computed extent; gets called when .paletteExtent is set to a string value
   * canUsePalette() (optional) - if this method exists and returns false, then .palette returns undefined
   * 
   * The following functions/properties are supplied:
   * 
   * initializePalette() - to be called once data has been loaded so that computePaletteExtent can be called
   * get/set palette
   * get/set paletteExtent
   * setPaletteExtent(extent) - like set paletteExtent, but returns a Promise to know when calculations etc. are done
   * getPaletteIndex(val) - returns the color index for the given value
   * 
   * @param {class} base The base class.
   * @return {class} The base class with PaletteMixin.
   */

  function PaletteMixin(base) {
    return (function (_base) {
      babelHelpers.inherits(_class, _base);

      function _class() {
        babelHelpers.classCallCheck(this, _class);
        babelHelpers.get(Object.getPrototypeOf(_class.prototype), 'constructor', this).apply(this, arguments);
      }

      babelHelpers.createClass(_class, [{
        key: 'initializePalette',
        value: function initializePalette() {
          var _this = this;

          var options = this.options;
          var parameter = this.parameter;
          if (!parameter) {
            return Promise.resolve();
          }
          var categories = parameter.observedProperty.categories;

          if (categories) {
            this._initCategoryIdxMap();
          }

          if (this._palette) {
            // do nothing, already set
          } else if (options.palette) {
              this._palette = options.palette;
            } else if (parameter.preferredPalette) {
              this._palette = createPalette(parameter.preferredPalette);
            } else if (categories) {
              if (categories.every(function (cat) {
                return cat.preferredColor;
              })) {
                this._palette = directPalette(categories.map(function (cat) {
                  return cat.preferredColor;
                }));
              } else {
                this._palette = DEFAULT_CATEGORICAL_PALETTE(categories.length);
              }
            } else {
              this._palette = DEFAULT_CONTINUOUS_PALETTE();
            }

          if (categories && categories.length !== this._palette.steps) {
            throw new Error('Categorical palettes must match the number of categories of the parameter');
          }

          this._paletteExtent = this._paletteExtent || options.paletteExtent;

          if (this.parameter.categoryEncoding) {
            (function () {
              // categorical parameter, does not depend on palette extent
              var valIdxMap = _this._categoryIdxMap;
              var max = valIdxMap.length - 1;
              _this.getPaletteIndex = function (val) {
                if (val === null || val < 0 || val > max) return;
                var idx = valIdxMap[val];
                if (idx === 255) return;
                return idx;
              };
            })();
          }

          if (!this.canUsePalette || this.canUsePalette()) {
            return this.setPaletteExtent(this._paletteExtent, true).then(function () {
              return _this._updatePaletteIndexFn();
            });
          } else {
            return Promise.resolve();
          }
        }
      }, {
        key: '_updatePaletteIndexFn',
        value: function _updatePaletteIndexFn() {
          var _this2 = this;

          if (!this.parameter.categoryEncoding) {
            (function () {
              // continuous parameter
              var palette = _this2.palette;
              var extent = _this2.paletteExtent;
              _this2.getPaletteIndex = function (val) {
                if (val === null) return;
                var idx = scale(val, palette, extent);
                return idx;
              };
            })();
          }
        }
      }, {
        key: 'setPaletteExtent',
        value: function setPaletteExtent(extent, skipRedraw) {
          var _this3 = this;

          if (this.parameter.observedProperty.categories) {
            return Promise.resolve();
          }

          var oldExtent = this.paletteExtent;
          var hasChanged = function hasChanged(newExtent) {
            if (!Array.isArray(oldExtent)) return true;
            if (oldExtent[0] !== newExtent[0] || oldExtent[1] !== newExtent[1]) return true;
            return false;
          };
          var res = Array.isArray(extent) ? Promise.resolve(extent) : this.computePaletteExtent(extent);
          return res.then(function (newExtent) {
            // ignore invalid extents (may come from using ParameterSync)
            if (Array.isArray(newExtent) && isNaN(newExtent[0])) return;
            if (!hasChanged(newExtent)) return;
            _this3._paletteExtent = newExtent;
            _this3._updatePaletteIndexFn();
            if (!skipRedraw) {
              _this3.redraw();
            }
            _this3.fire('paletteExtentChange');
          });
        }

        /**
         * Sets up a lookup table from categorical range value to palette index.
         */
      }, {
        key: '_initCategoryIdxMap',
        value: function _initCategoryIdxMap() {
          var param = this.parameter;
          if (!param.categoryEncoding) return;

          // categorical parameter with integer encoding
          // Note: The palette order is equal to the categories array order.
          var max = -Infinity;
          var min = Infinity;
          var categories = param.observedProperty.categories;
          var encoding = param.categoryEncoding;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = categories[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var category = _step.value;

              if (encoding.has(category.id)) {
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                  for (var _iterator3 = encoding.get(category.id)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var val = _step3.value;

                    max = Math.max(max, val);
                    min = Math.min(min, val);
                  }
                } catch (err) {
                  _didIteratorError3 = true;
                  _iteratorError3 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                      _iterator3['return']();
                    }
                  } finally {
                    if (_didIteratorError3) {
                      throw _iteratorError3;
                    }
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator['return']) {
                _iterator['return']();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          var valIdxMap = undefined;
          if (categories.length < 256) {
            if (max > 10000 || min < 0) {
              // TODO implement fallback to Map implementation
              throw new Error('category values too high (>10000) or low (<0)');
            }
            valIdxMap = new Uint8Array(max + 1);
            for (var i = 0; i <= max; i++) {
              // the above length < 256 check ensures that no palette index is ever 255
              valIdxMap[i] = 255;
            }

            for (var idx = 0; idx < categories.length; idx++) {
              var category = categories[idx];
              if (encoding.has(category.id)) {
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                  for (var _iterator2 = param.categoryEncoding.get(category.id)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var val = _step2.value;

                    valIdxMap[val] = idx;
                  }
                } catch (err) {
                  _didIteratorError2 = true;
                  _iteratorError2 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                      _iterator2['return']();
                    }
                  } finally {
                    if (_didIteratorError2) {
                      throw _iteratorError2;
                    }
                  }
                }
              }
            }
          } else {
            throw new Error('Too many categories: ' + categories.length);
          }
          this._categoryIdxMap = valIdxMap;
        }
      }, {
        key: 'palette',
        get: function get() {
          if (this.parameter && (!this.canUsePalette || this.canUsePalette())) {
            return this._palette;
          }
        },
        set: function set(p) {
          this._palette = p;
          this._updatePaletteIndexFn();
          this.redraw();
          this.fire('paletteChange');
        }
      }, {
        key: 'paletteExtent',
        set: function set(extent) {
          this.setPaletteExtent(extent);
        },
        get: function get() {
          return this._paletteExtent;
        }
      }]);
      return _class;
    })(base);
  }

  return {
    setters: [function (_d) {
      linearPalette = _d.linearPalette;
      directPalette = _d.directPalette;
      createPalette = _d.create;
      scale = _d.scale;
    }],
    execute: function () {
      DEFAULT_CONTINUOUS_PALETTE = function DEFAULT_CONTINUOUS_PALETTE() {
        return linearPalette(['#deebf7', '#3182bd']);
      };

      // blues

      DEFAULT_CATEGORICAL_PALETTE = function DEFAULT_CATEGORICAL_PALETTE(n) {
        if (n > 12) {
          throw new Error('not enough built-in categorical colors, must supply custom colors');
        }
        return directPalette(['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'].slice(0, n));
      };
    }
  };
});

$__System.register('4d', [], function (_export) {
  /**
   * Returns a linearly interpolated palette out of CSS colors.
   * 
   * @example
   * var grayscale = linearPalette(['#FFFFFF', '#000000'])
   * var rainbow = linearPalette(['#0000FF', '#00FFFF', '#00FF00', '#FFFF00', '#FF0000'])
   * 
   * @param {Array<string>} colors An array of CSS colors.
   * @param {number} [steps=256] The number of palette colors to generate.
   * @return {object}
   *   An object with members <code>steps</code>, <code>red</code>,
   *   <code>green</code>, and <code>blue</code>.
   */
  'use strict';

  var PaletteManager;

  /**
   * Converts an array of CSS colors to a palette of the same size.
   * 
   * @example
   * var bw = directPalette(['#000000', '#FFFFFF'])
   * // bw.steps == 2
   * 
   * @param {Array<string>} colors An array of CSS colors.
   * @return {object}
   *   An object with members <code>steps</code>, <code>red</code>,
   *   <code>green</code>, and <code>blue</code>.
   */

  _export('linearPalette', linearPalette);

  /**
   * Create a palette from a description object.
   * 
   * Currently, two forms are supported:
   * 
   * {
   *   "colors": ["red", "blue", ..]
   *   "interpolation": "linear",
   *   "steps": 200
   * }
   * 
   * {
   *   "colors": ["red", "blue", ..]
   * }
   */

  _export('directPalette', directPalette);

  /**
   * Linearly scales a value to a given palette and value extent.
   * 
   * @example
   * var value = 20
   * var grayscale = linearPalette(['#FFFFFF', '#000000'], 50) // 50 steps
   * var scaled = scale(value, grayscale, [0,100])
   * // scaled == 10
   * 
   * @param {number} val The value to scale.
   * @param {object} palette The palette onto which the value is scaled.
   * @param {Array} extent The lower and upper bound within which the value is scaled,
   *   typically the value extent of a legend.
   * @return {number} The scaled value.
   */

  _export('create', create);

  /**
   * Return enlarged extent if start and end are the same value,
   * otherwise return unchanged.
   * 
   * @param {Array<number>} extent The extent [min,max] to enlarge.
   * @param {number} [amount] The ratio by which to extend on each side.
   * @return {Array<number>} The enlarged extent.
   */

  _export('scale', scale);

  /**
   * Manages palettes under common names.
   *  
   * @example
   * var palettes = new PaletteManager({defaultSteps: 10})
   * palettes.addLinear('grayscale', ['#FFFFFF', '#000000']) // 10 steps
   * palettes.addLinear('grayscalehd', ['#FFFFFF', '#000000'], {steps: 200}) // high-resolution palette
   * palettes.add('breweroranges3', ['#fee6ce', '#fdae6b', '#e6550d']) // palette of those 3 colors
   * palettes.add('mycustom', {red: [0,255], green: [0,0], blue: [10,20]}) // different syntax
   */

  _export('enlargeExtentIfEqual', enlargeExtentIfEqual);

  function linearPalette(colors) {
    var steps = arguments.length <= 1 || arguments[1] === undefined ? 256 : arguments[1];

    if (steps === 1) {
      // work-around, a gradient with 1 pixel becomes black otherwise
      return directPalette([colors[0]]);
    }
    // draw the gradient in a canvas
    var canvas = document.createElement('canvas');
    canvas.width = steps;
    canvas.height = 1;
    var ctx = canvas.getContext('2d');
    var gradient = ctx.createLinearGradient(0, 0, steps - 1, 0);
    var num = colors.length;
    for (var i = 0; i < num; i++) {
      gradient.addColorStop(i / (num - 1), colors[i]);
    }
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, steps, 1);

    // now read back values into arrays
    var red = new Uint8Array(steps);
    var green = new Uint8Array(steps);
    var blue = new Uint8Array(steps);

    var pix = ctx.getImageData(0, 0, steps, 1).data;
    for (var _i = 0, j = 0; _i < pix.length; _i += 4, j++) {
      red[j] = pix[_i];
      green[j] = pix[_i + 1];
      blue[j] = pix[_i + 2];
    }

    return {
      steps: red.length,
      red: red,
      green: green,
      blue: blue
    };
  }

  function directPalette(colors) {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    var ctx = canvas.getContext('2d');

    var steps = colors.length;

    var red = new Uint8Array(steps);
    var green = new Uint8Array(steps);
    var blue = new Uint8Array(steps);

    for (var i = 0; i < colors.length; i++) {
      ctx.fillStyle = colors[i];
      ctx.fillRect(0, 0, 1, 1);
      var pix = ctx.getImageData(0, 0, 1, 1).data;
      red[i] = pix[0];
      green[i] = pix[1];
      blue[i] = pix[2];
    }

    return {
      steps: red.length,
      red: red,
      green: green,
      blue: blue
    };
  }

  function create(paletteSpec) {
    if (!paletteSpec) {
      return;
    }
    var colors = paletteSpec.colors;
    var palette = undefined;
    if (paletteSpec.interpolation === 'linear') {
      palette = linearPalette(colors, paletteSpec.steps);
    } else {
      palette = directPalette(colors);
    }
    return palette;
  }

  function scale(val, palette, extent) {
    // scale val to [0,paletteSize-1] using the palette extent
    // (IDL bytscl formula: http://www.exelisvis.com/docs/BYTSCL.html)
    var scaled = Math.trunc((palette.steps - 1 + 0.9999) * (val - extent[0]) / (extent[1] - extent[0]));
    return scaled;
  }

  function enlargeExtentIfEqual(extent) {
    var amount = arguments.length <= 1 || arguments[1] === undefined ? 0.1 : arguments[1];

    if (extent[0] === extent[1]) {
      var buffer = extent[0] * amount;
      return [extent[0] - buffer, extent[1] + buffer];
    } else {
      return extent;
    }
  }

  function _asUint8Array(arr) {
    var ta = new Uint8Array(arr.length);
    for (var i = 0; i < arr.length; i++) {
      var val = arr[i];
      if (val < 0 || val > 255) {
        throw new Error('Array value must be within [0,255], but is: ' + val);
      }
      ta[i] = val;
    }
    return ta;
  }
  return {
    setters: [],
    execute: function () {
      PaletteManager = (function () {

        /**
         * @param {Integer} defaultSteps The default number of steps when adding palettes with addLinear().
         */

        function PaletteManager() {
          var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

          var _ref$defaultSteps = _ref.defaultSteps;
          var defaultSteps = _ref$defaultSteps === undefined ? 256 : _ref$defaultSteps;
          babelHelpers.classCallCheck(this, PaletteManager);

          this._defaultSteps = defaultSteps;
          this._palettes = new Map();
        }

        /**
         * Store a supplied generic palette under the given name.
         * 
         * @example
         * var palettes = new PaletteManager()
         * palettes.add('breweroranges3', ['#fee6ce', '#fdae6b', '#e6550d']) // palette of those 3 colors
         * palettes.add('mycustom', {red: [0,255], green: [0,0], blue: [10,20]}) // different syntax
         * 
         * @param {string} name The unique name of the palette.
         * @param {object|Array<string>} palette A palette object or an array of CSS colors.
         */
        babelHelpers.createClass(PaletteManager, [{
          key: 'add',
          value: function add(name, palette) {
            if (Array.isArray(palette)) {
              palette = directPalette(palette);
            }

            if (![palette.red, palette.green, palette.blue].every(function (arr) {
              return arr.length === palette.red.length;
            })) {
              throw new Error('The red, green, blue arrays of the palette must be of equal lengths');
            }
            if (!(palette.red instanceof Uint8Array)) {
              palette.red = _asUint8Array(palette.red);
              palette.green = _asUint8Array(palette.green);
              palette.blue = _asUint8Array(palette.blue);
            }
            palette.steps = palette.red.length; // for convenience in clients
            this._palettes.set(name, palette);
          }

          /**
           * Store a linear palette under the given name created with the given CSS color specifications.
           * 
           * @example
           * var palettes = new PaletteManager()
           * palettes.addLinear('grayscale', ['#FFFFFF', '#000000']) // 10 steps
           * palettes.addLinear('grayscalehd', ['#FFFFFF', '#000000'], {steps: 200})
           * 
           * @param {String} name The unique name of the palette
           * @param {Array<string>} colors An array of CSS color specifications
           * @param {number} steps Use a different number of steps than the default of this manager.
           */
        }, {
          key: 'addLinear',
          value: function addLinear(name, colors) {
            var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

            var steps = _ref2.steps;

            this.add(name, linearPalette(colors, steps ? steps : this._defaultSteps));
          }

          /**
           * Return the palette stored under the given name, or throw an error if not found.
           * The palette is an object with properties steps, red, green, and blue.
           * Each of the color arrays is an Uint8Array of length steps.
           */
        }, {
          key: 'get',
          value: function get(name) {
            var palette = this._palettes.get(name);
            if (palette === undefined) {
              throw new Error('Palette "' + name + '" not found');
            }
            return palette;
          }
        }, {
          key: Symbol.iterator,
          get: function get() {
            return this._palettes[Symbol.iterator];
          }
        }]);
        return PaletteManager;
      })();

      _export('PaletteManager', PaletteManager);
    }
  };
});

$__System.register('74', ['5', '25', '29', '34', '35', '37', '4d', '4f', '4e', '1b', '1c'], function (_export) {
  /* */

  /**
   * Renderer for Coverages and Domains with (domain) profile Grid.
   * For Domain objects, a dummy parameter and range data is created.
   * 
   * Events:
   * "add" - Layer is initialized and is about to be added to the map
   * "remove" - Layer is removed from the map
   * "dataLoading" - Data loading has started
   * "dataLoad" - Data loading has finished (also in case of errors)
   * "error" - Error when loading data
   * "paletteChange" - Palette has changed
   * "paletteExtentChange" - Palette extent has changed
   * "axisChange" - Axis coordinate has changed (e.axis === 'time'|'vertical')
   * "remove" - Layer is removed from the map
   * 
   */
  'use strict';

  var L, rangeutil, getReferenceObject, ndarray, isDomain, fromDomain, enlargeExtentIfEqual, PaletteMixin, CoverageMixin, arrays, referencingutil, Grid;

  function wrapLongitude(lon, range) {
    return wrapNum(lon, range, true);
  }

  //stolen from https://github.com/Leaflet/Leaflet/blob/master/src/core/Util.js
  //doesn't exist in current release (0.7.3)
  function wrapNum(x, range, includeMax) {
    var max = range[1];
    var min = range[0];
    var d = max - min;
    return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
  }
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_3) {
      rangeutil = _3;
    }, function (_6) {
      getReferenceObject = _6.getReferenceObject;
    }, function (_2) {
      ndarray = _2['default'];
    }, function (_4) {
      isDomain = _4.isDomain;
    }, function (_5) {
      fromDomain = _5.fromDomain;
    }, function (_d) {
      enlargeExtentIfEqual = _d.enlargeExtentIfEqual;
    }, function (_f) {
      PaletteMixin = _f['default'];
    }, function (_e) {
      CoverageMixin = _e['default'];
    }, function (_b) {
      arrays = _b;
    }, function (_c) {
      referencingutil = _c;
    }],
    execute: function () {
      Grid = (function (_PaletteMixin) {
        babelHelpers.inherits(Grid, _PaletteMixin);

        /**
         * The key of the parameter to display must be given in the 'keys' options property,
         * except when the coverage data object is a Domain object.
         * 
         * Optional time and vertical axis target values can be defined with the 'time' and
         * 'vertical' options properties. The closest values on the respective axes are chosen.
         * 
         * Example: 
         * <pre><code>
         * var cov = ... // get Coverage data
         * var layer = new GridCoverage(cov, {
         *   keys: ['salinity'],
         *   time: new Date('2015-01-01T12:00:00Z'),
         *   vertical: 50,
         *   palette: palettes.get('blues'),
         *   paletteExtent: 'full' // or 'subset' (time/vertical), 'fov' (map field of view), or specific: [-10,10]
         * })
         * </code></pre>
         */

        function Grid(cov, options) {
          babelHelpers.classCallCheck(this, Grid);

          babelHelpers.get(Object.getPrototypeOf(Grid.prototype), 'constructor', this).call(this);

          if (isDomain(cov)) {
            cov = fromDomain(cov);
            options.keys = [cov.parameters.keys().next.value];
          }

          if (!options.paletteExtent) {
            options.paletteExtent = 'subset';
          }

          L.Util.setOptions(this, options);

          this.cov = cov;
          this.param = cov.parameters.get(options.keys[0]);
          this._axesSubset = { // x and y are not subsetted
            t: { coordPref: options.time ? options.time.toISOString() : undefined },
            z: { coordPref: options.vertical }
          };
        }

        babelHelpers.createClass(Grid, [{
          key: 'onAdd',
          value: function onAdd(map) {
            var _this = this;

            // "loading" and "load" events are provided by the underlying TileLayer class
            this._map = map;

            this.load().then(function () {
              return _this.initializePalette();
            }).then(function () {
              // used in controls/VerticalAxis.js
              var vertRef = getReferenceObject(_this.domain, 'z');
              if (vertRef && vertRef.components.length === 1) {
                var vertRefSys = vertRef.system;
                if (vertRefSys.cs && (vertRefSys.cs.csAxes || vertRefSys.cs.axes)) {
                  _this.crsVerticalAxis = vertRefSys.cs.csAxes ? vertRefSys.cs.csAxes[0] : vertRefSys.cs.axes[0];
                }
              } else {
                // TODO handle vertical axis part of 3D CRS
              }
            }).then(function () {
              _this.errored = false;
              babelHelpers.get(Object.getPrototypeOf(Grid.prototype), 'onAdd', _this).call(_this, map);
              _this.fire('add');
            })['catch'](function (e) {
              _this.errored = true;
              console.log(e);
              babelHelpers.get(Object.getPrototypeOf(Grid.prototype), 'onAdd', _this).call(_this, map);
            });
          }
        }, {
          key: 'onRemove',
          value: function onRemove(map) {
            delete this._map;
            // TODO delete references to domain/range, caching logic should happen elsewhere
            this.fire('remove');
            babelHelpers.get(Object.getPrototypeOf(Grid.prototype), 'onRemove', this).call(this, map);
          }
        }, {
          key: 'getBounds',
          value: function getBounds() {
            var bbox = undefined;
            if (this.cov.bbox) {
              bbox = this.cov.bbox;
            } else if (this._isDomainUsingEllipsoidalCRS()) {
              bbox = this._getDomainBbox();
            } else {
              return;
            }
            var southWest = L.latLng(bbox[1], bbox[0]);
            var northEast = L.latLng(bbox[3], bbox[2]);
            var bounds = new L.LatLngBounds(southWest, northEast);
            return bounds;
          }

          /**
           * Subsets the temporal and vertical axes based on the _axesSubset.*.coordPref property,
           * which is regarded as a preference and does not have to exactly match a coordinate.
           * 
           * The return value is a promise that succeeds with an empty result and
           * sets this.subsetCov to the subsetted coverage.
           * The subsetting always fixes a single time and vertical slice, choosing the first
           * axis value if no preference was given.
           * 
           * After calling this method, _axesSubset.*.idx and _axesSubset.*.coord have
           * values from the actual axes.
           */
        }, {
          key: '_loadCoverageSubset',
          value: function _loadCoverageSubset() {
            var _this2 = this;

            var spec = {};
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = Object.keys(this._axesSubset)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var axis = _step.value;

                var ax = this._axesSubset[axis];
                if (!this.domain.axes.has(axis)) {
                  continue;
                }
                if (ax.coordPref == undefined) {
                  // == also handles null
                  spec[axis] = { target: this.domain.axes.get(axis).values[0] };
                } else {
                  spec[axis] = { target: ax.coordPref };
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            this.fire('dataLoading'); // for supporting loading spinners
            return this.cov.subsetByValue(spec).then(function (subsetCov) {
              _this2.subsetCov = subsetCov;
              //  the goal is to avoid reloading data when approximating palette extent via subsetting
              //  but: memory has to be freed when the layer is removed from the map
              //      -> therefore cacheRanges is set on subsetCov whose reference is removed on onRemove
              subsetCov.cacheRanges = true;
              return Promise.all([subsetCov.loadDomain(), subsetCov.loadRange(_this2.param.key)]);
            }).then(function (_ref) {
              var _ref2 = babelHelpers.slicedToArray(_ref, 2);

              var subsetDomain = _ref2[0];
              var subsetRange = _ref2[1];

              _this2.subsetDomain = subsetDomain;
              _this2.subsetRange = subsetRange;
              _this2.fire('dataLoad');
            })['catch'](function (e) {
              _this2.fire('dataLoad');
              throw e;
            });
          }
        }, {
          key: 'computePaletteExtent',
          value: function computePaletteExtent(extent) {
            var _this3 = this;

            if (extent === 'subset') {
              // scan the current subset for min/max values

              var xlen = this.subsetRange.shape.get('x');
              var ylen = this.subsetRange.shape.get('y');

              // check if subsetted size is manageable
              if (xlen * ylen < 1000 * 1000) {
                extent = rangeutil.minMax(this.subsetRange);
                extent = enlargeExtentIfEqual(extent);
                return Promise.resolve(extent);
              } else {
                // subset x and y to get a fast estimate of the palette extent
                // since it is an estimate, the lower and upper bound needs a small buffer
                // (to prevent out-of-bounds colours)
                var xconstraint = { start: 0, stop: xlen, step: Math.max(Math.round(xlen / 1000), 1) };
                var yconstraint = { start: 0, stop: ylen, step: Math.max(Math.round(ylen / 1000), 1) };

                return this.subsetCov.subsetByIndex({ x: xconstraint, y: yconstraint }).then(function (subsetCov) {
                  return subsetCov.loadRange(_this3.param.key).then(function (subsetRange) {
                    var _rangeutil$minMax = rangeutil.minMax(subsetRange);

                    var _rangeutil$minMax2 = babelHelpers.slicedToArray(_rangeutil$minMax, 2);

                    var min = _rangeutil$minMax2[0];
                    var max = _rangeutil$minMax2[1];

                    var buffer = (max - min) * 0.1; // 10% buffer on each side
                    extent = [min - buffer, max + buffer];
                    return extent;
                  });
                });
              }
            } else if (extent === 'fov') {
              // scan the values that are currently in field of view on the map for min/max
              // this implies using the current subset
              var bounds = this._map.getBounds();

              // TODO implement
              throw new Error('NOT IMPLEMENTED YET');
            } else {
              throw new Error('Unknown extent specification: ' + extent);
            }
          }

          /**
           * Return the displayed value at a given geographic position.
           * If out of bounds, then undefined is returned, otherwise a number or null (for no data).
           */
        }, {
          key: 'getValueAt',
          value: function getValueAt(latlng) {
            // TODO see drawTile(), domain must be lat/lon for now
            var x = this.domain.axes.get('x').values;
            var y = this.domain.axes.get('y').values;
            var bbox = this._getDomainBbox();
            var lonRange = [bbox[0], bbox[0] + 360];
            var lat = latlng.lat;
            var lon = latlng.lng;

            // we first check whether the tile pixel is outside the domain bounding box
            // in that case we skip it as we do not want to extrapolate
            if (lat < bbox[1] || lat > bbox[3]) {
              return;
            }

            lon = wrapLongitude(lon, lonRange);
            if (lon < bbox[0] || lon > bbox[2]) {
              return;
            }

            var iLat = arrays.indexOfNearest(y, lat);
            var iLon = arrays.indexOfNearest(x, lon);

            return this.subsetRange.get({ y: iLat, x: iLon });
          }
        }, {
          key: 'drawTile',
          value: function drawTile(canvas, tilePoint, zoom) {
            if (this.errored) return;

            var ctx = canvas.getContext('2d');
            var tileSize = this.options.tileSize;

            var imgData = ctx.getImageData(0, 0, tileSize, tileSize);
            // Uint8ClampedArray, 1-dimensional, in order R,G,B,A,R,G,B,A,... row-major
            var rgba = ndarray(imgData.data, [tileSize, tileSize, 4]);

            // projection coordinates of top left tile pixel
            var start = tilePoint.multiplyBy(tileSize);
            var startX = start.x;
            var startY = start.y;

            var _palette = this.palette;
            var red = _palette.red;
            var green = _palette.green;
            var blue = _palette.blue;

            var getPaletteIndex = this.getPaletteIndex;
            var setPixel = function setPixel(tileY, tileX, val) {
              var idx = getPaletteIndex(val);
              if (idx !== undefined) {
                rgba.set(tileY, tileX, 0, red[idx]);
                rgba.set(tileY, tileX, 1, green[idx]);
                rgba.set(tileY, tileX, 2, blue[idx]);
                rgba.set(tileY, tileX, 3, 255);
              }
            };

            var vals = this.subsetRange.get;

            // FIXME check if "Geodetic WGS84 CRS" as term is enough to describe WGS84 angular
            //          what about cartesian??

            // TODO check if the domain and map CRS datum match
            // -> if not, then at least a warning should be shown
            if (this._isDomainUsingEllipsoidalCRS()) {
              if (this._isRectilinearGeodeticMap()) {
                // here we can apply heavy optimizations
                this._drawRectilinearGeodeticMapProjection(setPixel, tileSize, startX, startY, vals);
              } else {
                // this is for any random map projection
                // here we have to unproject each map pixel individually and find the matching domain coordinates
                this._drawAnyMapProjection(setPixel, tileSize, startX, startY, vals);
              }
            } else {
              // here we either have a projected CRS with base CRS = CRS84, or
              // a projected CRS with non-CRS84 base CRS (like British National Grid), or
              // a geodetic CRS not using a WGS84 datum
              // FIXME check this, what does geodetic CRS really mean? = lat/lon? = ellipsoid?

              if (this._isGeodeticTransformAvailableForDomain()) {
                throw new Error('NOT IMPLEMENTED YET');
                // TODO implement, use 2D coordinate arrays and/or proj4 transforms
              } else {
                  // TODO if the map projection base CRS matches the CRS of the domain,
                  //      could we still draw the grid in projected coordinates?
                  // -> e.g. UK domain CRS and UK basemap in that CRS

                  throw new Error('Cannot draw grid, spatial CRS is not geodetic ' + 'and no geodetic transform data is available');
                }
            }

            ctx.putImageData(imgData, 0, 0);
          }

          /**
           * Derives the bounding box of the x,y axes in CRS coordinates.
           * @returns {Array} [xmin,ymin,xmax,ymax]
           */
        }, {
          key: '_getDomainBbox',
          value: function _getDomainBbox() {
            var xAxis = this.domain.axes.get('x');
            var yAxis = this.domain.axes.get('y');
            var x = xAxis.values;
            var y = yAxis.values;
            var xBounds = xAxis.bounds;
            var yBounds = yAxis.bounds;

            var xend = x.length - 1;
            var yend = y.length - 1;
            var xmin = undefined,
                xmax = undefined;
            if (xBounds) {
              xmin = xBounds.get(0)[0];
              xmax = xBounds.get(xend)[1];
            } else {
              xmin = x[0];
              xmax = x[xend];
            }
            var ymin = undefined,
                ymax = undefined;
            if (yBounds) {
              ymin = yBounds.get(0)[0];
              ymax = yBounds.get(yend)[1];
            } else {
              ymin = y[0];
              ymax = y[yend];
            }
            if (xmin > xmax) {
              var _ref3 = [xmax, xmin];
              xmin = _ref3[0];
              xmax = _ref3[1];
            }
            if (ymin > ymax) {
              var _ref4 = [ymax, ymin];
              ymin = _ref4[0];
              ymax = _ref4[1];
            }
            if (!xBounds && x.length > 1) {
              xmin -= Math.abs(x[0] - x[1]) / 2;
              xmax += Math.abs(x[xend] - x[xend - 1]) / 2;
            }
            if (!yBounds && y.length > 1) {
              ymin -= Math.abs(y[0] - y[1]) / 2;
              ymax += Math.abs(y[yend] - y[yend - 1]) / 2;
            }

            return [xmin, ymin, xmax, ymax];
          }

          /**
           * Draws a geodetic rectilinear domain grid on a map with arbitrary projection.
           * 
           * @param {Function} setPixel A function with parameters (y,x,val) which 
           *                            sets the color of a pixel on a tile.
           * @param {Integer} tileSize Size of a tile in pixels.
           * @param {Integer} startX
           * @param {Integer} startY
           * @param {ndarray} vals Range values.
           */
        }, {
          key: '_drawAnyMapProjection',
          value: function _drawAnyMapProjection(setPixel, tileSize, startX, startY, vals) {
            // usable for any map projection, but computationally more intensive
            // there are two hotspots in the loops: map.unproject and indexOfNearest

            var map = this._map;
            var x = this.domain.axes.get('x').values;
            var y = this.domain.axes.get('y').values;
            var bbox = this._getDomainBbox();
            var lonRange = [bbox[0], bbox[0] + 360];

            for (var tileX = 0; tileX < tileSize; tileX++) {
              for (var tileY = 0; tileY < tileSize; tileY++) {
                var _map$unproject = map.unproject(L.point(startX + tileX, startY + tileY));

                var lat = _map$unproject.lat;
                var lon = _map$unproject.lon;

                // we first check whether the tile pixel is outside the domain bounding box
                // in that case we skip it as we do not want to extrapolate
                if (lat < bbox[1] || lat > bbox[3]) {
                  continue;
                }

                lon = wrapLongitude(lon, lonRange);
                if (lon < bbox[0] || lon > bbox[2]) {
                  continue;
                }

                // now we find the closest grid cell using simple binary search
                // for finding the closest latitude/longitude we use a simple binary search
                // (as there is no discontinuity)
                var iLat = arrays.indexOfNearest(y, lat);
                var iLon = arrays.indexOfNearest(x, lon);

                setPixel(tileY, tileX, vals({ y: iLat, x: iLon }));
              }
            }
          }

          /**
           * Draws a geodetic rectilinear domain grid on a map whose grid is, or can be directly
           * mapped to, a geodetic rectilinear grid.
           */
        }, {
          key: '_drawRectilinearGeodeticMapProjection',
          value: function _drawRectilinearGeodeticMapProjection(setPixel, tileSize, startX, startY, vals) {
            // optimized version for map projections that are equal to a rectilinear geodetic grid
            // this can be used when lat and lon can be computed independently for a given pixel

            var map = this._map;
            var x = this.domain.axes.get('x').values;
            var y = this.domain.axes.get('y').values;
            var bbox = this._getDomainBbox();
            var lonRange = [bbox[0], bbox[0] + 360];

            var latCache = new Float64Array(tileSize);
            var iLatCache = new Uint32Array(tileSize);
            for (var tileY = 0; tileY < tileSize; tileY++) {
              var lat = map.unproject(L.point(startX, startY + tileY)).lat;
              latCache[tileY] = lat;
              // find the index of the closest latitude in the grid using simple binary search
              iLatCache[tileY] = arrays.indexOfNearest(y, lat);
            }

            for (var tileX = 0; tileX < tileSize; tileX++) {
              var lon = map.unproject(L.point(startX + tileX, startY)).lng;
              lon = wrapLongitude(lon, lonRange);
              if (lon < bbox[0] || lon > bbox[2]) {
                continue;
              }

              // find the index of the closest longitude in the grid using simple binary search
              // (as there is no discontinuity)
              var iLon = arrays.indexOfNearest(x, lon);

              for (var tileY = 0; tileY < tileSize; tileY++) {
                // get geographic coordinates of tile pixel
                var _lat = latCache[tileY];

                // we first check whether the tile pixel is outside the domain bounding box
                // in that case we skip it as we do not want to extrapolate
                if (_lat < bbox[1] || _lat > bbox[3]) {
                  continue;
                }

                var iLat = iLatCache[tileY];

                setPixel(tileY, tileX, vals({ y: iLat, x: iLon }));
              }
            }
          }

          /**
           * Return true if the map projection grid can be mapped to a rectilinear
           * geodetic grid. For that, it must satisfy:
           * for all x, there is a longitude lon, for all y, unproject(x,y).lon = lon
           * for all y, there is a latitude lat, for all x, unproject(x,y).lat = lat
           * 
           * Returns false if this is not the case or unknown.
           */
        }, {
          key: '_isRectilinearGeodeticMap',
          value: function _isRectilinearGeodeticMap() {
            var crs = this._map.options.crs;
            // these are the ones included in Leaflet
            var recti = [L.CRS.EPSG3857, L.CRS.EPSG4326, L.CRS.EPSG3395, L.CRS.Simple];
            var isRecti = recti.indexOf(crs) !== -1;
            // TODO for unknown ones, how do we test that?
            return isRecti;
          }

          /**
           * Return whether the coverage domain is using a geodetic CRS with WGS84 datum.
           */
        }, {
          key: '_isDomainUsingEllipsoidalCRS',
          value: function _isDomainUsingEllipsoidalCRS() {
            return this.domain.referencing.some(function (ref) {
              return referencingutil.isEllipsoidalCRS(ref.system);
            });
          }
        }, {
          key: '_isGeodeticTransformAvailableForDomain',
          value: function _isGeodeticTransformAvailableForDomain() {
            var ref = this.domain.referencing.find(function (ref) {
              return referencingutil.isEllipsoidalCRS(ref.system);
            });
            // TODO implement
            return false;
          }
        }, {
          key: 'redraw',
          value: function redraw() {
            // we check getContainer() to prevent errors when trying to redraw when the layer has not
            // fully initialized yet
            if (this.getContainer()) {
              L.TileLayer.Canvas.prototype.redraw.call(this);
            }
          }
        }, {
          key: 'coverage',
          get: function get() {
            return this.cov;
          }
        }, {
          key: 'parameter',
          get: function get() {
            return this.param;
          }

          /**
           * Sets the currently active time to the one closest to the given Date object.
           * Throws an exception if there is no time axis.
           */
        }, {
          key: 'time',
          set: function set(val) {
            var _this4 = this;

            if (!this.domain.axes.has('t')) {
              throw new Error('No time axis found');
            }
            var old = this.time;
            this._axesSubset.t.coordPref = val.toISOString();
            this._loadCoverageSubset().then(function () {
              if (old === _this4.time) return;
              _this4.redraw();
              _this4.fire('axisChange', { axis: 'time' });
            });
          },

          /**
           * The currently active time on the temporal axis as Date object, 
           * or undefined if the grid has no time axis.
           */
          get: function get() {
            if (this.domain.axes.has('t')) {
              var time = this.subsetDomain.axes.get('t').values[0];
              return new Date(time);
            }
          }
        }, {
          key: 'timeSlices',
          get: function get() {
            if (this.domain.axes.has('t')) {
              return this.domain.axes.get('t').values.map(function (t) {
                return new Date(t);
              });
            }
          }

          /**
           * Sets the currently active vertical coordinate to the one closest to the given value.
           */
        }, {
          key: 'vertical',
          set: function set(val) {
            var _this5 = this;

            if (!this.domain.axes.has('z')) {
              throw new Error('No vertical axis found');
            }
            var old = this.vertical;
            this._axesSubset.z.coordPref = val;
            this._loadCoverageSubset().then(function () {
              if (old === _this5.vertical) return;
              _this5.redraw();
              _this5.fire('axisChange', { axis: 'vertical' });
            });
          },

          /**
           * The currently active vertical coordinate as a number, 
           * or undefined if the grid has no vertical axis.
           */
          get: function get() {
            if (this.domain.axes.has('z')) {
              var val = this.subsetDomain.axes.get('z').values[0];
              return val;
            }
          }
        }, {
          key: 'verticalSlices',
          get: function get() {
            if (this.domain.axes.has('z')) {
              var vals = this.domain.axes.get('z').values;
              if (ArrayBuffer.isView(vals)) {
                // convert to plain Array to allow easier use
                vals = [].concat(babelHelpers.toConsumableArray(vals));
              }
              return vals;
            }
          }
        }]);
        return Grid;
      })(PaletteMixin(CoverageMixin(L.TileLayer.Canvas)));

      _export('default', Grid);
    }
  };
});

$__System.register('75', ['50', '70', '71', '74', '6c', '6d', '6b', '6a', '4c', '1d'], function (_export) {
  /* */
  'use strict';

  var Point, PointSeries, Trajectory, Grid, PointCollection, VerticalProfile, VerticalProfileCollection, MultiPolygon, PolygonSeries, COVJSON_POINT, COVJSON_POINTSERIES, COVJSON_VERTICALPROFILE, COVJSON_GRID, COVJSON_TRAJECTORY, COVJSON_MULTIPOLYGON, COVJSON_POLYGONSERIES, COVERAGE, COVERAGECOLLECTION, DOMAIN, DOMAIN_LAYER_CLASSES, COLLECTION_LAYER_CLASSES;

  var _DOMAIN_LAYER_CLASSES, _COLLECTION_LAYER_CLASSES;

  /**
   * Return a layer class usable for the given coverage data object,
   * or <code>undefined</code> if none was found.
   * If multiple layers match, then an arbitrary one is returned.
   *  
   * @example
   * var cov = ...
   * var clazz = getLayerClass(cov)
   * if (clazz) {
   *   var layer = new clazz(cov, {keys: ['temperature']}).addTo(map)
   * }
   * 
   * @param {object} cov The coverage data object.
   * @return {class|undefined} The layer class.
   */

  _export('default', LayerFactory);

  _export('getLayerClass', getLayerClass);

  /**
   * Return a factory function that creates a layer for a given coverage data object
   * or throws an error if no layer class could be found.
   * 
   * This is a convenience function over using {@link getLayerClass} and manually
   * instantiating the layer.
   * 
   * @example
   * var factory = LayerFactory() // has to be defined just once
   * var cov = ...
   * var layer = factory(cov, {keys: ['temperature']}).addTo(map)
   * 
   * @example <caption>Non-module access</caption>
   * L.coverage.LayerFactory
   * 
   * @return {function} A function fn(cov, options) which returns a new layer for
   *   the given coverage data object and which is initialized with the given layer options.
   * @throws {Error} If no layer class could be found.
   */

  function LayerFactory() {
    return function (cov, opts) {
      var clazz = getLayerClass(cov);
      if (!clazz) {
        var coll = cov.type === COVERAGECOLLECTION ? 'collection ' : '';
        throw new Error('No ' + coll + 'layer class found for domainType=' + cov.domainType);
      }
      return new clazz(cov, opts);
    };
  }

  function getLayerClass(cov) {
    if ((cov.type === COVERAGE || cov.type === DOMAIN) && cov.domainType in DOMAIN_LAYER_CLASSES) {
      return DOMAIN_LAYER_CLASSES[cov.domainType];
    }
    if (cov.type === COVERAGECOLLECTION && cov.domainType in COLLECTION_LAYER_CLASSES) {
      return COLLECTION_LAYER_CLASSES[cov.domainType];
    }
  }

  return {
    setters: [function (_3) {
      Point = _3['default'];
    }, function (_4) {
      PointSeries = _4['default'];
    }, function (_2) {
      Trajectory = _2['default'];
    }, function (_) {
      Grid = _['default'];
    }, function (_c) {
      PointCollection = _c['default'];
    }, function (_d) {
      VerticalProfile = _d['default'];
    }, function (_b) {
      VerticalProfileCollection = _b['default'];
    }, function (_a) {
      MultiPolygon = _a['default'];
    }, function (_c2) {
      PolygonSeries = _c2['default'];
    }, function (_d2) {
      COVJSON_POINT = _d2.COVJSON_POINT;
      COVJSON_POINTSERIES = _d2.COVJSON_POINTSERIES;
      COVJSON_VERTICALPROFILE = _d2.COVJSON_VERTICALPROFILE;
      COVJSON_GRID = _d2.COVJSON_GRID;
      COVJSON_TRAJECTORY = _d2.COVJSON_TRAJECTORY;
      COVJSON_MULTIPOLYGON = _d2.COVJSON_MULTIPOLYGON;
      COVJSON_POLYGONSERIES = _d2.COVJSON_POLYGONSERIES;
      COVERAGE = _d2.COVERAGE;
      COVERAGECOLLECTION = _d2.COVERAGECOLLECTION;
      DOMAIN = _d2.DOMAIN;
    }],
    execute: function () {
      DOMAIN_LAYER_CLASSES = (_DOMAIN_LAYER_CLASSES = {}, babelHelpers.defineProperty(_DOMAIN_LAYER_CLASSES, COVJSON_GRID, Grid), babelHelpers.defineProperty(_DOMAIN_LAYER_CLASSES, COVJSON_POINT, Point), babelHelpers.defineProperty(_DOMAIN_LAYER_CLASSES, COVJSON_POINTSERIES, PointSeries), babelHelpers.defineProperty(_DOMAIN_LAYER_CLASSES, COVJSON_VERTICALPROFILE, VerticalProfile), babelHelpers.defineProperty(_DOMAIN_LAYER_CLASSES, COVJSON_TRAJECTORY, Trajectory), babelHelpers.defineProperty(_DOMAIN_LAYER_CLASSES, COVJSON_MULTIPOLYGON, MultiPolygon), babelHelpers.defineProperty(_DOMAIN_LAYER_CLASSES, COVJSON_POLYGONSERIES, PolygonSeries), _DOMAIN_LAYER_CLASSES);
      COLLECTION_LAYER_CLASSES = (_COLLECTION_LAYER_CLASSES = {}, babelHelpers.defineProperty(_COLLECTION_LAYER_CLASSES, COVJSON_POINT, PointCollection), babelHelpers.defineProperty(_COLLECTION_LAYER_CLASSES, COVJSON_VERTICALPROFILE, VerticalProfileCollection), _COLLECTION_LAYER_CLASSES);
    }
  };
});

$__System.register("76", ["75"], function (_export) {
  "use strict";

  return {
    setters: [function (_) {
      var _exportObj = {};

      for (var _key in _) {
        if (_key !== "default") _exportObj[_key] = _[_key];
      }

      _exportObj["default"] = _["default"];

      _export(_exportObj);
    }],
    execute: function () {}
  };
});

$__System.register('77', ['9', '42', '46', '76', '78', '4b', '1d', '4a', '1e', 'b'], function (_export) {
  'use strict';

  var i18n, ProfilePlot, VerticalAxis, LayerFactory, getLayerClass, CovJSON, ParameterSync, COVJSON_VERTICALPROFILE, CoverageLegend, TimeAxis, Action, VIEW, ModelObservationComparisonActivity, GeoCoverageView;
  return {
    setters: [function (_4) {
      i18n = _4.i18n;
    }, function (_3) {
      ProfilePlot = _3['default'];
    }, function (_2) {
      VerticalAxis = _2['default'];
    }, function (_) {
      LayerFactory = _['default'];
      getLayerClass = _.getLayerClass;
    }, function (_5) {
      CovJSON = _5['default'];
    }, function (_b) {
      ParameterSync = _b['default'];
    }, function (_d) {
      COVJSON_VERTICALPROFILE = _d.COVJSON_VERTICALPROFILE;
    }, function (_a) {
      CoverageLegend = _a['default'];
    }, function (_e) {
      TimeAxis = _e['default'];
    }, function (_b2) {
      Action = _b2['default'];
      VIEW = _b2.VIEW;
    }],
    execute: function () {
      ModelObservationComparisonActivity = 'ModelObservationComparisonActivity';

      /**
       * Displays geospatial coverages on a map.
       */

      GeoCoverageView = (function (_Action) {
        babelHelpers.inherits(GeoCoverageView, _Action);

        function GeoCoverageView(data, context) {
          babelHelpers.classCallCheck(this, GeoCoverageView);

          babelHelpers.get(Object.getPrototypeOf(GeoCoverageView.prototype), 'constructor', this).call(this, context);
          this.cov = data;

          this._setHidden();

          this.layers = [];
        }

        babelHelpers.createClass(GeoCoverageView, [{
          key: '_setVisible',
          value: function _setVisible() {
            this.visible = true;
            this.label = 'Hide';
            this.icon = '<span class="glyphicon glyphicon-eye-close"></span>';
            this.fire('labelChange');
          }
        }, {
          key: '_setHidden',
          value: function _setHidden() {
            this.visible = false;
            this.label = 'View';
            this.icon = '<span class="glyphicon glyphicon-eye-open"></span>';
            this.fire('labelChange');
          }
        }, {
          key: 'run',
          value: function run() {
            var map = this.context.map;

            var dataset = this.context.dataset;
            var datasetTitle = i18n(dataset.title);

            if (this.visible) {
              this.remove();
              this._setHidden();
              return;
            }

            this._setVisible();

            var cov = this.cov;
            if (!getLayerClass(cov)) {
              if (cov.coverages && cov.coverages.length === 1) {
                cov = cov.coverages[0];
              }
            }

            var formatLabel = this.context.distribution.formatImpl.shortLabel;
            var layerNamePrefix = '<span class="label label-success">' + formatLabel + '</span> ';

            // TODO param sync not needed anymore as we use the built-in collection layer classes of leaflet-coverage
            //  -> will this be needed later maybe?
            this.paramSync = new ParameterSync({
              syncProperties: {
                palette: function palette(p1, p2) {
                  return p1;
                },
                paletteExtent: function paletteExtent(e1, e2) {
                  return e1 && e2 ? [Math.min(e1[0], e2[0]), Math.max(e1[1], e2[1])] : null;
                }
              }
            }).on('parameterAdd', function (e) {
              // The virtual sync layer proxies the synced palette, paletteExtent, and parameter.
              // The sync layer will fire a 'remove' event if all real layers for that parameter were removed.
              var layer = e.syncLayer;
              if (layer.palette) {
                CoverageLegend(layer, {
                  position: 'bottomright'
                }).addTo(map);
              }
            });

            // each parameter becomes a layer
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = cov.parameters.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var key = _step.value;

                var opts = { keys: [key] };
                var layerName = i18n(cov.parameters.get(key).observedProperty.label);
                var fullLayerName = layerNamePrefix + layerName;
                var layer = this._createLayer(cov, opts);
                map.layerControl.addOverlay(layer, fullLayerName, { groupName: datasetTitle, expanded: true });
                this.layers.push(layer);
              }

              // display the first layer
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            var firstLayer = this.layers[0];
            map.addLayer(firstLayer);
          }
        }, {
          key: '_createLayer',
          value: function _createLayer(cov, opts) {
            var _this = this;

            var isCollection = cov.coverages;

            var map = this.context.map;
            var layer = LayerFactory()(cov, opts).on('add', function (e) {
              var covLayer = e.target;

              // This registers the layer with the sync manager.
              // By doing that, the palette and extent get unified (if existing)
              // and an event gets fired if a new parameter was added.
              // See the code above where ParameterSync gets instantiated.
              _this.paramSync.addLayer(covLayer);

              if (isCollection) {
                // we could display a time range control for filtering the displayed collection items
                // same for vertical axis where in addition a target value could be chosen
              } else {
                  if (covLayer.timeSlices) {
                    var timeAxis = new TimeAxis(covLayer);
                    timeAxis.addTo(map);
                  }

                  if (covLayer.verticalSlices) {
                    var vertAxis = new VerticalAxis(covLayer);
                    vertAxis.addTo(map);
                  }
                }
            }).on('dataLoading', function () {
              return _this.fire('loading');
            }).on('dataLoad', function () {
              return _this.fire('load');
            });

            // we do that outside of the above 'add' handler since we want to register only once,
            // not every time the layer is added to the map
            layer.on('click', function (_ref) {
              var coverage = _ref.coverage;

              var genBy = coverage.ld.wasGeneratedBy;

              if (coverage.domainType === COVJSON_VERTICALPROFILE) {
                new ProfilePlot(coverage).addTo(map);
              } else if (genBy && genBy.type === ModelObservationComparisonActivity) {
                (function () {
                  var usage = genBy.qualifiedUsage;
                  var modelParamKey = usage.model.parameterKey;
                  var obsParamKey = usage.observation.parameterKey;

                  // display a plot of the input model (subsetting to a point) and observation
                  // TODO we are at JS Coverage Data API abstraction here, how do we know the format of the linked cov?
                  // -> should the media type be included in the prov data?
                  var modelCovUrl = usage.model.entity;
                  var obsCovUrl = usage.observation.entity;
                  var covJSON = new CovJSON();
                  Promise.all([covJSON.load(modelCovUrl), covJSON.load(obsCovUrl, { eagerload: true })]).then(function (_ref2) {
                    var _ref22 = babelHelpers.slicedToArray(_ref2, 2);

                    var modelCov = _ref22[0];
                    var obsCov = _ref22[1];

                    return obsCov.loadDomain().then(function (obsDomain) {
                      // TODO handle CRS, reproject
                      var x = obsDomain.axes.get('x').values[0];
                      var y = obsDomain.axes.get('y').values[0];
                      return modelCov.subsetByValue({ x: { start: x, stop: x }, y: { start: y, stop: y } }, { eagerload: true }).then(function (modelSubset) {
                        new ProfilePlot([obsCov, modelSubset], {
                          keys: [[obsParamKey, modelParamKey]],
                          labels: ['Observation', 'Model']
                        }).addTo(map);
                      });
                    });
                  })['catch'](function (e) {
                    console.log(e);
                    // TODO display error
                  });
                })();
              }
            });

            return layer;
          }
        }, {
          key: 'remove',
          value: function remove() {
            var map = this.context.map;

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var layer = _step2.value;

                if (map.hasLayer(layer)) {
                  map.removeLayer(layer);
                }
                map.layerControl.removeLayer(layer);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                  _iterator2['return']();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }

            this.layers = [];
          }
        }, {
          key: 'isSupported',
          get: function get() {
            var cov = this.cov;
            // TODO for collections, parameters have to be defined at collection level
            // see https://github.com/Reading-eScience-Centre/coveragejson/issues/55

            // check if leaflet-coverage can directly visualize it
            if (getLayerClass(cov)) {
              return true;
            }
            // otherwise, if it's a 1-element collection, check if the single coverage can be visualized
            if (cov.coverages && cov.coverages.length === 1) {
              if (getLayerClass(cov.coverages[0])) {
                return true;
              }
            }
            return false;
          }
        }]);
        return GeoCoverageView;
      })(Action);

      _export('default', GeoCoverageView);

      GeoCoverageView.type = VIEW;
    }
  };
});

(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
/^u/.test(typeof define) && function(a) {
  var b = this.require = function(b) {
    return a[b];
  };
  this.define = function(c, d) {
    a[c] = a[c] || d(b);
  };
}({}), define("79", [], function() {
  function a(a) {
    return a.substr(0, 3);
  }
  function b(a) {
    return a != Fa ? "" + a : "";
  }
  function c(a) {
    return "string" == typeof a;
  }
  function d(a) {
    return !!a && "object" == typeof a;
  }
  function e(a) {
    return a && a.nodeType;
  }
  function f(a) {
    return "number" == typeof a;
  }
  function g(a) {
    return d(a) && !!a.getDay;
  }
  function h(a) {
    return !0 === a || !1 === a;
  }
  function i(a) {
    var b = typeof a;
    return "object" == b ? !(!a || !a.getDay) : "string" == b || "number" == b || h(a);
  }
  function j(a) {
    return a;
  }
  function k(a) {
    return a + 1;
  }
  function l(a, c, d) {
    return b(a).replace(c, d != Fa ? d : "");
  }
  function m(a) {
    return l(a, /[\\\[\]\/{}()*+?.$|^-]/g, "\\$&");
  }
  function n(a) {
    return l(a, /^\s+|\s+$/g);
  }
  function o(a, b, c) {
    for (var d in a)
      a.hasOwnProperty(d) && b.call(c || a, d, a[d]);
    return a;
  }
  function p(a, b, c) {
    if (a)
      for (var d = 0; d < a.length; d++)
        b.call(c || a, a[d], d);
    return a;
  }
  function q(a, b, c) {
    var d = [],
        e = ea(b) ? b : function(a) {
          return b != a;
        };
    return p(a, function(b, f) {
      e.call(c || a, b, f) && d.push(b);
    }), d;
  }
  function r(a, b, c, d) {
    var e = [];
    return a(b, function(a, f) {
      fa(a = c.call(d || b, a, f)) ? p(a, function(a) {
        e.push(a);
      }) : a != Fa && e.push(a);
    }), e;
  }
  function s(a, b, c) {
    return r(p, a, b, c);
  }
  function t(a) {
    var b = 0;
    return o(a, function() {
      b++;
    }), b;
  }
  function u(a) {
    var b = [];
    return o(a, function(a) {
      b.push(a);
    }), b;
  }
  function v(a, b, c) {
    var d = [];
    return p(a, function(e, f) {
      d.push(b.call(c || a, e, f));
    }), d;
  }
  function w(a, b) {
    if (fa(a)) {
      var c = wa(b);
      return M(G(a, 0, c.length), c);
    }
    return b != Fa && a.substr(0, b.length) == b;
  }
  function x(a, b) {
    if (fa(a)) {
      var c = wa(b);
      return M(G(a, -c.length), c) || !c.length;
    }
    return b != Fa && a.substr(a.length - b.length) == b;
  }
  function y(a) {
    var b = a.length;
    return fa(a) ? new va(v(a, function() {
      return a[--b];
    })) : l(a, /[\s\S]/g, function() {
      return a.charAt(--b);
    });
  }
  function z(a, b) {
    var c = {};
    return p(a, function(a) {
      c[a] = b;
    }), c;
  }
  function A(a, b) {
    var c,
        d = b || {};
    for (c in a)
      d[c] = a[c];
    return d;
  }
  function B(a, b) {
    for (var c = b,
        d = 0; d < a.length; d++)
      c = A(a[d], c);
    return c;
  }
  function C(a) {
    return ea(a) ? a : function(b, c) {
      return a === b ? c : void 0;
    };
  }
  function D(a, b, c) {
    return b == Fa ? c : 0 > b ? Math.max(a.length + b, 0) : Math.min(a.length, b);
  }
  function E(a, b, c, d) {
    b = C(b), d = D(a, d, a.length);
    for (var e = D(a, c, 0); d > e; e++)
      if ((c = b.call(a, a[e], e)) != Fa)
        return c;
  }
  function F(a, b, c, d) {
    b = C(b), d = D(a, d, -1);
    for (var e = D(a, c, a.length - 1); e > d; e--)
      if ((c = b.call(a, a[e], e)) != Fa)
        return c;
  }
  function G(a, b, c) {
    var d = [];
    if (a)
      for (c = D(a, c, a.length), b = D(a, b, 0); c > b; b++)
        d.push(a[b]);
    return d;
  }
  function H(a) {
    return v(a, j);
  }
  function I(a) {
    return function() {
      return new va(O(a, arguments));
    };
  }
  function J(a) {
    var b = {};
    return q(a, function(a) {
      return b[a] ? !1 : b[a] = 1;
    });
  }
  function K(a, b) {
    var c = z(b, 1);
    return q(a, function(a) {
      var b = c[a];
      return c[a] = 0, b;
    });
  }
  function L(a, b) {
    for (var c = 0; c < a.length; c++)
      if (a[c] == b)
        return !0;
    return !1;
  }
  function M(a, b) {
    var c,
        d = ea(a) ? a() : a,
        e = ea(b) ? b() : b;
    return d == e ? !0 : d == Fa || e == Fa ? !1 : i(d) || i(e) ? g(d) && g(e) && +d == +e : fa(d) ? d.length == e.length && !E(d, function(a, b) {
      return M(a, e[b]) ? void 0 : !0;
    }) : !fa(e) && (c = u(d)).length == t(e) && !E(c, function(a) {
      return M(d[a], e[a]) ? void 0 : !0;
    });
  }
  function N(a, b, c) {
    return ea(a) ? a.apply(c && b, v(c || b, j)) : void 0;
  }
  function O(a, b, c) {
    return v(a, function(a) {
      return N(a, b, c);
    });
  }
  function P(a, b, c, d) {
    return function() {
      return N(a, b, s([c, arguments, d], j));
    };
  }
  function Q(a, b) {
    for (var c = 0 > b ? "-" : "",
        d = (c ? -b : b).toFixed(0); d.length < a; )
      d = "0" + d;
    return c + d;
  }
  function R(a, b, c) {
    var d,
        e = 0,
        f = c ? b : y(b);
    return a = (c ? a : y(a)).replace(/./g, function(a) {
      return "0" == a ? (d = !1, f.charAt(e++) || "0") : "#" == a ? (d = !0, f.charAt(e++) || "") : d && !f.charAt(e) ? "" : a;
    }), c ? a : b.substr(0, b.length - e) + y(a);
  }
  function S(a, b, c) {
    return b != Fa && a ? 60 * parseFloat(a[b] + a[b + 1]) + parseFloat(a[b] + a[b + 2]) + c.getTimezoneOffset() : 0;
  }
  function T(a) {
    return new Date(+a);
  }
  function U(a, b, c) {
    return a["set" + b](a["get" + b]() + c), a;
  }
  function V(a, b, c) {
    return c == Fa ? V(new Date, a, b) : U(T(a), b.charAt(0).toUpperCase() + b.substr(1), c);
  }
  function W(a, b, c) {
    var d = +b,
        e = +c,
        f = e - d;
    if (0 > f)
      return -W(a, c, b);
    if (b = {
      milliseconds: 1,
      seconds: 1e3,
      minutes: 6e4,
      hours: 36e5
    }[a])
      return f / b;
    for (b = a.charAt(0).toUpperCase() + a.substr(1), a = Math.floor(f / {
      fullYear: 31536e6,
      month: 2628e6,
      date: 864e5
    }[a] - 2), d = U(new Date(d), b, a), f = a; 1.2 * a + 4 > f; f++)
      if (+U(d, b, 1) > e)
        return f;
  }
  function X(a) {
    return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
  }
  function Y(a) {
    return l(a, /[\x00-\x1f'"\u2028\u2029]/g, X);
  }
  function Z(a, b) {
    return a.split(b);
  }
  function $(a, b) {
    function c(a, c) {
      var d = [];
      return e.call(c || a, a, function(a, b) {
        fa(a) ? p(a, function(a, c) {
          b.call(a, a, c);
        }) : o(a, function(a, c) {
          b.call(c, a, c);
        });
      }, b || j, function() {
        N(d.push, d, arguments);
      }, wa), d.join("");
    }
    if (Ma[a])
      return Ma[a];
    var d = "with(_.isObject(obj)?obj:{}){" + v(Z(a, /{{|}}}?/g), function(a, b) {
      var c,
          d = n(a),
          e = l(d, /^{/),
          d = d == e ? "esc(" : "";
      return b % 2 ? (c = /^each\b(\s+([\w_]+(\s*,\s*[\w_]+)?)\s*:)?(.*)/.exec(e)) ? "each(" + (n(c[4]) ? c[4] : "this") + ", function(" + c[2] + "){" : (c = /^if\b(.*)/.exec(e)) ? "if(" + c[1] + "){" : (c = /^else\b\s*(if\b(.*))?/.exec(e)) ? "}else " + (c[1] ? "if(" + c[2] + ")" : "") + "{" : (c = /^\/(if)?/.exec(e)) ? c[1] ? "}\n" : "});\n" : (c = /^(var\s.*)/.exec(e)) ? c[1] + ";" : (c = /^#(.*)/.exec(e)) ? c[1] : (c = /(.*)::\s*(.*)/.exec(e)) ? "print(" + d + '_.formatValue("' + Y(c[2]) + '",' + (n(c[1]) ? c[1] : "this") + (d && ")") + "));\n" : "print(" + d + (n(e) ? e : "this") + (d && ")") + ");\n" : a ? 'print("' + Y(a) + '");\n' : void 0;
    }).join("") + "}",
        e = Function("obj", "each", "esc", "print", "_", d);
    return 99 < Na.push(c) && delete Ma[Na.shift()], Ma[a] = c;
  }
  function _(a) {
    return l(a, /[<>'"&]/g, function(a) {
      return "&#" + a.charCodeAt(0) + ";";
    });
  }
  function aa(a, b) {
    return $(a, _)(b);
  }
  function ba(a) {
    return function(b, c) {
      return new va(a(this, b, c));
    };
  }
  function ca(a) {
    return function(b, c, d) {
      return a(this, b, c, d);
    };
  }
  function da(a) {
    return function(b, c, d) {
      return new va(a(b, c, d));
    };
  }
  function ea(a) {
    return "function" == typeof a && !a.item;
  }
  function fa(a) {
    return a && a.length != Fa && !c(a) && !e(a) && !ea(a) && a !== ya;
  }
  function ga(a) {
    return parseFloat(l(a, /^[^\d-]+/));
  }
  function ha(a) {
    return a.Nia = a.Nia || ++Ba;
  }
  function ia(a, b) {
    var c,
        d = [],
        e = {};
    return sa(a, function(a) {
      sa(b(a), function(a) {
        e[c = ha(a)] || (d.push(a), e[c] = !0);
      });
    }), d;
  }
  function ja(a, b) {
    var c = {
      $position: "absolute",
      $visibility: "hidden",
      $display: "block",
      $height: Fa
    },
        d = a.get(c),
        c = a.set(c).get("clientHeight");
    return a.set(d), c * b + "px";
  }
  function ka(a) {
    Ca ? Ca.push(a) : setTimeout(a, 0);
  }
  function la(a, b, c) {
    return pa(a, b, c)[0];
  }
  function ma(a, b, c) {
    return a = oa(document.createElement(a)), fa(b) || b != Fa && !d(b) ? a.add(b) : a.set(b).add(c);
  }
  function na(a) {
    return r(sa, a, function(a) {
      return fa(a) ? na(a) : (e(a) && (a = a.cloneNode(!0), a.removeAttribute && a.removeAttribute("id")), a);
    });
  }
  function oa(a, b, c) {
    return ea(a) ? ka(a) : new va(pa(a, b, c));
  }
  function pa(a, b, d) {
    function f(a) {
      return fa(a) ? r(sa, a, f) : a;
    }
    function g(a) {
      return q(r(sa, a, f), function(a) {
        for (; a = a.parentNode; )
          if (a == b[0] || d)
            return a == b[0];
      });
    }
    return b ? 1 != (b = pa(b)).length ? ia(b, function(b) {
      return pa(a, b, d);
    }) : c(a) ? 1 != e(b[0]) ? [] : d ? g(b[0].querySelectorAll(a)) : b[0].querySelectorAll(a) : g(a) : c(a) ? document.querySelectorAll(a) : r(sa, a, f);
  }
  function qa(a, b) {
    function d(a, b) {
      var c = RegExp("(^|\\s+)" + a + "(?=$|\\s)", "i");
      return function(d) {
        return a ? c.test(d[b]) : !0;
      };
    }
    var g,
        h,
        i = {},
        j = i;
    return ea(a) ? a : f(a) ? function(b, c) {
      return c == a;
    } : !a || "*" == a || c(a) && (j = /^([\w-]*)\.?([\w-]*)$/.exec(a)) ? (g = d(j[1], "tagName"), h = d(j[2], "className"), function(a) {
      return 1 == e(a) && g(a) && h(a);
    }) : b ? function(c) {
      return oa(a, b).find(c) != Fa;
    } : (oa(a).each(function(a) {
      i[ha(a)] = !0;
    }), function(a) {
      return i[ha(a)];
    });
  }
  function ra(a) {
    var b = qa(a);
    return function(a) {
      return b(a) ? Fa : !0;
    };
  }
  function sa(a, b) {
    return fa(a) ? p(a, b) : a != Fa && b(a, 0), a;
  }
  function ta() {
    this.state = null, this.values = [], this.parent = null;
  }
  function ua() {
    var a,
        b,
        c = [],
        e = arguments,
        f = e.length,
        g = 0,
        h = 0,
        i = new ta;
    return i.errHandled = function() {
      h++, i.parent && i.parent.errHandled();
    }, a = i.fire = function(a, b) {
      return null == i.state && null != a && (i.state = !!a, i.values = fa(b) ? b : [b], setTimeout(function() {
        p(c, function(a) {
          a();
        });
      }, 0)), i;
    }, p(e, function j(b, c) {
      try {
        b.then ? b.then(function(b) {
          (d(b) || ea(b)) && ea(b.then) ? j(b, c) : (i.values[c] = H(arguments), ++g == f && a(!0, 2 > f ? i.values[c] : i.values));
        }, function() {
          i.values[c] = H(arguments), a(!1, 2 > f ? i.values[c] : [i.values[c][0], i.values, c]);
        }) : b(function() {
          a(!0, H(arguments));
        }, function() {
          a(!1, H(arguments));
        });
      } catch (e) {
        a(!1, [e, i.values, c]);
      }
    }), i.stop = function() {
      return p(e, function(a) {
        a.stop && a.stop();
      }), i.stop0 && N(i.stop0);
    }, b = i.then = function(a, b) {
      function e() {
        try {
          var c = i.state ? a : b;
          ea(c) ? function g(a) {
            try {
              var b,
                  c = 0;
              if ((d(a) || ea(a)) && ea(b = a.then)) {
                if (a === f)
                  throw new TypeError;
                b.call(a, function(a) {
                  c++ || g(a);
                }, function(a) {
                  c++ || f.fire(!1, [a]);
                }), f.stop0 = a.stop;
              } else
                f.fire(!0, [a]);
            } catch (e) {
              if (!c++ && (f.fire(!1, [e]), !h))
                throw e;
            }
          }(N(c, xa, i.values)) : f.fire(i.state, i.values);
        } catch (e) {
          if (f.fire(!1, [e]), !h)
            throw e;
        }
      }
      var f = ua();
      return ea(b) && i.errHandled(), f.stop0 = i.stop, f.parent = i, null != i.state ? setTimeout(e, 0) : c.push(e), f;
    }, i.always = function(a) {
      return b(a, a);
    }, i.error = function(a) {
      return b(0, a);
    }, i;
  }
  function va(a, b) {
    var c,
        d,
        e,
        f,
        g,
        h = 0;
    if (a)
      for (c = 0, d = a.length; d > c; c++)
        if (e = a[c], b && fa(e))
          for (f = 0, g = e.length; g > f; f++)
            this[h++] = e[f];
        else
          this[h++] = e;
    else
      this[h++] = b;
    this.length = h, this._ = !0;
  }
  function wa() {
    return new va(arguments, !0);
  }
  var xa,
      ya = window,
      za = {},
      Aa = {},
      Ba = 1,
      Ca = /^[ic]/.test(document.readyState) ? Fa : [],
      Da = {},
      Ea = 0,
      Fa = null,
      Ga = Z("January,February,March,April,May,June,July,August,September,October,November,December", /,/g),
      Ha = v(Ga, a),
      Ia = Z("Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday", /,/g),
      Ja = v(Ia, a),
      Ka = {
        y: ["FullYear", j],
        Y: ["FullYear", function(a) {
          return a % 100;
        }],
        M: ["Month", k],
        n: ["Month", Ha],
        N: ["Month", Ga],
        d: ["Date", j],
        m: ["Minutes", j],
        H: ["Hours", j],
        h: ["Hours", function(a) {
          return a % 12 || 12;
        }],
        k: ["Hours", k],
        K: ["Hours", function(a) {
          return a % 12;
        }],
        s: ["Seconds", j],
        S: ["Milliseconds", j],
        a: ["Hours", Z("am,am,am,am,am,am,am,am,am,am,am,am,pm,pm,pm,pm,pm,pm,pm,pm,pm,pm,pm,pm", /,/g)],
        w: ["Day", Ja],
        W: ["Day", Ia],
        z: ["TimezoneOffset", function(a, b, c) {
          return c ? c : (b = 0 > a ? -a : a, (a > 0 ? "-" : "+") + Q(2, Math.floor(b / 60)) + Q(2, b % 60));
        }]
      },
      La = {
        y: 0,
        Y: [0, -2e3],
        M: [1, 1],
        n: [1, Ha],
        N: [1, Ga],
        d: 2,
        m: 4,
        H: 3,
        h: 3,
        K: [3, 1],
        k: [3, 1],
        s: 5,
        S: 6,
        a: [3, Z("am,pm", /,/g)]
      },
      Ma = {},
      Na = [];
  return A({
    each: ca(p),
    filter: ba(q),
    collect: ba(s),
    map: ba(v),
    toObject: ca(z),
    equals: ca(M),
    sub: ba(G),
    reverse: ca(y),
    find: ca(E),
    findLast: ca(F),
    startsWith: ca(w),
    endsWith: ca(x),
    contains: ca(L),
    call: ba(O),
    array: ca(H),
    unite: ca(I),
    merge: ca(B),
    uniq: ba(J),
    intersection: ba(K),
    join: function(a) {
      return v(this, j).join(a);
    },
    reduce: function(a, b) {
      return p(this, function(c, d) {
        b = a.call(this, b, c, d);
      }), b;
    },
    sort: function(a) {
      return new va(v(this, j).sort(a));
    },
    remove: function() {
      sa(this, function(a) {
        a.parentNode.removeChild(a);
      });
    },
    text: function() {
      return r(sa, this, function(a) {
        return a.textContent;
      }).join("");
    },
    trav: function(a, b, c) {
      var d = f(b),
          e = qa(d ? Fa : b),
          g = d ? b : c;
      return new va(ia(this, function(b) {
        for (var c = []; (b = b[a]) && c.length != g; )
          e(b) && c.push(b);
        return c;
      }));
    },
    next: function(a, b) {
      return this.trav("nextSibling", a, b || 1);
    },
    up: function(a, b) {
      return this.trav("parentNode", a, b || 1);
    },
    select: function(a, b) {
      return oa(a, this, b);
    },
    is: function(a) {
      return !this.find(ra(a));
    },
    only: function(a) {
      return new va(q(this, qa(a)));
    },
    not: function(a) {
      return new va(q(this, ra(a)));
    },
    get: function(a, b) {
      var d,
          e,
          f,
          g,
          h = this,
          i = h[0];
      return i ? c(a) ? (d = /^(\W*)(.*)/.exec(l(a, /^%/, "@data-")), e = d[1], f = Aa[e] ? Aa[e](this, d[2]) : "$" == a ? h.get("className") : "$$" == a ? h.get("@style") : "$$slide" == a ? h.get("$height") : "$$fade" == a || "$$show" == a ? "hidden" == h.get("$visibility") || "none" == h.get("$display") ? 0 : "$$fade" == a ? isNaN(h.get("$opacity", !0)) ? 1 : h.get("$opacity", !0) : 1 : "$" == e ? ya.getComputedStyle(i, Fa).getPropertyValue(l(d[2], /[A-Z]/g, function(a) {
        return "-" + a.toLowerCase();
      })) : "@" == e ? i.getAttribute(d[2]) : i[d[2]], b ? ga(f) : f) : (g = {}, (fa(a) ? sa : o)(a, function(a) {
        g[a] = h.get(a, b);
      }), g) : void 0;
    },
    set: function(a, b) {
      var d,
          e,
          f = this;
      return b !== xa ? (d = /^(\W*)(.*)/.exec(l(l(a, /^\$float$/, "cssFloat"), /^%/, "@data-")), e = d[1], za[e] ? za[e](this, d[2], b) : "$$fade" == a ? this.set({
        $visibility: b ? "visible" : "hidden",
        $opacity: b
      }) : "$$slide" == a ? f.set({
        $visibility: b ? "visible" : "hidden",
        $overflow: "hidden",
        $height: /px/.test(b) ? b : function(a, c, d) {
          return ja(oa(d), b);
        }
      }) : "$$show" == a ? b ? f.set({
        $visibility: b ? "visible" : "hidden",
        $display: ""
      }).set({$display: function(a) {
          return "none" == a ? "block" : a;
        }}) : f.set({$display: "none"}) : "$$" == a ? f.set("@style", b) : sa(this, function(c, f) {
        var g = ea(b) ? b(oa(c).get(a), f, c) : b;
        "$" == e ? d[2] ? c.style[d[2]] = g : sa(g && g.split(/\s+/), function(a) {
          var b = l(a, /^[+-]/),
              d = c.className || "",
              e = l(d, RegExp("(^|\\s+)" + b + "(?=$|\\s)"));
          (/^\+/.test(a) || b == a && d == e) && (e += " " + b), c.className = n(e);
        }) : "$$scrollX" == a ? c.scroll(g, oa(c).get("$$scrollY")) : "$$scrollY" == a ? c.scroll(oa(c).get("$$scrollX"), g) : "@" == e ? g == Fa ? c.removeAttribute(d[2]) : c.setAttribute(d[2], g) : c[d[2]] = g;
      })) : c(a) || ea(a) ? f.set("$", a) : o(a, function(a, b) {
        f.set(a, b);
      }), f;
    },
    show: function() {
      return this.set("$$show", 1);
    },
    hide: function() {
      return this.set("$$show", 0);
    },
    add: function(a, b) {
      return this.each(function(c, d) {
        function f(a) {
          fa(a) ? sa(a, f) : ea(a) ? f(a(c, d)) : a != Fa && (a = e(a) ? a : document.createTextNode(a), g ? g.parentNode.insertBefore(a, g.nextSibling) : b ? b(a, c, c.parentNode) : c.appendChild(a), g = a);
        }
        var g;
        f(d && !ea(a) ? na(a) : a);
      });
    },
    fill: function(a) {
      return this.each(function(a) {
        oa(a.childNodes).remove();
      }).add(a);
    },
    addAfter: function(a) {
      return this.add(a, function(a, b, c) {
        c.insertBefore(a, b.nextSibling);
      });
    },
    addBefore: function(a) {
      return this.add(a, function(a, b, c) {
        c.insertBefore(a, b);
      });
    },
    addFront: function(a) {
      return this.add(a, function(a, b) {
        b.insertBefore(a, b.firstChild);
      });
    },
    replace: function(a) {
      return this.add(a, function(a, b, c) {
        c.replaceChild(a, b);
      });
    },
    clone: ba(na),
    animate: function(a, b, c) {
      var d,
          e = ua(),
          f = this,
          g = r(sa, this, function(b, d) {
            var e,
                f = oa(b),
                g = {};
            return o(e = f.get(a), function(c, e) {
              var h = a[c];
              g[c] = ea(h) ? h(e, d, b) : "$$slide" == c ? ja(f, h) : h;
            }), f.dial(e, g, c);
          }),
          h = b || 500;
      return e.stop0 = function() {
        return e.fire(!1), d();
      }, d = oa.loop(function(a) {
        O(g, [a / h]), a >= h && (d(), e.fire(!0, [f]));
      }), e;
    },
    dial: function(a, c, d) {
      function e(a, b) {
        return /^#/.test(a) ? parseInt(6 < a.length ? a.substr(2 * b + 1, 2) : (a = a.charAt(b + 1)) + a, 16) : ga(a.split(",")[b]);
      }
      var f = this,
          g = d || 0,
          h = ea(g) ? g : function(a, b, c) {
            return c * (b - a) * (g + (1 - g) * c * (3 - 2 * c)) + a;
          };
      return function(d) {
        o(a, function(a, g) {
          var i = c[a],
              j = 0;
          f.set(a, 0 >= d ? g : d >= 1 ? i : /^#|rgb\(/.test(i) ? "rgb(" + Math.round(h(e(g, j), e(i, j++), d)) + "," + Math.round(h(e(g, j), e(i, j++), d)) + "," + Math.round(h(e(g, j), e(i, j++), d)) + ")" : l(i, /-?[\d.]+/, b(h(ga(g), ga(i), d))));
        });
      };
    },
    toggle: function(a, b, c, d) {
      var e,
          f,
          g = this,
          h = !1;
      return b ? (g.set(a), function(i) {
        i !== h && (f = (h = !0 === i || !1 === i ? i : !h) ? b : a, c ? (e = g.animate(f, e ? e.stop() : c, d)).then(function() {
          e = Fa;
        }) : g.set(f));
      }) : g.toggle(l(a, /\b(?=\w)/g, "-"), l(a, /\b(?=\w)/g, "+"));
    },
    values: function(a) {
      var c = a || {};
      return this.each(function(a) {
        var d = a.name || a.id,
            e = b(a.value);
        if (/form/i.test(a.tagName))
          for (d = 0; d < a.elements.length; d++)
            oa(a.elements[d]).values(c);
        else
          !d || /ox|io/i.test(a.type) && !a.checked || (c[d] = c[d] == Fa ? e : r(sa, [c[d], e], j));
      }), c;
    },
    offset: function() {
      for (var a = this[0],
          b = {
            x: 0,
            y: 0
          }; a; )
        b.x += a.offsetLeft, b.y += a.offsetTop, a = a.offsetParent;
      return b;
    },
    on: function(a, d, e, f, g) {
      return ea(d) ? this.on(Fa, a, d, e, f) : c(f) ? this.on(a, d, e, Fa, f) : this.each(function(c, h) {
        sa(a ? pa(a, c) : c, function(a) {
          sa(b(d).split(/\s/), function(b) {
            function c(b, c, d) {
              var j,
                  l = !g;
              if (d = g ? d : a, g)
                for (j = qa(g, a); d && d != a && !(l = j(d)); )
                  d = d.parentNode;
              return !l || i != b || e.apply(oa(d), f || [c, h]) && "?" == k || "|" == k;
            }
            function d(a) {
              c(i, a, a.target) || (a.preventDefault(), a.stopPropagation());
            }
            var i = l(b, /[?|]/g),
                k = l(b, /[^?|]/g),
                m = ("blur" == i || "focus" == i) && !!g,
                n = Ba++;
            a.addEventListener(i, d, m), a.M || (a.M = {}), a.M[n] = c, e.M = r(sa, [e.M, function() {
              a.removeEventListener(i, d, m), delete a.M[n];
            }], j);
          });
        });
      });
    },
    onOver: function(a, b) {
      var c = this,
          d = [];
      return ea(b) ? this.on(a, "|mouseover |mouseout", function(a, e) {
        var f = a.relatedTarget || a.toElement,
            g = "mouseout" != a.type;
        d[e] === g || !g && f && (f == c[e] || oa(f).up(c[e]).length) || (d[e] = g, b.call(this, g, a));
      }) : this.onOver(Fa, a);
    },
    onFocus: function(a, b, c) {
      return ea(b) ? this.on(a, "|blur", b, [!1], c).on(a, "|focus", b, [!0], c) : this.onFocus(Fa, a, b);
    },
    onChange: function(a, b, c) {
      return ea(b) ? this.on(a, "|input |change |click", function(a, c) {
        var d = this[0],
            e = /ox|io/i.test(d.type) ? d.checked : d.value;
        d.NiaP != e && b.call(this, d.NiaP = e, c);
      }, c) : this.onChange(Fa, a, b);
    },
    onClick: function(a, b, c, d) {
      return ea(b) ? this.on(a, "click", b, c, d) : this.onClick(Fa, a, b, c);
    },
    trigger: function(a, b) {
      return this.each(function(c) {
        for (var d = !0,
            e = c; e && d; )
          o(e.M, function(e, f) {
            d = d && f(a, b, c);
          }), e = e.parentNode;
      });
    },
    per: function(a, b) {
      if (ea(a))
        for (var c = this.length,
            d = 0; c > d; d++)
          a.call(this, new va(Fa, this[d]), d);
      else
        oa(a, this).per(b);
      return this;
    },
    ht: function(a, b) {
      var c = 2 < arguments.length ? B(G(arguments, 1)) : b;
      return this.set("innerHTML", ea(a) ? a(c) : /{{/.test(a) ? aa(a, c) : /^#\S+$/.test(a) ? aa(la(a).text, c) : a);
    }
  }, va.prototype), A({
    request: function(a, c, d, e) {
      e = e || {};
      var f,
          g = 0,
          h = ua(),
          i = d && d.constructor == e.constructor;
      try {
        h.xhr = f = new XMLHttpRequest, h.stop0 = function() {
          f.abort();
        }, i && (d = r(o, d, function(a, b) {
          return r(sa, b, function(b) {
            return encodeURIComponent(a) + (b != Fa ? "=" + encodeURIComponent(b) : "");
          });
        }).join("&")), d == Fa || /post/i.test(a) || (c += "?" + d, d = Fa), f.open(a, c, !0, e.user, e.pass), i && /post/i.test(a) && f.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), o(e.headers, function(a, b) {
          f.setRequestHeader(a, b);
        }), o(e.xhr, function(a, b) {
          f[a] = b;
        }), f.onreadystatechange = function() {
          4 != f.readyState || g++ || (200 <= f.status && 300 > f.status ? h.fire(!0, [f.responseText, f]) : h.fire(!1, [f.status, f.responseText, f]));
        }, f.send(d);
      } catch (j) {
        g || h.fire(!1, [0, Fa, b(j)]);
      }
      return h;
    },
    toJSON: JSON.stringify,
    parseJSON: JSON.parse,
    ready: ka,
    loop: function(a) {
      function b(a) {
        o(Da, function(b, c) {
          c(a);
        }), Ea && g(b);
      }
      function c() {
        return Da[f] && (delete Da[f], Ea--), e;
      }
      var d,
          e = 0,
          f = Ba++,
          g = ya.requestAnimationFrame || function(a) {
            setTimeout(function() {
              a(+new Date);
            }, 33);
          };
      return Da[f] = function(b) {
        d = d || b, a(e = b - d, c);
      }, Ea++ || g(b), c;
    },
    off: function(a) {
      O(a.M), a.M = Fa;
    },
    setCookie: function(a, b, c, e) {
      document.cookie = a + "=" + (e ? b : escape(b)) + (c ? "; expires=" + (d(c) ? c : new Date(+new Date + 864e5 * c)).toUTCString() : "");
    },
    getCookie: function(a, b) {
      var c,
          d = (c = RegExp("(^|;)\\s*" + a + "=([^;]*)").exec(document.cookie)) && c[2];
      return b ? d : d && unescape(d);
    },
    wait: function(a, b) {
      var c = ua(),
          d = setTimeout(function() {
            c.fire(!0, b);
          }, a);
      return c.stop0 = function() {
        c.fire(!1), clearTimeout(d);
      }, c;
    }
  }, oa), A({
    filter: da(q),
    collect: da(s),
    map: da(v),
    sub: da(G),
    reverse: y,
    each: p,
    toObject: z,
    find: E,
    findLast: F,
    contains: L,
    startsWith: w,
    endsWith: x,
    equals: M,
    call: da(O),
    array: H,
    unite: I,
    merge: B,
    uniq: da(J),
    intersection: da(K),
    keys: da(u),
    values: da(function(a, b) {
      var c = [];
      return b ? p(b, function(b) {
        c.push(a[b]);
      }) : o(a, function(a, b) {
        c.push(b);
      }), c;
    }),
    copyObj: A,
    extend: function(a) {
      return B(G(arguments, 1), a);
    },
    range: function(a, b) {
      for (var c = [],
          d = b == Fa ? a : b,
          e = b != Fa ? a : 0; d > e; e++)
        c.push(e);
      return new va(c);
    },
    bind: P,
    partial: function(a, b, c) {
      return P(a, this, b, c);
    },
    eachObj: o,
    mapObj: function(a, b, c) {
      var d = {};
      return o(a, function(e, f) {
        d[e] = b.call(c || a, e, f);
      }), d;
    },
    filterObj: function(a, b, c) {
      var d = {};
      return o(a, function(e, f) {
        b.call(c || a, e, f) && (d[e] = f);
      }), d;
    },
    isList: fa,
    isFunction: ea,
    isObject: d,
    isNumber: f,
    isBool: h,
    isDate: g,
    isValue: i,
    isString: c,
    toString: b,
    dateClone: T,
    dateAdd: V,
    dateDiff: W,
    dateMidnight: function(a) {
      return a = a || new Date, new Date(a.getFullYear(), a.getMonth(), a.getDate());
    },
    pad: Q,
    formatValue: function(a, d) {
      var e,
          h,
          i = l(a, /^\?/);
      return g(d) ? ((h = /^\[(([+-])(\d\d)(\d\d))\]\s*(.*)/.exec(i)) && (e = h[1], d = V(d, "minutes", S(h, 2, d)), i = h[5]), l(i, /(\w)(\1*)(?:\[([^\]]+)\])?/g, function(a, b, f, g) {
        return (b = Ka[b]) && (a = d["get" + b[0]](), g = g && g.split(","), a = fa(b[1]) ? (g || b[1])[a] : b[1](a, g, e), a == Fa || c(a) || (a = Q(f.length + 1, a))), a;
      })) : E(i.split(/\s*\|\s*/), function(a) {
        var c,
            e;
        if (c = /^([<>]?)(=?)([^:]*?)\s*:\s*(.*)$/.exec(a)) {
          if (a = d, e = +c[3], (isNaN(e) || !f(a)) && (a = a == Fa ? "null" : b(a), e = c[3]), c[1]) {
            if (!c[2] && a == e || "<" == c[1] && a > e || ">" == c[1] && e > a)
              return Fa;
          } else if (a != e)
            return Fa;
          c = c[4];
        } else
          c = a;
        return f(d) ? c.replace(/[0#](.*[0#])?/, function(a) {
          var b,
              c = /^([^.]+)(\.)([^.]+)$/.exec(a) || /^([^,]+)(,)([^,]+)$/.exec(a),
              e = 0 > d ? "-" : "",
              f = /(\d+)(\.(\d+))?/.exec((e ? -d : d).toFixed(c ? c[3].length : 0));
          return a = c ? c[1] : a, b = c ? R(c[3], l(f[3], /0+$/), !0) : "", (e ? "-" : "") + ("#" == a ? f[1] : R(a, f[1])) + (b.length ? c[2] : "") + b;
        }) : c;
      });
    },
    parseDate: function(a, b) {
      var c,
          d,
          e,
          f,
          g,
          h,
          i,
          j,
          k,
          o = {},
          p = 1,
          q = l(a, /^\?/);
      if (q != a && !n(b))
        return Fa;
      if ((e = /^\[([+-])(\d\d)(\d\d)\]\s*(.*)/.exec(q)) && (c = e, q = e[4]), !(e = RegExp(q.replace(/(.)(\1*)(?:\[([^\]]*)\])?/g, function(a, b, c, e) {
        return /[dmhkyhs]/i.test(b) ? (o[p++] = b, a = c.length + 1, "(\\d" + (2 > a ? "+" : "{1," + a + "}") + ")") : "z" == b ? (d = p, p += 3, "([+-])(\\d\\d)(\\d\\d)") : /[Nna]/.test(b) ? (o[p++] = [b, e && e.split(",")], "([a-zA-Z\\u0080-\\u1fff]+)") : /w/i.test(b) ? "[a-zA-Z\\u0080-\\u1fff]+" : /\s/.test(b) ? "\\s+" : m(a);
      })).exec(b)))
        return xa;
      for (q = [0, 0, 0, 0, 0, 0, 0], f = 1; p > f; f++)
        if (g = e[f], h = o[f], fa(h)) {
          if (i = h[0], j = La[i], k = j[0], h = E(h[1] || j[1], function(a, b) {
            return w(g.toLowerCase(), a.toLowerCase()) ? b : void 0;
          }), h == Fa)
            return xa;
          q[k] = "a" == i ? q[k] + 12 * h : h;
        } else
          h && (i = parseFloat(g), j = La[h], fa(j) ? q[j[0]] += i - j[1] : q[j] += i);
      return q = new Date(q[0], q[1], q[2], q[3], q[4], q[5], q[6]), V(q, "minutes", -S(c, 1, q) - S(e, d, q));
    },
    parseNumber: function(a, b) {
      var c = l(a, /^\?/);
      return c == a || n(b) ? (c = /(^|[^0#.,])(,|[0#.]*,[0#]+|[0#]+\.[0#]+\.[0#.,]*)($|[^0#.,])/.test(c) ? "," : ".", c = parseFloat(l(l(l(b, "," == c ? /\./g : /,/g), c, "."), /^[^\d-]*(-?\d)/, "$1")), isNaN(c) ? xa : c) : Fa;
    },
    trim: n,
    isEmpty: function(a, b) {
      return a == Fa || !a.length || b && /^\s*$/.test(a);
    },
    escapeRegExp: m,
    escapeHtml: _,
    format: function(a, b, c) {
      return $(a, c)(b);
    },
    template: $,
    formatHtml: aa,
    promise: ua
  }, wa), document.addEventListener("DOMContentLoaded", function() {
    O(Ca), Ca = Fa;
  }, !1), {
    HTML: function() {
      var a = ma("div");
      return wa(N(a.ht, a, arguments)[0].childNodes);
    },
    _: wa,
    $: oa,
    $$: la,
    EE: ma,
    M: va,
    getter: Aa,
    setter: za
  };
});

_removeDefine();
})();
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("8", ["79"], function(main) {
  return main;
});

_removeDefine();
})();
$__System.register('7a', ['8', '7b'], function (_export) {
  'use strict';

  var $, Format, WMS;

  function readLayers(wmsEndpoint) {
    return readCapabilities(wmsEndpoint).then(getLayers);
  }

  function readCapabilities(wmsEndpoint) {
    // TODO rewrite with fetch
    var uriParts = document.createElement('a');
    uriParts.href = wmsEndpoint;
    var user = uriParts.username;
    var pass = uriParts.password;
    if (user) {
      // remove user and pass from URL and send as Auth header instead
      var parts = /^(https?:\/\/)(.*)@(.*)/.exec(wmsEndpoint);
      wmsEndpoint = parts[1] + parts[3];
    }
    var getCapabilitiesUrl = undefined;
    if (wmsEndpoint.startsWith('blob:') || wmsEndpoint.indexOf('GetCapabilities') !== -1) {
      getCapabilitiesUrl = wmsEndpoint;
    } else {
      getCapabilitiesUrl = wmsEndpoint + '?service=wms&version=1.1.1&request=GetCapabilities';
    }

    return new Promise(function (resolve, reject) {
      var req = new XMLHttpRequest();
      req.open('GET', getCapabilitiesUrl);
      req.overrideMimeType('text/xml');

      if (user) {
        var cred = user + ':' + pass;
        req.setRequestHeader('Authorization', 'Basic ' + btoa(cred));
      }

      req.addEventListener('load', function () {
        var xml = req.responseXML;
        resolve(xml);
      });

      req.addEventListener('error', function () {
        reject(new Error('Network error loading resource at ' + wmsEndpoint));
      });

      req.send();
    });
  }

  function getLayers(xml) {
    xml = xml.documentElement;
    var layers = [];
    $('Layer', xml).each(function (layerNode) {
      if ($(layerNode).get('@queryable') !== '1') return;
      var name = $('Name', layerNode, true).text();
      var title = $('Title', layerNode, true).text();
      layers.push({ name: name, title: title });
    });
    return layers;
  }
  return {
    setters: [function (_) {
      $ = _.$;
    }, function (_b) {
      Format = _b['default'];
    }],
    execute: function () {
      WMS = (function (_Format) {
        babelHelpers.inherits(WMS, _Format);

        /**
         * @param {Array} actionFactories Array of action class factories
         */

        function WMS(actionFactories) {
          babelHelpers.classCallCheck(this, WMS);

          babelHelpers.get(Object.getPrototypeOf(WMS.prototype), 'constructor', this).call(this, actionFactories);
          this.label = 'Web Map Service';
          this.shortLabel = 'WMS';
          // see dcat.js, this media type does not actually exist!
          this.mediaTypes = ['application/wms+xml'];
        }

        /**
         * @param url A WMS endpoint URL.
         * @returns {Promise} succeeds with layers metadata.
         */
        babelHelpers.createClass(WMS, [{
          key: 'doLoad',
          value: function doLoad(url) {
            return readLayers(url).then(function (layers) {
              return { layers: layers, url: url };
            });
          }
        }, {
          key: 'getMetadata',
          value: function getMetadata(data) {
            return {
              format: this.label,
              content: data.layers.length + ' layers'
            };
          }
        }]);
        return WMS;
      })(Format);

      _export('default', WMS);
    }
  };
});

$__System.register('33', ['9', '7b'], function (_export) {
  'use strict';

  var loadJSON, Format, CatRemap;
  return {
    setters: [function (_) {
      loadJSON = _.loadJSON;
    }, function (_b) {
      Format = _b['default'];
    }],
    execute: function () {
      CatRemap = (function (_Format) {
        babelHelpers.inherits(CatRemap, _Format);

        function CatRemap(actionFactories) {
          babelHelpers.classCallCheck(this, CatRemap);

          babelHelpers.get(Object.getPrototypeOf(CatRemap.prototype), 'constructor', this).call(this, actionFactories);
          this.label = 'Category Remapping Definition in JSON-LD';
          this.shortLabel = 'CatRemap';
          this.mediaTypes = ['application/ld+json;profile="http://purl.org/voc/cpm_catremap"'];
        }

        /**
         * @param urlOrObject Either a URL or an object.
         * @returns {Promise} succeeds with JSON-LD object
         */
        babelHelpers.createClass(CatRemap, [{
          key: 'doLoad',
          value: function doLoad(urlOrObject) {
            return loadJSON(urlOrObject, this.mediaTypes);
          }
        }, {
          key: 'getMetadata',
          value: function getMetadata(data) {
            return {
              format: this.label,
              content: '1 Mapping'
            };
          }
        }]);
        return CatRemap;
      })(Format);

      _export('default', CatRemap);
    }
  };
});

$__System.register('22', ['9', '7b'], function (_export) {
  'use strict';

  var loadJSON, Format, GeoJSON;
  return {
    setters: [function (_) {
      loadJSON = _.loadJSON;
    }, function (_b) {
      Format = _b['default'];
    }],
    execute: function () {
      GeoJSON = (function (_Format) {
        babelHelpers.inherits(GeoJSON, _Format);

        function GeoJSON(actionFactories) {
          babelHelpers.classCallCheck(this, GeoJSON);

          babelHelpers.get(Object.getPrototypeOf(GeoJSON.prototype), 'constructor', this).call(this, actionFactories);
          this.label = 'GeoJSON';
          this.shortLabel = this.label;
          this.mediaTypes = ['application/vnd.geo+json'];
        }

        /**
         * @param urlOrObject Either a URL or a GeoJSON object.
         * @returns {Promise}
         */
        babelHelpers.createClass(GeoJSON, [{
          key: 'doLoad',
          value: function doLoad(urlOrObject) {
            return loadJSON(urlOrObject, this.mediaTypes);
          }
        }, {
          key: 'getMetadata',
          value: function getMetadata(geojson) {
            return {
              format: this.label,
              content: geojson.type
            };
          }
        }]);
        return GeoJSON;
      })(Format);

      _export('default', GeoJSON);
    }
  };
});

$__System.register('7c', ['7d', '7e', '1a'], function (_export) {
  'use strict';

  var CovJSONReader, RestAPI, CoverageData, CovJSON;
  return {
    setters: [function (_d) {
      CovJSONReader = _d;
    }, function (_e) {
      RestAPI = _e;
    }, function (_a) {
      CoverageData = _a['default'];
    }],
    execute: function () {
      CovJSON = (function (_CoverageData) {
        babelHelpers.inherits(CovJSON, _CoverageData);

        /**
         * @param {Array} actionFactories Array of action class factories
         */

        function CovJSON(actionFactories) {
          babelHelpers.classCallCheck(this, CovJSON);

          babelHelpers.get(Object.getPrototypeOf(CovJSON.prototype), 'constructor', this).call(this, actionFactories);
          this.label = 'CoverageCBOR';
          this.shortLabel = 'CovCBOR';
          this.mediaTypes = ['application/prs.coverage+cbor'];
        }

        /**
         * @param urlOrObject Either a URL, a CovJSON object, or a Coverage API object.
         * @returns {Promise} succeeds with a Coverage or Coverage Collection API object
         */
        babelHelpers.createClass(CovJSON, [{
          key: 'doLoad',
          value: function doLoad(urlOrObject) {
            if (typeof urlOrObject === 'object' && urlOrObject.loadDomain) {
              return Promise.resolve(urlOrObject);
            } else {
              return CovJSONReader.read(urlOrObject).then(function (data) {
                return RestAPI.wrap(data, {
                  loader: CovJSONReader.read
                });
              });
            }
          }
        }]);
        return CovJSON;
      })(CoverageData);

      _export('default', CovJSON);
    }
  };
});

$__System.register('7f', [], function (_export) {
  // COPIED FROM covjson-reader -> DRY!!!!!

  'use strict';

  var OPENGIS_CRS_PREFIX, EPSG4979, EPSG4326, CRS84, EllipsoidalCRSs, LongitudeAxisIndex;

  var _LongitudeAxisIndex;

  /**
   * Return whether the given domain axis represents longitudes.
   * 
   * @ignore
   */

  _export('getLongitudeWrapper', getLongitudeWrapper);

  /**
   * Returns true if the given axis has ISO8601 date strings
   * as axis values.
   */

  _export('isLongitudeAxis', isLongitudeAxis);

  /**
   * Return the reference system connection object for the given domain component,
   * or undefined if none exists.
   */

  _export('isISODateAxis', isISODateAxis);

  /**
   * Returns a function which converts an arbitrary longitude to the
   * longitude extent used in the coverage domain.
   * This only supports primitive axes since this is what subsetByValue supports.
   * The longitude extent is extended to 360 degrees if the actual extent is smaller.
   * The extension is done equally on both sides of the extent. 
   * 
   * For example, the domain may have longitudes within [0,360].
   * An input longitude of -70 is converted to 290.
   * All longitudes within [0,360] are returned unchanged.
   * 
   * If the domain has longitudes within [10,50] then the
   * extended longitude range is [-150,210] (-+180 from the middle point).
   * An input longitude of -170 is converted to 190.
   * All longitudes within [-150,210] are returned unchanged.
   * 
   * @ignore
   */

  function getLongitudeWrapper(domain, axisName) {
    // for primitive axes, the axis identifier = component identifier
    if (!isLongitudeAxis(domain, axisName)) {
      throw new Error('\'' + axisName + '\' is not a longitude axis');
    }

    var vals = domain.axes.get(axisName).values;
    var lon_min = vals[0];
    var lon_max = vals[vals.length - 1];
    if (lon_min > lon_max) {
      var _ref = [lon_max, lon_min];
      lon_min = _ref[0];
      lon_max = _ref[1];
    }

    var x_mid = (lon_max + lon_min) / 2;
    var x_min = x_mid - 180;
    var x_max = x_mid + 180;

    return function (lon) {
      if (x_min <= lon && lon <= x_max) {
        // directly return to avoid introducing rounding errors
        return lon;
      } else {
        return ((lon - x_min) % 360 + 360) % 360 + x_min;
      }
    };
  }

  function isLongitudeAxis(domain, axisName) {
    var ref = getReferenceObject(domain, axisName);
    if (!ref) {
      return false;
    }

    var crsId = ref.system.id;
    // TODO should support unknown CRSs with embedded axis information
    if (EllipsoidalCRSs.indexOf(crsId) === -1) {
      // this also covers the case when there is no ID property
      return false;
    }

    var compIdx = ref.components.indexOf(axisName);
    var isLongitude = LongitudeAxisIndex[crsId] === compIdx;
    return isLongitude;
  }

  function isISODateAxis(domain, axisName) {
    var val = domain.axes.get(axisName).values[0];
    if (typeof val !== 'string') {
      return false;
    }
    return !isNaN(new Date(val).getTime());
  }

  function getReferenceObject(domain, component) {
    var ref = domain.referencing.find(function (ref) {
      return ref.components.indexOf(component) !== -1;
    });
    return ref;
  }
  return {
    setters: [],
    execute: function () {
      OPENGIS_CRS_PREFIX = 'http://www.opengis.net/def/crs/';

      /** 3D WGS84 in lat-lon-height order */
      EPSG4979 = OPENGIS_CRS_PREFIX + 'EPSG/0/4979';

      /** 2D WGS84 in lat-lon order */
      EPSG4326 = OPENGIS_CRS_PREFIX + 'EPSG/0/4326';

      /** 2D WGS84 in lon-lat order */
      CRS84 = OPENGIS_CRS_PREFIX + 'OGC/1.3/CRS84';

      /** CRSs in which position is specified by geodetic latitude and longitude */
      EllipsoidalCRSs = [EPSG4979, EPSG4326, CRS84];

      /** Position of longitude axis */
      LongitudeAxisIndex = (_LongitudeAxisIndex = {}, babelHelpers.defineProperty(_LongitudeAxisIndex, EPSG4979, 1), babelHelpers.defineProperty(_LongitudeAxisIndex, EPSG4326, 1), babelHelpers.defineProperty(_LongitudeAxisIndex, CRS84, 0), _LongitudeAxisIndex);
    }
  };
});

$__System.register("80", [], function (_export) {
  /* */
  "use strict";

  _export("shallowcopy", shallowcopy);

  _export("mergeInto", mergeInto);

  function shallowcopy(obj) {
    var copy = Object.create(Object.getPrototypeOf(obj));
    for (var prop in obj) {
      copy[prop] = obj[prop];
    }
    return copy;
  }

  function mergeInto(inputObj, targetObj) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = Object.keys(inputObj)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var k = _step.value;

        targetObj[k] = inputObj[k];
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"]) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return {
    setters: [],
    execute: function () {}
  };
});

$__System.register('81', [], function (_export) {
  // TODO this is copied from leaflet-coverage, DRY!

  /***
   * Return the indices of the two neighbors in the a array closest to x.
   * The array must be sorted (strictly monotone), either ascending or descending.
   * 
   * If x exists in the array, both neighbors point to x.
   * If x is lower (greated if descending) than the first value, both neighbors point to 0.
   * If x is greater (lower if descending) than the last value, both neighbors point to the last index.
   * 
   * Adapted from https://stackoverflow.com/a/4431347
   */
  'use strict';

  /**
   * Return the index in a of the value closest to x.
   * The array a must be sorted, either ascending or descending.
   * If x happens to be exactly between two values, the one that
   * appears first is returned.
   */

  _export('indicesOfNearest', indicesOfNearest);

  _export('indexOfNearest', indexOfNearest);

  function indicesOfNearest(a, x) {
    if (a.length === 0) {
      throw new Error('Array must have at least one element');
    }
    var lo = -1;
    var hi = a.length;
    var ascending = a.length === 1 || a[0] < a[1];
    // we have two separate code paths to help the runtime optimize the loop
    if (ascending) {
      while (hi - lo > 1) {
        var mid = Math.round((lo + hi) / 2);
        if (a[mid] <= x) {
          lo = mid;
        } else {
          hi = mid;
        }
      }
    } else {
      while (hi - lo > 1) {
        var mid = Math.round((lo + hi) / 2);
        if (a[mid] >= x) {
          // here's the difference
          lo = mid;
        } else {
          hi = mid;
        }
      }
    }
    if (a[lo] === x) hi = lo;
    if (lo === -1) lo = hi;
    if (hi === a.length) hi = lo;
    return [lo, hi];
  }

  function indexOfNearest(a, x) {
    var i = indicesOfNearest(a, x);
    var lo = i[0];
    var hi = i[1];
    if (Math.abs(x - a[lo]) <= Math.abs(x - a[hi])) {
      return lo;
    } else {
      return hi;
    }
  }

  return {
    setters: [],
    execute: function () {}
  };
});

$__System.registerDynamic("82", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(root, factory) {
    if (typeof exports === 'object') {
      module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
      define([], factory);
    } else {
      root.urltemplate = factory();
    }
  }(this, function() {
    function UrlTemplate() {}
    UrlTemplate.prototype.encodeReserved = function(str) {
      return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
        if (!/%[0-9A-Fa-f]/.test(part)) {
          part = encodeURI(part);
        }
        return part;
      }).join('');
    };
    UrlTemplate.prototype.encodeValue = function(operator, value, key) {
      value = (operator === '+' || operator === '#') ? this.encodeReserved(value) : encodeURIComponent(value);
      if (key) {
        return encodeURIComponent(key) + '=' + value;
      } else {
        return value;
      }
    };
    UrlTemplate.prototype.isDefined = function(value) {
      return value !== undefined && value !== null;
    };
    UrlTemplate.prototype.isKeyOperator = function(operator) {
      return operator === ';' || operator === '&' || operator === '?';
    };
    UrlTemplate.prototype.getValues = function(context, operator, key, modifier) {
      var value = context[key],
          result = [];
      if (this.isDefined(value) && value !== '') {
        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
          value = value.toString();
          if (modifier && modifier !== '*') {
            value = value.substring(0, parseInt(modifier, 10));
          }
          result.push(this.encodeValue(operator, value, this.isKeyOperator(operator) ? key : null));
        } else {
          if (modifier === '*') {
            if (Array.isArray(value)) {
              value.filter(this.isDefined).forEach(function(value) {
                result.push(this.encodeValue(operator, value, this.isKeyOperator(operator) ? key : null));
              }, this);
            } else {
              Object.keys(value).forEach(function(k) {
                if (this.isDefined(value[k])) {
                  result.push(this.encodeValue(operator, value[k], k));
                }
              }, this);
            }
          } else {
            var tmp = [];
            if (Array.isArray(value)) {
              value.filter(this.isDefined).forEach(function(value) {
                tmp.push(this.encodeValue(operator, value));
              }, this);
            } else {
              Object.keys(value).forEach(function(k) {
                if (this.isDefined(value[k])) {
                  tmp.push(encodeURIComponent(k));
                  tmp.push(this.encodeValue(operator, value[k].toString()));
                }
              }, this);
            }
            if (this.isKeyOperator(operator)) {
              result.push(encodeURIComponent(key) + '=' + tmp.join(','));
            } else if (tmp.length !== 0) {
              result.push(tmp.join(','));
            }
          }
        }
      } else {
        if (operator === ';') {
          result.push(encodeURIComponent(key));
        } else if (value === '' && (operator === '&' || operator === '?')) {
          result.push(encodeURIComponent(key) + '=');
        } else if (value === '') {
          result.push('');
        }
      }
      return result;
    };
    UrlTemplate.prototype.parse = function(template) {
      var that = this;
      var operators = ['+', '#', '.', '/', ';', '?', '&'];
      return {expand: function(context) {
          return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
            if (expression) {
              var operator = null,
                  values = [];
              if (operators.indexOf(expression.charAt(0)) !== -1) {
                operator = expression.charAt(0);
                expression = expression.substr(1);
              }
              expression.split(/,/g).forEach(function(variable) {
                var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
                values.push.apply(values, that.getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
              });
              if (operator && operator !== '+') {
                var separator = ',';
                if (operator === '?') {
                  separator = '&';
                } else if (operator !== '#') {
                  separator = operator;
                }
                return (values.length !== 0 ? operator : '') + values.join(separator);
              } else {
                return values.join(',');
              }
            } else {
              return that.encodeReserved(literal);
            }
          });
        }};
    };
    return new UrlTemplate();
  }));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("83", ["82"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('82');
  global.define = __define;
  return module.exports;
});

$__System.register('84', ['83', '85'], function (_export) {
  /* */
  'use strict';

  var urltemplate, jsonld, jsonldOriginal, PartialCollectionView, IriTemplate, COVAPI_NS, COVAPI_API, OSGEO_NS, OSTIME_NS, URL_PROPS, FRAME_CONTEXT, CONTEXTS, customLoader, jsonldOpts, API;

  _export('discover', discover);

  /**
   * Extracts API information from the given Coverage/CoverageCollection object
   * and returns an API object.
   */

  function discover(cov) {
    // Our main source of API information comes from data within the .ld property.
    // To query that we need the id of the coverage or coveragecollection.
    if (!cov.id) {
      return Promise.resolve(new API());
    }
    return jsonld.frame(cov.ld, {
      '@context': FRAME_CONTEXT,
      id: cov.id
    }, jsonldOpts).then(function (framed) {
      return jsonld.compact(framed, framed['@context'], jsonldOpts);
    }).then(function (compacted) {
      return new API(compacted);
    });
  }

  function checkEmpty(obj, err) {
    if (Object.keys(obj).length > 0) {
      throw new Error(err);
    }
  }

  function getBboxString(bbox) {
    return bbox.map(getNumberString).join(',');
  }

  /**
   * Converts a number to a decimal string in non-scientific notation.
   */
  function getNumberString(num) {
    // try toString() to avoid trailing zeros from toFixed()
    var str = num.toString();
    // if this resulted in scientific notation, use toFixed() instead
    if (str.indexOf('e') !== -1) {
      str = num.toFixed(20);
    }
    return str;
  }

  function getIndexSubsetString(axis, spec) {
    var slice = undefined;
    if (typeof spec === 'number') {
      slice = getNumberString(spec);
    } else if (spec.start === spec.stop && (!spec.step || spec.step === 1)) {
      slice = getNumberString(spec.start);
    } else {
      slice = getNumberString(spec.start) + ':' + getNumberString(stop);
      if (spec.step) {
        slice += ':' + getNumberString(spec.step);
      }
    }
    return axis + '[' + slice + ']';
  }
  return {
    setters: [function (_2) {
      urltemplate = _2['default'];
    }, function (_) {
      jsonld = _.promises;
      jsonldOriginal = _['default'];
    }],
    execute: function () {
      PartialCollectionView = 'PartialCollectionView';
      IriTemplate = 'IriTemplate';
      COVAPI_NS = 'http://coverageapi.org/ns#';
      COVAPI_API = COVAPI_NS + 'api';
      OSGEO_NS = 'http://a9.com/-/opensearch/extensions/geo/1.0/';
      OSTIME_NS = 'http://a9.com/-/opensearch/extensions/time/1.0/';
      URL_PROPS = {
        filterBbox: OSGEO_NS + 'box',
        filterTimeStart: OSTIME_NS + 'start',
        filterTimeEnd: OSTIME_NS + 'end',
        filterVerticalStart: COVAPI_NS + 'verticalStart',
        filterVerticalEnd: COVAPI_NS + 'verticalEnd',
        subsetBbox: COVAPI_NS + 'subsetBbox',
        subsetTimeStart: COVAPI_NS + 'subsetTimeStart',
        subsetTimeEnd: COVAPI_NS + 'subsetTimeEnd',
        subsetVerticalStart: COVAPI_NS + 'subsetVerticalStart',
        subsetVerticalEnd: COVAPI_NS + 'subsetVerticalEnd',
        subsetVerticalTarget: COVAPI_NS + 'subsetVerticalTarget',
        subsetIndex: COVAPI_NS + 'subsetIndex'
      };
      FRAME_CONTEXT = [
      // partial copy of http://www.hydra-cg.com/spec/latest/core/core.jsonld
      {
        "hydra": "http://www.w3.org/ns/hydra/core#",
        "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
        "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
        "xsd": "http://www.w3.org/2001/XMLSchema#",
        "owl": "http://www.w3.org/2002/07/owl#",
        "vs": "http://www.w3.org/2003/06/sw-vocab-status/ns#",
        "dc": "http://purl.org/dc/terms/",
        "cc": "http://creativecommons.org/ns#",
        "property": { "@id": "hydra:property", "@type": "@vocab" },
        "required": "hydra:required",
        "view": { "@id": "hydra:view", "@type": "@id" },
        "PartialCollectionView": "hydra:PartialCollectionView",
        "totalItems": "hydra:totalItems",
        "first": { "@id": "hydra:first", "@type": "@id" },
        "last": { "@id": "hydra:last", "@type": "@id" },
        "next": { "@id": "hydra:next", "@type": "@id" },
        "previous": { "@id": "hydra:previous", "@type": "@id" },
        "IriTemplate": "hydra:IriTemplate",
        "template": "hydra:template",
        "mapping": "hydra:mapping",
        "IriTemplateMapping": "hydra:IriTemplateMapping",
        "variable": "hydra:variable"
      }, {
        'id': '@id',
        'type': '@type',
        // Hydra has "@type": "@vocab" which confuses the compaction -> we override it as workaround
        // see https://github.com/json-ld/json-ld.org/issues/400
        // we also want the full object form anyway, which we can force by omitting "@type"
        "property": { "@id": "hydra:property" },
        'api': COVAPI_API
      }];

      /*
       * We are using a custom jsonld document loader to skip loading the CovJSON context URL
       * which may be included in the document. Instead we load a local partial copy of it.
       */
      CONTEXTS = {
        "https://rawgit.com/reading-escience-centre/coveragejson/master/contexts/coveragejson-base.jsonld": {
          "@context": {
            "id": "@id",
            "type": "@type"
          }
        }
      };

      customLoader = function customLoader(url) {
        if (url in CONTEXTS) {
          return Promise.resolve({
            contextUrl: null, // this is for a context via a link header
            document: CONTEXTS[url], // this is the actual document that was loaded
            documentUrl: url // this is the actual context URL after redirects
          });
        }
        // fall-back to default loader
        return jsonldOriginal.documentLoader(url);
      };

      jsonldOpts = {
        documentLoader: customLoader
      };

      API = (function () {
        /**
         * @param ld A framed and compacted JSON-LD document from which Hydra data can be read.
         */

        function API() {
          var ld = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
          babelHelpers.classCallCheck(this, API);

          this.supportedUrlProps = new Map();

          if (ld.view && ld.view.type === PartialCollectionView) {
            this.isPaged = true;
            this.paging = ld.view;
            this.paging.total = ld.totalItems;
          }

          if (ld.api && ld.api.type === IriTemplate) {
            this.hasUrlTemplate = true;
            this.urlTemplate = ld.api;

            var mappings = ld.api.mapping;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = mappings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var mapping = _step.value;

                var propId = mapping.property.id;
                for (var prop in URL_PROPS) {
                  if (URL_PROPS[prop] === propId) {
                    this.supportedUrlProps.set(propId, mapping.variable);
                  }
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }

          this._createCapabilities();
        }

        babelHelpers.createClass(API, [{
          key: '_createCapabilities',
          value: function _createCapabilities() {
            var caps = {
              filter: {},
              subset: {}
            };
            var startstop = function startstop() {
              return {
                start: true,
                stop: true
              };
            };
            if (this.supportsBboxFiltering) {
              // 'x' is not the axis name, it just represents the x-axis in a horizontal CRS
              caps.filter.x = {
                start: true,
                stop: true,
                dependency: ['y']
              };
              caps.filter.y = {
                start: true,
                stop: true,
                dependency: ['x']
              };
            }
            if (this.supportsTimeFiltering) {
              caps.filter.time = startstop();
            }
            if (this.supportsVerticalFiltering) {
              caps.filter.vertical = startstop();
            }
            if (this.supportsBboxSubsetting) {
              caps.subset.x = {
                start: true,
                stop: true,
                dependency: ['y']
              };
              caps.subset.y = {
                start: true,
                stop: true,
                dependency: ['x']
              };
            }
            if (this.supportsTimeSubsetting) {
              caps.subset.time = startstop();
            }
            if (this.supportsVerticalSubsetting) {
              caps.subset.vertical = startstop();
            }
            if (this.supportsVerticalTargetSubsetting) {
              if (!caps.subset.vertical) {
                caps.subset.vertical = {};
              }
              caps.subset.vertical.target = true;
            }
            if (this.supportsIndexSubsetting) {
              caps.subset.index = {
                start: true,
                stop: true,
                step: true
              };
            }
            this.capabilities = caps;
          }

          /**
           * Option keys: time, x, y, vertical
           * 
           * Each value except for 'embed' is one of (check this.capabilities to see which ones are supported!):
           * 
           * {start, stop} // intersect match
           */
        }, {
          key: '_getFilterTemplateVars',
          value: function _getFilterTemplateVars() {
            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            var templateVars = {};
            if (options.time) {
              if (!this.supportsTimeFiltering) {
                throw new Error('Time filtering not supported!');
              }
              var isoStart = options.time.start;
              var isoEnd = options.time.stop;
              templateVars[this.supportedUrlProps.get(URL_PROPS.filterTimeStart)] = isoStart;
              templateVars[this.supportedUrlProps.get(URL_PROPS.filterTimeEnd)] = isoEnd;
              delete options.time;
            }
            if (options.vertical) {
              if (!this.supportsVerticalFiltering) {
                throw new Error('Vertical filtering not supported!');
              }
              var start = getNumberString(options.vertical.start);
              var end = getNumberString(options.vertical.stop);
              templateVars[this.supportedUrlProps.get(URL_PROPS.filterVerticalStart)] = start;
              templateVars[this.supportedUrlProps.get(URL_PROPS.filterVerticalEnd)] = end;
              delete options.vertical;
            }
            if (options.x) {
              if (!this.supportsBboxFiltering) {
                throw new Error('BBOX filtering not supported!');
              }
              var bboxStr = getBboxString([options.x.start, options.y.start, options.x.stop, options.y.stop]);
              templateVars[this.supportedUrlProps.get(URL_PROPS.filterBbox)] = bboxStr;
              delete options.x;
              delete options.y;
            }
            checkEmpty(options, 'Unrecognized filter options');

            return templateVars;
          }

          /**
           * Option keys: time, x, y, vertical, index
           * 
           * Each value is one of (check this.capabilities to see which ones are supported!):
           * 
           * For time, x, y, vertical:
           * ISO string // exact match (time)
           * number // exact match (x, y, vertical) <- typically not supported by API
           * {start, stop} // intersect match
           * {target} // nearest neighbor match
           * 
           * For index:
           * {<axisName>: integer, ...}
           * {<axisName>: {start,stop[,step]}, ...}
           */
        }, {
          key: '_getSubsetTemplateVars',
          value: function _getSubsetTemplateVars() {
            var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

            var templateVars = {};
            if (options.time) {
              if (!this.supportsTimeSubsetting) {
                throw new Error('Time subsetting not supported!');
              }
              var isoStart = options.time.start;
              var isoEnd = options.time.stop;
              templateVars[this.supportedUrlProps.get(URL_PROPS.subsetTimeStart)] = isoStart;
              templateVars[this.supportedUrlProps.get(URL_PROPS.subsetTimeEnd)] = isoEnd;
              delete options.time;
            }
            if (options.x) {
              if (!this.supportsBboxSubsetting) {
                throw new Error('BBOX subsetting not supported!');
              }
              var bboxStr = getBboxString([options.x.start, options.y.start, options.x.stop, options.y.stop]);
              templateVars[this.supportedUrlProps.get(URL_PROPS.subsetBbox)] = bboxStr;
              delete options.x;
              delete options.y;
            }
            if (options.vertical) {
              if (options.vertical.target) {
                if (!this.supportsVerticalTargetSubsetting) {
                  throw new Error('vertical target subsetting not supported!');
                }
                var target = getNumberString(options.vertical.target);
                templateVars[this.supportedUrlProps.get(URL_PROPS.subsetVerticalTarget)] = target;
              }
              if (options.vertical.start) {
                if (!this.supportsVerticalSubsetting) {
                  throw new Error('vertical subsetting not supported!');
                }
                var start = getNumberString(options.vertical.start);
                var end = getNumberString(options.vertical.stop);
                templateVars[this.supportedUrlProps.get(URL_PROPS.subsetVerticalStart)] = start;
                templateVars[this.supportedUrlProps.get(URL_PROPS.subsetVerticalEnd)] = end;
              }
              delete options.vertical;
            }
            if (options.index) {
              if (!this.supportsIndexSubsetting) {
                throw new Error('index subsetting not supported!');
              }
              var strings = [];
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = Object.keys(options.index)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var axis = _step2.value;

                  strings.push(getIndexSubsetString(axis, options.index[axis]));
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                    _iterator2['return']();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }

              templateVars[this.supportedUrlProps.get(URL_PROPS.subsetIndex)] = strings;
            }
            checkEmpty(options, 'Unrecognized subset options');

            return templateVars;
          }
        }, {
          key: 'getUrl',
          value: function getUrl(options) {
            // deep-copy as we delete properties after they are applied
            options = JSON.parse(JSON.stringify(options));
            var subsetTemplateVars = this._getSubsetTemplateVars(options.subset);
            var filterTemplateVars = this._getFilterTemplateVars(options.filter);

            var templateVars = subsetTemplateVars;
            for (var key in filterTemplateVars) {
              templateVars[key] = filterTemplateVars[key];
            }

            var url = urltemplate.parse(this.urlTemplate.template).expand(templateVars);
            return url;
          }
        }, {
          key: 'supportsBboxFiltering',
          get: function get() {
            return this.supportedUrlProps.has(URL_PROPS.filterBbox);
          }
        }, {
          key: 'supportsBboxSubsetting',
          get: function get() {
            return this.supportedUrlProps.has(URL_PROPS.subsetBbox);
          }
        }, {
          key: 'supportsTimeFiltering',
          get: function get() {
            return this.supportedUrlProps.has(URL_PROPS.filterTimeStart) && this.supportedUrlProps.has(URL_PROPS.filterTimeEnd);
          }
        }, {
          key: 'supportsTimeSubsetting',
          get: function get() {
            return this.supportedUrlProps.has(URL_PROPS.subsetTimeStart) && this.supportedUrlProps.has(URL_PROPS.subsetTimeEnd);
          }
        }, {
          key: 'supportsVerticalFiltering',
          get: function get() {
            return this.supportedUrlProps.has(URL_PROPS.filterVerticalStart) && this.supportedUrlProps.has(URL_PROPS.filterVerticalEnd);
          }
        }, {
          key: 'supportsVerticalSubsetting',
          get: function get() {
            return this.supportedUrlProps.has(URL_PROPS.subsetVerticalStart) && this.supportedUrlProps.has(URL_PROPS.subsetVerticalEnd);
          }
        }, {
          key: 'supportsVerticalTargetSubsetting',
          get: function get() {
            return this.supportedUrlProps.has(URL_PROPS.subsetVerticalTarget);
          }
        }, {
          key: 'supportsIndexSubsetting',
          get: function get() {
            return this.supportedUrlProps.has(URL_PROPS.subsetIndex);
          }
        }]);
        return API;
      })();

      _export('API', API);
    }
  };
});

$__System.register('86', ['80', '81', '84', '7f'], function (_export) {
  /* */
  'use strict';

  var shallowcopy, mergeInto, arrays, API, isISODateAxis, isLongitudeAxis, getLongitudeWrapper, COVERAGE, COVERAGECOLLECTION, QueryProxy;

  _export('wrap', wrap);

  // Note: We currently can't handle Hydra data in non-default graphs due to lack of support in JSON-LD framing.

  /**
   * Wraps a Coverage or Coverage Collection object and executes certain functions
   * via a remote API, in particular subsetting.
   * 
   * @param {object} data The Coverage API object to wrap.
   * @param {object} options Options which control the behaviour of the wrapper.
   * @param {function} options.loader 
   *   The function to use for loading coverage data from a URL.
   *   It is called as loader(url, options) where options corresponds to the
   *   options parameter of Coverage.subsetBy* and CoverageCollectionQuery.execute.
   *   It must return a Promise succeeding with a Coverage Data API object.
   *   
   * @returns {object} The wrapped Coverage Data API object.
   */

  function wrap(data, options) {
    if (typeof options.loader !== 'function') {
      throw new Error('options.loader must be a function');
    }
    if (data.type === COVERAGECOLLECTION) {
      return wrapCollection(data, options);
    } else if (data.type === COVERAGE) {
      return wrapCoverage(data, options);
    } else {
      // Domain or other unknown type
      return data;
    }
  }

  function wrapCollection(collection, wrapOptions) {
    // TODO wrap each individual coverage as well!
    return API.discover(collection).then(function (api) {
      var newcoll = shallowcopy(collection);
      newcoll.query = function () {
        var query = collection.query();
        return new QueryProxy(query, newcoll, api, wrapOptions);
      };
      if (api.isPaged) {
        (function () {
          var _load = wrapOptions.loader;
          var wrapPageLink = function wrapPageLink(url) {
            if (!url) return;
            return {
              load: function load(options) {
                return _load(url, options).then(function (coll) {
                  return wrap(coll, wrapOptions);
                });
              }
            };
          };
          newcoll.paging = {
            total: api.paging.total,
            previous: wrapPageLink(api.paging.previous),
            next: wrapPageLink(api.paging.next),
            first: wrapPageLink(api.paging.first),
            last: wrapPageLink(api.paging.last)
          };
        })();
      }
      return newcoll;
    });
  }

  /**
   * Collects the query parts and executes the query remotely
   * if possible.
   */

  function wrapCoverage(coverage, wrapOptions) {
    return API.discover(coverage).then(function (api) {
      var wrappedCoverage = shallowcopy(coverage);
      wrappedCoverage.subsetByIndex = wrappedSubsetByIndex(coverage, wrappedCoverage, api, wrapOptions);
      wrappedCoverage.subsetByValue = wrappedSubsetByValue(coverage, wrappedCoverage, api, wrapOptions);
      return wrappedCoverage;
    });
  }

  function wrappedSubsetByIndex(coverage, wrappedCoverage, api, wrapOptions) {
    return function (constraints) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      return coverage.loadDomain().then(function (domain) {
        constraints = cleanedConstraints(constraints);

        if (!requiresSubsetting(domain, constraints)) {
          return wrappedCoverage;
        }

        // if the coverage is fully loaded, then there is no need to use a server API
        if (coverage.loaded) {
          return coverage.subsetByIndex(constraints, options);
        }

        var caps = api.capabilities.subset;
        var axisMap = getAxisConcepts(domain);

        /*
         * If the API supports generic index-based subsetting, then this is used.
         * If not, several emulation strategies are used instead (if possible).
         */

        // we split the subsetting constraints into API-compatible and local ones
        var apiConstraints = {
          subset: {} // API concept -> spec
        };
        var localSubsetConstraints = {}; // axis name -> spec

        if (caps.index) {
          apiConstraints.subset.index = constraints;
        } else {
          // try to emulate some constraints
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = Object.keys(constraints)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var axis = _step3.value;

              var useApi = false;
              var constraint = constraints[axis];
              var cap = caps[axisMap[axis]];

              if (!cap) {
                // leave useApi = false
              } else if (typeof constraint !== 'object') {
                  if (cap.start && cap.stop) {
                    // emulate identity match via start/stop
                    var val = domain.axes.get(axis).values[constraint];
                    constraint = { start: val, stop: val };
                    useApi = true;
                  }
                } else if (!constraint.step) {
                  // start / stop
                  if (cap.start && cap.stop) {
                    var start = domain.axes.get(axis).values[constraint.start];
                    var _stop = domain.axes.get(axis).values[constraint.stop];
                    constraint = { start: start, stop: _stop };
                    useApi = true;
                  }
                }

              if (useApi) {
                apiConstraints.subset[axisMap[axis]] = constraint;
              } else {
                localSubsetConstraints[axis] = constraint;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                _iterator3['return']();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }

        toLocalConstraintsIfDependencyMissing(apiConstraints.subset, localSubsetConstraints, caps, axisMap);

        if (Object.keys(apiConstraints.subset).length === 0) {
          // Note that we DON'T wrap the locally subsetted coverage again.
          // This would be incorrect as a partially applied local subset would not be
          // known by the API metadata and therefore a subsequent API subset operation would
          // return wrong data (too much).
          // A way out would be to attach the original API info to the original coverage identity,
          // which can be established with "subsetOf".
          // Somewhere the constraints used for subsetting would have to be stored as well,
          // so that we can reproduce them.
          // E.g.:
          // 1. Coverage A with API info
          // 2. Subset Coverage A by bounding box without API -> Coverage B with subset relationship to Coverage A
          // 3. Subset Coverage B by time
          //  3.1. Subset Coverage A by time with API -> Coverage C with API info
          //  3.2. Subset Coverage C by bounding box without API -> Coverage D with subset relationship to Coverage C
          // TODO implement that or think of something simpler
          return coverage.subsetByIndex(constraints, options);
        }

        var url = api.getUrl(apiConstraints);
        return wrapOptions.loader(url, options).then(function (subset) {
          // apply remaining subset constraints
          if (Object.keys(localSubsetConstraints).length > 0) {
            // again, we DON'T wrap the locally subsetted coverage again, see above
            return subset.subsetByIndex(localSubsetConstraints, options);
          } else {
            return wrap(subset, wrapOptions);
          }
        });
      });
    };
  }

  function wrappedSubsetByValue(coverage, wrappedCoverage, api, wrapOptions) {
    return function (constraints) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      return coverage.loadDomain().then(function (domain) {
        constraints = cleanedConstraints(constraints);

        if (!requiresSubsetting(domain, constraints)) {
          return wrappedCoverage;
        }

        // if the coverage is fully loaded, then there is no need to use a server API
        if (coverage.loaded) {
          return coverage.subsetByValue(constraints, options);
        }

        var caps = api.capabilities.subset;
        var axisMap = getAxisConcepts(domain);

        /* If the API does not support target-based subsetting, then this can be emulated
         * via intersection-based subsetting by inspecting the domain locally first
         * and then subsetting with equal start/stop with the identified domain value.
         * The same is done for exact match subsetting.
         * 
         * FIXME this approach will return invalid results (two instead of one axis step)
         * if the axis has bounds and they are aligned such that a bound start or end
         * is identical to the axis value and the neighboring bounds share their start/end.
         * This is common in WaterML. To account for that, this scenario could be explicitly checked for.
         * A safe start/stop would then be a newly calculated axis value which is in the middle
         * of the bounds.
         */

        // TODO if API axis-value-subsetting is not supported, try to emulate with API axis-index-subsetting

        // we split the subsetting constraints into API-compatible and local ones
        var apiConstraints = {
          subset: {} // API concept -> spec
        };
        var localSubsetConstraints = {}; // axis name -> spec

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = Object.keys(constraints)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var axis = _step4.value;

            var useApi = false;
            var constraint = constraints[axis];
            var cap = caps[axisMap[axis]];
            var isTimeString = isISODateAxis(domain, axis);

            if (!cap) {
              // leave useApi = false
            } else if (typeof constraint !== 'object') {
                if (cap.identity) {
                  useApi = true;
                } else if (cap.start && cap.stop) {
                  // emulate identity match via start/stop if we find a matching axis value
                  var idx = getClosestIndex(domain, axis, constraint.target);
                  var val = domain.axes.get(axis).values[idx];
                  if (isTimeString) {
                    if (new Date(val).getTime() === new Date(constraint).getTime()) {
                      constraint = { start: constraint, stop: constraint };
                      useApi = true;
                    }
                  } else if (val === constraint) {
                    constraint = { start: constraint, stop: constraint };
                    useApi = true;
                  }
                }
              } else if ('target' in constraint) {
                if (cap.target) {
                  useApi = true;
                } else if (cap.start && cap.stop) {
                  // emulate target via start/stop

                  var _prepareForAxisArraySearch = prepareForAxisArraySearch(domain, axis, constraint.target);

                  var _prepareForAxisArraySearch2 = babelHelpers.slicedToArray(_prepareForAxisArraySearch, 3);

                  var vals = _prepareForAxisArraySearch2[0];
                  var bounds = _prepareForAxisArraySearch2[1];
                  var target = _prepareForAxisArraySearch2[2];

                  var _getAxisExtent = getAxisExtent(vals, bounds);

                  var _getAxisExtent2 = babelHelpers.slicedToArray(_getAxisExtent, 2);

                  var minBound = _getAxisExtent2[0];
                  var maxBound = _getAxisExtent2[1];

                  // if the target is outside the axis extent then the API can't be used (as there is no intersection then)
                  if (minBound <= target && target <= maxBound) {
                    // FIXME handle explicit bounds
                    var idx = getClosestIndex(domain, axis, constraint.target);
                    var val = domain.axes.get(axis).values[idx];
                    constraint = { start: val, stop: val };
                    useApi = true;
                  }
                }
              } else {
                // start / stop
                useApi = cap.start && cap.stop;

                if (useApi) {
                  // snap start/stop to axis values to increase the chance of using a cached request

                  var _prepareForAxisArraySearch3 = prepareForAxisArraySearch(domain, axis, constraint.start, constraint.stop);

                  var _prepareForAxisArraySearch32 = babelHelpers.slicedToArray(_prepareForAxisArraySearch3, 4);

                  var vals = _prepareForAxisArraySearch32[0];
                  var bounds = _prepareForAxisArraySearch32[1];
                  var start = _prepareForAxisArraySearch32[2];
                  var _stop2 = _prepareForAxisArraySearch32[3];

                  var _getAxisExtent3 = getAxisExtent(vals, bounds);

                  var _getAxisExtent32 = babelHelpers.slicedToArray(_getAxisExtent3, 2);

                  var minBound = _getAxisExtent32[0];
                  var maxBound = _getAxisExtent32[1];

                  if (_stop2 < minBound || start > maxBound) {
                    // if both start and stop are outside the axis extent, then snapping would be wrong (has to be an error)
                    throw new Error('start or stop must be inside the axis extent');
                  } else {
                    // FIXME handle explicit bounds
                    var idxStart = getClosestIndexArr(vals, start);
                    var idxStop = getClosestIndexArr(vals, _stop2);
                    var axisVals = domain.axes.get(axis).values;
                    constraint = { start: axisVals[idxStart], stop: axisVals[idxStop] };
                  }
                }
              }

            if (useApi) {
              apiConstraints.subset[axisMap[axis]] = constraint;
            } else {
              localSubsetConstraints[axis] = constraint;
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4['return']) {
              _iterator4['return']();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        toLocalConstraintsIfDependencyMissing(apiConstraints.subset, localSubsetConstraints, caps, axisMap);

        if (Object.keys(apiConstraints.subset).length === 0) {
          // again, we DON'T wrap the locally subsetted coverage again, see above
          return coverage.subsetByValue(constraints, options);
        }

        var url = api.getUrl(apiConstraints);
        return wrapOptions.loader(url, options).then(function (subset) {
          // apply remaining subset constraints
          if (Object.keys(localSubsetConstraints).length > 0) {
            // again, we DON'T wrap the locally subsetted coverage again, see above
            return subset.subsetByValue(localSubsetConstraints, options);
          } else {
            return wrap(subset, wrapOptions);
          }
        });
      });
    };
  }

  /**
   * Returns an object that maps axis keys to API concept names by
   * interpreting domain referencing info.
   * An axis with unknown concept is mapped to undefined.
   */
  function getAxisConcepts(domain) {
    var axisConcepts = {};
    var referencing = domain.referencing;
    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
      var _loop = function () {
        var axis = _step5.value;

        var concept = undefined;

        var ref = referencing.filter(function (ref) {
          return ref.components.indexOf(axis) !== -1;
        });
        if (ref.length === 1) {
          var _ref$0 = ref[0];
          var components = _ref$0.components;
          var system = _ref$0.system;

          if (system.type === 'TemporalRS') {
            // The assumption is that if the API offers filtering/subsetting by time,
            // then this happens in the same concrete temporal system (calendar etc.).
            // Also, it is assumed that there is only one time axis.
            // TODO how to locate the "main" time axis if there are multiple?
            //      see https://github.com/Reading-eScience-Centre/coveragejson/issues/45
            concept = 'time';
          } else if (system.type === 'VerticalCRS') {
            concept = 'vertical';
          } else if (system.type === 'GeodeticCRS' || system.type === 'ProjectedCRS') {
            // a geodetic crs can be x,y or x,y,z
            // a projected crs is x,y
            var idx = components.indexOf(axis);
            if (idx === 0) {
              concept = 'x';
            } else if (idx === 1) {
              concept = 'y';
            } else if (idx === 2) {
              concept = 'vertical';
            }
          }
        }

        axisConcepts[axis] = concept;
      };

      for (var _iterator5 = domain.axes.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
        _loop();
      }
    } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion5 && _iterator5['return']) {
          _iterator5['return']();
        }
      } finally {
        if (_didIteratorError5) {
          throw _iteratorError5;
        }
      }
    }

    return axisConcepts;
  }

  /**
   *  Check if all API dependencies between concepts are met.
   *  This is mainly for the bounding box case which needs both x and y.
   *  If a dependency is missing, then the constraint is moved to the
   *  locally applied ones.
   */
  function toLocalConstraintsIfDependencyMissing(apiConstraints, localConstraints, capabilities, axisConcepts) {
    var _iteratorNormalCompletion6 = true;
    var _didIteratorError6 = false;
    var _iteratorError6 = undefined;

    try {
      var _loop2 = function () {
        var concept = _step6.value;

        var depends = capabilities[concept].dependency;
        if (depends && depends.some(function (concept_) {
          return !apiConstraints[concept_];
        })) {
          var axis = Object.keys(axisConcepts).filter(function (axis) {
            return axisConcepts[axis] === concept;
          })[0];
          localConstraints[axis] = apiConstraints[concept];
          delete apiConstraints[concept];
        }
      };

      for (var _iterator6 = Object.keys(apiConstraints)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
        _loop2();
      }
    } catch (err) {
      _didIteratorError6 = true;
      _iteratorError6 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion6 && _iterator6['return']) {
          _iterator6['return']();
        }
      } finally {
        if (_didIteratorError6) {
          throw _iteratorError6;
        }
      }
    }
  }

  function getAxisExtent(vals, bounds) {
    var min = undefined,
        max = undefined;
    if (bounds) {
      min = bounds.get(0)[0];
      max = bounds.get(vals.length - 1)[1];
    } else {
      min = vals[0];
      max = vals[vals.length - 1];
    }
    if (min > max) {
      var _ref = [max, min];
      min = _ref[0];
      max = _ref[1];
    }
    // if no explicit bounds are given then we assume a regular axis and derive bounds
    // TODO this is not desirable in all cases (time steps etc.), should be recorded in the domain data (point vs cell)
    if (!bounds && vals.length > 1) {
      // calculate cell size and extend by half a cell size on each end
      var halfSize = Math.abs(vals[0] - vals[1]) / 2;
      var _ref2 = [min - halfSize, max + halfSize];
      min = _ref2[0];
      max = _ref2[1];
    }
    return [min, max];
  }

  function getClosestIndex(domain, axis, val) {
    var _prepareForAxisArraySearch4 = prepareForAxisArraySearch(domain, axis, val);

    var _prepareForAxisArraySearch42 = babelHelpers.slicedToArray(_prepareForAxisArraySearch4, 3);

    var axisVals = _prepareForAxisArraySearch42[0];
    var searchVal = _prepareForAxisArraySearch42[2];

    return getClosestIndexArr(axisVals, searchVal);
  }

  function getClosestIndexArr(vals, val) {
    var _arrays$indicesOfNearest = arrays.indicesOfNearest(vals, val);

    var _arrays$indicesOfNearest2 = babelHelpers.slicedToArray(_arrays$indicesOfNearest, 2);

    var lo = _arrays$indicesOfNearest2[0];
    var hi = _arrays$indicesOfNearest2[1];

    var idx = Math.abs(val - vals[lo]) <= Math.abs(val - vals[hi]) ? lo : hi;
    return idx;
  }

  function prepareForAxisArraySearch(domain, axis) {
    for (var _len = arguments.length, searchVal = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      searchVal[_key - 2] = arguments[_key];
    }

    var axisVals = domain.axes.get(axis).values;
    var axisBounds = domain.axes.get(axis).bounds;
    searchVal = [].concat(babelHelpers.toConsumableArray(searchVal)); // to array
    if (isISODateAxis(domain, axis)) {
      (function () {
        // convert to unix timestamps as we need numbers
        var toUnix = function toUnix(v) {
          return new Date(v).getTime();
        };
        searchVal = searchVal.map(toUnix);
        axisVals = axisVals.map(toUnix);
        if (axisBounds) {
          (function () {
            var originalBounds = axisBounds;
            axisBounds = {
              get: function get(i) {
                return [toUnix(originalBounds.get(i)[0]), toUnix(originalBounds.get(i)[1])];
              }
            };
          })();
        }
      })();
    } else if (isLongitudeAxis(domain, axis)) {
      var lonWrapper = getLongitudeWrapper(domain, axis);
      searchVal = searchVal.map(lonWrapper);
    }
    return [axisVals, axisBounds].concat(babelHelpers.toConsumableArray(searchVal));
  }

  /**
   * Checks whether the constraints may result in an actual
   * subsetting of the coverage (=true), or whether they are guaranteed
   * to have no effect (=false). 
   */
  function requiresSubsetting(domain, constraints) {
    var _iteratorNormalCompletion7 = true;
    var _didIteratorError7 = false;
    var _iteratorError7 = undefined;

    try {
      for (var _iterator7 = Object.keys(constraints)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
        var axisKey = _step7.value;

        var len = domain.axes.get(axisKey).values.length;
        if (len > 1) {
          return true;
        }
      }
    } catch (err) {
      _didIteratorError7 = true;
      _iteratorError7 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion7 && _iterator7['return']) {
          _iterator7['return']();
        }
      } finally {
        if (_didIteratorError7) {
          throw _iteratorError7;
        }
      }
    }

    return false;
  }

  function cleanedConstraints(constraints) {
    var cleanConstraints = shallowcopy(constraints);
    var _iteratorNormalCompletion8 = true;
    var _didIteratorError8 = false;
    var _iteratorError8 = undefined;

    try {
      for (var _iterator8 = Object.keys(constraints)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
        var key = _step8.value;

        if (constraints[key] === undefined || constraints[key] === null) {
          delete cleanConstraints[key];
        }
      }
    } catch (err) {
      _didIteratorError8 = true;
      _iteratorError8 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion8 && _iterator8['return']) {
          _iterator8['return']();
        }
      } finally {
        if (_didIteratorError8) {
          throw _iteratorError8;
        }
      }
    }

    return cleanConstraints;
  }
  return {
    setters: [function (_3) {
      shallowcopy = _3.shallowcopy;
      mergeInto = _3.mergeInto;
    }, function (_2) {
      arrays = _2;
    }, function (_) {
      API = _;
    }, function (_f) {
      isISODateAxis = _f.isISODateAxis;
      isLongitudeAxis = _f.isLongitudeAxis;
      getLongitudeWrapper = _f.getLongitudeWrapper;
    }],
    execute: function () {
      COVERAGE = 'Coverage';
      COVERAGECOLLECTION = COVERAGE + 'Collection';

      QueryProxy = (function () {
        function QueryProxy(query, collection, api, wrapOptions) {
          babelHelpers.classCallCheck(this, QueryProxy);

          this._query = query;
          this._collection = collection;
          this._api = api;
          this._wrapOptions = wrapOptions;

          this._filter = {};
          this._subset = {};
        }

        babelHelpers.createClass(QueryProxy, [{
          key: 'filter',
          value: function filter(spec) {
            this._query.filter(spec);
            mergeInto(spec, this._filter);
            return this;
          }
        }, {
          key: 'subset',
          value: function subset(spec) {
            this._query.subset(spec);
            mergeInto(spec, this._subset);
            return this;
          }
        }, {
          key: 'execute',
          value: function execute(options) {
            var _this = this;

            var domainTemplate = this._collection.domainTemplate;
            if (domainTemplate) {
              return this._doExecute(domainTemplate);
            } else {
              // inspect domain of first coverage and assume uniform collection
              if (this._collection.coverages.length > 0) {
                return this._collection.coverages[0].loadDomain().then(function (domain) {
                  return _this._doExecute(options, domain);
                });
              } else {
                return this._query.execute(options);
              }
            }
          }
        }, {
          key: '_doExecute',
          value: function _doExecute(options, domainTemplate) {
            var _this2 = this;

            var load = this._wrapOptions.loader;

            var filterCaps = this._api.capabilities.filter;
            var subsetCaps = this._api.capabilities.subset;
            var axisMap = getAxisConcepts(domainTemplate);

            // split constraints into API and locally applied ones
            var apiConstraints = {
              filter: {},
              subset: {}
            };

            var localFilterConstraints = {}; // axis name -> spec
            var localSubsetConstraints = {}; // axis name -> spec

            // filtering
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = Object.keys(this._filter)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var axis = _step.value;

                var constraint = this._filter[axis];
                var cap = filterCaps[axisMap[axis]];
                if (cap && cap.start && cap.stop) {
                  apiConstraints.filter[axisMap[axis]] = constraint;
                } else {
                  localFilterConstraints[axis] = constraint;
                }
              }

              // subsetting
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = Object.keys(this._subset)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var axis = _step2.value;

                var constraint = this._subset[axis];
                var cap = subsetCaps[axisMap[axis]];
                var useApi = false;

                if (!cap) {
                  // leave useApi = false
                } else if (typeof constraint !== 'object' && cap.identity) {
                    useApi = true;
                  } else if ('target' in constraint && cap.target) {
                    useApi = true;
                  } else if ('start' in constraint && 'stop' in constraint && cap.start && cap.stop) {
                    useApi = true;
                  }

                if (useApi) {
                  apiConstraints.subset[axisMap[axis]] = constraint;
                } else {
                  localSubsetConstraints[axis] = constraint;
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                  _iterator2['return']();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }

            toLocalConstraintsIfDependencyMissing(apiConstraints.filter, localFilterConstraints, filterCaps, axisMap);
            toLocalConstraintsIfDependencyMissing(apiConstraints.subset, localSubsetConstraints, subsetCaps, axisMap);

            if (Object.keys(apiConstraints.filter).length === 0 && Object.keys(apiConstraints.subset).length === 0) {
              return this._query.execute(options);
            }

            var url = this._api.getUrl(apiConstraints);
            return load(url, options).then(function (resultCollection) {
              // apply remaining query parts
              if (Object.keys(localSubsetConstraints).length > 0 || Object.keys(localFilterConstraints).length > 0) {
                // the locally queried collection is NOT wrapped! see comment for coverage subsetting below
                return resultCollection.query().filter(localFilterConstraints).subset(localSubsetConstraints).execute();
              } else {
                return wrap(resultCollection, _this2._wrapOptions);
              }
            });
          }
        }]);
        return QueryProxy;
      })();
    }
  };
});

$__System.register("7e", ["86"], function (_export) {
  "use strict";

  return {
    setters: [function (_) {
      var _exportObj = {};

      for (var _key in _) {
        if (_key !== "default") _exportObj[_key] = _[_key];
      }

      _exportObj["default"] = _["default"];

      _export(_exportObj);
    }],
    execute: function () {}
  };
});

$__System.registerDynamic("87", ["88", "89", "8a", "29"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var _slicedToArray = function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  var _createClass = function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.CollectionQuery = undefined;
  var _constants = req('88');
  var _Coverage = req('89');
  var _Coverage2 = _interopRequireDefault(_Coverage);
  var _util = req('8a');
  var _referencing = req('29');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var CoverageCollection = function() {
    function CoverageCollection(covjson) {
      _classCallCheck(this, CoverageCollection);
      this.type = _constants.COVERAGECOLLECTION;
      this.ld = {};
      this._exposeLd(covjson);
      this.id = covjson.id;
      this.profiles = [];
      var profile = covjson.profile;
      var domainType = undefined;
      if (profile) {
        if (profile.substr(0, 4) !== 'http') {
          if ((0, _util.endsWith)(profile, _constants.COVERAGECOLLECTION)) {
            domainType = profile.substr(0, profile.length - _constants.COVERAGECOLLECTION.length);
          }
          profile = _util.PREFIX + profile;
        }
        this.profiles.push(profile);
      }
      if (!domainType) {
        domainType = covjson.domainType;
      }
      if (domainType && domainType.substr(0, 4) !== 'http') {
        domainType = _util.PREFIX + domainType;
      }
      this.domainType = domainType;
      if (!profile && domainType) {
        profile = domainType + _constants.COVERAGECOLLECTION;
        this.profiles.push(profile);
      }
      var covs = [];
      var rootParams = covjson.parameters ? covjson.parameters : {};
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;
      try {
        for (var _iterator = Object.keys(rootParams)[Symbol.iterator](),
            _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;
          var param = rootParams[key];
          if (!param.id) {
            param.id = Math.round(new Date().getTime() * Math.random()).toString();
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var covOptions = {};
      if (covjson.referencing) {
        covOptions.referencing = covjson.referencing;
      }
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;
      try {
        for (var _iterator2 = covjson.coverages[Symbol.iterator](),
            _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var coverage = _step2.value;
          if (!coverage.domainProfile) {
            coverage.domainProfile = domainType;
          }
          if (!coverage.parameters) {
            coverage.parameters = {};
          }
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;
          try {
            for (var _iterator4 = Object.keys(rootParams)[Symbol.iterator](),
                _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var key = _step4.value;
              if (key in coverage.ranges) {
                coverage.parameters[key] = rootParams[key];
              }
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
          if (covjson['@context']) {
            coverage['@context'] = covjson['@context'];
          }
          covs.push(new _Coverage2.default(coverage, covOptions));
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
      this.coverages = covs;
      if (covjson.parameters) {
        this.parameters = new Map();
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;
        try {
          for (var _iterator3 = Object.keys(covjson.parameters)[Symbol.iterator](),
              _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var key = _step3.value;
            (0, _Coverage.transformParameter)(covjson.parameters, key);
            this.parameters.set(key, covjson.parameters[key]);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }
      if (covjson.domainTemplate) {
        (0, _Coverage.transformDomain)(covjson.domainTemplate);
        this.domainTemplate = covjson.domainTemplate;
      }
    }
    _createClass(CoverageCollection, [{
      key: 'query',
      value: function query() {
        return new CollectionQuery(this);
      }
    }, {
      key: '_exposeLd',
      value: function _exposeLd(covjson) {
        if (!covjson['@context']) {
          return;
        }
        var copy = (0, _util.shallowcopy)(covjson);
        delete copy.coverages;
        this.ld = JSON.parse(JSON.stringify(copy));
      }
    }]);
    return CoverageCollection;
  }();
  exports.default = CoverageCollection;
  var CollectionQuery = exports.CollectionQuery = function() {
    function CollectionQuery(collection) {
      _classCallCheck(this, CollectionQuery);
      this._collection = collection;
      this._filter = {};
      this._subset = {};
    }
    _createClass(CollectionQuery, [{
      key: 'filter',
      value: function filter(spec) {
        mergeInto(spec, this._filter);
        return this;
      }
    }, {
      key: 'subset',
      value: function subset(spec) {
        mergeInto(spec, this._subset);
        return this;
      }
    }, {
      key: 'embed',
      value: function embed(spec) {
        return this;
      }
    }, {
      key: 'execute',
      value: function execute() {
        var _this = this;
        var coll = this._collection;
        var newcoll = {
          type: _constants.COVERAGECOLLECTION,
          coverages: [],
          parameters: coll.parameters,
          domainTemplate: coll.domainTemplate,
          profiles: coll.profiles
        };
        var promises = [];
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;
        try {
          var _loop = function _loop() {
            var cov = _step5.value;
            promises.push(cov.loadDomain().then(function(domain) {
              if (!matchesFilter(domain, _this._filter)) {
                return;
              }
              if (Object.keys(_this._subset).length === 0) {
                newcoll.coverages.push(cov);
              } else {
                return cov.subsetByValue(_this._subset).then(function(subsetted) {
                  newcoll.coverages.push(subsetted);
                });
              }
            }));
          };
          for (var _iterator5 = coll.coverages[Symbol.iterator](),
              _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            _loop();
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5.return) {
              _iterator5.return();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
        return Promise.all(promises).then(function() {
          newcoll.query = function() {
            return new CollectionQuery(newcoll);
          };
          return newcoll;
        });
      }
    }]);
    return CollectionQuery;
  }();
  function matchesFilter(domain, filter) {
    var _iteratorNormalCompletion6 = true;
    var _didIteratorError6 = false;
    var _iteratorError6 = undefined;
    try {
      for (var _iterator6 = Object.keys(filter)[Symbol.iterator](),
          _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
        var axisName = _step6.value;
        var condition = filter[axisName];
        if (!domain.axes.has(axisName)) {
          throw new Error('Axis "' + axisName + '" does not exist');
        }
        var axis = domain.axes.get(axisName);
        var vals = axis.values;
        var min = vals[0];
        var max = vals[vals.length - 1];
        if (typeof min !== 'number' && typeof min !== 'string') {
          throw new Error('Can only filter primitive axis values');
        }
        var start = condition.start;
        var stop = condition.stop;
        if ((0, _referencing.isISODateAxis)(domain, axisName)) {
          var _ref = [(0, _util.asTime)(min), (0, _util.asTime)(max)][(start, stop)] = [(0, _util.asTime)(start), (0, _util.asTime)(stop)];
          var _ref2 = _slicedToArray(_ref, 2);
          min = _ref2[0];
          max = _ref2[1];
        } else if ((0, _referencing.isLongitudeAxis)(domain, axisName)) {
          var lonWrapper = (0, _referencing.getLongitudeWrapper)(domain, axisName)[(start, stop)] = [lonWrapper(start), lonWrapper(stop)];
        }
        if (min > max) {
          var _ref3 = [max, min];
          min = _ref3[0];
          max = _ref3[1];
        }
        if (max < start || stop < min) {
          return false;
        }
      }
    } catch (err) {
      _didIteratorError6 = true;
      _iteratorError6 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion6 && _iterator6.return) {
          _iterator6.return();
        }
      } finally {
        if (_didIteratorError6) {
          throw _iteratorError6;
        }
      }
    }
    return true;
  }
  function mergeInto(inputObj, targetObj) {
    var _iteratorNormalCompletion7 = true;
    var _didIteratorError7 = false;
    var _iteratorError7 = undefined;
    try {
      for (var _iterator7 = Object.keys(inputObj)[Symbol.iterator](),
          _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
        var k = _step7.value;
        targetObj[k] = inputObj[k];
      }
    } catch (err) {
      _didIteratorError7 = true;
      _iteratorError7 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion7 && _iterator7.return) {
          _iterator7.return();
        }
      } finally {
        if (_didIteratorError7) {
          throw _iteratorError7;
        }
      }
    }
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8b", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.getAcceptHeader = getAcceptHeader;
  exports.matchesMediaTypes = matchesMediaTypes;
  var MEDIATYPE = exports.MEDIATYPE = {
    COVCBOR: 'application/prs.coverage+cbor',
    COVJSON: 'application/prs.coverage+json',
    JSONLD: 'application/ld+json',
    JSON: 'application/json',
    OCTETSTREAM: 'application/octet-stream',
    TEXT: 'text/plain'
  };
  var COVJSON_PROFILE_STANDALONE = exports.COVJSON_PROFILE_STANDALONE = 'http://coveragejson.org/profiles/standalone';
  function getAcceptHeader(standalone) {
    var covjsonProfile = standalone ? '; profile="' + COVJSON_PROFILE_STANDALONE + '"' : '';
    var accept = MEDIATYPE.COVCBOR + '; q=1.0, ' + MEDIATYPE.COVJSON + covjsonProfile + '; q=0.5, ' + MEDIATYPE.JSONLD + '; q=0.1, ' + MEDIATYPE.JSON + '; q=0.1';
    return accept;
  }
  function matchesMediaTypes(mediaType, matchingMediaTypes) {
    if (!Array.isArray(matchingMediaTypes)) {
      matchingMediaTypes = [matchingMediaTypes];
    }
    return matchingMediaTypes.some(function(t) {
      return mediaType.indexOf(t) === 0;
    });
  }
  var EXT = exports.EXT = {
    COVJSON: '.covjson',
    COVCBOR: '.covcbor'
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8c", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(global, undefined) {
    "use strict";
    var POW_2_24 = Math.pow(2, -24),
        POW_2_32 = Math.pow(2, 32),
        POW_2_53 = Math.pow(2, 53);
    function encode(value) {
      var data = new ArrayBuffer(256);
      var dataView = new DataView(data);
      var lastLength;
      var offset = 0;
      function ensureSpace(length) {
        var newByteLength = data.byteLength;
        var requiredLength = offset + length;
        while (newByteLength < requiredLength)
          newByteLength *= 2;
        if (newByteLength !== data.byteLength) {
          var oldDataView = dataView;
          data = new ArrayBuffer(newByteLength);
          dataView = new DataView(data);
          var uint32count = (offset + 3) >> 2;
          for (var i = 0; i < uint32count; ++i)
            dataView.setUint32(i * 4, oldDataView.getUint32(i * 4));
        }
        lastLength = length;
        return dataView;
      }
      function write() {
        offset += lastLength;
      }
      function writeFloat64(value) {
        write(ensureSpace(8).setFloat64(offset, value));
      }
      function writeUint8(value) {
        write(ensureSpace(1).setUint8(offset, value));
      }
      function writeUint8Array(value) {
        var dataView = ensureSpace(value.length);
        for (var i = 0; i < value.length; ++i)
          dataView.setUint8(offset + i, value[i]);
        write();
      }
      function writeUint16(value) {
        write(ensureSpace(2).setUint16(offset, value));
      }
      function writeUint32(value) {
        write(ensureSpace(4).setUint32(offset, value));
      }
      function writeUint64(value) {
        var low = value % POW_2_32;
        var high = (value - low) / POW_2_32;
        var dataView = ensureSpace(8);
        dataView.setUint32(offset, high);
        dataView.setUint32(offset + 4, low);
        write();
      }
      function writeTypeAndLength(type, length) {
        if (length < 24) {
          writeUint8(type << 5 | length);
        } else if (length < 0x100) {
          writeUint8(type << 5 | 24);
          writeUint8(length);
        } else if (length < 0x10000) {
          writeUint8(type << 5 | 25);
          writeUint16(length);
        } else if (length < 0x100000000) {
          writeUint8(type << 5 | 26);
          writeUint32(length);
        } else {
          writeUint8(type << 5 | 27);
          writeUint64(length);
        }
      }
      function encodeItem(value) {
        var i;
        if (value === false)
          return writeUint8(0xf4);
        if (value === true)
          return writeUint8(0xf5);
        if (value === null)
          return writeUint8(0xf6);
        if (value === undefined)
          return writeUint8(0xf7);
        switch (typeof value) {
          case "number":
            if (Math.floor(value) === value) {
              if (0 <= value && value <= POW_2_53)
                return writeTypeAndLength(0, value);
              if (-POW_2_53 <= value && value < 0)
                return writeTypeAndLength(1, -(value + 1));
            }
            writeUint8(0xfb);
            return writeFloat64(value);
          case "string":
            var utf8data = [];
            for (i = 0; i < value.length; ++i) {
              var charCode = value.charCodeAt(i);
              if (charCode < 0x80) {
                utf8data.push(charCode);
              } else if (charCode < 0x800) {
                utf8data.push(0xc0 | charCode >> 6);
                utf8data.push(0x80 | charCode & 0x3f);
              } else if (charCode < 0xd800) {
                utf8data.push(0xe0 | charCode >> 12);
                utf8data.push(0x80 | (charCode >> 6) & 0x3f);
                utf8data.push(0x80 | charCode & 0x3f);
              } else {
                charCode = (charCode & 0x3ff) << 10;
                charCode |= value.charCodeAt(++i) & 0x3ff;
                charCode += 0x10000;
                utf8data.push(0xf0 | charCode >> 18);
                utf8data.push(0x80 | (charCode >> 12) & 0x3f);
                utf8data.push(0x80 | (charCode >> 6) & 0x3f);
                utf8data.push(0x80 | charCode & 0x3f);
              }
            }
            writeTypeAndLength(3, utf8data.length);
            return writeUint8Array(utf8data);
          default:
            var length;
            if (Array.isArray(value)) {
              length = value.length;
              writeTypeAndLength(4, length);
              for (i = 0; i < length; ++i)
                encodeItem(value[i]);
            } else if (value instanceof Uint8Array) {
              writeTypeAndLength(2, value.length);
              writeUint8Array(value);
            } else {
              var keys = Object.keys(value);
              length = keys.length;
              writeTypeAndLength(5, length);
              for (i = 0; i < length; ++i) {
                var key = keys[i];
                encodeItem(key);
                encodeItem(value[key]);
              }
            }
        }
      }
      encodeItem(value);
      if ("slice" in data)
        return data.slice(0, offset);
      var ret = new ArrayBuffer(offset);
      var retView = new DataView(ret);
      for (var i = 0; i < offset; ++i)
        retView.setUint8(i, dataView.getUint8(i));
      return ret;
    }
    function decode(data, tagger, simpleValue) {
      var dataView = new DataView(data);
      var offset = 0;
      if (typeof tagger !== "function")
        tagger = function(value) {
          return value;
        };
      if (typeof simpleValue !== "function")
        simpleValue = function() {
          return undefined;
        };
      function read(value, length) {
        offset += length;
        return value;
      }
      function readArrayBuffer(length) {
        return read(new Uint8Array(data, offset, length), length);
      }
      function readFloat16() {
        var tempArrayBuffer = new ArrayBuffer(4);
        var tempDataView = new DataView(tempArrayBuffer);
        var value = readUint16();
        var sign = value & 0x8000;
        var exponent = value & 0x7c00;
        var fraction = value & 0x03ff;
        if (exponent === 0x7c00)
          exponent = 0xff << 10;
        else if (exponent !== 0)
          exponent += (127 - 15) << 10;
        else if (fraction !== 0)
          return fraction * POW_2_24;
        tempDataView.setUint32(0, sign << 16 | exponent << 13 | fraction << 13);
        return tempDataView.getFloat32(0);
      }
      function readFloat32() {
        return read(dataView.getFloat32(offset), 4);
      }
      function readFloat64() {
        return read(dataView.getFloat64(offset), 8);
      }
      function readUint8() {
        return read(dataView.getUint8(offset), 1);
      }
      function readUint16() {
        return read(dataView.getUint16(offset), 2);
      }
      function readUint32() {
        return read(dataView.getUint32(offset), 4);
      }
      function readUint64() {
        return readUint32() * POW_2_32 + readUint32();
      }
      function readBreak() {
        if (dataView.getUint8(offset) !== 0xff)
          return false;
        offset += 1;
        return true;
      }
      function readLength(additionalInformation) {
        if (additionalInformation < 24)
          return additionalInformation;
        if (additionalInformation === 24)
          return readUint8();
        if (additionalInformation === 25)
          return readUint16();
        if (additionalInformation === 26)
          return readUint32();
        if (additionalInformation === 27)
          return readUint64();
        if (additionalInformation === 31)
          return -1;
        throw "Invalid length encoding";
      }
      function readIndefiniteStringLength(majorType) {
        var initialByte = readUint8();
        if (initialByte === 0xff)
          return -1;
        var length = readLength(initialByte & 0x1f);
        if (length < 0 || (initialByte >> 5) !== majorType)
          throw "Invalid indefinite length element";
        return length;
      }
      function appendUtf16data(utf16data, length) {
        for (var i = 0; i < length; ++i) {
          var value = readUint8();
          if (value & 0x80) {
            if (value < 0xe0) {
              value = (value & 0x1f) << 6 | (readUint8() & 0x3f);
              length -= 1;
            } else if (value < 0xf0) {
              value = (value & 0x0f) << 12 | (readUint8() & 0x3f) << 6 | (readUint8() & 0x3f);
              length -= 2;
            } else {
              value = (value & 0x0f) << 18 | (readUint8() & 0x3f) << 12 | (readUint8() & 0x3f) << 6 | (readUint8() & 0x3f);
              length -= 3;
            }
          }
          if (value < 0x10000) {
            utf16data.push(value);
          } else {
            value -= 0x10000;
            utf16data.push(0xd800 | (value >> 10));
            utf16data.push(0xdc00 | (value & 0x3ff));
          }
        }
      }
      function decodeItem() {
        var initialByte = readUint8();
        var majorType = initialByte >> 5;
        var additionalInformation = initialByte & 0x1f;
        var i;
        var length;
        if (majorType === 7) {
          switch (additionalInformation) {
            case 25:
              return readFloat16();
            case 26:
              return readFloat32();
            case 27:
              return readFloat64();
          }
        }
        length = readLength(additionalInformation);
        if (length < 0 && (majorType < 2 || 6 < majorType))
          throw "Invalid length";
        switch (majorType) {
          case 0:
            return length;
          case 1:
            return -1 - length;
          case 2:
            if (length < 0) {
              var elements = [];
              var fullArrayLength = 0;
              while ((length = readIndefiniteStringLength(majorType)) >= 0) {
                fullArrayLength += length;
                elements.push(readArrayBuffer(length));
              }
              var fullArray = new Uint8Array(fullArrayLength);
              var fullArrayOffset = 0;
              for (i = 0; i < elements.length; ++i) {
                fullArray.set(elements[i], fullArrayOffset);
                fullArrayOffset += elements[i].length;
              }
              return fullArray;
            }
            return readArrayBuffer(length);
          case 3:
            var utf16data = [];
            if (length < 0) {
              while ((length = readIndefiniteStringLength(majorType)) >= 0)
                appendUtf16data(utf16data, length);
            } else
              appendUtf16data(utf16data, length);
            return String.fromCharCode.apply(null, utf16data);
          case 4:
            var retArray;
            if (length < 0) {
              retArray = [];
              while (!readBreak())
                retArray.push(decodeItem());
            } else {
              retArray = new Array(length);
              for (i = 0; i < length; ++i)
                retArray[i] = decodeItem();
            }
            return retArray;
          case 5:
            var retObject = {};
            for (i = 0; i < length || length < 0 && !readBreak(); ++i) {
              var key = decodeItem();
              retObject[key] = decodeItem();
            }
            return retObject;
          case 6:
            return tagger(decodeItem(), length);
          case 7:
            switch (length) {
              case 20:
                return false;
              case 21:
                return true;
              case 22:
                return null;
              case 23:
                return undefined;
              default:
                return simpleValue(length);
            }
        }
      }
      var ret = decodeItem();
      if (offset !== data.byteLength)
        throw "Remaining bytes";
      return ret;
    }
    var obj = {
      encode: encode,
      decode: decode
    };
    if (typeof define === "function" && define.amd)
      define("cbor/cbor", obj);
    else if (typeof module !== 'undefined' && module.exports)
      module.exports = obj;
    else if (!global.CBOR)
      global.CBOR = obj;
  })(this);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8d", ["8c"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('8c');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8e", ["8d", "8a", "8b"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.load = load;
  var _cborJs = req('8d');
  var _cborJs2 = _interopRequireDefault(_cborJs);
  var _util = req('8a');
  var _httpCommon = req('8b');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function load(url) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    var responseType = arguments.length <= 2 || arguments[2] === undefined ? 'arraybuffer' : arguments[2];
    if (['arraybuffer', 'text'].indexOf(responseType) === -1) {
      throw new Error();
    }
    var headers = options.headers || {};
    return new Promise(function(resolve, reject) {
      var req = new XMLHttpRequest();
      req.open('GET', url);
      req.responseType = responseType;
      var accept = (0, _httpCommon.getAcceptHeader)(options.eagerload);
      req.setRequestHeader('Accept', accept);
      if (headers) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;
        try {
          for (var _iterator = Object.keys(headers)[Symbol.iterator](),
              _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var header = _step.value;
            req.setRequestHeader(header, headers[header]);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      req.addEventListener('load', function() {
        try {
          if (!(req.status >= 200 && req.status < 300 || req.status === 304)) {
            reject(new Error('Resource "' + url + '" not found, HTTP status code: ' + req.status));
            return;
          }
          var type = req.getResponseHeader('Content-Type');
          if ((0, _httpCommon.matchesMediaTypes)(type, [_httpCommon.MEDIATYPE.OCTETSTREAM, _httpCommon.MEDIATYPE.TEXT])) {
            if ((0, _util.endsWith)(url, _httpCommon.EXT.COVJSON)) {
              type = _httpCommon.MEDIATYPE.COVJSON;
            } else if ((0, _util.endsWith)(url, _httpCommon.EXT.COVCBOR)) {
              type = _httpCommon.MEDIATYPE.COVCBOR;
            }
          }
          var data = undefined;
          if ((0, _httpCommon.matchesMediaTypes)(type, _httpCommon.MEDIATYPE.COVCBOR)) {
            var arrayBuffer = req.response;
            var t0 = new Date();
            data = _cborJs2.default.decode(arrayBuffer);
            console.log('CBOR decoding: ' + (new Date() - t0) + 'ms');
          } else if ((0, _httpCommon.matchesMediaTypes)(type, [_httpCommon.MEDIATYPE.COVJSON, _httpCommon.MEDIATYPE.JSONLD, _httpCommon.MEDIATYPE.JSON])) {
            if (responseType === 'arraybuffer') {
              if (window.TextDecoder) {
                var t0 = new Date();
                data = JSON.parse(new TextDecoder().decode(new DataView(req.response)));
                console.log('JSON decoding: ' + (new Date() - t0) + 'ms');
              } else {
                reject({responseType: 'text'});
                return;
              }
            } else {
              var t0 = new Date();
              data = JSON.parse(req.response);
              console.log('JSON decoding (slow path): ' + (new Date() - t0) + 'ms');
            }
          } else {
            reject(new Error('Unsupported media type: ' + type));
            return;
          }
          var responseHeaders = parseResponseHeaders(req.getAllResponseHeaders());
          resolve({
            data: data,
            headers: responseHeaders
          });
        } catch (e) {
          reject(e);
        }
      });
      req.addEventListener('error', function() {
        reject(new Error('Network error loading resource at ' + url));
      });
      req.send();
    }).catch(function(e) {
      if (e.responseType) {
        return load(url, headers, e.responseType);
      } else {
        throw e;
      }
    });
  }
  function parseResponseHeaders(headerStr) {
    var headers = {};
    if (!headerStr) {
      return headers;
    }
    var headerPairs = headerStr.split('\r\n');
    for (var i = 0; i < headerPairs.length; i++) {
      var headerPair = headerPairs[i];
      var index = headerPair.indexOf(': ');
      if (index > 0) {
        var key = headerPair.substring(0, index).toLowerCase();
        var val = headerPair.substring(index + 2);
        headers[key] = val;
      }
    }
    return headers;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8a", ["73"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, "__esModule", {value: true});
  var _array = req('73');
  Object.defineProperty(exports, 'minMax', {
    enumerable: true,
    get: function get() {
      return _array.minMax;
    }
  });
  Object.defineProperty(exports, 'indicesOfNearest', {
    enumerable: true,
    get: function get() {
      return _array.indicesOfNearest;
    }
  });
  Object.defineProperty(exports, 'indexOfNearest', {
    enumerable: true,
    get: function get() {
      return _array.indexOfNearest;
    }
  });
  exports.assert = assert;
  exports.shallowcopy = shallowcopy;
  exports.endsWith = endsWith;
  var PREFIX = exports.PREFIX = 'http://coveragejson.org/def#';
  function assert(condition, message) {
    if (!condition) {
      message = message || 'Assertion failed';
      throw new Error(message);
    }
  }
  function shallowcopy(obj) {
    var copy = Object.create(Object.getPrototypeOf(obj));
    for (var prop in obj) {
      copy[prop] = obj[prop];
    }
    return copy;
  }
  function endsWith(subject, search) {
    var position = subject.length - search.length;
    var lastIndex = subject.indexOf(search, position);
    return lastIndex !== -1 && lastIndex === position;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("88", ["28"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, "__esModule", {value: true});
  var _constants = req('28');
  Object.defineProperty(exports, 'DOMAIN', {
    enumerable: true,
    get: function get() {
      return _constants.DOMAIN;
    }
  });
  Object.defineProperty(exports, 'COVERAGE', {
    enumerable: true,
    get: function get() {
      return _constants.COVERAGE;
    }
  });
  Object.defineProperty(exports, 'COVERAGECOLLECTION', {
    enumerable: true,
    get: function get() {
      return _constants.COVERAGECOLLECTION;
    }
  });
  var LINKRELPREFIX = exports.LINKRELPREFIX = 'http://www.iana.org/assignments/relation/';
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("73", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.minMax = minMax;
  exports.indicesOfNearest = indicesOfNearest;
  exports.indexOfNearest = indexOfNearest;
  function minMax(arr) {
    var len = arr.length;
    var min = Infinity;
    var max = -Infinity;
    while (len--) {
      var el = arr[len];
      if (el == null) {} else if (el < min) {
        min = el;
      } else if (el > max) {
        max = el;
      }
    }
    if (min === Infinity) {
      min = max;
    } else if (max === -Infinity) {
      max = min;
    }
    if (min === Infinity || min === -Infinity) {
      min = null;
      max = null;
    }
    return [min, max];
  }
  function indicesOfNearest(a, x) {
    if (a.length === 0) {
      throw new Error('Array must have at least one element');
    }
    var lo = -1;
    var hi = a.length;
    var ascending = a.length === 1 || a[0] < a[1];
    if (ascending) {
      while (hi - lo > 1) {
        var mid = Math.round((lo + hi) / 2);
        if (a[mid] <= x) {
          lo = mid;
        } else {
          hi = mid;
        }
      }
    } else {
      while (hi - lo > 1) {
        var _mid = Math.round((lo + hi) / 2);
        if (a[_mid] >= x) {
          lo = _mid;
        } else {
          hi = _mid;
        }
      }
    }
    if (a[lo] === x)
      hi = lo;
    if (lo === -1)
      lo = hi;
    if (hi === a.length)
      hi = lo;
    return [lo, hi];
  }
  function indexOfNearest(a, x) {
    var i = indicesOfNearest(a, x);
    var lo = i[0];
    var hi = i[1];
    if (Math.abs(x - a[lo]) <= Math.abs(x - a[hi])) {
      return lo;
    } else {
      return hi;
    }
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("29", ["28"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, "__esModule", {value: true});
  var _slicedToArray = function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  var _LongitudeAxisIndex;
  exports.getReferenceObject = getReferenceObject;
  exports.getHorizontalCRSReferenceObject = getHorizontalCRSReferenceObject;
  exports.isEllipsoidalCRS = isEllipsoidalCRS;
  exports.getProjection = getProjection;
  exports.reproject = reproject;
  exports.getLongitudeWrapper = getLongitudeWrapper;
  exports.isLongitudeAxis = isLongitudeAxis;
  exports.isISODateAxis = isISODateAxis;
  exports.asTime = asTime;
  var _constants = req('28');
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0,
          arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var OPENGIS_CRS_PREFIX = 'http://www.opengis.net/def/crs/';
  var EPSG4979 = OPENGIS_CRS_PREFIX + 'EPSG/0/4979';
  var EPSG4326 = OPENGIS_CRS_PREFIX + 'EPSG/0/4326';
  var CRS84 = OPENGIS_CRS_PREFIX + 'OGC/1.3/CRS84';
  var EllipsoidalCRSs = [EPSG4979, EPSG4326, CRS84];
  var LongitudeAxisIndex = (_LongitudeAxisIndex = {}, _defineProperty(_LongitudeAxisIndex, EPSG4979, 1), _defineProperty(_LongitudeAxisIndex, EPSG4326, 1), _defineProperty(_LongitudeAxisIndex, CRS84, 0), _LongitudeAxisIndex);
  function getReferenceObject(domain, component) {
    var ref = domain.referencing.find(function(ref) {
      return ref.components.indexOf(component) !== -1;
    });
    return ref;
  }
  function getHorizontalCRSReferenceObject(domain) {
    var isHorizontal = function isHorizontal(ref) {
      return ['GeodeticCRS', 'ProjectedCRS'].indexOf(ref.system.type) !== -1 && ref.components.length === 2;
    };
    var ref = domain.referencing.find(isHorizontal);
    return ref;
  }
  function isEllipsoidalCRS(rs) {
    return EllipsoidalCRSs.indexOf(rs.id) !== -1;
  }
  function getProjection(domain) {
    var ref = domain.referencing.find(function(ref) {
      return isEllipsoidalCRS(ref.system);
    });
    if (!ref) {
      return;
    }
    var lonIdx = LongitudeAxisIndex[ref.system.id];
    if (lonIdx > 1) {
      throw new Error();
    }
    var lonComponent = ref.components[lonIdx];
    var lonMin = void 0,
        lonMax = void 0;
    if (domain.axes.has(lonComponent)) {
      var lonAxisName = lonComponent;
      var lonAxisVals = domain.axes.get(lonAxisName).values;
      lonMin = lonAxisVals[0];
      lonMax = lonAxisVals[lonAxisVals.length - 1];
      if (lonMin > lonMax) {
        var _ref = [lonMax, lonMin];
        lonMin = _ref[0];
        lonMax = _ref[1];
      }
    } else {
      var axes = [].concat(_toConsumableArray(domain.axes.values()));
      var axis = axes.find(function(axis) {
        return axis.components.indexOf(lonComponent) !== -1;
      });
      var lonCompIdx = axis.components.indexOf(lonComponent);
      lonMin = Infinity;
      lonMax = -Infinity;
      if (axis.dataType === _constants.COVJSON_DATATYPE_TUPLE) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;
        try {
          for (var _iterator = axis.values[Symbol.iterator](),
              _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var tuple = _step.value;
            var lon = tuple[lonCompIdx];
            lonMin = Math.min(lon, lonMin);
            lonMax = Math.max(lon, lonMax);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else if (axis.dataType === _constants.COVJSON_DATATYPE_POLYGON) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;
        try {
          for (var _iterator2 = axis.values[Symbol.iterator](),
              _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var poly = _step2.value;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;
            try {
              for (var _iterator3 = poly[Symbol.iterator](),
                  _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var ring = _step3.value;
                var _iteratorNormalCompletion4 = true;
                var _didIteratorError4 = false;
                var _iteratorError4 = undefined;
                try {
                  for (var _iterator4 = ring[Symbol.iterator](),
                      _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var point = _step4.value;
                    var _lon = point[lonCompIdx];
                    lonMin = Math.min(_lon, lonMin);
                    lonMax = Math.max(_lon, lonMax);
                  }
                } catch (err) {
                  _didIteratorError4 = true;
                  _iteratorError4 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                      _iterator4.return();
                    }
                  } finally {
                    if (_didIteratorError4) {
                      throw _iteratorError4;
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      } else {
        throw new Error('Unsupported data type: ' + axis.dataType);
      }
    }
    var lonMid = (lonMax + lonMin) / 2;
    var lonMinExtended = lonMid - 180;
    var lonMaxExtended = lonMid + 180;
    return {
      project: function project(_ref2) {
        var lon = _ref2.lon;
        var lat = _ref2.lat;
        var lonProjected = void 0;
        if (lonMinExtended <= lon && lon <= lonMaxExtended) {
          lonProjected = lon;
        } else {
          lonProjected = ((lon - lonMinExtended) % 360 + 360) % 360 + lonMinExtended;
        }
        var _ref3 = lonIdx === 0 ? [lonProjected, lat] : [lat, lonProjected];
        var _ref4 = _slicedToArray(_ref3, 2);
        var x = _ref4[0];
        var y = _ref4[1];
        return {
          x: x,
          y: y
        };
      },
      unproject: function unproject(_ref5) {
        var x = _ref5.x;
        var y = _ref5.y;
        var _ref6 = lonIdx === 0 ? [x, y] : [y, x];
        var _ref7 = _slicedToArray(_ref6, 2);
        var lon = _ref7[0];
        var lat = _ref7[1];
        return {
          lon: lon,
          lat: lat
        };
      }
    };
  }
  function reproject(pos, fromProjection, toProjection) {
    return toProjection.project(fromProjection.unproject(pos));
  }
  function getLongitudeWrapper(domain, axisName) {
    if (!isLongitudeAxis(domain, axisName)) {
      throw new Error('\'' + axisName + '\' is not a longitude axis');
    }
    var vals = domain.axes.get(axisName).values;
    var lon_min = vals[0];
    var lon_max = vals[vals.length - 1];
    if (lon_min > lon_max) {
      var _ref8 = [lon_max, lon_min];
      lon_min = _ref8[0];
      lon_max = _ref8[1];
    }
    var x_mid = (lon_max + lon_min) / 2;
    var x_min = x_mid - 180;
    var x_max = x_mid + 180;
    return function(lon) {
      if (x_min <= lon && lon <= x_max) {
        return lon;
      } else {
        return ((lon - x_min) % 360 + 360) % 360 + x_min;
      }
    };
  }
  function isLongitudeAxis(domain, axisName) {
    var ref = getReferenceObject(domain, axisName);
    if (!ref) {
      return false;
    }
    var crsId = ref.system.id;
    if (EllipsoidalCRSs.indexOf(crsId) === -1) {
      return false;
    }
    var compIdx = ref.components.indexOf(axisName);
    var isLongitude = LongitudeAxisIndex[crsId] === compIdx;
    return isLongitude;
  }
  function isISODateAxis(domain, axisName) {
    var val = domain.axes.get(axisName).values[0];
    if (typeof val !== 'string') {
      return false;
    }
    return !isNaN(new Date(val).getTime());
  }
  function asTime(inp) {
    var res = void 0;
    var err = false;
    if (typeof inp === 'string') {
      res = new Date(inp).getTime();
    } else if (inp instanceof Date) {
      res = inp.getTime();
    } else {
      err = true;
    }
    if (isNaN(res)) {
      err = true;
    }
    if (err) {
      throw new Error('Invalid date: ' + inp);
    }
    return res;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2b", ["29", "8f", "73", "28"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, "__esModule", {value: true});
  var _slicedToArray = function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  exports.subsetByBbox = subsetByBbox;
  exports.subsetByIndex = subsetByIndex;
  exports.subsetByValue = subsetByValue;
  var _referencing = req('29');
  var _subset = req('8f');
  var _array = req('73');
  var _constants = req('28');
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0,
          arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function subsetByBbox(cov, bbox) {
    var _cov$subsetByValue;
    var axes = arguments.length <= 2 || arguments[2] === undefined ? ['x', 'y'] : arguments[2];
    var _bbox = _slicedToArray(bbox, 4);
    var xmin = _bbox[0];
    var ymin = _bbox[1];
    var xmax = _bbox[2];
    var ymax = _bbox[3];
    return cov.subsetByValue((_cov$subsetByValue = {}, _defineProperty(_cov$subsetByValue, axes[0], {
      start: xmin,
      stop: xmax
    }), _defineProperty(_cov$subsetByValue, axes[1], {
      start: ymin,
      stop: ymax
    }), _cov$subsetByValue));
  }
  function subsetByIndex(cov, constraints) {
    return cov.loadDomain().then(function(domain) {
      constraints = (0, _subset.normalizeIndexSubsetConstraints)(domain, constraints);
      var newdomain = (0, _subset.subsetByIndex)(domain, constraints);
      var rangeWrapper = function rangeWrapper(range) {
        var newrange = {
          dataType: range.dataType,
          get: function get(obj) {
            var newobj = {};
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;
            try {
              for (var _iterator = Object.keys(obj)[Symbol.iterator](),
                  _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var axisName = _step.value;
                var _constraints$axisName = constraints[axisName];
                var start = _constraints$axisName.start;
                var step = _constraints$axisName.step;
                newobj[axisName] = start + obj[axisName] * step;
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
            return range.get(newobj);
          }
        };
        newrange.shape = new Map();
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;
        try {
          for (var _iterator2 = domain.axes.keys()[Symbol.iterator](),
              _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var axisName = _step2.value;
            var size = newdomain.axes.get(axisName).values.length;
            newrange.shape.set(axisName, size);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        return newrange;
      };
      var loadRange = function loadRange(key) {
        return cov.loadRange(key).then(rangeWrapper);
      };
      var loadRanges = function loadRanges(keys) {
        return cov.loadRanges(keys).then(function(ranges) {
          return new Map([].concat(_toConsumableArray(ranges)).map(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 2);
            var key = _ref2[0];
            var range = _ref2[1];
            return [key, rangeWrapper(range)];
          }));
        });
      };
      var newcov = {
        type: _constants.COVERAGE,
        domainType: cov.domainType,
        parameters: cov.parameters,
        loadDomain: function loadDomain() {
          return Promise.resolve(newdomain);
        },
        loadRange: loadRange,
        loadRanges: loadRanges
      };
      newcov.subsetByIndex = subsetByIndex.bind(null, newcov);
      newcov.subsetByValue = subsetByValue.bind(null, newcov);
      return newcov;
    });
  }
  function subsetByValue(cov, constraints) {
    return cov.loadDomain().then(function(domain) {
      var indexConstraints = {};
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;
      try {
        for (var _iterator3 = Object.keys(constraints)[Symbol.iterator](),
            _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var axisName = _step3.value;
          var spec = constraints[axisName];
          if (spec === undefined || spec === null || !domain.axes.has(axisName)) {
            continue;
          }
          var axis = domain.axes.get(axisName);
          var vals = axis.values;
          var isISODate = (0, _referencing.isISODateAxis)(domain, axisName);
          var isLongitude = (0, _referencing.isLongitudeAxis)(domain, axisName);
          var lonWrapper = isLongitude ? (0, _referencing.getLongitudeWrapper)(domain, axisName) : undefined;
          if (typeof spec === 'number' || typeof spec === 'string' || spec instanceof Date) {
            var match = spec;
            if (isISODate) {
              match = (0, _referencing.asTime)(match);
              vals = vals.map(function(v) {
                return new Date(v).getTime();
              });
            } else if (isLongitude) {
              match = lonWrapper(match);
            }
            var i = void 0;
            if (vals.indexOf) {
              i = vals.indexOf(match);
            } else {
              i = Array.prototype.indexOf.call(vals, match);
            }
            if (i === -1) {
              throw new Error('Domain value not found: ' + spec);
            }
            indexConstraints[axisName] = i;
          } else if ('target' in spec) {
            var target = spec.target;
            if (isISODate) {
              target = (0, _referencing.asTime)(target);
              vals = vals.map(function(v) {
                return new Date(v).getTime();
              });
            } else if (isLongitude) {
              target = lonWrapper(target);
            } else if (typeof vals[0] !== 'number' || typeof target !== 'number') {
              throw new Error('Invalid axis or constraint value type');
            }
            var _i = (0, _array.indexOfNearest)(vals, target);
            indexConstraints[axisName] = _i;
          } else if ('start' in spec && 'stop' in spec) {
            var start = spec.start;
            var stop = spec.stop;
            if (isISODate) {
              var _ref3 = [(0, _referencing.asTime)(start), (0, _referencing.asTime)(stop)];
              start = _ref3[0];
              stop = _ref3[1];
              vals = vals.map(function(v) {
                return new Date(v).getTime();
              });
            } else if (isLongitude) {
              var _ref4 = [lonWrapper(start), lonWrapper(stop)];
              start = _ref4[0];
              stop = _ref4[1];
            } else if (typeof vals[0] !== 'number' || typeof start !== 'number') {
              throw new Error('Invalid axis or constraint value type');
            }
            var _indicesOfNearest = (0, _array.indicesOfNearest)(vals, start);
            var _indicesOfNearest2 = _slicedToArray(_indicesOfNearest, 2);
            var lo1 = _indicesOfNearest2[0];
            var hi1 = _indicesOfNearest2[1];
            var _indicesOfNearest3 = (0, _array.indicesOfNearest)(vals, stop);
            var _indicesOfNearest4 = _slicedToArray(_indicesOfNearest3, 2);
            var lo2 = _indicesOfNearest4[0];
            var hi2 = _indicesOfNearest4[1];
            var imin = Math.min(lo1, hi1, lo2, hi2);
            var imax = Math.max(lo1, hi1, lo2, hi2) + 1;
            indexConstraints[axisName] = {
              start: imin,
              stop: imax
            };
          } else {
            throw new Error('Invalid subset constraints');
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
      return cov.subsetByIndex(indexConstraints);
    });
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("28", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, "__esModule", {value: true});
  var DOMAIN = exports.DOMAIN = 'Domain';
  var COVERAGE = exports.COVERAGE = 'Coverage';
  var COVERAGECOLLECTION = exports.COVERAGECOLLECTION = COVERAGE + 'Collection';
  var COVJSON_PREFIX = 'http://coveragejson.org/def#';
  var COVJSON_DATATYPE_TUPLE = exports.COVJSON_DATATYPE_TUPLE = COVJSON_PREFIX + 'Tuple';
  var COVJSON_DATATYPE_POLYGON = exports.COVJSON_DATATYPE_POLYGON = COVJSON_PREFIX + 'Polygon';
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("8f", ["28"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.normalizeIndexSubsetConstraints = normalizeIndexSubsetConstraints;
  exports.subsetByIndex = subsetByIndex;
  var _constants = req('28');
  function normalizeIndexSubsetConstraints(domain, constraints) {
    var normalizedConstraints = {};
    for (var axisName in constraints) {
      if (!domain.axes.has(axisName)) {
        continue;
      }
      if (constraints[axisName] === undefined || constraints[axisName] === null) {
        continue;
      }
      if (typeof constraints[axisName] === 'number') {
        var constraint = constraints[axisName];
        normalizedConstraints[axisName] = {
          start: constraint,
          stop: constraint + 1
        };
      } else {
        normalizedConstraints[axisName] = constraints[axisName];
      }
      var _normalizedConstraint = normalizedConstraints[axisName];
      var _normalizedConstraint2 = _normalizedConstraint.start;
      var start = _normalizedConstraint2 === undefined ? 0 : _normalizedConstraint2;
      var _normalizedConstraint3 = _normalizedConstraint.stop;
      var stop = _normalizedConstraint3 === undefined ? domain.axes.get(axisName).values.length : _normalizedConstraint3;
      var _normalizedConstraint4 = _normalizedConstraint.step;
      var step = _normalizedConstraint4 === undefined ? 1 : _normalizedConstraint4;
      if (step <= 0) {
        throw new Error('Invalid constraint for ' + axisName + ': step=' + step + ' must be > 0');
      }
      if (start >= stop || start < 0) {
        throw new Error('Invalid constraint for ' + axisName + ': stop=' + stop + ' must be > start=' + start + ' and both >= 0');
      }
      normalizedConstraints[axisName] = {
        start: start,
        stop: stop,
        step: step
      };
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;
    try {
      for (var _iterator = domain.axes.keys()[Symbol.iterator](),
          _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _axisName = _step.value;
        if (!(_axisName in normalizedConstraints)) {
          var len = domain.axes.get(_axisName).values.length;
          normalizedConstraints[_axisName] = {
            start: 0,
            stop: len,
            step: 1
          };
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return normalizedConstraints;
  }
  function subsetByIndex(domain, constraints) {
    constraints = normalizeIndexSubsetConstraints(domain, constraints);
    var newdomain = {
      type: _constants.DOMAIN,
      domainType: domain.domainType,
      axes: new Map(domain.axes),
      referencing: domain.referencing
    };
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;
    try {
      var _loop = function _loop() {
        var axisName = _step2.value;
        var axis = domain.axes.get(axisName);
        var coords = axis.values;
        var bounds = axis.bounds;
        var constraint = constraints[axisName];
        var newcoords = void 0;
        var newbounds = void 0;
        var start = constraint.start;
        var stop = constraint.stop;
        var step = constraint.step;
        if (start === 0 && stop === coords.length && step === 1) {
          newcoords = coords;
          newbounds = bounds;
        } else if (step === 1) {
          if (coords.subarray) {
            newcoords = coords.subarray(start, stop);
          } else {
            newcoords = coords.slice(start, stop);
          }
          if (bounds) {
            newbounds = {get: function get(i) {
                return bounds.get(start + i);
              }};
          }
        } else {
          var q = Math.trunc((stop - start) / step);
          var r = (stop - start) % step;
          var len = q + r;
          newcoords = new coords.constructor(len);
          for (var i = start,
              j = 0; i < stop; i += step, j++) {
            newcoords[j] = coords[i];
          }
          if (bounds) {
            newbounds = {get: function get(i) {
                return bounds.get(start + i * step);
              }};
          }
        }
        var newaxis = {
          dataType: axis.dataType,
          components: axis.components,
          values: newcoords,
          bounds: newbounds
        };
        newdomain.axes.set(axisName, newaxis);
      };
      for (var _iterator2 = Object.keys(constraints)[Symbol.iterator](),
          _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        _loop();
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
    return newdomain;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("90", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = Array.isArray || function(arr) {
    return toString.call(arr) == '[object Array]';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("91", ["90"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('90');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("92", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e,
        m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity);
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e,
        m,
        c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    buffer[offset + i - d] |= s * 128;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("93", ["92"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('92');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("94", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  ;
  (function(exports) {
    'use strict';
    var Arr = (typeof Uint8Array !== 'undefined') ? Uint8Array : Array;
    var PLUS = '+'.charCodeAt(0);
    var SLASH = '/'.charCodeAt(0);
    var NUMBER = '0'.charCodeAt(0);
    var LOWER = 'a'.charCodeAt(0);
    var UPPER = 'A'.charCodeAt(0);
    var PLUS_URL_SAFE = '-'.charCodeAt(0);
    var SLASH_URL_SAFE = '_'.charCodeAt(0);
    function decode(elt) {
      var code = elt.charCodeAt(0);
      if (code === PLUS || code === PLUS_URL_SAFE)
        return 62;
      if (code === SLASH || code === SLASH_URL_SAFE)
        return 63;
      if (code < NUMBER)
        return -1;
      if (code < NUMBER + 10)
        return code - NUMBER + 26 + 26;
      if (code < UPPER + 26)
        return code - UPPER;
      if (code < LOWER + 26)
        return code - LOWER + 26;
    }
    function b64ToByteArray(b64) {
      var i,
          j,
          l,
          tmp,
          placeHolders,
          arr;
      if (b64.length % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
      }
      var len = b64.length;
      placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
      arr = new Arr(b64.length * 3 / 4 - placeHolders);
      l = placeHolders > 0 ? b64.length - 4 : b64.length;
      var L = 0;
      function push(v) {
        arr[L++] = v;
      }
      for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));
        push((tmp & 0xFF0000) >> 16);
        push((tmp & 0xFF00) >> 8);
        push(tmp & 0xFF);
      }
      if (placeHolders === 2) {
        tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);
        push(tmp & 0xFF);
      } else if (placeHolders === 1) {
        tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);
        push((tmp >> 8) & 0xFF);
        push(tmp & 0xFF);
      }
      return arr;
    }
    function uint8ToBase64(uint8) {
      var i,
          extraBytes = uint8.length % 3,
          output = "",
          temp,
          length;
      function encode(num) {
        return lookup.charAt(num);
      }
      function tripletToBase64(num) {
        return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
      }
      for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
        temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
        output += tripletToBase64(temp);
      }
      switch (extraBytes) {
        case 1:
          temp = uint8[uint8.length - 1];
          output += encode(temp >> 2);
          output += encode((temp << 4) & 0x3F);
          output += '==';
          break;
        case 2:
          temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
          output += encode(temp >> 10);
          output += encode((temp >> 4) & 0x3F);
          output += encode((temp << 2) & 0x3F);
          output += '=';
          break;
      }
      return output;
    }
    exports.toByteArray = b64ToByteArray;
    exports.fromByteArray = uint8ToBase64;
  }(typeof exports === 'undefined' ? (this.base64js = {}) : exports));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("95", ["94"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('94');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("96", ["95", "93", "91"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var base64 = req('95');
  var ieee754 = req('93');
  var isArray = req('91');
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  Buffer.poolSize = 8192;
  var rootParent = {};
  Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
  function typedArraySupport() {
    function Bar() {}
    try {
      var arr = new Uint8Array(1);
      arr.foo = function() {
        return 42;
      };
      arr.constructor = Bar;
      return arr.foo() === 42 && arr.constructor === Bar && typeof arr.subarray === 'function' && arr.subarray(1, 1).byteLength === 0;
    } catch (e) {
      return false;
    }
  }
  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }
  function Buffer(arg) {
    if (!(this instanceof Buffer)) {
      if (arguments.length > 1)
        return new Buffer(arg, arguments[1]);
      return new Buffer(arg);
    }
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      this.length = 0;
      this.parent = undefined;
    }
    if (typeof arg === 'number') {
      return fromNumber(this, arg);
    }
    if (typeof arg === 'string') {
      return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8');
    }
    return fromObject(this, arg);
  }
  function fromNumber(that, length) {
    that = allocate(that, length < 0 ? 0 : checked(length) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < length; i++) {
        that[i] = 0;
      }
    }
    return that;
  }
  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '')
      encoding = 'utf8';
    var length = byteLength(string, encoding) | 0;
    that = allocate(that, length);
    that.write(string, encoding);
    return that;
  }
  function fromObject(that, object) {
    if (Buffer.isBuffer(object))
      return fromBuffer(that, object);
    if (isArray(object))
      return fromArray(that, object);
    if (object == null) {
      throw new TypeError('must start with number, buffer, array or string');
    }
    if (typeof ArrayBuffer !== 'undefined') {
      if (object.buffer instanceof ArrayBuffer) {
        return fromTypedArray(that, object);
      }
      if (object instanceof ArrayBuffer) {
        return fromArrayBuffer(that, object);
      }
    }
    if (object.length)
      return fromArrayLike(that, object);
    return fromJsonObject(that, object);
  }
  function fromBuffer(that, buffer) {
    var length = checked(buffer.length) | 0;
    that = allocate(that, length);
    buffer.copy(that, 0, 0, length);
    return that;
  }
  function fromArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromTypedArray(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      array.byteLength;
      that = Buffer._augment(new Uint8Array(array));
    } else {
      that = fromTypedArray(that, new Uint8Array(array));
    }
    return that;
  }
  function fromArrayLike(that, array) {
    var length = checked(array.length) | 0;
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromJsonObject(that, object) {
    var array;
    var length = 0;
    if (object.type === 'Buffer' && isArray(object.data)) {
      array = object.data;
      length = checked(array.length) | 0;
    }
    that = allocate(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  } else {
    Buffer.prototype.length = undefined;
    Buffer.prototype.parent = undefined;
  }
  function allocate(that, length) {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      that = Buffer._augment(new Uint8Array(length));
      that.__proto__ = Buffer.prototype;
    } else {
      that.length = length;
      that._isBuffer = true;
    }
    var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1;
    if (fromPool)
      that.parent = rootParent;
    return that;
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
    }
    return length | 0;
  }
  function SlowBuffer(subject, encoding) {
    if (!(this instanceof SlowBuffer))
      return new SlowBuffer(subject, encoding);
    var buf = new Buffer(subject, encoding);
    delete buf.parent;
    return buf;
  }
  Buffer.isBuffer = function isBuffer(b) {
    return !!(b != null && b._isBuffer);
  };
  Buffer.compare = function compare(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }
    if (a === b)
      return 0;
    var x = a.length;
    var y = b.length;
    var i = 0;
    var len = Math.min(x, y);
    while (i < len) {
      if (a[i] !== b[i])
        break;
      ++i;
    }
    if (i !== len) {
      x = a[i];
      y = b[i];
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'raw':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat(list, length) {
    if (!isArray(list))
      throw new TypeError('list argument must be an Array of Buffers.');
    if (list.length === 0) {
      return new Buffer(0);
    }
    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; i++) {
        length += list[i].length;
      }
    }
    var buf = new Buffer(length);
    var pos = 0;
    for (i = 0; i < list.length; i++) {
      var item = list[i];
      item.copy(buf, pos);
      pos += item.length;
    }
    return buf;
  };
  function byteLength(string, encoding) {
    if (typeof string !== 'string')
      string = '' + string;
    var len = string.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'ascii':
        case 'binary':
        case 'raw':
        case 'raws':
          return len;
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;
        case 'hex':
          return len >>> 1;
        case 'base64':
          return base64ToBytes(string).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string).length;
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    start = start | 0;
    end = end === undefined || end === Infinity ? this.length : end | 0;
    if (!encoding)
      encoding = 'utf8';
    if (start < 0)
      start = 0;
    if (end > this.length)
      end = this.length;
    if (end <= start)
      return '';
    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);
        case 'ascii':
          return asciiSlice(this, start, end);
        case 'binary':
          return binarySlice(this, start, end);
        case 'base64':
          return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0)
      return '';
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return true;
    return Buffer.compare(this, b) === 0;
  };
  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max)
        str += ' ... ';
    }
    return '<Buffer ' + str + '>';
  };
  Buffer.prototype.compare = function compare(b) {
    if (!Buffer.isBuffer(b))
      throw new TypeError('Argument must be a Buffer');
    if (this === b)
      return 0;
    return Buffer.compare(this, b);
  };
  Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
    if (byteOffset > 0x7fffffff)
      byteOffset = 0x7fffffff;
    else if (byteOffset < -0x80000000)
      byteOffset = -0x80000000;
    byteOffset >>= 0;
    if (this.length === 0)
      return -1;
    if (byteOffset >= this.length)
      return -1;
    if (byteOffset < 0)
      byteOffset = Math.max(this.length + byteOffset, 0);
    if (typeof val === 'string') {
      if (val.length === 0)
        return -1;
      return String.prototype.indexOf.call(this, val, byteOffset);
    }
    if (Buffer.isBuffer(val)) {
      return arrayIndexOf(this, val, byteOffset);
    }
    if (typeof val === 'number') {
      if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
        return Uint8Array.prototype.indexOf.call(this, val, byteOffset);
      }
      return arrayIndexOf(this, [val], byteOffset);
    }
    function arrayIndexOf(arr, val, byteOffset) {
      var foundIndex = -1;
      for (var i = 0; byteOffset + i < arr.length; i++) {
        if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === val.length)
            return byteOffset + foundIndex;
        } else {
          foundIndex = -1;
        }
      }
      return -1;
    }
    throw new TypeError('val must be string, number or Buffer');
  };
  Buffer.prototype.get = function get(offset) {
    console.log('.get() is deprecated. Access using array indexes instead.');
    return this.readUInt8(offset);
  };
  Buffer.prototype.set = function set(v, offset) {
    console.log('.set() is deprecated. Access using array indexes instead.');
    return this.writeUInt8(v, offset);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new Error('Invalid hex string');
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; i++) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed))
        throw new Error('Invalid hex string');
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function binaryWrite(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined)
          encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      var swap = encoding;
      encoding = offset;
      offset = length | 0;
      length = swap;
    }
    var remaining = this.length - offset;
    if (length === undefined || length > remaining)
      length = remaining;
    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('attempt to write outside buffer bounds');
    }
    if (!encoding)
      encoding = 'utf8';
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);
        case 'ascii':
          return asciiWrite(this, string, offset, length);
        case 'binary':
          return binaryWrite(this, string, offset, length);
        case 'base64':
          return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4 : (firstByte > 0xDF) ? 3 : (firstByte > 0xBF) ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte,
            thirdByte,
            fourthByte,
            tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 0x1000;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }
  function binarySlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; i++) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = '';
    for (var i = start; i < end; i++) {
      out += toHex(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = Buffer._augment(this.subarray(start, end));
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; i++) {
        newBuf[i] = this[i + start];
      }
    }
    if (newBuf.length)
      newBuf.parent = this.parent || this;
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0)
      throw new RangeError('offset is not uint');
    if (offset + ext > length)
      throw new RangeError('Trying to access beyond buffer length');
  }
  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }
    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }
    return val;
  };
  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8);
  };
  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1];
  };
  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000);
  };
  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);
  };
  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80))
      return (this[offset]);
    return ((0xff - this[offset] + 1) * -1);
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3]);
  };
  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf))
      throw new TypeError('buffer must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
  }
  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert)
      checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0);
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1;
  };
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 2); i < j; i++) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 0xffffffff + value + 1;
    for (var i = 0,
        j = Math.min(buf.length - offset, 4); i < j; i++) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }
  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = value < 0 ? 1 : 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    if (value < 0)
      value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0)
      value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (value > max || value < min)
      throw new RangeError('value is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError('index out of range');
    if (offset < 0)
      throw new RangeError('index out of range');
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length)
      throw new RangeError('sourceStart out of bounds');
    if (end < 0)
      throw new RangeError('sourceEnd out of bounds');
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    var i;
    if (this === target && start < targetStart && targetStart < end) {
      for (i = len - 1; i >= 0; i--) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      for (i = 0; i < len; i++) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      target._set(this.subarray(start, start + len), targetStart);
    }
    return len;
  };
  Buffer.prototype.fill = function fill(value, start, end) {
    if (!value)
      value = 0;
    if (!start)
      start = 0;
    if (!end)
      end = this.length;
    if (end < start)
      throw new RangeError('end < start');
    if (end === start)
      return;
    if (this.length === 0)
      return;
    if (start < 0 || start >= this.length)
      throw new RangeError('start out of bounds');
    if (end < 0 || end > this.length)
      throw new RangeError('end out of bounds');
    var i;
    if (typeof value === 'number') {
      for (i = start; i < end; i++) {
        this[i] = value;
      }
    } else {
      var bytes = utf8ToBytes(value.toString());
      var len = bytes.length;
      for (i = start; i < end; i++) {
        this[i] = bytes[i % len];
      }
    }
    return this;
  };
  Buffer.prototype.toArrayBuffer = function toArrayBuffer() {
    if (typeof Uint8Array !== 'undefined') {
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        return (new Buffer(this)).buffer;
      } else {
        var buf = new Uint8Array(this.length);
        for (var i = 0,
            len = buf.length; i < len; i += 1) {
          buf[i] = this[i];
        }
        return buf.buffer;
      }
    } else {
      throw new TypeError('Buffer.toArrayBuffer not supported in this browser');
    }
  };
  var BP = Buffer.prototype;
  Buffer._augment = function _augment(arr) {
    arr.constructor = Buffer;
    arr._isBuffer = true;
    arr._set = arr.set;
    arr.get = BP.get;
    arr.set = BP.set;
    arr.write = BP.write;
    arr.toString = BP.toString;
    arr.toLocaleString = BP.toString;
    arr.toJSON = BP.toJSON;
    arr.equals = BP.equals;
    arr.compare = BP.compare;
    arr.indexOf = BP.indexOf;
    arr.copy = BP.copy;
    arr.slice = BP.slice;
    arr.readUIntLE = BP.readUIntLE;
    arr.readUIntBE = BP.readUIntBE;
    arr.readUInt8 = BP.readUInt8;
    arr.readUInt16LE = BP.readUInt16LE;
    arr.readUInt16BE = BP.readUInt16BE;
    arr.readUInt32LE = BP.readUInt32LE;
    arr.readUInt32BE = BP.readUInt32BE;
    arr.readIntLE = BP.readIntLE;
    arr.readIntBE = BP.readIntBE;
    arr.readInt8 = BP.readInt8;
    arr.readInt16LE = BP.readInt16LE;
    arr.readInt16BE = BP.readInt16BE;
    arr.readInt32LE = BP.readInt32LE;
    arr.readInt32BE = BP.readInt32BE;
    arr.readFloatLE = BP.readFloatLE;
    arr.readFloatBE = BP.readFloatBE;
    arr.readDoubleLE = BP.readDoubleLE;
    arr.readDoubleBE = BP.readDoubleBE;
    arr.writeUInt8 = BP.writeUInt8;
    arr.writeUIntLE = BP.writeUIntLE;
    arr.writeUIntBE = BP.writeUIntBE;
    arr.writeUInt16LE = BP.writeUInt16LE;
    arr.writeUInt16BE = BP.writeUInt16BE;
    arr.writeUInt32LE = BP.writeUInt32LE;
    arr.writeUInt32BE = BP.writeUInt32BE;
    arr.writeIntLE = BP.writeIntLE;
    arr.writeIntBE = BP.writeIntBE;
    arr.writeInt8 = BP.writeInt8;
    arr.writeInt16LE = BP.writeInt16LE;
    arr.writeInt16BE = BP.writeInt16BE;
    arr.writeInt32LE = BP.writeInt32LE;
    arr.writeInt32BE = BP.writeInt32BE;
    arr.writeFloatLE = BP.writeFloatLE;
    arr.writeFloatBE = BP.writeFloatBE;
    arr.writeDoubleLE = BP.writeDoubleLE;
    arr.writeDoubleBE = BP.writeDoubleBE;
    arr.fill = BP.fill;
    arr.inspect = BP.inspect;
    arr.toArrayBuffer = BP.toArrayBuffer;
    return arr;
  };
  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    if (str.length < 2)
      return '';
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }
  function toHex(n) {
    if (n < 16)
      return '0' + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; i++) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        if (!leadSurrogate) {
          if (codePoint > 0xDBFF) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1)
            bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(0xEF, 0xBF, 0xBD);
      }
      leadSurrogate = null;
      if (codePoint < 0x80) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c,
        hi,
        lo;
    var byteArray = [];
    for (var i = 0; i < str.length; i++) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; i++) {
      if ((i + offset >= dst.length) || (i >= src.length))
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("97", ["96"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('96');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("98", ["97"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? $__System._nodeRequire('buffer') : req('97');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("99", ["98"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('98');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9a", ["99"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(Buffer) {
    module.exports = function(obj) {
      return !!(obj != null && (obj._isBuffer || (obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj))));
    };
  })(req('99').Buffer);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9b", ["9a"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('9a');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9c", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  function iota(n) {
    var result = new Array(n);
    for (var i = 0; i < n; ++i) {
      result[i] = i;
    }
    return result;
  }
  module.exports = iota;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9d", ["9c"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('9c');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9e", ["9d", "9b"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var iota = req('9d');
  var isBuffer = req('9b');
  var hasTypedArrays = ((typeof Float64Array) !== "undefined");
  function compare1st(a, b) {
    return a[0] - b[0];
  }
  function order() {
    var stride = this.stride;
    var terms = new Array(stride.length);
    var i;
    for (i = 0; i < terms.length; ++i) {
      terms[i] = [Math.abs(stride[i]), i];
    }
    terms.sort(compare1st);
    var result = new Array(terms.length);
    for (i = 0; i < result.length; ++i) {
      result[i] = terms[i][1];
    }
    return result;
  }
  function compileConstructor(dtype, dimension) {
    var className = ["View", dimension, "d", dtype].join("");
    if (dimension < 0) {
      className = "View_Nil" + dtype;
    }
    var useGetters = (dtype === "generic");
    if (dimension === -1) {
      var code = "function " + className + "(a){this.data=a;};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new " + className + "(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_" + className + "(a){return new " + className + "(a);}";
      var procedure = new Function(code);
      return procedure();
    } else if (dimension === 0) {
      var code = "function " + className + "(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function " + className + "_copy() {\
return new " + className + "(this.data,this.offset)\
};\
proto.pick=function " + className + "_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function " + className + "_get(){\
return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};\
proto.set=function " + className + "_set(v){\
return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "\
};\
return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
      var procedure = new Function("TrivialArray", code);
      return procedure(CACHED_CONSTRUCTORS[dtype][0]);
    }
    var code = ["'use strict'"];
    var indices = iota(dimension);
    var args = indices.map(function(i) {
      return "i" + i;
    });
    var index_str = "this.offset+" + indices.map(function(i) {
      return "this.stride[" + i + "]*i" + i;
    }).join("+");
    var shapeArg = indices.map(function(i) {
      return "b" + i;
    }).join(",");
    var strideArg = indices.map(function(i) {
      return "c" + i;
    }).join(",");
    code.push("function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a", "this.shape=[" + shapeArg + "]", "this.stride=[" + strideArg + "]", "this.offset=d|0}", "var proto=" + className + ".prototype", "proto.dtype='" + dtype + "'", "proto.dimension=" + dimension);
    code.push("Object.defineProperty(proto,'size',{get:function " + className + "_size(){\
return " + indices.map(function(i) {
      return "this.shape[" + i + "]";
    }).join("*"), "}})");
    if (dimension === 1) {
      code.push("proto.order=[0]");
    } else {
      code.push("Object.defineProperty(proto,'order',{get:");
      if (dimension < 4) {
        code.push("function " + className + "_order(){");
        if (dimension === 2) {
          code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
        } else if (dimension === 3) {
          code.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})");
        }
      } else {
        code.push("ORDER})");
      }
    }
    code.push("proto.set=function " + className + "_set(" + args.join(",") + ",v){");
    if (useGetters) {
      code.push("return this.data.set(" + index_str + ",v)}");
    } else {
      code.push("return this.data[" + index_str + "]=v}");
    }
    code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");
    if (useGetters) {
      code.push("return this.data.get(" + index_str + ")}");
    } else {
      code.push("return this.data[" + index_str + "]}");
    }
    code.push("proto.index=function " + className + "_index(", args.join(), "){return " + index_str + "}");
    code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function(i) {
      return ["(typeof i", i, "!=='number'||i", i, "<0)?this.shape[", i, "]:i", i, "|0"].join("");
    }).join(",") + "," + indices.map(function(i) {
      return "this.stride[" + i + "]";
    }).join(",") + ",this.offset)}");
    var a_vars = indices.map(function(i) {
      return "a" + i + "=this.shape[" + i + "]";
    });
    var c_vars = indices.map(function(i) {
      return "c" + i + "=this.stride[" + i + "]";
    });
    code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));
    for (var i = 0; i < dimension; ++i) {
      code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){\
d=i" + i + "|0;\
b+=c" + i + "*d;\
a" + i + "-=d}");
    }
    code.push("return new " + className + "(this.data," + indices.map(function(i) {
      return "a" + i;
    }).join(",") + "," + indices.map(function(i) {
      return "c" + i;
    }).join(",") + ",b)}");
    code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function(i) {
      return "a" + i + "=this.shape[" + i + "]";
    }).join(",") + "," + indices.map(function(i) {
      return "b" + i + "=this.stride[" + i + "]";
    }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");
    for (var i = 0; i < dimension; ++i) {
      code.push("if(typeof i" + i + "==='number'){\
d=i" + i + "|0;\
if(d<0){\
c+=b" + i + "*(a" + i + "-1);\
a" + i + "=ceil(-a" + i + "/d)\
}else{\
a" + i + "=ceil(a" + i + "/d)\
}\
b" + i + "*=d\
}");
    }
    code.push("return new " + className + "(this.data," + indices.map(function(i) {
      return "a" + i;
    }).join(",") + "," + indices.map(function(i) {
      return "b" + i;
    }).join(",") + ",c)}");
    var tShape = new Array(dimension);
    var tStride = new Array(dimension);
    for (var i = 0; i < dimension; ++i) {
      tShape[i] = "a[i" + i + "]";
      tStride[i] = "b[i" + i + "]";
    }
    code.push("proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function(n, idx) {
      return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
    }).join(";"), "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}");
    code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");
    for (var i = 0; i < dimension; ++i) {
      code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}");
    }
    code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}");
    code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function(i) {
      return "shape[" + i + "]";
    }).join(",") + "," + indices.map(function(i) {
      return "stride[" + i + "]";
    }).join(",") + ",offset)}");
    var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
    return procedure(CACHED_CONSTRUCTORS[dtype], order);
  }
  function arrayDType(data) {
    if (isBuffer(data)) {
      return "buffer";
    }
    if (hasTypedArrays) {
      switch (Object.prototype.toString.call(data)) {
        case "[object Float64Array]":
          return "float64";
        case "[object Float32Array]":
          return "float32";
        case "[object Int8Array]":
          return "int8";
        case "[object Int16Array]":
          return "int16";
        case "[object Int32Array]":
          return "int32";
        case "[object Uint8Array]":
          return "uint8";
        case "[object Uint16Array]":
          return "uint16";
        case "[object Uint32Array]":
          return "uint32";
        case "[object Uint8ClampedArray]":
          return "uint8_clamped";
      }
    }
    if (Array.isArray(data)) {
      return "array";
    }
    return "generic";
  }
  var CACHED_CONSTRUCTORS = {
    "float32": [],
    "float64": [],
    "int8": [],
    "int16": [],
    "int32": [],
    "uint8": [],
    "uint16": [],
    "uint32": [],
    "array": [],
    "uint8_clamped": [],
    "buffer": [],
    "generic": []
  };
  ;
  (function() {
    for (var id in CACHED_CONSTRUCTORS) {
      CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1));
    }
  });
  function wrappedNDArrayCtor(data, shape, stride, offset) {
    if (data === undefined) {
      var ctor = CACHED_CONSTRUCTORS.array[0];
      return ctor([]);
    } else if (typeof data === "number") {
      data = [data];
    }
    if (shape === undefined) {
      shape = [data.length];
    }
    var d = shape.length;
    if (stride === undefined) {
      stride = new Array(d);
      for (var i = d - 1,
          sz = 1; i >= 0; --i) {
        stride[i] = sz;
        sz *= shape[i];
      }
    }
    if (offset === undefined) {
      offset = 0;
      for (var i = 0; i < d; ++i) {
        if (stride[i] < 0) {
          offset -= (shape[i] - 1) * stride[i];
        }
      }
    }
    var dtype = arrayDType(data);
    var ctor_list = CACHED_CONSTRUCTORS[dtype];
    while (ctor_list.length <= d + 1) {
      ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
    }
    var ctor = ctor_list[d + 1];
    return ctor(data, shape, stride, offset);
  }
  module.exports = wrappedNDArrayCtor;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("34", ["9e"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('9e');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("89", ["34", "8f", "2b", "73", "88", "8a", "8e"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var _slicedToArray = function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
  };
  var _createClass = function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.transformParameter = transformParameter;
  exports.transformDomain = transformDomain;
  var _ndarray = req('34');
  var _ndarray2 = _interopRequireDefault(_ndarray);
  var _subset = req('8f');
  var _subset2 = req('2b');
  var _array = req('73');
  var _constants = req('88');
  var _util = req('8a');
  var _http = req('8e');
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0,
          arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Coverage = function() {
    function Coverage(covjson, options) {
      _classCallCheck(this, Coverage);
      this._covjson = covjson;
      this.type = _constants.COVERAGE;
      this.ld = {};
      this._exposeLd(covjson);
      this.options = options ? (0, _util.shallowcopy)(options) : {};
      this.id = covjson.id;
      this.parameters = new Map();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;
      try {
        for (var _iterator = Object.keys(covjson.parameters)[Symbol.iterator](),
            _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;
          transformParameter(covjson.parameters, key);
          this.parameters.set(key, covjson.parameters[key]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      this.profiles = [];
      var profile = this._covjson.profile;
      if (profile) {
        if (profile.substr(0, 4) !== 'http') {
          profile = _util.PREFIX + profile;
        }
        this.profiles.push(profile);
      }
      this.domainProfiles = [];
      var domainProfile = undefined;
      if (typeof this._covjson.domain === 'string') {
        domainProfile = this._covjson.domainProfile || this._covjson.domainType;
      } else {
        domainProfile = this._covjson.domain.profile || this._covjson.domain.domainType || this._covjson.domainProfile || this._covjson.domainType;
      }
      if (domainProfile) {
        if (domainProfile.substr(0, 4) !== 'http') {
          domainProfile = _util.PREFIX + domainProfile;
        }
        this.domainType = domainProfile;
        this.domainProfiles.push(domainProfile);
      }
      if (!profile && domainProfile) {
        profile = domainProfile + _constants.COVERAGE;
        this.profiles.push(profile);
      }
      this._updateLoadStatus();
    }
    _createClass(Coverage, [{
      key: '_updateLoadStatus',
      value: function _updateLoadStatus() {
        var _this = this;
        var isLoaded = function isLoaded(prop) {
          return (typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) === 'object';
        };
        var domainLoaded = isLoaded(this._covjson.domain);
        var rangesLoaded = Object.keys(this._covjson.ranges).every(function(key) {
          return isLoaded(_this._covjson.ranges[key]);
        });
        this.loaded = domainLoaded && rangesLoaded;
      }
    }, {
      key: '_exposeLd',
      value: function _exposeLd(covjson) {
        if (!covjson['@context']) {
          return;
        }
        var copy = (0, _util.shallowcopy)(covjson);
        delete copy.domain;
        delete copy.ranges;
        this.ld = JSON.parse(JSON.stringify(copy));
      }
    }, {
      key: 'loadDomain',
      value: function loadDomain() {
        var _this2 = this;
        var domainOrUrl = this._covjson.domain;
        if (this._domainPromise)
          return this._domainPromise;
        var promise = undefined;
        if ((typeof domainOrUrl === 'undefined' ? 'undefined' : _typeof(domainOrUrl)) === 'object') {
          var domain = domainOrUrl;
          transformDomain(domain, this.options.referencing, this.domainType);
          promise = Promise.resolve(domain);
        } else {
          var url = domainOrUrl;
          promise = (0, _http.load)(url).then(function(result) {
            var domain = result.data;
            transformDomain(domain, _this2.options.referencing, _this2.domainType);
            _this2._covjson.domain = domain;
            _this2._updateLoadStatus();
            return domain;
          });
        }
        this._domainPromise = promise;
        return promise;
      }
    }, {
      key: 'loadRange',
      value: function loadRange(paramKey) {
        var _this3 = this;
        return this.loadDomain().then(function(domain) {
          var rangeOrUrl = _this3._covjson.ranges[paramKey];
          if ((typeof rangeOrUrl === 'undefined' ? 'undefined' : _typeof(rangeOrUrl)) === 'object') {
            var range = rangeOrUrl;
            transformRange(range, domain);
            return Promise.resolve(range);
          } else {
            var url = rangeOrUrl;
            return (0, _http.load)(url).then(function(result) {
              var range = result.data;
              transformRange(range, domain);
              if (_this3.options.cacheRanges) {
                _this3._covjson.ranges[paramKey] = range;
                _this3._updateLoadStatus();
              }
              return range;
            });
          }
        });
      }
    }, {
      key: 'loadRanges',
      value: function loadRanges(paramKeys) {
        var _this4 = this;
        if (paramKeys === undefined)
          paramKeys = this.parameters.keys();
        paramKeys = Array.from(paramKeys);
        return Promise.all(paramKeys.map(function(k) {
          return _this4.loadRange(k);
        })).then(function(ranges) {
          var map = new Map();
          for (var i = 0; i < paramKeys.length; i++) {
            map.set(paramKeys[i], ranges[i]);
          }
          return map;
        });
      }
    }, {
      key: 'subsetByIndex',
      value: function subsetByIndex(constraints) {
        return _subsetByIndex(this, constraints);
      }
    }, {
      key: 'subsetByValue',
      value: function subsetByValue(constraints) {
        return (0, _subset2.subsetByValue)(this, constraints);
      }
    }]);
    return Coverage;
  }();
  exports.default = Coverage;
  function getRangeAxisOrder(domain, range) {
    var needsRangeAxisOrder = [].concat(_toConsumableArray(domain.axes.values())).filter(function(axis) {
      return axis.values.length > 1;
    }).length > 1;
    var axisOrder = domain._rangeAxisOrder || range._axisNames;
    if (needsRangeAxisOrder && !axisOrder) {
      throw new Error('Range axis order missing');
    }
    axisOrder = axisOrder || [].concat(_toConsumableArray(domain.axes.keys()));
    return axisOrder;
  }
  function getRangeShapeArray(domain, range) {
    var axisOrder = getRangeAxisOrder(domain, range);
    var shape = axisOrder.map(function(k) {
      return domain.axes.get(k).values.length;
    });
    if (range._shape) {
      var matchesDomain = range._shape.length === shape.length && range._shape.every(function(v, i) {
        return v === shape[i];
      });
      if (!matchesDomain) {
        throw new Error('range.shape must match domain axis sizes');
      }
    }
    return shape;
  }
  function _subsetByIndex(cov, constraints) {
    return cov.loadDomain().then(function(domain) {
      constraints = (0, _subset.normalizeIndexSubsetConstraints)(domain, constraints);
      var newdomain = (0, _subset.subsetByIndex)(domain, constraints);
      if (domain._rangeAxisOrder) {
        newdomain._rangeAxisOrder = domain._rangeAxisOrder;
      }
      var rangeWrapper = function rangeWrapper(range) {
        var _ndarr$hi$lo,
            _ndarr$hi;
        var ndarr = range._ndarr;
        var axisNames = getRangeAxisOrder(domain, range);
        var los = axisNames.map(function(name) {
          return constraints[name].start;
        });
        var his = axisNames.map(function(name) {
          return constraints[name].stop;
        });
        var steps = axisNames.map(function(name) {
          return constraints[name].step;
        });
        var newndarr = (_ndarr$hi$lo = (_ndarr$hi = ndarr.hi.apply(ndarr, _toConsumableArray(his))).lo.apply(_ndarr$hi, _toConsumableArray(los))).step.apply(_ndarr$hi$lo, _toConsumableArray(steps));
        var newrange = {
          dataType: range.dataType,
          get: createRangeGetFunction(newndarr, axisNames),
          _ndarr: newndarr,
          _axisNames: axisNames,
          _shape: axisNames.map(function(axisName) {
            return newdomain.axes.get(axisName).values.length;
          })
        };
        newrange.shape = new Map();
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;
        try {
          for (var _iterator2 = axisNames[Symbol.iterator](),
              _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var axisName = _step2.value;
            var size = newdomain.axes.get(axisName).values.length;
            newrange.shape.set(axisName, size);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        return newrange;
      };
      var loadRange = function loadRange(key) {
        return cov.loadRange(key).then(rangeWrapper);
      };
      var loadRanges = function loadRanges(keys) {
        return cov.loadRanges(keys).then(function(ranges) {
          return new Map([].concat(_toConsumableArray(ranges)).map(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 2);
            var key = _ref2[0];
            var range = _ref2[1];
            return [key, rangeWrapper(range)];
          }));
        });
      };
      var newcov = {
        type: _constants.COVERAGE,
        domainProfiles: cov.domainProfiles,
        domainType: cov.domainType,
        parameters: cov.parameters,
        loadDomain: function loadDomain() {
          return Promise.resolve(newdomain);
        },
        loadRange: loadRange,
        loadRanges: loadRanges
      };
      newcov.subsetByIndex = _subsetByIndex.bind(null, newcov);
      newcov.subsetByValue = _subset2.subsetByValue.bind(null, newcov);
      return newcov;
    });
  }
  function transformParameter(params, key) {
    if ('__transformDone' in params[key])
      return;
    var param = params[key];
    param.key = key;
    if (param.unit) {
      if (typeof param.unit.symbol === 'string') {
        param.unit.symbol = {value: param.unit.symbol};
      }
    }
    if (param.categoryEncoding) {
      var map = new Map();
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;
      try {
        for (var _iterator3 = Object.keys(param.categoryEncoding)[Symbol.iterator](),
            _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var category = _step3.value;
          var vals = param.categoryEncoding[category];
          if (!Array.isArray(vals)) {
            vals = [vals];
          }
          map.set(category, vals);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
      param.categoryEncoding = map;
    }
    param.__transformDone = true;
  }
  function transformRange(range, domain) {
    if ('__transformDone' in range)
      return;
    var values = range.values;
    var targetDataType = range.dataType;
    var isTyped = ArrayBuffer.isView(values);
    var missingIsEncoded = typeof range.validMin === 'number';
    var hasOffsetFactor = 'offset' in range;
    if ('offset' in range) {
      (0, _util.assert)('factor' in range);
    }
    var offset = range.offset;
    var factor = range.factor;
    if (missingIsEncoded) {
      (0, _util.assert)('validMin' in range);
      (0, _util.assert)('validMax' in range);
    }
    var validMin = range.validMin;
    var validMax = range.validMax;
    var vals = undefined;
    if (!missingIsEncoded && !hasOffsetFactor) {
      vals = values;
    } else {
      vals = new Array(values.length);
      if (hasOffsetFactor) {
        for (var i = 0; i < values.length; i++) {
          var val = values[i];
          if (missingIsEncoded && (val < validMin || val > validMax)) {
            vals[i] = null;
          } else if (!missingIsEncoded && val === null) {
            vals[i] = null;
          } else {
            vals[i] = val * factor + offset;
          }
        }
        if (validMin !== undefined) {
          range.validMin = validMin * factor + offset;
          range.validMax = validMax * factor + offset;
        }
      } else {
        for (var i = 0; i < values.length; i++) {
          var val = values[i];
          if (val < validMin || val > validMax) {
            vals[i] = null;
          } else {
            vals[i] = val;
          }
        }
      }
      delete range.offset;
      delete range.factor;
      delete range.validMin;
      delete range.validMax;
    }
    if (range.actualMin === undefined) {
      var _minMax = (0, _array.minMax)(vals);
      var _minMax2 = _slicedToArray(_minMax, 2);
      var min = _minMax2[0];
      var max = _minMax2[1];
      if (min !== null) {
        range.actualMin = min;
        range.actualMax = max;
      }
    }
    if (range.shape) {
      range._shape = range.shape;
    }
    if (range.axisNames) {
      range._axisNames = range.axisNames;
      delete range.axisNames;
    }
    var axisNames = getRangeAxisOrder(domain, range);
    var shapeArr = getRangeShapeArray(domain, range);
    var ndarr = (0, _ndarray2.default)(vals, shapeArr);
    range._ndarr = ndarr;
    range.get = createRangeGetFunction(ndarr, axisNames);
    var shapeMap = new Map();
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;
    try {
      for (var _iterator4 = domain.axes[Symbol.iterator](),
          _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var _step4$value = _slicedToArray(_step4.value, 2);
        var axisName = _step4$value[0];
        var axis = _step4$value[1];
        shapeMap.set(axisName, axis.values.length);
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4.return) {
          _iterator4.return();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }
    range.shape = shapeMap;
    range.__transformDone = true;
    return range;
  }
  function createRangeGetFunction(ndarr, axisOrder) {
    var ndargs = '';
    for (var i = 0; i < axisOrder.length; i++) {
      if (ndargs)
        ndargs += ',';
      ndargs += '\'' + axisOrder[i] + '\' in obj ? obj[\'' + axisOrder[i] + '\'] : 0';
    }
    var fn = new Function('ndarr', 'return function ndarrget (obj) { return ndarr.get(' + ndargs + ') }')(ndarr);
    return fn;
  }
  function transformDomain(domain, referencing, domainType) {
    if ('__transformDone' in domain)
      return;
    domain.profiles = [];
    var profile = domain.profile || domain.domainType || domainType;
    if (profile) {
      if (profile.substr(0, 4) !== 'http') {
        profile = _util.PREFIX + profile;
      }
      domain.domainType = profile;
      domain.profiles.push(profile);
    }
    var axes = new Map();
    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;
    try {
      for (var _iterator5 = Object.keys(domain.axes)[Symbol.iterator](),
          _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
        var axisName = _step5.value;
        axes.set(axisName, domain.axes[axisName]);
      }
    } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion5 && _iterator5.return) {
          _iterator5.return();
        }
      } finally {
        if (_didIteratorError5) {
          throw _iteratorError5;
        }
      }
    }
    domain.axes = axes;
    var _iteratorNormalCompletion6 = true;
    var _didIteratorError6 = false;
    var _iteratorError6 = undefined;
    try {
      for (var _iterator6 = axes[Symbol.iterator](),
          _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
        var _step6$value = _slicedToArray(_step6.value, 2);
        var key = _step6$value[0];
        var axis = _step6$value[1];
        axis.key = key;
        if (axis.dataType === 'Tuple' || axis.dataType === 'Polygon') {
          axis.dataType = _util.PREFIX + axis.dataType;
        }
        if (axis.dimensions) {
          axis.components = axis.dimensions;
        }
        if (!axis.components) {
          axis.components = [key];
        }
        axis.dimensions = axis.components;
        if ('start' in axis && 'stop' in axis && 'num' in axis) {
          var arr = new Float64Array(axis.num);
          var step = undefined;
          if (axis.num === 1) {
            if (axis.start !== axis.stop) {
              throw new Error('regular axis of length 1 must have equal start/stop values');
            }
            step = 0;
          } else {
            step = (axis.stop - axis.start) / (axis.num - 1);
          }
          for (var i = 0; i < axis.num; i++) {
            arr[i] = axis.start + i * step;
          }
          axis.values = arr;
          delete axis.start;
          delete axis.stop;
          delete axis.num;
        }
        if (ArrayBuffer.isView(axis.values)) {
          continue;
        }
        if (Array.isArray(axis.values) && typeof axis.values[0] === 'number') {
          var arr = new Float64Array(axis.values.length);
          for (var i = 0; i < axis.values.length; i++) {
            arr[i] = axis.values[i];
          }
          axis.values = arr;
        }
        axis.bounds = wrapBounds(axis);
      }
    } catch (err) {
      _didIteratorError6 = true;
      _iteratorError6 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion6 && _iterator6.return) {
          _iterator6.return();
        }
      } finally {
        if (_didIteratorError6) {
          throw _iteratorError6;
        }
      }
    }
    if (referencing) {
      domain.referencing = referencing;
    }
    var _iteratorNormalCompletion7 = true;
    var _didIteratorError7 = false;
    var _iteratorError7 = undefined;
    try {
      for (var _iterator7 = domain.referencing[Symbol.iterator](),
          _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
        var obj = _step7.value;
        if (obj.system)
          break;
        obj.system = obj.srs || obj.trs || obj.rs;
        if (obj.dimensions) {
          obj.components = obj.dimensions;
        }
        delete obj.srs;
        delete obj.trs;
        delete obj.rs;
      }
    } catch (err) {
      _didIteratorError7 = true;
      _iteratorError7 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion7 && _iterator7.return) {
          _iterator7.return();
        }
      } finally {
        if (_didIteratorError7) {
          throw _iteratorError7;
        }
      }
    }
    if (domain.rangeAxisOrder) {
      domain._rangeAxisOrder = domain.rangeAxisOrder;
      delete domain.rangeAxisOrder;
    }
    domain.__transformDone = true;
    return domain;
  }
  function wrapBounds(axis) {
    if (axis.bounds) {
      var _ret = function() {
        var bounds = axis.bounds;
        return {v: {get: function get(i) {
              return [bounds[2 * i], bounds[2 * i + 1]];
            }}};
      }();
      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object")
        return _ret.v;
    }
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9f", ["89", "87", "8a", "88", "8e"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
  };
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.load = load;
  exports.read = read;
  var _Coverage = req('89');
  var _Coverage2 = _interopRequireDefault(_Coverage);
  var _CoverageCollection = req('87');
  var _CoverageCollection2 = _interopRequireDefault(_CoverageCollection);
  var _util = req('8a');
  var _constants = req('88');
  var _http = req('8e');
  var http = _interopRequireWildcard(_http);
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};
      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            newObj[key] = obj[key];
        }
      }
      newObj.default = obj;
      return newObj;
    }
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function load(url, options) {
    return http.load(url, options);
  }
  function read(input) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
    if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object') {
      return Promise.resolve().then(function() {
        return transformCovJSON(input);
      });
    } else {
      return load(input, options).then(function(_ref) {
        var data = _ref.data;
        var headers = _ref.headers;
        return transformCovJSON(data, headers);
      });
    }
  }
  function transformCovJSON(obj, headers) {
    checkValidCovJSON(obj);
    if ([_constants.COVERAGE, _constants.COVERAGECOLLECTION, _constants.DOMAIN].indexOf(obj.type) === -1) {
      throw new Error('CoverageJSON document must be of Coverage, CoverageCollection, or Domain type');
    }
    var result = undefined;
    if (obj.type === _constants.DOMAIN) {
      (0, _Coverage.transformDomain)(obj);
      result = obj;
    } else if (obj.type === _constants.COVERAGE) {
      result = new _Coverage2.default(obj);
    } else {
      result = new _CoverageCollection2.default(obj);
    }
    if (obj.type === _constants.COVERAGE || obj.type === _constants.COVERAGECOLLECTION) {
      addLinkRelations(result, headers);
    }
    return result;
  }
  function addLinkRelations(cov, headers) {
    if (!headers || !headers['link']) {
      return;
    }
    var ld = cov.ld;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;
    try {
      for (var _iterator = headers['link'].split(',')[Symbol.iterator](),
          _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var link = _step.value;
        link = link.trim();
        var parts = link.split(';');
        var url = parts[0].substr(1, parts[0].length - 2);
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;
        try {
          for (var _iterator2 = parts.slice(1)[Symbol.iterator](),
              _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var param = _step2.value;
            var relStart = param.indexOf('rel=');
            if (relStart === -1) {
              continue;
            }
            var rel = param.substring(relStart + 5, param.length - 1);
            if (!rel.startsWith('http://') && !rel.startsWith('https://')) {
              rel = _constants.LINKRELPREFIX + rel;
            }
            if (ld[rel]) {
              if (Array.isArray(ld[rel])) {
                ld[rel].push(url);
              } else {
                ld[rel] = [ld[rel], url];
              }
            } else {
              ld[rel] = url;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
  function checkValidCovJSON(obj) {
    (0, _util.assert)('type' in obj, '"type" missing');
    if (obj.type === _constants.COVERAGE) {
      (0, _util.assert)('parameters' in obj, '"parameters" missing');
      (0, _util.assert)('domain' in obj, '"domain" missing');
      (0, _util.assert)('ranges' in obj, '"ranges" missing');
    } else if (obj.type === _constants.COVERAGECOLLECTION) {
      (0, _util.assert)(Array.isArray(obj.coverages), '"coverages" must be an array');
    }
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7d", ["9f"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('9f');
  global.define = __define;
  return module.exports;
});

$__System.register('78', ['7d', '7e', '1a'], function (_export) {
  'use strict';

  var CovJSONReader, RestAPI, CoverageData, CovJSON;
  return {
    setters: [function (_d) {
      CovJSONReader = _d;
    }, function (_e) {
      RestAPI = _e;
    }, function (_a) {
      CoverageData = _a['default'];
    }],
    execute: function () {
      CovJSON = (function (_CoverageData) {
        babelHelpers.inherits(CovJSON, _CoverageData);

        /**
         * @param {Array} actionFactories Array of action class factories
         */

        function CovJSON(actionFactories) {
          babelHelpers.classCallCheck(this, CovJSON);

          babelHelpers.get(Object.getPrototypeOf(CovJSON.prototype), 'constructor', this).call(this, actionFactories);
          this.label = 'CoverageJSON';
          this.shortLabel = 'CovJSON';
          this.mediaTypes = ['application/prs.coverage+json'];
        }

        /**
         * @param urlOrObject Either a URL, a CovJSON object, or a Coverage API object.
         * @returns {Promise} succeeds with a Coverage or Coverage Collection API object
         */
        babelHelpers.createClass(CovJSON, [{
          key: 'doLoad',
          value: function doLoad(urlOrObject, options) {
            if (typeof urlOrObject === 'object' && urlOrObject.loadDomain) {
              return Promise.resolve(urlOrObject);
            } else {
              return CovJSONReader.read(urlOrObject, options).then(function (data) {
                return RestAPI.wrap(data, {
                  loader: CovJSONReader.read
                });
              });
            }
          }
        }]);
        return CovJSON;
      })(CoverageData);

      _export('default', CovJSON);
    }
  };
});

$__System.register('7b', ['a'], function (_export) {
  'use strict';

  var Eventable, Format;
  return {
    setters: [function (_a) {
      Eventable = _a['default'];
    }],
    execute: function () {
      Format = (function (_Eventable) {
        babelHelpers.inherits(Format, _Eventable);

        function Format(actionClasses) {
          babelHelpers.classCallCheck(this, Format);

          babelHelpers.get(Object.getPrototypeOf(Format.prototype), 'constructor', this).call(this);
          this.actionClasses = actionClasses || [];
          // overwrite in subclass
          this.label = undefined;
          this.shortLabel = undefined;
          this.mediaTypes = undefined;
        }

        babelHelpers.createClass(Format, [{
          key: 'supports',
          value: function supports(mediaType) {
            return mediaType && this.mediaTypes.some(function (m) {
              return mediaType.toLowerCase().startsWith(m);
            });
          }
        }, {
          key: 'getActions',
          value: function getActions(obj, context) {
            var actions = [];
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = this.actionClasses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var actionClass = _step.value;

                var action = new actionClass(obj, context);
                if (action.isSupported) {
                  actions.push(action);
                  this.fire('actionCreate', { action: action });
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            return actions;
          }
        }, {
          key: 'load',
          value: function load(input, options) {
            var _this = this;

            this.fire('loading');
            return this.doLoad(input, options).then(function (data) {
              _this.fire('load');
              return data;
            })['catch'](function (error) {
              _this.fire('loadError', { error: error });
              throw error;
            });
          }
        }]);
        return Format;
      })(Eventable);

      _export('default', Format);
    }
  };
});

$__System.register('1a', ['7b'], function (_export) {

  /**
   * An object-only format that is used for derived data.
   */
  'use strict';

  var Format, CoverageData;
  return {
    setters: [function (_b) {
      Format = _b['default'];
    }],
    execute: function () {
      CoverageData = (function (_Format) {
        babelHelpers.inherits(CoverageData, _Format);

        /**
         * @param {Array} actionFactories Array of action class factories
         */

        function CoverageData(actionFactories) {
          babelHelpers.classCallCheck(this, CoverageData);

          babelHelpers.get(Object.getPrototypeOf(CoverageData.prototype), 'constructor', this).call(this, actionFactories);
          this.label = 'Coverage data';
          this.shortLabel = 'Coverage data';
          // pseudo media type for our internal Coverage objects (https://github.com/Reading-eScience-Centre/coverage-jsapi)
          this.mediaTypes = ['coveragedata'];
        }

        /**
         * @param object Either a URL, a CovJSON object, or a Coverage API object.
         * @returns {Promise} succeeds with a Coverage or Coverage Collection API object
         */
        babelHelpers.createClass(CoverageData, [{
          key: 'doLoad',
          value: function doLoad(object) {
            return Promise.resolve(object);
          }
        }, {
          key: 'getMetadata',
          value: function getMetadata(cov) {
            var count = undefined;
            if (cov.coverages) {
              if (cov.paging) {
                count = cov.paging.total;
              } else {
                count = cov.coverages.length;
              }
            } else {
              count = 1;
            }
            return {
              format: this.label,
              content: count === 1 ? '1 coverage' : count + ' coverages'
            };
          }
        }]);
        return CoverageData;
      })(Format);

      _export('default', CoverageData);
    }
  };
});

$__System.register('a0', ['a'], function (_export) {
  'use strict';

  var Eventable, Workspace;
  return {
    setters: [function (_a) {
      Eventable = _a['default'];
    }],
    execute: function () {
      Workspace = (function (_Eventable) {
        babelHelpers.inherits(Workspace, _Eventable);

        function Workspace(formats) {
          babelHelpers.classCallCheck(this, Workspace);

          babelHelpers.get(Object.getPrototypeOf(Workspace.prototype), 'constructor', this).call(this);
          this._datasets = new Map();

          this._formats = formats;
          this._staticActionContext = {};
        }

        /**
         * Context that should be set on every Action after it is instantiated.
         */
        babelHelpers.createClass(Workspace, [{
          key: 'addStaticActionContext',
          value: function addStaticActionContext(staticContext) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = Object.keys(staticContext)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var key = _step.value;

                this._staticActionContext[key] = staticContext[key];
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }

          /**
           * @param {object} dataset The dataset to add.
           * @param {object} [parent] 
           *   The parent dataset out of which the dataset creation was triggered.
           *   This is currently used for UI purposes only to insert the new dataset at
           *   an appropriate place.
           */
        }, {
          key: 'addDataset',
          value: function addDataset(dataset, parent) {
            if (!dataset.id) {
              dataset.id = new Date().getTime();
            }
            if (!this._datasets.has(dataset.id)) {
              // deep copy as we may modify the dataset (e.g. the title)
              if (!dataset.virtual) {
                dataset = JSON.parse(JSON.stringify(dataset));
              }
              this._datasets.set(dataset.id, dataset);
              // TODO check if dataset has same title as another one, if yes, rename it (e.g. append number)
              this.fire('add', { dataset: dataset, parent: parent });
              this._loadDistribution(dataset);
            }
          }
        }, {
          key: 'removeDataset',
          value: function removeDataset(dataset) {
            if (this._datasets.has(dataset.id)) {
              // give all actions a chance to clean up
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = dataset.distributions.filter(function (dist) {
                  return ('actions' in dist);
                })[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var dist = _step2.value;
                  var _iteratorNormalCompletion3 = true;
                  var _didIteratorError3 = false;
                  var _iteratorError3 = undefined;

                  try {
                    for (var _iterator3 = dist.actions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                      var action = _step3.value;

                      action.remove();
                    }
                  } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                        _iterator3['return']();
                      }
                    } finally {
                      if (_didIteratorError3) {
                        throw _iteratorError3;
                      }
                    }
                  }
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                    _iterator2['return']();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }

              this._datasets['delete'](dataset.id);
              this.fire('remove', { dataset: dataset });
            }
          }
        }, {
          key: 'requestFocus',
          value: function requestFocus(dataset) {
            this.fire('requestFocus', { dataset: dataset });
          }
        }, {
          key: 'setDatasetTitle',
          value: function setDatasetTitle(dataset, title) {
            var oldTitle = dataset.title;
            var newTitle = { unknown: title };
            dataset.title = newTitle;
            this.fire('titleChange', { dataset: dataset, oldTitle: oldTitle, newTitle: newTitle });
          }
        }, {
          key: 'filterDistributions',
          value: function filterDistributions(matchFn) {
            var dists = [];
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = this.datasets[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var dataset = _step4.value;
                var _iteratorNormalCompletion5 = true;
                var _didIteratorError5 = false;
                var _iteratorError5 = undefined;

                try {
                  for (var _iterator5 = dataset.distributions[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                    var dist = _step5.value;

                    if (matchFn(dist)) {
                      dists.push({ distribution: dist, dataset: dataset });
                    }
                  }
                } catch (err) {
                  _didIteratorError5 = true;
                  _iteratorError5 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion5 && _iterator5['return']) {
                      _iterator5['return']();
                    }
                  } finally {
                    if (_didIteratorError5) {
                      throw _iteratorError5;
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                  _iterator4['return']();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            return dists;
          }

          /**
           * Loads analysable distributions of a dataset and stores metadata about them
           * in their "metadata" field.
           * If the format/API supports it then only the metadata part (or similar)
           * of a distribution is loaded.
           * 
           * Note that the loaded distributions are not cached or stored in any way
           * to prevent out-of-memory situations.
           * 
           * To support virtual datasets that we derived in some way,
           * a distribution object can also have a "data" property (which is
           * a JavaScript object) instead of an accessURL or downloadURL.
           * It would be infeasible to persist such data somehow into a Blob and
           * use URL.createObjectURL(blob) just to get a URL.
           */
        }, {
          key: '_loadDistribution',
          value: function _loadDistribution(dataset) {
            var _this = this;

            this.fire('distributionsLoading', { dataset: dataset });
            var promises = [];
            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = undefined;

            try {
              var _loop = function () {
                var distribution = _step6.value;
                _iteratorNormalCompletion7 = true;
                _didIteratorError7 = false;
                _iteratorError7 = undefined;

                try {
                  var _loop2 = function () {
                    var format = _step7.value;

                    if (format.supports(distribution.mediaType)) {
                      _this.fire('distributionLoading', { dataset: dataset, distribution: distribution });
                      var urlOrData = distribution.url || distribution.data;
                      distribution.formatImpl = format;
                      var promise = format.load(urlOrData).then(function (data) {
                        var meta = format.getMetadata(data);

                        var actionContext = { dataset: dataset, distribution: distribution, workspace: _this };
                        for (var key in _this._staticActionContext) {
                          actionContext[key] = _this._staticActionContext[key];
                        }

                        var actions = format.getActions(data, actionContext);

                        distribution.metadata = meta;
                        distribution.actions = actions;
                        distribution.data = data;

                        _this.fire('distributionLoad', { dataset: dataset, distribution: distribution });
                      })['catch'](function (e) {
                        distribution.error = e;
                        _this.fire('distributionLoadError', { dataset: dataset, distribution: distribution, error: e });
                        console.log(e);
                      });
                      promises.push(promise);
                    }
                  };

                  for (_iterator7 = _this._formats[Symbol.iterator](); !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                    _loop2();
                  }
                } catch (err) {
                  _didIteratorError7 = true;
                  _iteratorError7 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion7 && _iterator7['return']) {
                      _iterator7['return']();
                    }
                  } finally {
                    if (_didIteratorError7) {
                      throw _iteratorError7;
                    }
                  }
                }
              };

              for (var _iterator6 = dataset.distributions[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                var _iteratorNormalCompletion7;

                var _didIteratorError7;

                var _iteratorError7;

                var _iterator7, _step7;

                _loop();
              }
            } catch (err) {
              _didIteratorError6 = true;
              _iteratorError6 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion6 && _iterator6['return']) {
                  _iterator6['return']();
                }
              } finally {
                if (_didIteratorError6) {
                  throw _iteratorError6;
                }
              }
            }

            Promise.all(promises).then(function () {
              _this.fire('distributionsLoad', { dataset: dataset });
            });
          }
        }, {
          key: 'datasets',
          get: function get() {
            return [].concat(babelHelpers.toConsumableArray(this._datasets.values()));
          }
        }]);
        return Workspace;
      })(Eventable);

      _export('default', Workspace);
    }
  };
});

$__System.registerDynamic("a1", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a2", ["2e"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    (function() {
      "use strict";
      function $$utils$$objectOrFunction(x) {
        return typeof x === 'function' || (typeof x === 'object' && x !== null);
      }
      function $$utils$$isFunction(x) {
        return typeof x === 'function';
      }
      function $$utils$$isMaybeThenable(x) {
        return typeof x === 'object' && x !== null;
      }
      var $$utils$$_isArray;
      if (!Array.isArray) {
        $$utils$$_isArray = function(x) {
          return Object.prototype.toString.call(x) === '[object Array]';
        };
      } else {
        $$utils$$_isArray = Array.isArray;
      }
      var $$utils$$isArray = $$utils$$_isArray;
      var $$utils$$now = Date.now || function() {
        return new Date().getTime();
      };
      function $$utils$$F() {}
      var $$utils$$o_create = (Object.create || function(o) {
        if (arguments.length > 1) {
          throw new Error('Second argument not supported');
        }
        if (typeof o !== 'object') {
          throw new TypeError('Argument must be an object');
        }
        $$utils$$F.prototype = o;
        return new $$utils$$F();
      });
      var $$asap$$len = 0;
      var $$asap$$default = function asap(callback, arg) {
        $$asap$$queue[$$asap$$len] = callback;
        $$asap$$queue[$$asap$$len + 1] = arg;
        $$asap$$len += 2;
        if ($$asap$$len === 2) {
          $$asap$$scheduleFlush();
        }
      };
      var $$asap$$browserGlobal = (typeof window !== 'undefined') ? window : {};
      var $$asap$$BrowserMutationObserver = $$asap$$browserGlobal.MutationObserver || $$asap$$browserGlobal.WebKitMutationObserver;
      var $$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
      function $$asap$$useNextTick() {
        return function() {
          process.nextTick($$asap$$flush);
        };
      }
      function $$asap$$useMutationObserver() {
        var iterations = 0;
        var observer = new $$asap$$BrowserMutationObserver($$asap$$flush);
        var node = document.createTextNode('');
        observer.observe(node, {characterData: true});
        return function() {
          node.data = (iterations = ++iterations % 2);
        };
      }
      function $$asap$$useMessageChannel() {
        var channel = new MessageChannel();
        channel.port1.onmessage = $$asap$$flush;
        return function() {
          channel.port2.postMessage(0);
        };
      }
      function $$asap$$useSetTimeout() {
        return function() {
          setTimeout($$asap$$flush, 1);
        };
      }
      var $$asap$$queue = new Array(1000);
      function $$asap$$flush() {
        for (var i = 0; i < $$asap$$len; i += 2) {
          var callback = $$asap$$queue[i];
          var arg = $$asap$$queue[i + 1];
          callback(arg);
          $$asap$$queue[i] = undefined;
          $$asap$$queue[i + 1] = undefined;
        }
        $$asap$$len = 0;
      }
      var $$asap$$scheduleFlush;
      if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
        $$asap$$scheduleFlush = $$asap$$useNextTick();
      } else if ($$asap$$BrowserMutationObserver) {
        $$asap$$scheduleFlush = $$asap$$useMutationObserver();
      } else if ($$asap$$isWorker) {
        $$asap$$scheduleFlush = $$asap$$useMessageChannel();
      } else {
        $$asap$$scheduleFlush = $$asap$$useSetTimeout();
      }
      function $$$internal$$noop() {}
      var $$$internal$$PENDING = void 0;
      var $$$internal$$FULFILLED = 1;
      var $$$internal$$REJECTED = 2;
      var $$$internal$$GET_THEN_ERROR = new $$$internal$$ErrorObject();
      function $$$internal$$selfFullfillment() {
        return new TypeError("You cannot resolve a promise with itself");
      }
      function $$$internal$$cannotReturnOwn() {
        return new TypeError('A promises callback cannot return that same promise.');
      }
      function $$$internal$$getThen(promise) {
        try {
          return promise.then;
        } catch (error) {
          $$$internal$$GET_THEN_ERROR.error = error;
          return $$$internal$$GET_THEN_ERROR;
        }
      }
      function $$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
        try {
          then.call(value, fulfillmentHandler, rejectionHandler);
        } catch (e) {
          return e;
        }
      }
      function $$$internal$$handleForeignThenable(promise, thenable, then) {
        $$asap$$default(function(promise) {
          var sealed = false;
          var error = $$$internal$$tryThen(then, thenable, function(value) {
            if (sealed) {
              return;
            }
            sealed = true;
            if (thenable !== value) {
              $$$internal$$resolve(promise, value);
            } else {
              $$$internal$$fulfill(promise, value);
            }
          }, function(reason) {
            if (sealed) {
              return;
            }
            sealed = true;
            $$$internal$$reject(promise, reason);
          }, 'Settle: ' + (promise._label || ' unknown promise'));
          if (!sealed && error) {
            sealed = true;
            $$$internal$$reject(promise, error);
          }
        }, promise);
      }
      function $$$internal$$handleOwnThenable(promise, thenable) {
        if (thenable._state === $$$internal$$FULFILLED) {
          $$$internal$$fulfill(promise, thenable._result);
        } else if (promise._state === $$$internal$$REJECTED) {
          $$$internal$$reject(promise, thenable._result);
        } else {
          $$$internal$$subscribe(thenable, undefined, function(value) {
            $$$internal$$resolve(promise, value);
          }, function(reason) {
            $$$internal$$reject(promise, reason);
          });
        }
      }
      function $$$internal$$handleMaybeThenable(promise, maybeThenable) {
        if (maybeThenable.constructor === promise.constructor) {
          $$$internal$$handleOwnThenable(promise, maybeThenable);
        } else {
          var then = $$$internal$$getThen(maybeThenable);
          if (then === $$$internal$$GET_THEN_ERROR) {
            $$$internal$$reject(promise, $$$internal$$GET_THEN_ERROR.error);
          } else if (then === undefined) {
            $$$internal$$fulfill(promise, maybeThenable);
          } else if ($$utils$$isFunction(then)) {
            $$$internal$$handleForeignThenable(promise, maybeThenable, then);
          } else {
            $$$internal$$fulfill(promise, maybeThenable);
          }
        }
      }
      function $$$internal$$resolve(promise, value) {
        if (promise === value) {
          $$$internal$$reject(promise, $$$internal$$selfFullfillment());
        } else if ($$utils$$objectOrFunction(value)) {
          $$$internal$$handleMaybeThenable(promise, value);
        } else {
          $$$internal$$fulfill(promise, value);
        }
      }
      function $$$internal$$publishRejection(promise) {
        if (promise._onerror) {
          promise._onerror(promise._result);
        }
        $$$internal$$publish(promise);
      }
      function $$$internal$$fulfill(promise, value) {
        if (promise._state !== $$$internal$$PENDING) {
          return;
        }
        promise._result = value;
        promise._state = $$$internal$$FULFILLED;
        if (promise._subscribers.length === 0) {} else {
          $$asap$$default($$$internal$$publish, promise);
        }
      }
      function $$$internal$$reject(promise, reason) {
        if (promise._state !== $$$internal$$PENDING) {
          return;
        }
        promise._state = $$$internal$$REJECTED;
        promise._result = reason;
        $$asap$$default($$$internal$$publishRejection, promise);
      }
      function $$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
        var subscribers = parent._subscribers;
        var length = subscribers.length;
        parent._onerror = null;
        subscribers[length] = child;
        subscribers[length + $$$internal$$FULFILLED] = onFulfillment;
        subscribers[length + $$$internal$$REJECTED] = onRejection;
        if (length === 0 && parent._state) {
          $$asap$$default($$$internal$$publish, parent);
        }
      }
      function $$$internal$$publish(promise) {
        var subscribers = promise._subscribers;
        var settled = promise._state;
        if (subscribers.length === 0) {
          return;
        }
        var child,
            callback,
            detail = promise._result;
        for (var i = 0; i < subscribers.length; i += 3) {
          child = subscribers[i];
          callback = subscribers[i + settled];
          if (child) {
            $$$internal$$invokeCallback(settled, child, callback, detail);
          } else {
            callback(detail);
          }
        }
        promise._subscribers.length = 0;
      }
      function $$$internal$$ErrorObject() {
        this.error = null;
      }
      var $$$internal$$TRY_CATCH_ERROR = new $$$internal$$ErrorObject();
      function $$$internal$$tryCatch(callback, detail) {
        try {
          return callback(detail);
        } catch (e) {
          $$$internal$$TRY_CATCH_ERROR.error = e;
          return $$$internal$$TRY_CATCH_ERROR;
        }
      }
      function $$$internal$$invokeCallback(settled, promise, callback, detail) {
        var hasCallback = $$utils$$isFunction(callback),
            value,
            error,
            succeeded,
            failed;
        if (hasCallback) {
          value = $$$internal$$tryCatch(callback, detail);
          if (value === $$$internal$$TRY_CATCH_ERROR) {
            failed = true;
            error = value.error;
            value = null;
          } else {
            succeeded = true;
          }
          if (promise === value) {
            $$$internal$$reject(promise, $$$internal$$cannotReturnOwn());
            return;
          }
        } else {
          value = detail;
          succeeded = true;
        }
        if (promise._state !== $$$internal$$PENDING) {} else if (hasCallback && succeeded) {
          $$$internal$$resolve(promise, value);
        } else if (failed) {
          $$$internal$$reject(promise, error);
        } else if (settled === $$$internal$$FULFILLED) {
          $$$internal$$fulfill(promise, value);
        } else if (settled === $$$internal$$REJECTED) {
          $$$internal$$reject(promise, value);
        }
      }
      function $$$internal$$initializePromise(promise, resolver) {
        try {
          resolver(function resolvePromise(value) {
            $$$internal$$resolve(promise, value);
          }, function rejectPromise(reason) {
            $$$internal$$reject(promise, reason);
          });
        } catch (e) {
          $$$internal$$reject(promise, e);
        }
      }
      function $$$enumerator$$makeSettledResult(state, position, value) {
        if (state === $$$internal$$FULFILLED) {
          return {
            state: 'fulfilled',
            value: value
          };
        } else {
          return {
            state: 'rejected',
            reason: value
          };
        }
      }
      function $$$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {
        this._instanceConstructor = Constructor;
        this.promise = new Constructor($$$internal$$noop, label);
        this._abortOnReject = abortOnReject;
        if (this._validateInput(input)) {
          this._input = input;
          this.length = input.length;
          this._remaining = input.length;
          this._init();
          if (this.length === 0) {
            $$$internal$$fulfill(this.promise, this._result);
          } else {
            this.length = this.length || 0;
            this._enumerate();
            if (this._remaining === 0) {
              $$$internal$$fulfill(this.promise, this._result);
            }
          }
        } else {
          $$$internal$$reject(this.promise, this._validationError());
        }
      }
      $$$enumerator$$Enumerator.prototype._validateInput = function(input) {
        return $$utils$$isArray(input);
      };
      $$$enumerator$$Enumerator.prototype._validationError = function() {
        return new Error('Array Methods must be provided an Array');
      };
      $$$enumerator$$Enumerator.prototype._init = function() {
        this._result = new Array(this.length);
      };
      var $$$enumerator$$default = $$$enumerator$$Enumerator;
      $$$enumerator$$Enumerator.prototype._enumerate = function() {
        var length = this.length;
        var promise = this.promise;
        var input = this._input;
        for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {
          this._eachEntry(input[i], i);
        }
      };
      $$$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
        var c = this._instanceConstructor;
        if ($$utils$$isMaybeThenable(entry)) {
          if (entry.constructor === c && entry._state !== $$$internal$$PENDING) {
            entry._onerror = null;
            this._settledAt(entry._state, i, entry._result);
          } else {
            this._willSettleAt(c.resolve(entry), i);
          }
        } else {
          this._remaining--;
          this._result[i] = this._makeResult($$$internal$$FULFILLED, i, entry);
        }
      };
      $$$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
        var promise = this.promise;
        if (promise._state === $$$internal$$PENDING) {
          this._remaining--;
          if (this._abortOnReject && state === $$$internal$$REJECTED) {
            $$$internal$$reject(promise, value);
          } else {
            this._result[i] = this._makeResult(state, i, value);
          }
        }
        if (this._remaining === 0) {
          $$$internal$$fulfill(promise, this._result);
        }
      };
      $$$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {
        return value;
      };
      $$$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
        var enumerator = this;
        $$$internal$$subscribe(promise, undefined, function(value) {
          enumerator._settledAt($$$internal$$FULFILLED, i, value);
        }, function(reason) {
          enumerator._settledAt($$$internal$$REJECTED, i, reason);
        });
      };
      var $$promise$all$$default = function all(entries, label) {
        return new $$$enumerator$$default(this, entries, true, label).promise;
      };
      var $$promise$race$$default = function race(entries, label) {
        var Constructor = this;
        var promise = new Constructor($$$internal$$noop, label);
        if (!$$utils$$isArray(entries)) {
          $$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
          return promise;
        }
        var length = entries.length;
        function onFulfillment(value) {
          $$$internal$$resolve(promise, value);
        }
        function onRejection(reason) {
          $$$internal$$reject(promise, reason);
        }
        for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {
          $$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
        }
        return promise;
      };
      var $$promise$resolve$$default = function resolve(object, label) {
        var Constructor = this;
        if (object && typeof object === 'object' && object.constructor === Constructor) {
          return object;
        }
        var promise = new Constructor($$$internal$$noop, label);
        $$$internal$$resolve(promise, object);
        return promise;
      };
      var $$promise$reject$$default = function reject(reason, label) {
        var Constructor = this;
        var promise = new Constructor($$$internal$$noop, label);
        $$$internal$$reject(promise, reason);
        return promise;
      };
      var $$es6$promise$promise$$counter = 0;
      function $$es6$promise$promise$$needsResolver() {
        throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
      }
      function $$es6$promise$promise$$needsNew() {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
      }
      var $$es6$promise$promise$$default = $$es6$promise$promise$$Promise;
      function $$es6$promise$promise$$Promise(resolver) {
        this._id = $$es6$promise$promise$$counter++;
        this._state = undefined;
        this._result = undefined;
        this._subscribers = [];
        if ($$$internal$$noop !== resolver) {
          if (!$$utils$$isFunction(resolver)) {
            $$es6$promise$promise$$needsResolver();
          }
          if (!(this instanceof $$es6$promise$promise$$Promise)) {
            $$es6$promise$promise$$needsNew();
          }
          $$$internal$$initializePromise(this, resolver);
        }
      }
      $$es6$promise$promise$$Promise.all = $$promise$all$$default;
      $$es6$promise$promise$$Promise.race = $$promise$race$$default;
      $$es6$promise$promise$$Promise.resolve = $$promise$resolve$$default;
      $$es6$promise$promise$$Promise.reject = $$promise$reject$$default;
      $$es6$promise$promise$$Promise.prototype = {
        constructor: $$es6$promise$promise$$Promise,
        then: function(onFulfillment, onRejection) {
          var parent = this;
          var state = parent._state;
          if (state === $$$internal$$FULFILLED && !onFulfillment || state === $$$internal$$REJECTED && !onRejection) {
            return this;
          }
          var child = new this.constructor($$$internal$$noop);
          var result = parent._result;
          if (state) {
            var callback = arguments[state - 1];
            $$asap$$default(function() {
              $$$internal$$invokeCallback(state, child, callback, result);
            });
          } else {
            $$$internal$$subscribe(parent, child, onFulfillment, onRejection);
          }
          return child;
        },
        'catch': function(onRejection) {
          return this.then(null, onRejection);
        }
      };
      var $$es6$promise$polyfill$$default = function polyfill() {
        var local;
        if (typeof global !== 'undefined') {
          local = global;
        } else if (typeof window !== 'undefined' && window.document) {
          local = window;
        } else {
          local = self;
        }
        var es6PromiseSupport = "Promise" in local && "resolve" in local.Promise && "reject" in local.Promise && "all" in local.Promise && "race" in local.Promise && (function() {
          var resolve;
          new local.Promise(function(r) {
            resolve = r;
          });
          return $$utils$$isFunction(resolve);
        }());
        if (!es6PromiseSupport) {
          local.Promise = $$es6$promise$promise$$default;
        }
      };
      var es6$promise$umd$$ES6Promise = {
        'Promise': $$es6$promise$promise$$default,
        'polyfill': $$es6$promise$polyfill$$default
      };
      if (typeof define === 'function' && define['amd']) {
        define(function() {
          return es6$promise$umd$$ES6Promise;
        });
      } else if (typeof module !== 'undefined' && module['exports']) {
        module['exports'] = es6$promise$umd$$ES6Promise;
      } else if (typeof this !== 'undefined') {
        this['ES6Promise'] = es6$promise$umd$$ES6Promise;
      }
    }).call(this);
  })(req('2e'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a3", ["a2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('a2');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a4", ["a3", "a1", "2e"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var __filename = module.id,
      __dirname = module.id.split('/').splice(0, module.id.split('/').length - 1).join('/');
  "format cjs";
  (function(process) {
    (function() {
      var _nodejs = (typeof process !== 'undefined' && process.versions && process.versions.node);
      var _browser = !_nodejs && (typeof window !== 'undefined' || typeof self !== 'undefined');
      if (_browser) {
        if (typeof global === 'undefined') {
          if (typeof window !== 'undefined') {
            global = window;
          } else if (typeof self !== 'undefined') {
            global = self;
          } else if (typeof $ !== 'undefined') {
            global = $;
          }
        }
      }
      var wrapper = function(jsonld) {
        jsonld.compact = function(input, ctx, options, callback) {
          if (arguments.length < 2) {
            return jsonld.nextTick(function() {
              callback(new TypeError('Could not compact, too few arguments.'));
            });
          }
          if (typeof options === 'function') {
            callback = options;
            options = {};
          }
          options = options || {};
          if (ctx === null) {
            return jsonld.nextTick(function() {
              callback(new JsonLdError('The compaction context must not be null.', 'jsonld.CompactError', {code: 'invalid local context'}));
            });
          }
          if (input === null) {
            return jsonld.nextTick(function() {
              callback(null, null);
            });
          }
          if (!('base' in options)) {
            options.base = (typeof input === 'string') ? input : '';
          }
          if (!('compactArrays' in options)) {
            options.compactArrays = true;
          }
          if (!('graph' in options)) {
            options.graph = false;
          }
          if (!('skipExpansion' in options)) {
            options.skipExpansion = false;
          }
          if (!('documentLoader' in options)) {
            options.documentLoader = jsonld.loadDocument;
          }
          if (!('link' in options)) {
            options.link = false;
          }
          if (options.link) {
            options.skipExpansion = true;
          }
          var expand = function(input, options, callback) {
            jsonld.nextTick(function() {
              if (options.skipExpansion) {
                return callback(null, input);
              }
              jsonld.expand(input, options, callback);
            });
          };
          expand(input, options, function(err, expanded) {
            if (err) {
              return callback(new JsonLdError('Could not expand input before compaction.', 'jsonld.CompactError', {cause: err}));
            }
            var activeCtx = _getInitialContext(options);
            jsonld.processContext(activeCtx, ctx, options, function(err, activeCtx) {
              if (err) {
                return callback(new JsonLdError('Could not process context before compaction.', 'jsonld.CompactError', {cause: err}));
              }
              var compacted;
              try {
                compacted = new Processor().compact(activeCtx, null, expanded, options);
              } catch (ex) {
                return callback(ex);
              }
              cleanup(null, compacted, activeCtx, options);
            });
          });
          function cleanup(err, compacted, activeCtx, options) {
            if (err) {
              return callback(err);
            }
            if (options.compactArrays && !options.graph && _isArray(compacted)) {
              if (compacted.length === 1) {
                compacted = compacted[0];
              } else if (compacted.length === 0) {
                compacted = {};
              }
            } else if (options.graph && _isObject(compacted)) {
              compacted = [compacted];
            }
            if (_isObject(ctx) && '@context' in ctx) {
              ctx = ctx['@context'];
            }
            ctx = _clone(ctx);
            if (!_isArray(ctx)) {
              ctx = [ctx];
            }
            var tmp = ctx;
            ctx = [];
            for (var i = 0; i < tmp.length; ++i) {
              if (!_isObject(tmp[i]) || Object.keys(tmp[i]).length > 0) {
                ctx.push(tmp[i]);
              }
            }
            var hasContext = (ctx.length > 0);
            if (ctx.length === 1) {
              ctx = ctx[0];
            }
            if (_isArray(compacted)) {
              var kwgraph = _compactIri(activeCtx, '@graph');
              var graph = compacted;
              compacted = {};
              if (hasContext) {
                compacted['@context'] = ctx;
              }
              compacted[kwgraph] = graph;
            } else if (_isObject(compacted) && hasContext) {
              var graph = compacted;
              compacted = {'@context': ctx};
              for (var key in graph) {
                compacted[key] = graph[key];
              }
            }
            callback(null, compacted, activeCtx);
          }
        };
        jsonld.expand = function(input, options, callback) {
          if (arguments.length < 1) {
            return jsonld.nextTick(function() {
              callback(new TypeError('Could not expand, too few arguments.'));
            });
          }
          if (typeof options === 'function') {
            callback = options;
            options = {};
          }
          options = options || {};
          if (!('documentLoader' in options)) {
            options.documentLoader = jsonld.loadDocument;
          }
          if (!('keepFreeFloatingNodes' in options)) {
            options.keepFreeFloatingNodes = false;
          }
          jsonld.nextTick(function() {
            if (typeof input === 'string') {
              var done = function(err, remoteDoc) {
                if (err) {
                  return callback(err);
                }
                try {
                  if (!remoteDoc.document) {
                    throw new JsonLdError('No remote document found at the given URL.', 'jsonld.NullRemoteDocument');
                  }
                  if (typeof remoteDoc.document === 'string') {
                    remoteDoc.document = JSON.parse(remoteDoc.document);
                  }
                } catch (ex) {
                  return callback(new JsonLdError('Could not retrieve a JSON-LD document from the URL. URL ' + 'dereferencing not implemented.', 'jsonld.LoadDocumentError', {
                    code: 'loading document failed',
                    cause: ex,
                    remoteDoc: remoteDoc
                  }));
                }
                expand(remoteDoc);
              };
              var promise = options.documentLoader(input, done);
              if (promise && 'then' in promise) {
                promise.then(done.bind(null, null), done);
              }
              return;
            }
            expand({
              contextUrl: null,
              documentUrl: null,
              document: input
            });
          });
          function expand(remoteDoc) {
            if (!('base' in options)) {
              options.base = remoteDoc.documentUrl || '';
            }
            var input = {
              document: _clone(remoteDoc.document),
              remoteContext: {'@context': remoteDoc.contextUrl}
            };
            if ('expandContext' in options) {
              var expandContext = _clone(options.expandContext);
              if (typeof expandContext === 'object' && '@context' in expandContext) {
                input.expandContext = expandContext;
              } else {
                input.expandContext = {'@context': expandContext};
              }
            }
            _retrieveContextUrls(input, options, function(err, input) {
              if (err) {
                return callback(err);
              }
              var expanded;
              try {
                var processor = new Processor();
                var activeCtx = _getInitialContext(options);
                var document = input.document;
                var remoteContext = input.remoteContext['@context'];
                if (input.expandContext) {
                  activeCtx = processor.processContext(activeCtx, input.expandContext['@context'], options);
                }
                if (remoteContext) {
                  activeCtx = processor.processContext(activeCtx, remoteContext, options);
                }
                expanded = processor.expand(activeCtx, null, document, options, false);
                if (_isObject(expanded) && ('@graph' in expanded) && Object.keys(expanded).length === 1) {
                  expanded = expanded['@graph'];
                } else if (expanded === null) {
                  expanded = [];
                }
                if (!_isArray(expanded)) {
                  expanded = [expanded];
                }
              } catch (ex) {
                return callback(ex);
              }
              callback(null, expanded);
            });
          }
        };
        jsonld.flatten = function(input, ctx, options, callback) {
          if (arguments.length < 1) {
            return jsonld.nextTick(function() {
              callback(new TypeError('Could not flatten, too few arguments.'));
            });
          }
          if (typeof options === 'function') {
            callback = options;
            options = {};
          } else if (typeof ctx === 'function') {
            callback = ctx;
            ctx = null;
            options = {};
          }
          options = options || {};
          if (!('base' in options)) {
            options.base = (typeof input === 'string') ? input : '';
          }
          if (!('documentLoader' in options)) {
            options.documentLoader = jsonld.loadDocument;
          }
          jsonld.expand(input, options, function(err, _input) {
            if (err) {
              return callback(new JsonLdError('Could not expand input before flattening.', 'jsonld.FlattenError', {cause: err}));
            }
            var flattened;
            try {
              flattened = new Processor().flatten(_input);
            } catch (ex) {
              return callback(ex);
            }
            if (ctx === null) {
              return callback(null, flattened);
            }
            options.graph = true;
            options.skipExpansion = true;
            jsonld.compact(flattened, ctx, options, function(err, compacted) {
              if (err) {
                return callback(new JsonLdError('Could not compact flattened output.', 'jsonld.FlattenError', {cause: err}));
              }
              callback(null, compacted);
            });
          });
        };
        jsonld.frame = function(input, frame, options, callback) {
          if (arguments.length < 2) {
            return jsonld.nextTick(function() {
              callback(new TypeError('Could not frame, too few arguments.'));
            });
          }
          if (typeof options === 'function') {
            callback = options;
            options = {};
          }
          options = options || {};
          if (!('base' in options)) {
            options.base = (typeof input === 'string') ? input : '';
          }
          if (!('documentLoader' in options)) {
            options.documentLoader = jsonld.loadDocument;
          }
          if (!('embed' in options)) {
            options.embed = '@last';
          }
          options.explicit = options.explicit || false;
          if (!('requireAll' in options)) {
            options.requireAll = true;
          }
          options.omitDefault = options.omitDefault || false;
          jsonld.nextTick(function() {
            if (typeof frame === 'string') {
              var done = function(err, remoteDoc) {
                if (err) {
                  return callback(err);
                }
                try {
                  if (!remoteDoc.document) {
                    throw new JsonLdError('No remote document found at the given URL.', 'jsonld.NullRemoteDocument');
                  }
                  if (typeof remoteDoc.document === 'string') {
                    remoteDoc.document = JSON.parse(remoteDoc.document);
                  }
                } catch (ex) {
                  return callback(new JsonLdError('Could not retrieve a JSON-LD document from the URL. URL ' + 'dereferencing not implemented.', 'jsonld.LoadDocumentError', {
                    code: 'loading document failed',
                    cause: ex,
                    remoteDoc: remoteDoc
                  }));
                }
                doFrame(remoteDoc);
              };
              var promise = options.documentLoader(frame, done);
              if (promise && 'then' in promise) {
                promise.then(done.bind(null, null), done);
              }
              return;
            }
            doFrame({
              contextUrl: null,
              documentUrl: null,
              document: frame
            });
          });
          function doFrame(remoteFrame) {
            var frame = remoteFrame.document;
            var ctx;
            if (frame) {
              ctx = frame['@context'];
              if (remoteFrame.contextUrl) {
                if (!ctx) {
                  ctx = remoteFrame.contextUrl;
                } else if (_isArray(ctx)) {
                  ctx.push(remoteFrame.contextUrl);
                } else {
                  ctx = [ctx, remoteFrame.contextUrl];
                }
                frame['@context'] = ctx;
              } else {
                ctx = ctx || {};
              }
            } else {
              ctx = {};
            }
            jsonld.expand(input, options, function(err, expanded) {
              if (err) {
                return callback(new JsonLdError('Could not expand input before framing.', 'jsonld.FrameError', {cause: err}));
              }
              var opts = _clone(options);
              opts.isFrame = true;
              opts.keepFreeFloatingNodes = true;
              jsonld.expand(frame, opts, function(err, expandedFrame) {
                if (err) {
                  return callback(new JsonLdError('Could not expand frame before framing.', 'jsonld.FrameError', {cause: err}));
                }
                var framed;
                try {
                  framed = new Processor().frame(expanded, expandedFrame, opts);
                } catch (ex) {
                  return callback(ex);
                }
                opts.graph = true;
                opts.skipExpansion = true;
                opts.link = {};
                jsonld.compact(framed, ctx, opts, function(err, compacted, ctx) {
                  if (err) {
                    return callback(new JsonLdError('Could not compact framed output.', 'jsonld.FrameError', {cause: err}));
                  }
                  var graph = _compactIri(ctx, '@graph');
                  opts.link = {};
                  compacted[graph] = _removePreserve(ctx, compacted[graph], opts);
                  callback(null, compacted);
                });
              });
            });
          }
        };
        jsonld.link = function(input, ctx, options, callback) {
          var frame = {};
          if (ctx) {
            frame['@context'] = ctx;
          }
          frame['@embed'] = '@link';
          jsonld.frame(input, frame, options, callback);
        };
        jsonld.objectify = function(input, ctx, options, callback) {
          if (typeof options === 'function') {
            callback = options;
            options = {};
          }
          options = options || {};
          if (!('base' in options)) {
            options.base = (typeof input === 'string') ? input : '';
          }
          if (!('documentLoader' in options)) {
            options.documentLoader = jsonld.loadDocument;
          }
          jsonld.expand(input, options, function(err, _input) {
            if (err) {
              return callback(new JsonLdError('Could not expand input before linking.', 'jsonld.LinkError', {cause: err}));
            }
            var flattened;
            try {
              flattened = new Processor().flatten(_input);
            } catch (ex) {
              return callback(ex);
            }
            options.graph = true;
            options.skipExpansion = true;
            jsonld.compact(flattened, ctx, options, function(err, compacted, ctx) {
              if (err) {
                return callback(new JsonLdError('Could not compact flattened output before linking.', 'jsonld.LinkError', {cause: err}));
              }
              var graph = _compactIri(ctx, '@graph');
              var top = compacted[graph][0];
              var recurse = function(subject) {
                if (!_isObject(subject) && !_isArray(subject)) {
                  return;
                }
                if (_isObject(subject)) {
                  if (recurse.visited[subject['@id']]) {
                    return;
                  }
                  recurse.visited[subject['@id']] = true;
                }
                for (var k in subject) {
                  var obj = subject[k];
                  var isid = (jsonld.getContextValue(ctx, k, '@type') === '@id');
                  if (!_isArray(obj) && !_isObject(obj) && !isid) {
                    continue;
                  }
                  if (_isString(obj) && isid) {
                    subject[k] = obj = top[obj];
                    recurse(obj);
                  } else if (_isArray(obj)) {
                    for (var i = 0; i < obj.length; ++i) {
                      if (_isString(obj[i]) && isid) {
                        obj[i] = top[obj[i]];
                      } else if (_isObject(obj[i]) && '@id' in obj[i]) {
                        obj[i] = top[obj[i]['@id']];
                      }
                      recurse(obj[i]);
                    }
                  } else if (_isObject(obj)) {
                    var sid = obj['@id'];
                    subject[k] = obj = top[sid];
                    recurse(obj);
                  }
                }
              };
              recurse.visited = {};
              recurse(top);
              compacted.of_type = {};
              for (var s in top) {
                if (!('@type' in top[s])) {
                  continue;
                }
                var types = top[s]['@type'];
                if (!_isArray(types)) {
                  types = [types];
                }
                for (var t = 0; t < types.length; ++t) {
                  if (!(types[t] in compacted.of_type)) {
                    compacted.of_type[types[t]] = [];
                  }
                  compacted.of_type[types[t]].push(top[s]);
                }
              }
              callback(null, compacted);
            });
          });
        };
        jsonld.normalize = function(input, options, callback) {
          if (arguments.length < 1) {
            return jsonld.nextTick(function() {
              callback(new TypeError('Could not normalize, too few arguments.'));
            });
          }
          if (typeof options === 'function') {
            callback = options;
            options = {};
          }
          options = options || {};
          if (!('algorithm' in options)) {
            options.algorithm = 'URGNA2012';
          }
          if (!('base' in options)) {
            options.base = (typeof input === 'string') ? input : '';
          }
          if (!('documentLoader' in options)) {
            options.documentLoader = jsonld.loadDocument;
          }
          if ('inputFormat' in options) {
            if (options.inputFormat !== 'application/nquads') {
              return callback(new JsonLdError('Unknown normalization input format.', 'jsonld.NormalizeError'));
            }
            var parsedInput = _parseNQuads(input);
            new Processor().normalize(parsedInput, options, callback);
          } else {
            var opts = _clone(options);
            delete opts.format;
            opts.produceGeneralizedRdf = false;
            jsonld.toRDF(input, opts, function(err, dataset) {
              if (err) {
                return callback(new JsonLdError('Could not convert input to RDF dataset before normalization.', 'jsonld.NormalizeError', {cause: err}));
              }
              new Processor().normalize(dataset, options, callback);
            });
          }
        };
        jsonld.fromRDF = function(dataset, options, callback) {
          if (arguments.length < 1) {
            return jsonld.nextTick(function() {
              callback(new TypeError('Could not convert from RDF, too few arguments.'));
            });
          }
          if (typeof options === 'function') {
            callback = options;
            options = {};
          }
          options = options || {};
          if (!('useRdfType' in options)) {
            options.useRdfType = false;
          }
          if (!('useNativeTypes' in options)) {
            options.useNativeTypes = false;
          }
          if (!('format' in options) && _isString(dataset)) {
            if (!('format' in options)) {
              options.format = 'application/nquads';
            }
          }
          jsonld.nextTick(function() {
            var rdfParser;
            if (options.format) {
              rdfParser = options.rdfParser || _rdfParsers[options.format];
              if (!rdfParser) {
                return callback(new JsonLdError('Unknown input format.', 'jsonld.UnknownFormat', {format: options.format}));
              }
            } else {
              rdfParser = function() {
                return dataset;
              };
            }
            var callbackCalled = false;
            try {
              dataset = rdfParser(dataset, function(err, dataset) {
                callbackCalled = true;
                if (err) {
                  return callback(err);
                }
                fromRDF(dataset, options, callback);
              });
            } catch (e) {
              if (!callbackCalled) {
                return callback(e);
              }
              throw e;
            }
            if (dataset) {
              if ('then' in dataset) {
                return dataset.then(function(dataset) {
                  fromRDF(dataset, options, callback);
                }, callback);
              }
              fromRDF(dataset, options, callback);
            }
            function fromRDF(dataset, options, callback) {
              new Processor().fromRDF(dataset, options, callback);
            }
          });
        };
        jsonld.toRDF = function(input, options, callback) {
          if (arguments.length < 1) {
            return jsonld.nextTick(function() {
              callback(new TypeError('Could not convert to RDF, too few arguments.'));
            });
          }
          if (typeof options === 'function') {
            callback = options;
            options = {};
          }
          options = options || {};
          if (!('base' in options)) {
            options.base = (typeof input === 'string') ? input : '';
          }
          if (!('documentLoader' in options)) {
            options.documentLoader = jsonld.loadDocument;
          }
          jsonld.expand(input, options, function(err, expanded) {
            if (err) {
              return callback(new JsonLdError('Could not expand input before serialization to RDF.', 'jsonld.RdfError', {cause: err}));
            }
            var dataset;
            try {
              dataset = Processor.prototype.toRDF(expanded, options);
              if (options.format) {
                if (options.format === 'application/nquads') {
                  return callback(null, _toNQuads(dataset));
                }
                throw new JsonLdError('Unknown output format.', 'jsonld.UnknownFormat', {format: options.format});
              }
            } catch (ex) {
              return callback(ex);
            }
            callback(null, dataset);
          });
        };
        jsonld.createNodeMap = function(input, options, callback) {
          if (arguments.length < 1) {
            return jsonld.nextTick(function() {
              callback(new TypeError('Could not create node map, too few arguments.'));
            });
          }
          if (typeof options === 'function') {
            callback = options;
            options = {};
          }
          options = options || {};
          if (!('base' in options)) {
            options.base = (typeof input === 'string') ? input : '';
          }
          if (!('documentLoader' in options)) {
            options.documentLoader = jsonld.loadDocument;
          }
          jsonld.expand(input, options, function(err, _input) {
            if (err) {
              return callback(new JsonLdError('Could not expand input before creating node map.', 'jsonld.CreateNodeMapError', {cause: err}));
            }
            var nodeMap;
            try {
              nodeMap = new Processor().createNodeMap(_input, options);
            } catch (ex) {
              return callback(ex);
            }
            callback(null, nodeMap);
          });
        };
        jsonld.merge = function(docs, ctx, options, callback) {
          if (arguments.length < 1) {
            return jsonld.nextTick(function() {
              callback(new TypeError('Could not merge, too few arguments.'));
            });
          }
          if (!_isArray(docs)) {
            return jsonld.nextTick(function() {
              callback(new TypeError('Could not merge, "docs" must be an array.'));
            });
          }
          if (typeof options === 'function') {
            callback = options;
            options = {};
          } else if (typeof ctx === 'function') {
            callback = ctx;
            ctx = null;
            options = {};
          }
          options = options || {};
          var expanded = [];
          var error = null;
          var count = docs.length;
          for (var i = 0; i < docs.length; ++i) {
            var opts = {};
            for (var key in options) {
              opts[key] = options[key];
            }
            jsonld.expand(docs[i], opts, expandComplete);
          }
          function expandComplete(err, _input) {
            if (error) {
              return;
            }
            if (err) {
              error = err;
              return callback(new JsonLdError('Could not expand input before flattening.', 'jsonld.FlattenError', {cause: err}));
            }
            expanded.push(_input);
            if (--count === 0) {
              merge(expanded);
            }
          }
          function merge(expanded) {
            var mergeNodes = true;
            if ('mergeNodes' in options) {
              mergeNodes = options.mergeNodes;
            }
            var issuer = options.namer || options.issuer || new IdentifierIssuer('_:b');
            var graphs = {'@default': {}};
            var defaultGraph;
            try {
              for (var i = 0; i < expanded.length; ++i) {
                var doc = expanded[i];
                doc = jsonld.relabelBlankNodes(doc, {issuer: new IdentifierIssuer('_:b' + i + '-')});
                var _graphs = (mergeNodes || i === 0) ? graphs : {'@default': {}};
                _createNodeMap(doc, _graphs, '@default', issuer);
                if (_graphs !== graphs) {
                  for (var graphName in _graphs) {
                    var _nodeMap = _graphs[graphName];
                    if (!(graphName in graphs)) {
                      graphs[graphName] = _nodeMap;
                      continue;
                    }
                    var nodeMap = graphs[graphName];
                    for (var key in _nodeMap) {
                      if (!(key in nodeMap)) {
                        nodeMap[key] = _nodeMap[key];
                      }
                    }
                  }
                }
              }
              defaultGraph = _mergeNodeMaps(graphs);
            } catch (ex) {
              return callback(ex);
            }
            var flattened = [];
            var keys = Object.keys(defaultGraph).sort();
            for (var ki = 0; ki < keys.length; ++ki) {
              var node = defaultGraph[keys[ki]];
              if (!_isSubjectReference(node)) {
                flattened.push(node);
              }
            }
            if (ctx === null) {
              return callback(null, flattened);
            }
            options.graph = true;
            options.skipExpansion = true;
            jsonld.compact(flattened, ctx, options, function(err, compacted) {
              if (err) {
                return callback(new JsonLdError('Could not compact merged output.', 'jsonld.MergeError', {cause: err}));
              }
              callback(null, compacted);
            });
          }
        };
        jsonld.relabelBlankNodes = function(input, options) {
          options = options || {};
          var issuer = options.namer || options.issuer || new IdentifierIssuer('_:b');
          return _labelBlankNodes(issuer, input);
        };
        jsonld.prependBase = function(base, iri) {
          return _prependBase(base, iri);
        };
        jsonld.documentLoader = function(url, callback) {
          var err = new JsonLdError('Could not retrieve a JSON-LD document from the URL. URL ' + 'dereferencing not implemented.', 'jsonld.LoadDocumentError', {code: 'loading document failed'});
          if (_nodejs) {
            return callback(err, {
              contextUrl: null,
              documentUrl: url,
              document: null
            });
          }
          return jsonld.promisify(function(callback) {
            callback(err);
          });
        };
        jsonld.loadDocument = function(url, callback) {
          var promise = jsonld.documentLoader(url, callback);
          if (promise && 'then' in promise) {
            promise.then(callback.bind(null, null), callback);
          }
        };
        jsonld.promises = function(options) {
          options = options || {};
          var slice = Array.prototype.slice;
          var promisify = jsonld.promisify;
          var api = options.api || {};
          var version = options.version || 'jsonld.js';
          if (typeof options.api === 'string') {
            if (!options.version) {
              version = options.api;
            }
            api = {};
          }
          api.expand = function(input) {
            if (arguments.length < 1) {
              throw new TypeError('Could not expand, too few arguments.');
            }
            return promisify.apply(null, [jsonld.expand].concat(slice.call(arguments)));
          };
          api.compact = function(input, ctx) {
            if (arguments.length < 2) {
              throw new TypeError('Could not compact, too few arguments.');
            }
            var compact = function(input, ctx, options, callback) {
              jsonld.compact(input, ctx, options, function(err, compacted) {
                callback(err, compacted);
              });
            };
            return promisify.apply(null, [compact].concat(slice.call(arguments)));
          };
          api.flatten = function(input) {
            if (arguments.length < 1) {
              throw new TypeError('Could not flatten, too few arguments.');
            }
            return promisify.apply(null, [jsonld.flatten].concat(slice.call(arguments)));
          };
          api.frame = function(input, frame) {
            if (arguments.length < 2) {
              throw new TypeError('Could not frame, too few arguments.');
            }
            return promisify.apply(null, [jsonld.frame].concat(slice.call(arguments)));
          };
          api.fromRDF = function(dataset) {
            if (arguments.length < 1) {
              throw new TypeError('Could not convert from RDF, too few arguments.');
            }
            return promisify.apply(null, [jsonld.fromRDF].concat(slice.call(arguments)));
          };
          api.toRDF = function(input) {
            if (arguments.length < 1) {
              throw new TypeError('Could not convert to RDF, too few arguments.');
            }
            return promisify.apply(null, [jsonld.toRDF].concat(slice.call(arguments)));
          };
          api.normalize = function(input) {
            if (arguments.length < 1) {
              throw new TypeError('Could not normalize, too few arguments.');
            }
            return promisify.apply(null, [jsonld.normalize].concat(slice.call(arguments)));
          };
          if (version === 'jsonld.js') {
            api.link = function(input, ctx) {
              if (arguments.length < 2) {
                throw new TypeError('Could not link, too few arguments.');
              }
              return promisify.apply(null, [jsonld.link].concat(slice.call(arguments)));
            };
            api.objectify = function(input) {
              return promisify.apply(null, [jsonld.objectify].concat(slice.call(arguments)));
            };
            api.createNodeMap = function(input) {
              return promisify.apply(null, [jsonld.createNodeMap].concat(slice.call(arguments)));
            };
            api.merge = function(input) {
              return promisify.apply(null, [jsonld.merge].concat(slice.call(arguments)));
            };
          }
          try {
            jsonld.Promise = global.Promise || req('a3').Promise;
          } catch (e) {
            var f = function() {
              throw new Error('Unable to find a Promise implementation.');
            };
            for (var method in api) {
              api[method] = f;
            }
          }
          return api;
        };
        jsonld.promisify = function(op) {
          if (!jsonld.Promise) {
            try {
              jsonld.Promise = global.Promise || req('a3').Promise;
            } catch (e) {
              throw new Error('Unable to find a Promise implementation.');
            }
          }
          var args = Array.prototype.slice.call(arguments, 1);
          return new jsonld.Promise(function(resolve, reject) {
            op.apply(null, args.concat(function(err, value) {
              if (!err) {
                resolve(value);
              } else {
                reject(err);
              }
            }));
          });
        };
        jsonld.promises({api: jsonld.promises});
        function JsonLdProcessor() {}
        JsonLdProcessor.prototype = jsonld.promises({version: 'json-ld-1.0'});
        JsonLdProcessor.prototype.toString = function() {
          if (this instanceof JsonLdProcessor) {
            return '[object JsonLdProcessor]';
          }
          return '[object JsonLdProcessorPrototype]';
        };
        jsonld.JsonLdProcessor = JsonLdProcessor;
        var canDefineProperty = !!Object.defineProperty;
        if (canDefineProperty) {
          try {
            Object.defineProperty({}, 'x', {});
          } catch (e) {
            canDefineProperty = false;
          }
        }
        if (canDefineProperty) {
          Object.defineProperty(JsonLdProcessor, 'prototype', {
            writable: false,
            enumerable: false
          });
          Object.defineProperty(JsonLdProcessor.prototype, 'constructor', {
            writable: true,
            enumerable: false,
            configurable: true,
            value: JsonLdProcessor
          });
        }
        if (_browser && typeof global.JsonLdProcessor === 'undefined') {
          if (canDefineProperty) {
            Object.defineProperty(global, 'JsonLdProcessor', {
              writable: true,
              enumerable: false,
              configurable: true,
              value: JsonLdProcessor
            });
          } else {
            global.JsonLdProcessor = JsonLdProcessor;
          }
        }
        var _setImmediate = typeof setImmediate === 'function' && setImmediate;
        var _delay = _setImmediate ? function(fn) {
          _setImmediate(fn);
        } : function(fn) {
          setTimeout(fn, 0);
        };
        if (typeof process === 'object' && typeof process.nextTick === 'function') {
          jsonld.nextTick = process.nextTick;
        } else {
          jsonld.nextTick = _delay;
        }
        jsonld.setImmediate = _setImmediate ? _delay : jsonld.nextTick;
        jsonld.parseLinkHeader = function(header) {
          var rval = {};
          var entries = header.match(/(?:<[^>]*?>|"[^"]*?"|[^,])+/g);
          var rLinkHeader = /\s*<([^>]*?)>\s*(?:;\s*(.*))?/;
          for (var i = 0; i < entries.length; ++i) {
            var match = entries[i].match(rLinkHeader);
            if (!match) {
              continue;
            }
            var result = {target: match[1]};
            var params = match[2];
            var rParams = /(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g;
            while (match = rParams.exec(params)) {
              result[match[1]] = (match[2] === undefined) ? match[3] : match[2];
            }
            var rel = result['rel'] || '';
            if (_isArray(rval[rel])) {
              rval[rel].push(result);
            } else if (rel in rval) {
              rval[rel] = [rval[rel], result];
            } else {
              rval[rel] = result;
            }
          }
          return rval;
        };
        jsonld.RequestQueue = function() {
          this._requests = {};
        };
        jsonld.RequestQueue.prototype.wrapLoader = function(loader) {
          this._loader = loader;
          this._usePromise = (loader.length === 1);
          return this.add.bind(this);
        };
        jsonld.RequestQueue.prototype.add = function(url, callback) {
          var self = this;
          if (!callback && !self._usePromise) {
            throw new Error('callback must be specified.');
          }
          if (self._usePromise) {
            return new jsonld.Promise(function(resolve, reject) {
              var load = self._requests[url];
              if (!load) {
                load = self._requests[url] = self._loader(url).then(function(remoteDoc) {
                  delete self._requests[url];
                  return remoteDoc;
                }).catch(function(err) {
                  delete self._requests[url];
                  throw err;
                });
              }
              load.then(function(remoteDoc) {
                resolve(remoteDoc);
              }).catch(function(err) {
                reject(err);
              });
            });
          }
          if (url in self._requests) {
            self._requests[url].push(callback);
          } else {
            self._requests[url] = [callback];
            self._loader(url, function(err, remoteDoc) {
              var callbacks = self._requests[url];
              delete self._requests[url];
              for (var i = 0; i < callbacks.length; ++i) {
                callbacks[i](err, remoteDoc);
              }
            });
          }
        };
        jsonld.DocumentCache = function(size) {
          this.order = [];
          this.cache = {};
          this.size = size || 50;
          this.expires = 30 * 1000;
        };
        jsonld.DocumentCache.prototype.get = function(url) {
          if (url in this.cache) {
            var entry = this.cache[url];
            if (entry.expires >= +new Date()) {
              return entry.ctx;
            }
            delete this.cache[url];
            this.order.splice(this.order.indexOf(url), 1);
          }
          return null;
        };
        jsonld.DocumentCache.prototype.set = function(url, ctx) {
          if (this.order.length === this.size) {
            delete this.cache[this.order.shift()];
          }
          this.order.push(url);
          this.cache[url] = {
            ctx: ctx,
            expires: (+new Date() + this.expires)
          };
        };
        jsonld.ActiveContextCache = function(size) {
          this.order = [];
          this.cache = {};
          this.size = size || 100;
        };
        jsonld.ActiveContextCache.prototype.get = function(activeCtx, localCtx) {
          var key1 = JSON.stringify(activeCtx);
          var key2 = JSON.stringify(localCtx);
          var level1 = this.cache[key1];
          if (level1 && key2 in level1) {
            return level1[key2];
          }
          return null;
        };
        jsonld.ActiveContextCache.prototype.set = function(activeCtx, localCtx, result) {
          if (this.order.length === this.size) {
            var entry = this.order.shift();
            delete this.cache[entry.activeCtx][entry.localCtx];
          }
          var key1 = JSON.stringify(activeCtx);
          var key2 = JSON.stringify(localCtx);
          this.order.push({
            activeCtx: key1,
            localCtx: key2
          });
          if (!(key1 in this.cache)) {
            this.cache[key1] = {};
          }
          this.cache[key1][key2] = _clone(result);
        };
        jsonld.cache = {activeCtx: new jsonld.ActiveContextCache()};
        jsonld.documentLoaders = {};
        jsonld.documentLoaders.jquery = function($, options) {
          options = options || {};
          var queue = new jsonld.RequestQueue();
          var usePromise = ('usePromise' in options ? options.usePromise : (typeof Promise !== 'undefined'));
          if (usePromise) {
            return queue.wrapLoader(function(url) {
              return jsonld.promisify(loader, url);
            });
          }
          return queue.wrapLoader(loader);
          function loader(url, callback) {
            if (url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0) {
              return callback(new JsonLdError('URL could not be dereferenced; only "http" and "https" URLs are ' + 'supported.', 'jsonld.InvalidUrl', {
                code: 'loading document failed',
                url: url
              }), {
                contextUrl: null,
                documentUrl: url,
                document: null
              });
            }
            if (options.secure && url.indexOf('https') !== 0) {
              return callback(new JsonLdError('URL could not be dereferenced; secure mode is enabled and ' + 'the URL\'s scheme is not "https".', 'jsonld.InvalidUrl', {
                code: 'loading document failed',
                url: url
              }), {
                contextUrl: null,
                documentUrl: url,
                document: null
              });
            }
            $.ajax({
              url: url,
              accepts: {json: 'application/ld+json, application/json'},
              headers: {'Accept': 'application/ld+json, application/json'},
              dataType: 'json',
              crossDomain: true,
              success: function(data, textStatus, jqXHR) {
                var doc = {
                  contextUrl: null,
                  documentUrl: url,
                  document: data
                };
                var contentType = jqXHR.getResponseHeader('Content-Type');
                var linkHeader = jqXHR.getResponseHeader('Link');
                if (linkHeader && contentType !== 'application/ld+json') {
                  linkHeader = jsonld.parseLinkHeader(linkHeader)[LINK_HEADER_REL];
                  if (_isArray(linkHeader)) {
                    return callback(new JsonLdError('URL could not be dereferenced, it has more than one ' + 'associated HTTP Link Header.', 'jsonld.InvalidUrl', {
                      code: 'multiple context link headers',
                      url: url
                    }), doc);
                  }
                  if (linkHeader) {
                    doc.contextUrl = linkHeader.target;
                  }
                }
                callback(null, doc);
              },
              error: function(jqXHR, textStatus, err) {
                callback(new JsonLdError('URL could not be dereferenced, an error occurred.', 'jsonld.LoadDocumentError', {
                  code: 'loading document failed',
                  url: url,
                  cause: err
                }), {
                  contextUrl: null,
                  documentUrl: url,
                  document: null
                });
              }
            });
          }
        };
        jsonld.documentLoaders.node = function(options) {
          options = options || {};
          var strictSSL = ('strictSSL' in options) ? options.strictSSL : true;
          var maxRedirects = ('maxRedirects' in options) ? options.maxRedirects : -1;
          var request = ('request' in options) ? options.request : req('a1');
          var acceptHeader = 'application/ld+json, application/json';
          var http = req('a1');
          var queue = new jsonld.RequestQueue();
          if (options.usePromise) {
            return queue.wrapLoader(function(url) {
              return jsonld.promisify(loadDocument, url, []);
            });
          }
          var headers = options.headers || {};
          if ('Accept' in headers || 'accept' in headers) {
            throw new RangeError('Accept header may not be specified as an option; only "' + acceptHeader + '" is supported.');
          }
          return queue.wrapLoader(function(url, callback) {
            loadDocument(url, [], callback);
          });
          function loadDocument(url, redirects, callback) {
            if (url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0) {
              return callback(new JsonLdError('URL could not be dereferenced; only "http" and "https" URLs are ' + 'supported.', 'jsonld.InvalidUrl', {
                code: 'loading document failed',
                url: url
              }), {
                contextUrl: null,
                documentUrl: url,
                document: null
              });
            }
            if (options.secure && url.indexOf('https') !== 0) {
              return callback(new JsonLdError('URL could not be dereferenced; secure mode is enabled and ' + 'the URL\'s scheme is not "https".', 'jsonld.InvalidUrl', {
                code: 'loading document failed',
                url: url
              }), {
                contextUrl: null,
                documentUrl: url,
                document: null
              });
            }
            var doc = null;
            if (doc !== null) {
              return callback(null, doc);
            }
            var headers = {'Accept': acceptHeader};
            for (var k in options.headers) {
              headers[k] = options.headers[k];
            }
            request({
              url: url,
              headers: headers,
              strictSSL: strictSSL,
              followRedirect: false
            }, handleResponse);
            function handleResponse(err, res, body) {
              doc = {
                contextUrl: null,
                documentUrl: url,
                document: body || null
              };
              if (err) {
                return callback(new JsonLdError('URL could not be dereferenced, an error occurred.', 'jsonld.LoadDocumentError', {
                  code: 'loading document failed',
                  url: url,
                  cause: err
                }), doc);
              }
              var statusText = http.STATUS_CODES[res.statusCode];
              if (res.statusCode >= 400) {
                return callback(new JsonLdError('URL could not be dereferenced: ' + statusText, 'jsonld.InvalidUrl', {
                  code: 'loading document failed',
                  url: url,
                  httpStatusCode: res.statusCode
                }), doc);
              }
              if (res.headers.link && res.headers['content-type'] !== 'application/ld+json') {
                var linkHeader = jsonld.parseLinkHeader(res.headers.link)[LINK_HEADER_REL];
                if (_isArray(linkHeader)) {
                  return callback(new JsonLdError('URL could not be dereferenced, it has more than one associated ' + 'HTTP Link Header.', 'jsonld.InvalidUrl', {
                    code: 'multiple context link headers',
                    url: url
                  }), doc);
                }
                if (linkHeader) {
                  doc.contextUrl = linkHeader.target;
                }
              }
              if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
                if (redirects.length === maxRedirects) {
                  return callback(new JsonLdError('URL could not be dereferenced; there were too many redirects.', 'jsonld.TooManyRedirects', {
                    code: 'loading document failed',
                    url: url,
                    httpStatusCode: res.statusCode,
                    redirects: redirects
                  }), doc);
                }
                if (redirects.indexOf(url) !== -1) {
                  return callback(new JsonLdError('URL could not be dereferenced; infinite redirection was detected.', 'jsonld.InfiniteRedirectDetected', {
                    code: 'recursive context inclusion',
                    url: url,
                    httpStatusCode: res.statusCode,
                    redirects: redirects
                  }), doc);
                }
                redirects.push(url);
                return loadDocument(res.headers.location, redirects, callback);
              }
              redirects.push(url);
              callback(err, doc);
            }
          }
        };
        jsonld.documentLoaders.xhr = function(options) {
          options = options || {};
          var rlink = /(^|(\r\n))link:/i;
          var queue = new jsonld.RequestQueue();
          var usePromise = ('usePromise' in options ? options.usePromise : (typeof Promise !== 'undefined'));
          if (usePromise) {
            return queue.wrapLoader(function(url) {
              return jsonld.promisify(loader, url);
            });
          }
          return queue.wrapLoader(loader);
          function loader(url, callback) {
            if (url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0) {
              return callback(new JsonLdError('URL could not be dereferenced; only "http" and "https" URLs are ' + 'supported.', 'jsonld.InvalidUrl', {
                code: 'loading document failed',
                url: url
              }), {
                contextUrl: null,
                documentUrl: url,
                document: null
              });
            }
            if (options.secure && url.indexOf('https') !== 0) {
              return callback(new JsonLdError('URL could not be dereferenced; secure mode is enabled and ' + 'the URL\'s scheme is not "https".', 'jsonld.InvalidUrl', {
                code: 'loading document failed',
                url: url
              }), {
                contextUrl: null,
                documentUrl: url,
                document: null
              });
            }
            var xhr = options.xhr || XMLHttpRequest;
            var req = new xhr();
            req.onload = function() {
              if (req.status >= 400) {
                return callback(new JsonLdError('URL could not be dereferenced: ' + req.statusText, 'jsonld.LoadDocumentError', {
                  code: 'loading document failed',
                  url: url,
                  httpStatusCode: req.status
                }), {
                  contextUrl: null,
                  documentUrl: url,
                  document: null
                });
              }
              var doc = {
                contextUrl: null,
                documentUrl: url,
                document: req.response
              };
              var contentType = req.getResponseHeader('Content-Type');
              var linkHeader;
              if (rlink.test(req.getAllResponseHeaders())) {
                linkHeader = req.getResponseHeader('Link');
              }
              if (linkHeader && contentType !== 'application/ld+json') {
                linkHeader = jsonld.parseLinkHeader(linkHeader)[LINK_HEADER_REL];
                if (_isArray(linkHeader)) {
                  return callback(new JsonLdError('URL could not be dereferenced, it has more than one ' + 'associated HTTP Link Header.', 'jsonld.InvalidUrl', {
                    code: 'multiple context link headers',
                    url: url
                  }), doc);
                }
                if (linkHeader) {
                  doc.contextUrl = linkHeader.target;
                }
              }
              callback(null, doc);
            };
            req.onerror = function() {
              callback(new JsonLdError('URL could not be dereferenced, an error occurred.', 'jsonld.LoadDocumentError', {
                code: 'loading document failed',
                url: url
              }), {
                contextUrl: null,
                documentUrl: url,
                document: null
              });
            };
            req.open('GET', url, true);
            req.setRequestHeader('Accept', 'application/ld+json, application/json');
            req.send();
          }
        };
        jsonld.useDocumentLoader = function(type) {
          if (!(type in jsonld.documentLoaders)) {
            throw new JsonLdError('Unknown document loader type: "' + type + '"', 'jsonld.UnknownDocumentLoader', {type: type});
          }
          jsonld.documentLoader = jsonld.documentLoaders[type].apply(jsonld, Array.prototype.slice.call(arguments, 1));
        };
        jsonld.processContext = function(activeCtx, localCtx) {
          var options = {};
          var callbackArg = 2;
          if (arguments.length > 3) {
            options = arguments[2] || {};
            callbackArg += 1;
          }
          var callback = arguments[callbackArg];
          if (!('base' in options)) {
            options.base = '';
          }
          if (!('documentLoader' in options)) {
            options.documentLoader = jsonld.loadDocument;
          }
          if (localCtx === null) {
            return callback(null, _getInitialContext(options));
          }
          localCtx = _clone(localCtx);
          if (!(_isObject(localCtx) && '@context' in localCtx)) {
            localCtx = {'@context': localCtx};
          }
          _retrieveContextUrls(localCtx, options, function(err, ctx) {
            if (err) {
              return callback(err);
            }
            try {
              ctx = new Processor().processContext(activeCtx, ctx, options);
            } catch (ex) {
              return callback(ex);
            }
            callback(null, ctx);
          });
        };
        jsonld.hasProperty = function(subject, property) {
          var rval = false;
          if (property in subject) {
            var value = subject[property];
            rval = (!_isArray(value) || value.length > 0);
          }
          return rval;
        };
        jsonld.hasValue = function(subject, property, value) {
          var rval = false;
          if (jsonld.hasProperty(subject, property)) {
            var val = subject[property];
            var isList = _isList(val);
            if (_isArray(val) || isList) {
              if (isList) {
                val = val['@list'];
              }
              for (var i = 0; i < val.length; ++i) {
                if (jsonld.compareValues(value, val[i])) {
                  rval = true;
                  break;
                }
              }
            } else if (!_isArray(value)) {
              rval = jsonld.compareValues(value, val);
            }
          }
          return rval;
        };
        jsonld.addValue = function(subject, property, value, options) {
          options = options || {};
          if (!('propertyIsArray' in options)) {
            options.propertyIsArray = false;
          }
          if (!('allowDuplicate' in options)) {
            options.allowDuplicate = true;
          }
          if (_isArray(value)) {
            if (value.length === 0 && options.propertyIsArray && !(property in subject)) {
              subject[property] = [];
            }
            for (var i = 0; i < value.length; ++i) {
              jsonld.addValue(subject, property, value[i], options);
            }
          } else if (property in subject) {
            var hasValue = (!options.allowDuplicate && jsonld.hasValue(subject, property, value));
            if (!_isArray(subject[property]) && (!hasValue || options.propertyIsArray)) {
              subject[property] = [subject[property]];
            }
            if (!hasValue) {
              subject[property].push(value);
            }
          } else {
            subject[property] = options.propertyIsArray ? [value] : value;
          }
        };
        jsonld.getValues = function(subject, property) {
          var rval = subject[property] || [];
          if (!_isArray(rval)) {
            rval = [rval];
          }
          return rval;
        };
        jsonld.removeProperty = function(subject, property) {
          delete subject[property];
        };
        jsonld.removeValue = function(subject, property, value, options) {
          options = options || {};
          if (!('propertyIsArray' in options)) {
            options.propertyIsArray = false;
          }
          var values = jsonld.getValues(subject, property).filter(function(e) {
            return !jsonld.compareValues(e, value);
          });
          if (values.length === 0) {
            jsonld.removeProperty(subject, property);
          } else if (values.length === 1 && !options.propertyIsArray) {
            subject[property] = values[0];
          } else {
            subject[property] = values;
          }
        };
        jsonld.compareValues = function(v1, v2) {
          if (v1 === v2) {
            return true;
          }
          if (_isValue(v1) && _isValue(v2) && v1['@value'] === v2['@value'] && v1['@type'] === v2['@type'] && v1['@language'] === v2['@language'] && v1['@index'] === v2['@index']) {
            return true;
          }
          if (_isObject(v1) && ('@id' in v1) && _isObject(v2) && ('@id' in v2)) {
            return v1['@id'] === v2['@id'];
          }
          return false;
        };
        jsonld.getContextValue = function(ctx, key, type) {
          var rval = null;
          if (key === null) {
            return rval;
          }
          if (type === '@language' && (type in ctx)) {
            rval = ctx[type];
          }
          if (ctx.mappings[key]) {
            var entry = ctx.mappings[key];
            if (_isUndefined(type)) {
              rval = entry;
            } else if (type in entry) {
              rval = entry[type];
            }
          }
          return rval;
        };
        var _rdfParsers = {};
        jsonld.registerRDFParser = function(contentType, parser) {
          _rdfParsers[contentType] = parser;
        };
        jsonld.unregisterRDFParser = function(contentType) {
          delete _rdfParsers[contentType];
        };
        if (_nodejs) {
          if (typeof XMLSerializer === 'undefined') {
            var XMLSerializer = null;
          }
          if (typeof Node === 'undefined') {
            var Node = {
              ELEMENT_NODE: 1,
              ATTRIBUTE_NODE: 2,
              TEXT_NODE: 3,
              CDATA_SECTION_NODE: 4,
              ENTITY_REFERENCE_NODE: 5,
              ENTITY_NODE: 6,
              PROCESSING_INSTRUCTION_NODE: 7,
              COMMENT_NODE: 8,
              DOCUMENT_NODE: 9,
              DOCUMENT_TYPE_NODE: 10,
              DOCUMENT_FRAGMENT_NODE: 11,
              NOTATION_NODE: 12
            };
          }
        }
        var XSD_BOOLEAN = 'http://www.w3.org/2001/XMLSchema#boolean';
        var XSD_DOUBLE = 'http://www.w3.org/2001/XMLSchema#double';
        var XSD_INTEGER = 'http://www.w3.org/2001/XMLSchema#integer';
        var XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string';
        var RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
        var RDF_LIST = RDF + 'List';
        var RDF_FIRST = RDF + 'first';
        var RDF_REST = RDF + 'rest';
        var RDF_NIL = RDF + 'nil';
        var RDF_TYPE = RDF + 'type';
        var RDF_PLAIN_LITERAL = RDF + 'PlainLiteral';
        var RDF_XML_LITERAL = RDF + 'XMLLiteral';
        var RDF_OBJECT = RDF + 'object';
        var RDF_LANGSTRING = RDF + 'langString';
        var LINK_HEADER_REL = 'http://www.w3.org/ns/json-ld#context';
        var MAX_CONTEXT_URLS = 10;
        var JsonLdError = function(msg, type, details) {
          if (_nodejs) {
            Error.call(this);
            Error.captureStackTrace(this, this.constructor);
          } else if (typeof Error !== 'undefined') {
            this.stack = (new Error()).stack;
          }
          this.name = type || 'jsonld.Error';
          this.message = msg || 'An unspecified JSON-LD error occurred.';
          this.details = details || {};
        };
        if (_nodejs) {
          req('a1').inherits(JsonLdError, Error);
        } else if (typeof Error !== 'undefined') {
          JsonLdError.prototype = new Error();
        }
        var Processor = function() {};
        Processor.prototype.compact = function(activeCtx, activeProperty, element, options) {
          if (_isArray(element)) {
            var rval = [];
            for (var i = 0; i < element.length; ++i) {
              var compacted = this.compact(activeCtx, activeProperty, element[i], options);
              if (compacted !== null) {
                rval.push(compacted);
              }
            }
            if (options.compactArrays && rval.length === 1) {
              var container = jsonld.getContextValue(activeCtx, activeProperty, '@container');
              if (container === null) {
                rval = rval[0];
              }
            }
            return rval;
          }
          if (_isObject(element)) {
            if (options.link && '@id' in element && element['@id'] in options.link) {
              var linked = options.link[element['@id']];
              for (var i = 0; i < linked.length; ++i) {
                if (linked[i].expanded === element) {
                  return linked[i].compacted;
                }
              }
            }
            if (_isValue(element) || _isSubjectReference(element)) {
              var rval = _compactValue(activeCtx, activeProperty, element);
              if (options.link && _isSubjectReference(element)) {
                if (!(element['@id'] in options.link)) {
                  options.link[element['@id']] = [];
                }
                options.link[element['@id']].push({
                  expanded: element,
                  compacted: rval
                });
              }
              return rval;
            }
            var insideReverse = (activeProperty === '@reverse');
            var rval = {};
            if (options.link && '@id' in element) {
              if (!(element['@id'] in options.link)) {
                options.link[element['@id']] = [];
              }
              options.link[element['@id']].push({
                expanded: element,
                compacted: rval
              });
            }
            var keys = Object.keys(element).sort();
            for (var ki = 0; ki < keys.length; ++ki) {
              var expandedProperty = keys[ki];
              var expandedValue = element[expandedProperty];
              if (expandedProperty === '@id' || expandedProperty === '@type') {
                var compactedValue;
                if (_isString(expandedValue)) {
                  compactedValue = _compactIri(activeCtx, expandedValue, null, {vocab: (expandedProperty === '@type')});
                } else {
                  compactedValue = [];
                  for (var vi = 0; vi < expandedValue.length; ++vi) {
                    compactedValue.push(_compactIri(activeCtx, expandedValue[vi], null, {vocab: true}));
                  }
                }
                var alias = _compactIri(activeCtx, expandedProperty);
                var isArray = (_isArray(compactedValue) && expandedValue.length === 0);
                jsonld.addValue(rval, alias, compactedValue, {propertyIsArray: isArray});
                continue;
              }
              if (expandedProperty === '@reverse') {
                var compactedValue = this.compact(activeCtx, '@reverse', expandedValue, options);
                for (var compactedProperty in compactedValue) {
                  if (activeCtx.mappings[compactedProperty] && activeCtx.mappings[compactedProperty].reverse) {
                    var value = compactedValue[compactedProperty];
                    var container = jsonld.getContextValue(activeCtx, compactedProperty, '@container');
                    var useArray = (container === '@set' || !options.compactArrays);
                    jsonld.addValue(rval, compactedProperty, value, {propertyIsArray: useArray});
                    delete compactedValue[compactedProperty];
                  }
                }
                if (Object.keys(compactedValue).length > 0) {
                  var alias = _compactIri(activeCtx, expandedProperty);
                  jsonld.addValue(rval, alias, compactedValue);
                }
                continue;
              }
              if (expandedProperty === '@index') {
                var container = jsonld.getContextValue(activeCtx, activeProperty, '@container');
                if (container === '@index') {
                  continue;
                }
                var alias = _compactIri(activeCtx, expandedProperty);
                jsonld.addValue(rval, alias, expandedValue);
                continue;
              }
              if (expandedProperty !== '@graph' && expandedProperty !== '@list' && _isKeyword(expandedProperty)) {
                var alias = _compactIri(activeCtx, expandedProperty);
                jsonld.addValue(rval, alias, expandedValue);
                continue;
              }
              if (expandedValue.length === 0) {
                var itemActiveProperty = _compactIri(activeCtx, expandedProperty, expandedValue, {vocab: true}, insideReverse);
                jsonld.addValue(rval, itemActiveProperty, expandedValue, {propertyIsArray: true});
              }
              for (var vi = 0; vi < expandedValue.length; ++vi) {
                var expandedItem = expandedValue[vi];
                var itemActiveProperty = _compactIri(activeCtx, expandedProperty, expandedItem, {vocab: true}, insideReverse);
                var container = jsonld.getContextValue(activeCtx, itemActiveProperty, '@container');
                var isList = _isList(expandedItem);
                var list = null;
                if (isList) {
                  list = expandedItem['@list'];
                }
                var compactedItem = this.compact(activeCtx, itemActiveProperty, isList ? list : expandedItem, options);
                if (isList) {
                  if (!_isArray(compactedItem)) {
                    compactedItem = [compactedItem];
                  }
                  if (container !== '@list') {
                    var wrapper = {};
                    wrapper[_compactIri(activeCtx, '@list')] = compactedItem;
                    compactedItem = wrapper;
                    if ('@index' in expandedItem) {
                      compactedItem[_compactIri(activeCtx, '@index')] = expandedItem['@index'];
                    }
                  } else if (itemActiveProperty in rval) {
                    throw new JsonLdError('JSON-LD compact error; property has a "@list" @container ' + 'rule but there is more than a single @list that matches ' + 'the compacted term in the document. Compaction might mix ' + 'unwanted items into the list.', 'jsonld.SyntaxError', {code: 'compaction to list of lists'});
                  }
                }
                if (container === '@language' || container === '@index') {
                  var mapObject;
                  if (itemActiveProperty in rval) {
                    mapObject = rval[itemActiveProperty];
                  } else {
                    rval[itemActiveProperty] = mapObject = {};
                  }
                  if (container === '@language' && _isValue(compactedItem)) {
                    compactedItem = compactedItem['@value'];
                  }
                  jsonld.addValue(mapObject, expandedItem[container], compactedItem);
                } else {
                  var isArray = (!options.compactArrays || container === '@set' || container === '@list' || (_isArray(compactedItem) && compactedItem.length === 0) || expandedProperty === '@list' || expandedProperty === '@graph');
                  jsonld.addValue(rval, itemActiveProperty, compactedItem, {propertyIsArray: isArray});
                }
              }
            }
            return rval;
          }
          return element;
        };
        Processor.prototype.expand = function(activeCtx, activeProperty, element, options, insideList) {
          var self = this;
          if (element === null || element === undefined) {
            return null;
          }
          if (!_isArray(element) && !_isObject(element)) {
            if (!insideList && (activeProperty === null || _expandIri(activeCtx, activeProperty, {vocab: true}) === '@graph')) {
              return null;
            }
            return _expandValue(activeCtx, activeProperty, element);
          }
          if (_isArray(element)) {
            var rval = [];
            var container = jsonld.getContextValue(activeCtx, activeProperty, '@container');
            insideList = insideList || container === '@list';
            for (var i = 0; i < element.length; ++i) {
              var e = self.expand(activeCtx, activeProperty, element[i], options);
              if (insideList && (_isArray(e) || _isList(e))) {
                throw new JsonLdError('Invalid JSON-LD syntax; lists of lists are not permitted.', 'jsonld.SyntaxError', {code: 'list of lists'});
              }
              if (e !== null) {
                if (_isArray(e)) {
                  rval = rval.concat(e);
                } else {
                  rval.push(e);
                }
              }
            }
            return rval;
          }
          if ('@context' in element) {
            activeCtx = self.processContext(activeCtx, element['@context'], options);
          }
          var expandedActiveProperty = _expandIri(activeCtx, activeProperty, {vocab: true});
          var rval = {};
          var keys = Object.keys(element).sort();
          for (var ki = 0; ki < keys.length; ++ki) {
            var key = keys[ki];
            var value = element[key];
            var expandedValue;
            if (key === '@context') {
              continue;
            }
            var expandedProperty = _expandIri(activeCtx, key, {vocab: true});
            if (expandedProperty === null || !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty))) {
              continue;
            }
            if (_isKeyword(expandedProperty)) {
              if (expandedActiveProperty === '@reverse') {
                throw new JsonLdError('Invalid JSON-LD syntax; a keyword cannot be used as a @reverse ' + 'property.', 'jsonld.SyntaxError', {
                  code: 'invalid reverse property map',
                  value: value
                });
              }
              if (expandedProperty in rval) {
                throw new JsonLdError('Invalid JSON-LD syntax; colliding keywords detected.', 'jsonld.SyntaxError', {
                  code: 'colliding keywords',
                  keyword: expandedProperty
                });
              }
            }
            if (expandedProperty === '@id' && !_isString(value)) {
              if (!options.isFrame) {
                throw new JsonLdError('Invalid JSON-LD syntax; "@id" value must a string.', 'jsonld.SyntaxError', {
                  code: 'invalid @id value',
                  value: value
                });
              }
              if (!_isObject(value)) {
                throw new JsonLdError('Invalid JSON-LD syntax; "@id" value must be a string or an ' + 'object.', 'jsonld.SyntaxError', {
                  code: 'invalid @id value',
                  value: value
                });
              }
            }
            if (expandedProperty === '@type') {
              _validateTypeValue(value);
            }
            if (expandedProperty === '@graph' && !(_isObject(value) || _isArray(value))) {
              throw new JsonLdError('Invalid JSON-LD syntax; "@graph" value must not be an ' + 'object or an array.', 'jsonld.SyntaxError', {
                code: 'invalid @graph value',
                value: value
              });
            }
            if (expandedProperty === '@value' && (_isObject(value) || _isArray(value))) {
              throw new JsonLdError('Invalid JSON-LD syntax; "@value" value must not be an ' + 'object or an array.', 'jsonld.SyntaxError', {
                code: 'invalid value object value',
                value: value
              });
            }
            if (expandedProperty === '@language') {
              if (value === null) {
                continue;
              }
              if (!_isString(value)) {
                throw new JsonLdError('Invalid JSON-LD syntax; "@language" value must be a string.', 'jsonld.SyntaxError', {
                  code: 'invalid language-tagged string',
                  value: value
                });
              }
              value = value.toLowerCase();
            }
            if (expandedProperty === '@index') {
              if (!_isString(value)) {
                throw new JsonLdError('Invalid JSON-LD syntax; "@index" value must be a string.', 'jsonld.SyntaxError', {
                  code: 'invalid @index value',
                  value: value
                });
              }
            }
            if (expandedProperty === '@reverse') {
              if (!_isObject(value)) {
                throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must be an object.', 'jsonld.SyntaxError', {
                  code: 'invalid @reverse value',
                  value: value
                });
              }
              expandedValue = self.expand(activeCtx, '@reverse', value, options);
              if ('@reverse' in expandedValue) {
                for (var property in expandedValue['@reverse']) {
                  jsonld.addValue(rval, property, expandedValue['@reverse'][property], {propertyIsArray: true});
                }
              }
              var reverseMap = rval['@reverse'] || null;
              for (var property in expandedValue) {
                if (property === '@reverse') {
                  continue;
                }
                if (reverseMap === null) {
                  reverseMap = rval['@reverse'] = {};
                }
                jsonld.addValue(reverseMap, property, [], {propertyIsArray: true});
                var items = expandedValue[property];
                for (var ii = 0; ii < items.length; ++ii) {
                  var item = items[ii];
                  if (_isValue(item) || _isList(item)) {
                    throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must not be a ' + '@value or an @list.', 'jsonld.SyntaxError', {
                      code: 'invalid reverse property value',
                      value: expandedValue
                    });
                  }
                  jsonld.addValue(reverseMap, property, item, {propertyIsArray: true});
                }
              }
              continue;
            }
            var container = jsonld.getContextValue(activeCtx, key, '@container');
            if (container === '@language' && _isObject(value)) {
              expandedValue = _expandLanguageMap(value);
            } else if (container === '@index' && _isObject(value)) {
              expandedValue = (function _expandIndexMap(activeProperty) {
                var rval = [];
                var keys = Object.keys(value).sort();
                for (var ki = 0; ki < keys.length; ++ki) {
                  var key = keys[ki];
                  var val = value[key];
                  if (!_isArray(val)) {
                    val = [val];
                  }
                  val = self.expand(activeCtx, activeProperty, val, options, false);
                  for (var vi = 0; vi < val.length; ++vi) {
                    var item = val[vi];
                    if (!('@index' in item)) {
                      item['@index'] = key;
                    }
                    rval.push(item);
                  }
                }
                return rval;
              })(key);
            } else {
              var isList = (expandedProperty === '@list');
              if (isList || expandedProperty === '@set') {
                var nextActiveProperty = activeProperty;
                if (isList && expandedActiveProperty === '@graph') {
                  nextActiveProperty = null;
                }
                expandedValue = self.expand(activeCtx, nextActiveProperty, value, options, isList);
                if (isList && _isList(expandedValue)) {
                  throw new JsonLdError('Invalid JSON-LD syntax; lists of lists are not permitted.', 'jsonld.SyntaxError', {code: 'list of lists'});
                }
              } else {
                expandedValue = self.expand(activeCtx, key, value, options, false);
              }
            }
            if (expandedValue === null && expandedProperty !== '@value') {
              continue;
            }
            if (expandedProperty !== '@list' && !_isList(expandedValue) && container === '@list') {
              expandedValue = (_isArray(expandedValue) ? expandedValue : [expandedValue]);
              expandedValue = {'@list': expandedValue};
            }
            if (activeCtx.mappings[key] && activeCtx.mappings[key].reverse) {
              var reverseMap = rval['@reverse'] = rval['@reverse'] || {};
              if (!_isArray(expandedValue)) {
                expandedValue = [expandedValue];
              }
              for (var ii = 0; ii < expandedValue.length; ++ii) {
                var item = expandedValue[ii];
                if (_isValue(item) || _isList(item)) {
                  throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must not be a ' + '@value or an @list.', 'jsonld.SyntaxError', {
                    code: 'invalid reverse property value',
                    value: expandedValue
                  });
                }
                jsonld.addValue(reverseMap, expandedProperty, item, {propertyIsArray: true});
              }
              continue;
            }
            var useArray = ['@index', '@id', '@type', '@value', '@language'].indexOf(expandedProperty) === -1;
            jsonld.addValue(rval, expandedProperty, expandedValue, {propertyIsArray: useArray});
          }
          keys = Object.keys(rval);
          var count = keys.length;
          if ('@value' in rval) {
            if ('@type' in rval && '@language' in rval) {
              throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" may not ' + 'contain both "@type" and "@language".', 'jsonld.SyntaxError', {
                code: 'invalid value object',
                element: rval
              });
            }
            var validCount = count - 1;
            if ('@type' in rval) {
              validCount -= 1;
            }
            if ('@index' in rval) {
              validCount -= 1;
            }
            if ('@language' in rval) {
              validCount -= 1;
            }
            if (validCount !== 0) {
              throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" may only ' + 'have an "@index" property and at most one other property ' + 'which can be "@type" or "@language".', 'jsonld.SyntaxError', {
                code: 'invalid value object',
                element: rval
              });
            }
            if (rval['@value'] === null) {
              rval = null;
            } else if ('@language' in rval && !_isString(rval['@value'])) {
              throw new JsonLdError('Invalid JSON-LD syntax; only strings may be language-tagged.', 'jsonld.SyntaxError', {
                code: 'invalid language-tagged value',
                element: rval
              });
            } else if ('@type' in rval && (!_isAbsoluteIri(rval['@type']) || rval['@type'].indexOf('_:') === 0)) {
              throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" and "@type" ' + 'must have an absolute IRI for the value of "@type".', 'jsonld.SyntaxError', {
                code: 'invalid typed value',
                element: rval
              });
            }
          } else if ('@type' in rval && !_isArray(rval['@type'])) {
            rval['@type'] = [rval['@type']];
          } else if ('@set' in rval || '@list' in rval) {
            if (count > 1 && !(count === 2 && '@index' in rval)) {
              throw new JsonLdError('Invalid JSON-LD syntax; if an element has the property "@set" ' + 'or "@list", then it can have at most one other property that is ' + '"@index".', 'jsonld.SyntaxError', {
                code: 'invalid set or list object',
                element: rval
              });
            }
            if ('@set' in rval) {
              rval = rval['@set'];
              keys = Object.keys(rval);
              count = keys.length;
            }
          } else if (count === 1 && '@language' in rval) {
            rval = null;
          }
          if (_isObject(rval) && !options.keepFreeFloatingNodes && !insideList && (activeProperty === null || expandedActiveProperty === '@graph')) {
            if (count === 0 || '@value' in rval || '@list' in rval || (count === 1 && '@id' in rval)) {
              rval = null;
            }
          }
          return rval;
        };
        Processor.prototype.createNodeMap = function(input, options) {
          options = options || {};
          var issuer = options.namer || options.issuer || new IdentifierIssuer('_:b');
          var graphs = {'@default': {}};
          _createNodeMap(input, graphs, '@default', issuer);
          return _mergeNodeMaps(graphs);
        };
        Processor.prototype.flatten = function(input) {
          var defaultGraph = this.createNodeMap(input);
          var flattened = [];
          var keys = Object.keys(defaultGraph).sort();
          for (var ki = 0; ki < keys.length; ++ki) {
            var node = defaultGraph[keys[ki]];
            if (!_isSubjectReference(node)) {
              flattened.push(node);
            }
          }
          return flattened;
        };
        Processor.prototype.frame = function(input, frame, options) {
          var state = {
            options: options,
            graphs: {
              '@default': {},
              '@merged': {}
            },
            subjectStack: [],
            link: {}
          };
          var issuer = new IdentifierIssuer('_:b');
          _createNodeMap(input, state.graphs, '@merged', issuer);
          state.subjects = state.graphs['@merged'];
          var framed = [];
          _frame(state, Object.keys(state.subjects).sort(), frame, framed, null);
          return framed;
        };
        Processor.prototype.normalize = function(dataset, options, callback) {
          if (options.algorithm === 'URDNA2015') {
            return new URDNA2015(options).main(dataset, callback);
          }
          if (options.algorithm === 'URGNA2012') {
            return new URGNA2012(options).main(dataset, callback);
          }
          callback(new Error('Invalid RDF Dataset Normalization algorithm: ' + options.algorithm));
        };
        Processor.prototype.fromRDF = function(dataset, options, callback) {
          var defaultGraph = {};
          var graphMap = {'@default': defaultGraph};
          var referencedOnce = {};
          for (var name in dataset) {
            var graph = dataset[name];
            if (!(name in graphMap)) {
              graphMap[name] = {};
            }
            if (name !== '@default' && !(name in defaultGraph)) {
              defaultGraph[name] = {'@id': name};
            }
            var nodeMap = graphMap[name];
            for (var ti = 0; ti < graph.length; ++ti) {
              var triple = graph[ti];
              var s = triple.subject.value;
              var p = triple.predicate.value;
              var o = triple.object;
              if (!(s in nodeMap)) {
                nodeMap[s] = {'@id': s};
              }
              var node = nodeMap[s];
              var objectIsId = (o.type === 'IRI' || o.type === 'blank node');
              if (objectIsId && !(o.value in nodeMap)) {
                nodeMap[o.value] = {'@id': o.value};
              }
              if (p === RDF_TYPE && !options.useRdfType && objectIsId) {
                jsonld.addValue(node, '@type', o.value, {propertyIsArray: true});
                continue;
              }
              var value = _RDFToObject(o, options.useNativeTypes);
              jsonld.addValue(node, p, value, {propertyIsArray: true});
              if (objectIsId) {
                if (o.value === RDF_NIL) {
                  var object = nodeMap[o.value];
                  if (!('usages' in object)) {
                    object.usages = [];
                  }
                  object.usages.push({
                    node: node,
                    property: p,
                    value: value
                  });
                } else if (o.value in referencedOnce) {
                  referencedOnce[o.value] = false;
                } else {
                  referencedOnce[o.value] = {
                    node: node,
                    property: p,
                    value: value
                  };
                }
              }
            }
          }
          for (var name in graphMap) {
            var graphObject = graphMap[name];
            if (!(RDF_NIL in graphObject)) {
              continue;
            }
            var nil = graphObject[RDF_NIL];
            for (var i = 0; i < nil.usages.length; ++i) {
              var usage = nil.usages[i];
              var node = usage.node;
              var property = usage.property;
              var head = usage.value;
              var list = [];
              var listNodes = [];
              var nodeKeyCount = Object.keys(node).length;
              while (property === RDF_REST && _isObject(referencedOnce[node['@id']]) && _isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 && _isArray(node[RDF_REST]) && node[RDF_REST].length === 1 && (nodeKeyCount === 3 || (nodeKeyCount === 4 && _isArray(node['@type']) && node['@type'].length === 1 && node['@type'][0] === RDF_LIST))) {
                list.push(node[RDF_FIRST][0]);
                listNodes.push(node['@id']);
                usage = referencedOnce[node['@id']];
                node = usage.node;
                property = usage.property;
                head = usage.value;
                nodeKeyCount = Object.keys(node).length;
                if (node['@id'].indexOf('_:') !== 0) {
                  break;
                }
              }
              if (property === RDF_FIRST) {
                if (node['@id'] === RDF_NIL) {
                  continue;
                }
                head = graphObject[head['@id']][RDF_REST][0];
                list.pop();
                listNodes.pop();
              }
              delete head['@id'];
              head['@list'] = list.reverse();
              for (var j = 0; j < listNodes.length; ++j) {
                delete graphObject[listNodes[j]];
              }
            }
            delete nil.usages;
          }
          var result = [];
          var subjects = Object.keys(defaultGraph).sort();
          for (var i = 0; i < subjects.length; ++i) {
            var subject = subjects[i];
            var node = defaultGraph[subject];
            if (subject in graphMap) {
              var graph = node['@graph'] = [];
              var graphObject = graphMap[subject];
              var subjects_ = Object.keys(graphObject).sort();
              for (var si = 0; si < subjects_.length; ++si) {
                var node_ = graphObject[subjects_[si]];
                if (!_isSubjectReference(node_)) {
                  graph.push(node_);
                }
              }
            }
            if (!_isSubjectReference(node)) {
              result.push(node);
            }
          }
          callback(null, result);
        };
        Processor.prototype.toRDF = function(input, options) {
          var issuer = new IdentifierIssuer('_:b');
          var nodeMap = {'@default': {}};
          _createNodeMap(input, nodeMap, '@default', issuer);
          var dataset = {};
          var graphNames = Object.keys(nodeMap).sort();
          for (var i = 0; i < graphNames.length; ++i) {
            var graphName = graphNames[i];
            if (graphName === '@default' || _isAbsoluteIri(graphName)) {
              dataset[graphName] = _graphToRDF(nodeMap[graphName], issuer, options);
            }
          }
          return dataset;
        };
        Processor.prototype.processContext = function(activeCtx, localCtx, options) {
          if (_isObject(localCtx) && '@context' in localCtx && _isArray(localCtx['@context'])) {
            localCtx = localCtx['@context'];
          }
          var ctxs = _isArray(localCtx) ? localCtx : [localCtx];
          if (ctxs.length === 0) {
            return activeCtx.clone();
          }
          var rval = activeCtx;
          for (var i = 0; i < ctxs.length; ++i) {
            var ctx = ctxs[i];
            if (ctx === null) {
              rval = activeCtx = _getInitialContext(options);
              continue;
            }
            if (_isObject(ctx) && '@context' in ctx) {
              ctx = ctx['@context'];
            }
            if (!_isObject(ctx)) {
              throw new JsonLdError('Invalid JSON-LD syntax; @context must be an object.', 'jsonld.SyntaxError', {
                code: 'invalid local context',
                context: ctx
              });
            }
            if (jsonld.cache.activeCtx) {
              var cached = jsonld.cache.activeCtx.get(activeCtx, ctx);
              if (cached) {
                rval = activeCtx = cached;
                continue;
              }
            }
            activeCtx = rval;
            rval = rval.clone();
            var defined = {};
            if ('@base' in ctx) {
              var base = ctx['@base'];
              if (base === null) {
                base = null;
              } else if (!_isString(base)) {
                throw new JsonLdError('Invalid JSON-LD syntax; the value of "@base" in a ' + '@context must be a string or null.', 'jsonld.SyntaxError', {
                  code: 'invalid base IRI',
                  context: ctx
                });
              } else if (base !== '' && !_isAbsoluteIri(base)) {
                throw new JsonLdError('Invalid JSON-LD syntax; the value of "@base" in a ' + '@context must be an absolute IRI or the empty string.', 'jsonld.SyntaxError', {
                  code: 'invalid base IRI',
                  context: ctx
                });
              }
              if (base !== null) {
                base = jsonld.url.parse(base || '');
              }
              rval['@base'] = base;
              defined['@base'] = true;
            }
            if ('@vocab' in ctx) {
              var value = ctx['@vocab'];
              if (value === null) {
                delete rval['@vocab'];
              } else if (!_isString(value)) {
                throw new JsonLdError('Invalid JSON-LD syntax; the value of "@vocab" in a ' + '@context must be a string or null.', 'jsonld.SyntaxError', {
                  code: 'invalid vocab mapping',
                  context: ctx
                });
              } else if (!_isAbsoluteIri(value)) {
                throw new JsonLdError('Invalid JSON-LD syntax; the value of "@vocab" in a ' + '@context must be an absolute IRI.', 'jsonld.SyntaxError', {
                  code: 'invalid vocab mapping',
                  context: ctx
                });
              } else {
                rval['@vocab'] = value;
              }
              defined['@vocab'] = true;
            }
            if ('@language' in ctx) {
              var value = ctx['@language'];
              if (value === null) {
                delete rval['@language'];
              } else if (!_isString(value)) {
                throw new JsonLdError('Invalid JSON-LD syntax; the value of "@language" in a ' + '@context must be a string or null.', 'jsonld.SyntaxError', {
                  code: 'invalid default language',
                  context: ctx
                });
              } else {
                rval['@language'] = value.toLowerCase();
              }
              defined['@language'] = true;
            }
            for (var key in ctx) {
              _createTermDefinition(rval, ctx, key, defined);
            }
            if (jsonld.cache.activeCtx) {
              jsonld.cache.activeCtx.set(activeCtx, ctx, rval);
            }
          }
          return rval;
        };
        function _expandLanguageMap(languageMap) {
          var rval = [];
          var keys = Object.keys(languageMap).sort();
          for (var ki = 0; ki < keys.length; ++ki) {
            var key = keys[ki];
            var val = languageMap[key];
            if (!_isArray(val)) {
              val = [val];
            }
            for (var vi = 0; vi < val.length; ++vi) {
              var item = val[vi];
              if (item === null) {
                continue;
              }
              if (!_isString(item)) {
                throw new JsonLdError('Invalid JSON-LD syntax; language map values must be strings.', 'jsonld.SyntaxError', {
                  code: 'invalid language map value',
                  languageMap: languageMap
                });
              }
              rval.push({
                '@value': item,
                '@language': key.toLowerCase()
              });
            }
          }
          return rval;
        }
        function _labelBlankNodes(issuer, element) {
          if (_isArray(element)) {
            for (var i = 0; i < element.length; ++i) {
              element[i] = _labelBlankNodes(issuer, element[i]);
            }
          } else if (_isList(element)) {
            element['@list'] = _labelBlankNodes(issuer, element['@list']);
          } else if (_isObject(element)) {
            if (_isBlankNode(element)) {
              element['@id'] = issuer.getId(element['@id']);
            }
            var keys = Object.keys(element).sort();
            for (var ki = 0; ki < keys.length; ++ki) {
              var key = keys[ki];
              if (key !== '@id') {
                element[key] = _labelBlankNodes(issuer, element[key]);
              }
            }
          }
          return element;
        }
        function _expandValue(activeCtx, activeProperty, value) {
          if (value === null || value === undefined) {
            return null;
          }
          var expandedProperty = _expandIri(activeCtx, activeProperty, {vocab: true});
          if (expandedProperty === '@id') {
            return _expandIri(activeCtx, value, {base: true});
          } else if (expandedProperty === '@type') {
            return _expandIri(activeCtx, value, {
              vocab: true,
              base: true
            });
          }
          var type = jsonld.getContextValue(activeCtx, activeProperty, '@type');
          if (type === '@id' || (expandedProperty === '@graph' && _isString(value))) {
            return {'@id': _expandIri(activeCtx, value, {base: true})};
          }
          if (type === '@vocab') {
            return {'@id': _expandIri(activeCtx, value, {
                vocab: true,
                base: true
              })};
          }
          if (_isKeyword(expandedProperty)) {
            return value;
          }
          var rval = {};
          if (type !== null) {
            rval['@type'] = type;
          } else if (_isString(value)) {
            var language = jsonld.getContextValue(activeCtx, activeProperty, '@language');
            if (language !== null) {
              rval['@language'] = language;
            }
          }
          if (['boolean', 'number', 'string'].indexOf(typeof value) === -1) {
            value = value.toString();
          }
          rval['@value'] = value;
          return rval;
        }
        function _graphToRDF(graph, issuer, options) {
          var rval = [];
          var ids = Object.keys(graph).sort();
          for (var i = 0; i < ids.length; ++i) {
            var id = ids[i];
            var node = graph[id];
            var properties = Object.keys(node).sort();
            for (var pi = 0; pi < properties.length; ++pi) {
              var property = properties[pi];
              var items = node[property];
              if (property === '@type') {
                property = RDF_TYPE;
              } else if (_isKeyword(property)) {
                continue;
              }
              for (var ii = 0; ii < items.length; ++ii) {
                var item = items[ii];
                var subject = {};
                subject.type = (id.indexOf('_:') === 0) ? 'blank node' : 'IRI';
                subject.value = id;
                if (!_isAbsoluteIri(id)) {
                  continue;
                }
                var predicate = {};
                predicate.type = (property.indexOf('_:') === 0) ? 'blank node' : 'IRI';
                predicate.value = property;
                if (!_isAbsoluteIri(property)) {
                  continue;
                }
                if (predicate.type === 'blank node' && !options.produceGeneralizedRdf) {
                  continue;
                }
                if (_isList(item)) {
                  _listToRDF(item['@list'], issuer, subject, predicate, rval);
                } else {
                  var object = _objectToRDF(item);
                  if (object) {
                    rval.push({
                      subject: subject,
                      predicate: predicate,
                      object: object
                    });
                  }
                }
              }
            }
          }
          return rval;
        }
        function _listToRDF(list, issuer, subject, predicate, triples) {
          var first = {
            type: 'IRI',
            value: RDF_FIRST
          };
          var rest = {
            type: 'IRI',
            value: RDF_REST
          };
          var nil = {
            type: 'IRI',
            value: RDF_NIL
          };
          for (var i = 0; i < list.length; ++i) {
            var item = list[i];
            var blankNode = {
              type: 'blank node',
              value: issuer.getId()
            };
            triples.push({
              subject: subject,
              predicate: predicate,
              object: blankNode
            });
            subject = blankNode;
            predicate = first;
            var object = _objectToRDF(item);
            if (object) {
              triples.push({
                subject: subject,
                predicate: predicate,
                object: object
              });
            }
            predicate = rest;
          }
          triples.push({
            subject: subject,
            predicate: predicate,
            object: nil
          });
        }
        function _objectToRDF(item) {
          var object = {};
          if (_isValue(item)) {
            object.type = 'literal';
            var value = item['@value'];
            var datatype = item['@type'] || null;
            if (_isBoolean(value)) {
              object.value = value.toString();
              object.datatype = datatype || XSD_BOOLEAN;
            } else if (_isDouble(value) || datatype === XSD_DOUBLE) {
              if (!_isDouble(value)) {
                value = parseFloat(value);
              }
              object.value = value.toExponential(15).replace(/(\d)0*e\+?/, '$1E');
              object.datatype = datatype || XSD_DOUBLE;
            } else if (_isNumber(value)) {
              object.value = value.toFixed(0);
              object.datatype = datatype || XSD_INTEGER;
            } else if ('@language' in item) {
              object.value = value;
              object.datatype = datatype || RDF_LANGSTRING;
              object.language = item['@language'];
            } else {
              object.value = value;
              object.datatype = datatype || XSD_STRING;
            }
          } else {
            var id = _isObject(item) ? item['@id'] : item;
            object.type = (id.indexOf('_:') === 0) ? 'blank node' : 'IRI';
            object.value = id;
          }
          if (object.type === 'IRI' && !_isAbsoluteIri(object.value)) {
            return null;
          }
          return object;
        }
        function _RDFToObject(o, useNativeTypes) {
          if (o.type === 'IRI' || o.type === 'blank node') {
            return {'@id': o.value};
          }
          var rval = {'@value': o.value};
          if (o.language) {
            rval['@language'] = o.language;
          } else {
            var type = o.datatype;
            if (!type) {
              type = XSD_STRING;
            }
            if (useNativeTypes) {
              if (type === XSD_BOOLEAN) {
                if (rval['@value'] === 'true') {
                  rval['@value'] = true;
                } else if (rval['@value'] === 'false') {
                  rval['@value'] = false;
                }
              } else if (_isNumeric(rval['@value'])) {
                if (type === XSD_INTEGER) {
                  var i = parseInt(rval['@value'], 10);
                  if (i.toFixed(0) === rval['@value']) {
                    rval['@value'] = i;
                  }
                } else if (type === XSD_DOUBLE) {
                  rval['@value'] = parseFloat(rval['@value']);
                }
              }
              if ([XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].indexOf(type) === -1) {
                rval['@type'] = type;
              }
            } else if (type !== XSD_STRING) {
              rval['@type'] = type;
            }
          }
          return rval;
        }
        function _compareRDFTriples(t1, t2) {
          var attrs = ['subject', 'predicate', 'object'];
          for (var i = 0; i < attrs.length; ++i) {
            var attr = attrs[i];
            if (t1[attr].type !== t2[attr].type || t1[attr].value !== t2[attr].value) {
              return false;
            }
          }
          if (t1.object.language !== t2.object.language) {
            return false;
          }
          if (t1.object.datatype !== t2.object.datatype) {
            return false;
          }
          return true;
        }
        var URDNA2015 = (function() {
          var POSITIONS = {
            'subject': 's',
            'object': 'o',
            'name': 'g'
          };
          var Normalize = function(options) {
            options = options || {};
            this.name = 'URDNA2015';
            this.options = options;
            this.blankNodeInfo = {};
            this.hashToBlankNodes = {};
            this.canonicalIssuer = new IdentifierIssuer('_:c14n');
            this.quads = [];
            this.schedule = {};
            if ('maxCallStackDepth' in options) {
              this.schedule.MAX_DEPTH = options.maxCallStackDepth;
            } else {
              this.schedule.MAX_DEPTH = 500;
            }
            if ('maxTotalCallStackDepth' in options) {
              this.schedule.MAX_TOTAL_DEPTH = options.maxCallStackDepth;
            } else {
              this.schedule.MAX_TOTAL_DEPTH = 0xFFFFFFFF;
            }
            this.schedule.depth = 0;
            this.schedule.totalDepth = 0;
            if ('timeSlice' in options) {
              this.schedule.timeSlice = options.timeSlice;
            } else {
              this.schedule.timeSlice = 10;
            }
          };
          Normalize.prototype.doWork = function(fn, callback) {
            var schedule = this.schedule;
            if (schedule.totalDepth >= schedule.MAX_TOTAL_DEPTH) {
              return callback(new Error('Maximum total call stack depth exceeded; normalization aborting.'));
            }
            (function work() {
              if (schedule.depth === schedule.MAX_DEPTH) {
                schedule.depth = 0;
                schedule.running = false;
                return jsonld.nextTick(work);
              }
              var now = new Date().getTime();
              if (!schedule.running) {
                schedule.start = new Date().getTime();
                schedule.deadline = schedule.start + schedule.timeSlice;
              }
              if (now < schedule.deadline) {
                schedule.running = true;
                schedule.depth++;
                schedule.totalDepth++;
                return fn(function(err, result) {
                  schedule.depth--;
                  schedule.totalDepth--;
                  callback(err, result);
                });
              }
              schedule.depth = 0;
              schedule.running = false;
              jsonld.setImmediate(work);
            })();
          };
          Normalize.prototype.forEach = function(iterable, fn, callback) {
            var self = this;
            var iterator;
            var idx = 0;
            var length;
            if (_isArray(iterable)) {
              length = iterable.length;
              iterator = function() {
                if (idx === length) {
                  return false;
                }
                iterator.value = iterable[idx++];
                iterator.key = idx;
                return true;
              };
            } else {
              var keys = Object.keys(iterable);
              length = keys.length;
              iterator = function() {
                if (idx === length) {
                  return false;
                }
                iterator.key = keys[idx++];
                iterator.value = iterable[iterator.key];
                return true;
              };
            }
            (function iterate(err, result) {
              if (err) {
                return callback(err);
              }
              if (iterator()) {
                return self.doWork(function() {
                  fn(iterator.value, iterator.key, iterate);
                });
              }
              callback();
            })();
          };
          Normalize.prototype.waterfall = function(fns, callback) {
            var self = this;
            self.forEach(fns, function(fn, idx, callback) {
              self.doWork(fn, callback);
            }, callback);
          };
          Normalize.prototype.whilst = function(condition, fn, callback) {
            var self = this;
            (function loop(err) {
              if (err) {
                return callback(err);
              }
              if (!condition()) {
                return callback();
              }
              self.doWork(fn, loop);
            })();
          };
          Normalize.prototype.main = function(dataset, callback) {
            var self = this;
            self.schedule.start = new Date().getTime();
            var result;
            if (self.options.format) {
              if (self.options.format !== 'application/nquads') {
                return callback(new JsonLdError('Unknown output format.', 'jsonld.UnknownFormat', {format: self.options.format}));
              }
            }
            var nonNormalized = {};
            self.waterfall([function(callback) {
              self.forEach(dataset, function(triples, graphName, callback) {
                if (graphName === '@default') {
                  graphName = null;
                }
                self.forEach(triples, function(quad, idx, callback) {
                  if (graphName !== null) {
                    if (graphName.indexOf('_:') === 0) {
                      quad.name = {
                        type: 'blank node',
                        value: graphName
                      };
                    } else {
                      quad.name = {
                        type: 'IRI',
                        value: graphName
                      };
                    }
                  }
                  self.quads.push(quad);
                  self.forEachComponent(quad, function(component) {
                    if (component.type !== 'blank node') {
                      return;
                    }
                    var id = component.value;
                    if (id in self.blankNodeInfo) {
                      self.blankNodeInfo[id].quads.push(quad);
                    } else {
                      nonNormalized[id] = true;
                      self.blankNodeInfo[id] = {quads: [quad]};
                    }
                  });
                  callback();
                }, callback);
              }, callback);
            }, function(callback) {
              var simple = true;
              self.whilst(function() {
                return simple;
              }, function(callback) {
                simple = false;
                self.hashToBlankNodes = {};
                self.waterfall([function(callback) {
                  self.forEach(nonNormalized, function(value, id, callback) {
                    self.hashFirstDegreeQuads(id, function(err, hash) {
                      if (err) {
                        return callback(err);
                      }
                      if (hash in self.hashToBlankNodes) {
                        self.hashToBlankNodes[hash].push(id);
                      } else {
                        self.hashToBlankNodes[hash] = [id];
                      }
                      callback();
                    });
                  }, callback);
                }, function(callback) {
                  var hashes = Object.keys(self.hashToBlankNodes).sort();
                  self.forEach(hashes, function(hash, i, callback) {
                    var idList = self.hashToBlankNodes[hash];
                    if (idList.length > 1) {
                      return callback();
                    }
                    var id = idList[0];
                    self.canonicalIssuer.getId(id);
                    delete nonNormalized[id];
                    delete self.hashToBlankNodes[hash];
                    simple = true;
                    callback();
                  }, callback);
                }], callback);
              }, callback);
            }, function(callback) {
              var hashes = Object.keys(self.hashToBlankNodes).sort();
              self.forEach(hashes, function(hash, idx, callback) {
                var hashPathList = [];
                var idList = self.hashToBlankNodes[hash];
                self.waterfall([function(callback) {
                  self.forEach(idList, function(id, idx, callback) {
                    if (self.canonicalIssuer.hasId(id)) {
                      return callback();
                    }
                    var issuer = new IdentifierIssuer('_:b');
                    issuer.getId(id);
                    self.hashNDegreeQuads(id, issuer, function(err, result) {
                      if (err) {
                        return callback(err);
                      }
                      hashPathList.push(result);
                      callback();
                    });
                  }, callback);
                }, function(callback) {
                  hashPathList.sort(function(a, b) {
                    return (a.hash < b.hash) ? -1 : ((a.hash > b.hash) ? 1 : 0);
                  });
                  self.forEach(hashPathList, function(result, idx, callback) {
                    for (var existing in result.issuer.existing) {
                      self.canonicalIssuer.getId(existing);
                    }
                    callback();
                  }, callback);
                }], callback);
              }, callback);
            }, function(callback) {
              var normalized = [];
              self.waterfall([function(callback) {
                self.forEach(self.quads, function(quad, idx, callback) {
                  self.forEachComponent(quad, function(component) {
                    if (component.type === 'blank node' && component.value.indexOf(self.canonicalIssuer.prefix) !== 0) {
                      component.value = self.canonicalIssuer.getId(component.value);
                    }
                  });
                  normalized.push(_toNQuad(quad));
                  callback();
                }, callback);
              }, function(callback) {
                normalized.sort();
                if (self.options.format === 'application/nquads') {
                  result = normalized.join('');
                  return callback();
                }
                result = _parseNQuads(normalized.join(''));
                callback();
              }], callback);
            }], function(err) {
              callback(err, result);
            });
          };
          Normalize.prototype.hashFirstDegreeQuads = function(id, callback) {
            var self = this;
            var info = self.blankNodeInfo[id];
            if ('hash' in info) {
              return callback(null, info.hash);
            }
            var nquads = [];
            var quads = info.quads;
            self.forEach(quads, function(quad, idx, callback) {
              var copy = {predicate: quad.predicate};
              self.forEachComponent(quad, function(component, key) {
                copy[key] = self.modifyFirstDegreeComponent(id, component, key);
              });
              nquads.push(_toNQuad(copy));
              callback();
            }, function(err) {
              if (err) {
                return callback(err);
              }
              nquads.sort();
              info.hash = NormalizeHash.hashNQuads(self.name, nquads);
              callback(null, info.hash);
            });
          };
          Normalize.prototype.modifyFirstDegreeComponent = function(id, component) {
            if (component.type !== 'blank node') {
              return component;
            }
            component = _clone(component);
            component.value = (component.value === id ? '_:a' : '_:z');
            return component;
          };
          Normalize.prototype.hashRelatedBlankNode = function(related, quad, issuer, position, callback) {
            var self = this;
            var id;
            self.waterfall([function(callback) {
              if (self.canonicalIssuer.hasId(related)) {
                id = self.canonicalIssuer.getId(related);
                return callback();
              }
              if (issuer.hasId(related)) {
                id = issuer.getId(related);
                return callback();
              }
              self.hashFirstDegreeQuads(related, function(err, hash) {
                if (err) {
                  return callback(err);
                }
                id = hash;
                callback();
              });
            }], function(err) {
              if (err) {
                return callback(err);
              }
              var md = new NormalizeHash(self.name);
              md.update(position);
              if (position !== 'g') {
                md.update(self.getRelatedPredicate(quad));
              }
              md.update(id);
              return callback(null, md.digest());
            });
          };
          Normalize.prototype.getRelatedPredicate = function(quad) {
            return '<' + quad.predicate.value + '>';
          };
          Normalize.prototype.hashNDegreeQuads = function(id, issuer, callback) {
            var self = this;
            var hashToRelated;
            var md = new NormalizeHash(self.name);
            self.waterfall([function(callback) {
              self.createHashToRelated(id, issuer, function(err, result) {
                if (err) {
                  return callback(err);
                }
                hashToRelated = result;
                callback();
              });
            }, function(callback) {
              var hashes = Object.keys(hashToRelated).sort();
              self.forEach(hashes, function(hash, idx, callback) {
                md.update(hash);
                var chosenPath = '';
                var chosenIssuer;
                var permutator = new Permutator(hashToRelated[hash]);
                self.whilst(function() {
                  return permutator.hasNext();
                }, function(nextPermutation) {
                  var permutation = permutator.next();
                  var issuerCopy = issuer.clone();
                  var path = '';
                  var recursionList = [];
                  self.waterfall([function(callback) {
                    self.forEach(permutation, function(related, idx, callback) {
                      if (self.canonicalIssuer.hasId(related)) {
                        path += self.canonicalIssuer.getId(related);
                      } else {
                        if (!issuerCopy.hasId(related)) {
                          recursionList.push(related);
                        }
                        path += issuerCopy.getId(related);
                      }
                      if (chosenPath.length !== 0 && path.length >= chosenPath.length && path > chosenPath) {
                        return nextPermutation();
                      }
                      callback();
                    }, callback);
                  }, function(callback) {
                    self.forEach(recursionList, function(related, idx, callback) {
                      self.hashNDegreeQuads(related, issuerCopy, function(err, result) {
                        if (err) {
                          return callback(err);
                        }
                        path += issuerCopy.getId(related);
                        path += '<' + result.hash + '>';
                        issuerCopy = result.issuer;
                        if (chosenPath.length !== 0 && path.length >= chosenPath.length && path > chosenPath) {
                          return nextPermutation();
                        }
                        callback();
                      });
                    }, callback);
                  }, function(callback) {
                    if (chosenPath.length === 0 || path < chosenPath) {
                      chosenPath = path;
                      chosenIssuer = issuerCopy;
                    }
                    callback();
                  }], nextPermutation);
                }, function(err) {
                  if (err) {
                    return callback(err);
                  }
                  md.update(chosenPath);
                  issuer = chosenIssuer;
                  callback();
                });
              }, callback);
            }], function(err) {
              callback(err, {
                hash: md.digest(),
                issuer: issuer
              });
            });
          };
          Normalize.prototype.createHashToRelated = function(id, issuer, callback) {
            var self = this;
            var hashToRelated = {};
            var quads = self.blankNodeInfo[id].quads;
            self.forEach(quads, function(quad, idx, callback) {
              self.forEach(quad, function(component, key, callback) {
                if (key === 'predicate' || !(component.type === 'blank node' && component.value !== id)) {
                  return callback();
                }
                var related = component.value;
                var position = POSITIONS[key];
                self.hashRelatedBlankNode(related, quad, issuer, position, function(err, hash) {
                  if (err) {
                    return callback(err);
                  }
                  if (hash in hashToRelated) {
                    hashToRelated[hash].push(related);
                  } else {
                    hashToRelated[hash] = [related];
                  }
                  callback();
                });
              }, callback);
            }, function(err) {
              callback(err, hashToRelated);
            });
          };
          Normalize.prototype.forEachComponent = function(quad, op) {
            for (var key in quad) {
              if (key === 'predicate') {
                continue;
              }
              op(quad[key], key, quad);
            }
          };
          return Normalize;
        })();
        var URGNA2012 = (function() {
          var Normalize = function(options) {
            URDNA2015.call(this, options);
            this.name = 'URGNA2012';
          };
          Normalize.prototype = new URDNA2015();
          Normalize.prototype.modifyFirstDegreeComponent = function(id, component, key) {
            if (component.type !== 'blank node') {
              return component;
            }
            component = _clone(component);
            if (key === 'name') {
              component.value = '_:g';
            } else {
              component.value = (component.value === id ? '_:a' : '_:z');
            }
            return component;
          };
          Normalize.prototype.getRelatedPredicate = function(quad) {
            return quad.predicate.value;
          };
          Normalize.prototype.createHashToRelated = function(id, issuer, callback) {
            var self = this;
            var hashToRelated = {};
            var quads = self.blankNodeInfo[id].quads;
            self.forEach(quads, function(quad, idx, callback) {
              var position;
              var related;
              if (quad.subject.type === 'blank node' && quad.subject.value !== id) {
                related = quad.subject.value;
                position = 'p';
              } else if (quad.object.type === 'blank node' && quad.object.value !== id) {
                related = quad.object.value;
                position = 'r';
              } else {
                return callback();
              }
              self.hashRelatedBlankNode(related, quad, issuer, position, function(err, hash) {
                if (hash in hashToRelated) {
                  hashToRelated[hash].push(related);
                } else {
                  hashToRelated[hash] = [related];
                }
                callback();
              });
            }, function(err) {
              callback(err, hashToRelated);
            });
          };
          return Normalize;
        })();
        function _createNodeMap(input, graphs, graph, issuer, name, list) {
          if (_isArray(input)) {
            for (var i = 0; i < input.length; ++i) {
              _createNodeMap(input[i], graphs, graph, issuer, undefined, list);
            }
            return;
          }
          if (!_isObject(input)) {
            if (list) {
              list.push(input);
            }
            return;
          }
          if (_isValue(input)) {
            if ('@type' in input) {
              var type = input['@type'];
              if (type.indexOf('_:') === 0) {
                input['@type'] = type = issuer.getId(type);
              }
            }
            if (list) {
              list.push(input);
            }
            return;
          }
          if ('@type' in input) {
            var types = input['@type'];
            for (var i = 0; i < types.length; ++i) {
              var type = types[i];
              if (type.indexOf('_:') === 0) {
                issuer.getId(type);
              }
            }
          }
          if (_isUndefined(name)) {
            name = _isBlankNode(input) ? issuer.getId(input['@id']) : input['@id'];
          }
          if (list) {
            list.push({'@id': name});
          }
          var subjects = graphs[graph];
          var subject = subjects[name] = subjects[name] || {};
          subject['@id'] = name;
          var properties = Object.keys(input).sort();
          for (var pi = 0; pi < properties.length; ++pi) {
            var property = properties[pi];
            if (property === '@id') {
              continue;
            }
            if (property === '@reverse') {
              var referencedNode = {'@id': name};
              var reverseMap = input['@reverse'];
              for (var reverseProperty in reverseMap) {
                var items = reverseMap[reverseProperty];
                for (var ii = 0; ii < items.length; ++ii) {
                  var item = items[ii];
                  var itemName = item['@id'];
                  if (_isBlankNode(item)) {
                    itemName = issuer.getId(itemName);
                  }
                  _createNodeMap(item, graphs, graph, issuer, itemName);
                  jsonld.addValue(subjects[itemName], reverseProperty, referencedNode, {
                    propertyIsArray: true,
                    allowDuplicate: false
                  });
                }
              }
              continue;
            }
            if (property === '@graph') {
              if (!(name in graphs)) {
                graphs[name] = {};
              }
              var g = (graph === '@merged') ? graph : name;
              _createNodeMap(input[property], graphs, g, issuer);
              continue;
            }
            if (property !== '@type' && _isKeyword(property)) {
              if (property === '@index' && property in subject && (input[property] !== subject[property] || input[property]['@id'] !== subject[property]['@id'])) {
                throw new JsonLdError('Invalid JSON-LD syntax; conflicting @index property detected.', 'jsonld.SyntaxError', {
                  code: 'conflicting indexes',
                  subject: subject
                });
              }
              subject[property] = input[property];
              continue;
            }
            var objects = input[property];
            if (property.indexOf('_:') === 0) {
              property = issuer.getId(property);
            }
            if (objects.length === 0) {
              jsonld.addValue(subject, property, [], {propertyIsArray: true});
              continue;
            }
            for (var oi = 0; oi < objects.length; ++oi) {
              var o = objects[oi];
              if (property === '@type') {
                o = (o.indexOf('_:') === 0) ? issuer.getId(o) : o;
              }
              if (_isSubject(o) || _isSubjectReference(o)) {
                var id = _isBlankNode(o) ? issuer.getId(o['@id']) : o['@id'];
                jsonld.addValue(subject, property, {'@id': id}, {
                  propertyIsArray: true,
                  allowDuplicate: false
                });
                _createNodeMap(o, graphs, graph, issuer, id);
              } else if (_isList(o)) {
                var _list = [];
                _createNodeMap(o['@list'], graphs, graph, issuer, name, _list);
                o = {'@list': _list};
                jsonld.addValue(subject, property, o, {
                  propertyIsArray: true,
                  allowDuplicate: false
                });
              } else {
                _createNodeMap(o, graphs, graph, issuer, name);
                jsonld.addValue(subject, property, o, {
                  propertyIsArray: true,
                  allowDuplicate: false
                });
              }
            }
          }
        }
        function _mergeNodeMaps(graphs) {
          var defaultGraph = graphs['@default'];
          var graphNames = Object.keys(graphs).sort();
          for (var i = 0; i < graphNames.length; ++i) {
            var graphName = graphNames[i];
            if (graphName === '@default') {
              continue;
            }
            var nodeMap = graphs[graphName];
            var subject = defaultGraph[graphName];
            if (!subject) {
              defaultGraph[graphName] = subject = {
                '@id': graphName,
                '@graph': []
              };
            } else if (!('@graph' in subject)) {
              subject['@graph'] = [];
            }
            var graph = subject['@graph'];
            var ids = Object.keys(nodeMap).sort();
            for (var ii = 0; ii < ids.length; ++ii) {
              var node = nodeMap[ids[ii]];
              if (!_isSubjectReference(node)) {
                graph.push(node);
              }
            }
          }
          return defaultGraph;
        }
        function _frame(state, subjects, frame, parent, property) {
          _validateFrame(frame);
          frame = frame[0];
          var options = state.options;
          var flags = {
            embed: _getFrameFlag(frame, options, 'embed'),
            explicit: _getFrameFlag(frame, options, 'explicit'),
            requireAll: _getFrameFlag(frame, options, 'requireAll')
          };
          var matches = _filterSubjects(state, subjects, frame, flags);
          var ids = Object.keys(matches).sort();
          for (var idx = 0; idx < ids.length; ++idx) {
            var id = ids[idx];
            var subject = matches[id];
            if (flags.embed === '@link' && id in state.link) {
              _addFrameOutput(parent, property, state.link[id]);
              continue;
            }
            if (property === null) {
              state.uniqueEmbeds = {};
            }
            var output = {};
            output['@id'] = id;
            state.link[id] = output;
            if (flags.embed === '@never' || _createsCircularReference(subject, state.subjectStack)) {
              _addFrameOutput(parent, property, output);
              continue;
            }
            if (flags.embed === '@last') {
              if (id in state.uniqueEmbeds) {
                _removeEmbed(state, id);
              }
              state.uniqueEmbeds[id] = {
                parent: parent,
                property: property
              };
            }
            state.subjectStack.push(subject);
            var props = Object.keys(subject).sort();
            for (var i = 0; i < props.length; i++) {
              var prop = props[i];
              if (_isKeyword(prop)) {
                output[prop] = _clone(subject[prop]);
                continue;
              }
              if (flags.explicit && !(prop in frame)) {
                continue;
              }
              var objects = subject[prop];
              for (var oi = 0; oi < objects.length; ++oi) {
                var o = objects[oi];
                if (_isList(o)) {
                  var list = {'@list': []};
                  _addFrameOutput(output, prop, list);
                  var src = o['@list'];
                  for (var n in src) {
                    o = src[n];
                    if (_isSubjectReference(o)) {
                      var subframe = (prop in frame ? frame[prop][0]['@list'] : _createImplicitFrame(flags));
                      _frame(state, [o['@id']], subframe, list, '@list');
                    } else {
                      _addFrameOutput(list, '@list', _clone(o));
                    }
                  }
                  continue;
                }
                if (_isSubjectReference(o)) {
                  var subframe = (prop in frame ? frame[prop] : _createImplicitFrame(flags));
                  _frame(state, [o['@id']], subframe, output, prop);
                } else {
                  _addFrameOutput(output, prop, _clone(o));
                }
              }
            }
            var props = Object.keys(frame).sort();
            for (var i = 0; i < props.length; ++i) {
              var prop = props[i];
              if (_isKeyword(prop)) {
                continue;
              }
              var next = frame[prop][0];
              var omitDefaultOn = _getFrameFlag(next, options, 'omitDefault');
              if (!omitDefaultOn && !(prop in output)) {
                var preserve = '@null';
                if ('@default' in next) {
                  preserve = _clone(next['@default']);
                }
                if (!_isArray(preserve)) {
                  preserve = [preserve];
                }
                output[prop] = [{'@preserve': preserve}];
              }
            }
            _addFrameOutput(parent, property, output);
            state.subjectStack.pop();
          }
        }
        function _createImplicitFrame(flags) {
          var frame = {};
          for (var key in flags) {
            if (flags[key] !== undefined) {
              frame['@' + key] = [flags[key]];
            }
          }
          return [frame];
        }
        function _createsCircularReference(subjectToEmbed, subjectStack) {
          for (var i = subjectStack.length - 1; i >= 0; --i) {
            if (subjectStack[i]['@id'] === subjectToEmbed['@id']) {
              return true;
            }
          }
          return false;
        }
        function _getFrameFlag(frame, options, name) {
          var flag = '@' + name;
          var rval = (flag in frame ? frame[flag][0] : options[name]);
          if (name === 'embed') {
            if (rval === true) {
              rval = '@last';
            } else if (rval === false) {
              rval = '@never';
            } else if (rval !== '@always' && rval !== '@never' && rval !== '@link') {
              rval = '@last';
            }
          }
          return rval;
        }
        function _validateFrame(frame) {
          if (!_isArray(frame) || frame.length !== 1 || !_isObject(frame[0])) {
            throw new JsonLdError('Invalid JSON-LD syntax; a JSON-LD frame must be a single object.', 'jsonld.SyntaxError', {frame: frame});
          }
        }
        function _filterSubjects(state, subjects, frame, flags) {
          var rval = {};
          for (var i = 0; i < subjects.length; ++i) {
            var id = subjects[i];
            var subject = state.subjects[id];
            if (_filterSubject(subject, frame, flags)) {
              rval[id] = subject;
            }
          }
          return rval;
        }
        function _filterSubject(subject, frame, flags) {
          if ('@type' in frame && !(frame['@type'].length === 1 && _isObject(frame['@type'][0]))) {
            var types = frame['@type'];
            for (var i = 0; i < types.length; ++i) {
              if (jsonld.hasValue(subject, '@type', types[i])) {
                return true;
              }
            }
            return false;
          }
          var wildcard = true;
          var matchesSome = false;
          for (var key in frame) {
            if (_isKeyword(key)) {
              if (key !== '@id' && key !== '@type') {
                continue;
              }
              wildcard = false;
              if (key === '@id' && _isString(frame[key])) {
                if (subject[key] !== frame[key]) {
                  return false;
                }
                matchesSome = true;
                continue;
              }
            }
            wildcard = false;
            if (key in subject) {
              if (_isArray(frame[key]) && frame[key].length === 0 && subject[key] !== undefined) {
                return false;
              }
              matchesSome = true;
              continue;
            }
            var hasDefault = (_isArray(frame[key]) && _isObject(frame[key][0]) && '@default' in frame[key][0]);
            if (flags.requireAll && !hasDefault) {
              return false;
            }
          }
          return wildcard || matchesSome;
        }
        function _removeEmbed(state, id) {
          var embeds = state.uniqueEmbeds;
          var embed = embeds[id];
          var parent = embed.parent;
          var property = embed.property;
          var subject = {'@id': id};
          if (_isArray(parent)) {
            for (var i = 0; i < parent.length; ++i) {
              if (jsonld.compareValues(parent[i], subject)) {
                parent[i] = subject;
                break;
              }
            }
          } else {
            var useArray = _isArray(parent[property]);
            jsonld.removeValue(parent, property, subject, {propertyIsArray: useArray});
            jsonld.addValue(parent, property, subject, {propertyIsArray: useArray});
          }
          var removeDependents = function(id) {
            var ids = Object.keys(embeds);
            for (var i = 0; i < ids.length; ++i) {
              var next = ids[i];
              if (next in embeds && _isObject(embeds[next].parent) && embeds[next].parent['@id'] === id) {
                delete embeds[next];
                removeDependents(next);
              }
            }
          };
          removeDependents(id);
        }
        function _addFrameOutput(parent, property, output) {
          if (_isObject(parent)) {
            jsonld.addValue(parent, property, output, {propertyIsArray: true});
          } else {
            parent.push(output);
          }
        }
        function _removePreserve(ctx, input, options) {
          if (_isArray(input)) {
            var output = [];
            for (var i = 0; i < input.length; ++i) {
              var result = _removePreserve(ctx, input[i], options);
              if (result !== null) {
                output.push(result);
              }
            }
            input = output;
          } else if (_isObject(input)) {
            if ('@preserve' in input) {
              if (input['@preserve'] === '@null') {
                return null;
              }
              return input['@preserve'];
            }
            if (_isValue(input)) {
              return input;
            }
            if (_isList(input)) {
              input['@list'] = _removePreserve(ctx, input['@list'], options);
              return input;
            }
            var idAlias = _compactIri(ctx, '@id');
            if (idAlias in input) {
              var id = input[idAlias];
              if (id in options.link) {
                var idx = options.link[id].indexOf(input);
                if (idx === -1) {
                  options.link[id].push(input);
                } else {
                  return options.link[id][idx];
                }
              } else {
                options.link[id] = [input];
              }
            }
            for (var prop in input) {
              var result = _removePreserve(ctx, input[prop], options);
              var container = jsonld.getContextValue(ctx, prop, '@container');
              if (options.compactArrays && _isArray(result) && result.length === 1 && container === null) {
                result = result[0];
              }
              input[prop] = result;
            }
          }
          return input;
        }
        function _compareShortestLeast(a, b) {
          if (a.length < b.length) {
            return -1;
          }
          if (b.length < a.length) {
            return 1;
          }
          if (a === b) {
            return 0;
          }
          return (a < b) ? -1 : 1;
        }
        function _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {
          if (typeOrLanguageValue === null) {
            typeOrLanguageValue = '@null';
          }
          var prefs = [];
          if ((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') && _isSubjectReference(value)) {
            if (typeOrLanguageValue === '@reverse') {
              prefs.push('@reverse');
            }
            var term = _compactIri(activeCtx, value['@id'], null, {vocab: true});
            if (term in activeCtx.mappings && activeCtx.mappings[term] && activeCtx.mappings[term]['@id'] === value['@id']) {
              prefs.push.apply(prefs, ['@vocab', '@id']);
            } else {
              prefs.push.apply(prefs, ['@id', '@vocab']);
            }
          } else {
            prefs.push(typeOrLanguageValue);
          }
          prefs.push('@none');
          var containerMap = activeCtx.inverse[iri];
          for (var ci = 0; ci < containers.length; ++ci) {
            var container = containers[ci];
            if (!(container in containerMap)) {
              continue;
            }
            var typeOrLanguageValueMap = containerMap[container][typeOrLanguage];
            for (var pi = 0; pi < prefs.length; ++pi) {
              var pref = prefs[pi];
              if (!(pref in typeOrLanguageValueMap)) {
                continue;
              }
              return typeOrLanguageValueMap[pref];
            }
          }
          return null;
        }
        function _compactIri(activeCtx, iri, value, relativeTo, reverse) {
          if (iri === null) {
            return iri;
          }
          if (_isUndefined(value)) {
            value = null;
          }
          if (_isUndefined(reverse)) {
            reverse = false;
          }
          relativeTo = relativeTo || {};
          if (_isKeyword(iri)) {
            relativeTo.vocab = true;
          }
          if (relativeTo.vocab && iri in activeCtx.getInverse()) {
            var defaultLanguage = activeCtx['@language'] || '@none';
            var containers = [];
            if (_isObject(value) && '@index' in value) {
              containers.push('@index');
            }
            var typeOrLanguage = '@language';
            var typeOrLanguageValue = '@null';
            if (reverse) {
              typeOrLanguage = '@type';
              typeOrLanguageValue = '@reverse';
              containers.push('@set');
            } else if (_isList(value)) {
              if (!('@index' in value)) {
                containers.push('@list');
              }
              var list = value['@list'];
              var commonLanguage = (list.length === 0) ? defaultLanguage : null;
              var commonType = null;
              for (var i = 0; i < list.length; ++i) {
                var item = list[i];
                var itemLanguage = '@none';
                var itemType = '@none';
                if (_isValue(item)) {
                  if ('@language' in item) {
                    itemLanguage = item['@language'];
                  } else if ('@type' in item) {
                    itemType = item['@type'];
                  } else {
                    itemLanguage = '@null';
                  }
                } else {
                  itemType = '@id';
                }
                if (commonLanguage === null) {
                  commonLanguage = itemLanguage;
                } else if (itemLanguage !== commonLanguage && _isValue(item)) {
                  commonLanguage = '@none';
                }
                if (commonType === null) {
                  commonType = itemType;
                } else if (itemType !== commonType) {
                  commonType = '@none';
                }
                if (commonLanguage === '@none' && commonType === '@none') {
                  break;
                }
              }
              commonLanguage = commonLanguage || '@none';
              commonType = commonType || '@none';
              if (commonType !== '@none') {
                typeOrLanguage = '@type';
                typeOrLanguageValue = commonType;
              } else {
                typeOrLanguageValue = commonLanguage;
              }
            } else {
              if (_isValue(value)) {
                if ('@language' in value && !('@index' in value)) {
                  containers.push('@language');
                  typeOrLanguageValue = value['@language'];
                } else if ('@type' in value) {
                  typeOrLanguage = '@type';
                  typeOrLanguageValue = value['@type'];
                }
              } else {
                typeOrLanguage = '@type';
                typeOrLanguageValue = '@id';
              }
              containers.push('@set');
            }
            containers.push('@none');
            var term = _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);
            if (term !== null) {
              return term;
            }
          }
          if (relativeTo.vocab) {
            if ('@vocab' in activeCtx) {
              var vocab = activeCtx['@vocab'];
              if (iri.indexOf(vocab) === 0 && iri !== vocab) {
                var suffix = iri.substr(vocab.length);
                if (!(suffix in activeCtx.mappings)) {
                  return suffix;
                }
              }
            }
          }
          var choice = null;
          for (var term in activeCtx.mappings) {
            if (term.indexOf(':') !== -1) {
              continue;
            }
            var definition = activeCtx.mappings[term];
            if (!definition || definition['@id'] === iri || iri.indexOf(definition['@id']) !== 0) {
              continue;
            }
            var curie = term + ':' + iri.substr(definition['@id'].length);
            var isUsableCurie = (!(curie in activeCtx.mappings) || (value === null && activeCtx.mappings[curie] && activeCtx.mappings[curie]['@id'] === iri));
            if (isUsableCurie && (choice === null || _compareShortestLeast(curie, choice) < 0)) {
              choice = curie;
            }
          }
          if (choice !== null) {
            return choice;
          }
          if (!relativeTo.vocab) {
            return _removeBase(activeCtx['@base'], iri);
          }
          return iri;
        }
        function _compactValue(activeCtx, activeProperty, value) {
          if (_isValue(value)) {
            var type = jsonld.getContextValue(activeCtx, activeProperty, '@type');
            var language = jsonld.getContextValue(activeCtx, activeProperty, '@language');
            var container = jsonld.getContextValue(activeCtx, activeProperty, '@container');
            var preserveIndex = (('@index' in value) && container !== '@index');
            if (!preserveIndex) {
              if (value['@type'] === type || value['@language'] === language) {
                return value['@value'];
              }
            }
            var keyCount = Object.keys(value).length;
            var isValueOnlyKey = (keyCount === 1 || (keyCount === 2 && ('@index' in value) && !preserveIndex));
            var hasDefaultLanguage = ('@language' in activeCtx);
            var isValueString = _isString(value['@value']);
            var hasNullMapping = (activeCtx.mappings[activeProperty] && activeCtx.mappings[activeProperty]['@language'] === null);
            if (isValueOnlyKey && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {
              return value['@value'];
            }
            var rval = {};
            if (preserveIndex) {
              rval[_compactIri(activeCtx, '@index')] = value['@index'];
            }
            if ('@type' in value) {
              rval[_compactIri(activeCtx, '@type')] = _compactIri(activeCtx, value['@type'], null, {vocab: true});
            } else if ('@language' in value) {
              rval[_compactIri(activeCtx, '@language')] = value['@language'];
            }
            rval[_compactIri(activeCtx, '@value')] = value['@value'];
            return rval;
          }
          var expandedProperty = _expandIri(activeCtx, activeProperty, {vocab: true});
          var type = jsonld.getContextValue(activeCtx, activeProperty, '@type');
          var compacted = _compactIri(activeCtx, value['@id'], null, {vocab: type === '@vocab'});
          if (type === '@id' || type === '@vocab' || expandedProperty === '@graph') {
            return compacted;
          }
          var rval = {};
          rval[_compactIri(activeCtx, '@id')] = compacted;
          return rval;
        }
        function _createTermDefinition(activeCtx, localCtx, term, defined) {
          if (term in defined) {
            if (defined[term]) {
              return;
            }
            throw new JsonLdError('Cyclical context definition detected.', 'jsonld.CyclicalContext', {
              code: 'cyclic IRI mapping',
              context: localCtx,
              term: term
            });
          }
          defined[term] = false;
          if (_isKeyword(term)) {
            throw new JsonLdError('Invalid JSON-LD syntax; keywords cannot be overridden.', 'jsonld.SyntaxError', {
              code: 'keyword redefinition',
              context: localCtx,
              term: term
            });
          }
          if (term === '') {
            throw new JsonLdError('Invalid JSON-LD syntax; a term cannot be an empty string.', 'jsonld.SyntaxError', {
              code: 'invalid term definition',
              context: localCtx
            });
          }
          if (activeCtx.mappings[term]) {
            delete activeCtx.mappings[term];
          }
          var value = localCtx[term];
          if (value === null || (_isObject(value) && value['@id'] === null)) {
            activeCtx.mappings[term] = null;
            defined[term] = true;
            return;
          }
          if (_isString(value)) {
            value = {'@id': value};
          }
          if (!_isObject(value)) {
            throw new JsonLdError('Invalid JSON-LD syntax; @context property values must be ' + 'strings or objects.', 'jsonld.SyntaxError', {
              code: 'invalid term definition',
              context: localCtx
            });
          }
          var mapping = activeCtx.mappings[term] = {};
          mapping.reverse = false;
          if ('@reverse' in value) {
            if ('@id' in value) {
              throw new JsonLdError('Invalid JSON-LD syntax; a @reverse term definition must not ' + 'contain @id.', 'jsonld.SyntaxError', {
                code: 'invalid reverse property',
                context: localCtx
              });
            }
            var reverse = value['@reverse'];
            if (!_isString(reverse)) {
              throw new JsonLdError('Invalid JSON-LD syntax; a @context @reverse value must be a string.', 'jsonld.SyntaxError', {
                code: 'invalid IRI mapping',
                context: localCtx
              });
            }
            var id = _expandIri(activeCtx, reverse, {
              vocab: true,
              base: false
            }, localCtx, defined);
            if (!_isAbsoluteIri(id)) {
              throw new JsonLdError('Invalid JSON-LD syntax; a @context @reverse value must be an ' + 'absolute IRI or a blank node identifier.', 'jsonld.SyntaxError', {
                code: 'invalid IRI mapping',
                context: localCtx
              });
            }
            mapping['@id'] = id;
            mapping.reverse = true;
          } else if ('@id' in value) {
            var id = value['@id'];
            if (!_isString(id)) {
              throw new JsonLdError('Invalid JSON-LD syntax; a @context @id value must be an array ' + 'of strings or a string.', 'jsonld.SyntaxError', {
                code: 'invalid IRI mapping',
                context: localCtx
              });
            }
            if (id !== term) {
              id = _expandIri(activeCtx, id, {
                vocab: true,
                base: false
              }, localCtx, defined);
              if (!_isAbsoluteIri(id) && !_isKeyword(id)) {
                throw new JsonLdError('Invalid JSON-LD syntax; a @context @id value must be an ' + 'absolute IRI, a blank node identifier, or a keyword.', 'jsonld.SyntaxError', {
                  code: 'invalid IRI mapping',
                  context: localCtx
                });
              }
              mapping['@id'] = id;
            }
          }
          if (!('@id' in mapping)) {
            var colon = term.indexOf(':');
            if (colon !== -1) {
              var prefix = term.substr(0, colon);
              if (prefix in localCtx) {
                _createTermDefinition(activeCtx, localCtx, prefix, defined);
              }
              if (activeCtx.mappings[prefix]) {
                var suffix = term.substr(colon + 1);
                mapping['@id'] = activeCtx.mappings[prefix]['@id'] + suffix;
              } else {
                mapping['@id'] = term;
              }
            } else {
              if (!('@vocab' in activeCtx)) {
                throw new JsonLdError('Invalid JSON-LD syntax; @context terms must define an @id.', 'jsonld.SyntaxError', {
                  code: 'invalid IRI mapping',
                  context: localCtx,
                  term: term
                });
              }
              mapping['@id'] = activeCtx['@vocab'] + term;
            }
          }
          defined[term] = true;
          if ('@type' in value) {
            var type = value['@type'];
            if (!_isString(type)) {
              throw new JsonLdError('Invalid JSON-LD syntax; an @context @type values must be a string.', 'jsonld.SyntaxError', {
                code: 'invalid type mapping',
                context: localCtx
              });
            }
            if (type !== '@id' && type !== '@vocab') {
              type = _expandIri(activeCtx, type, {
                vocab: true,
                base: false
              }, localCtx, defined);
              if (!_isAbsoluteIri(type)) {
                throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must be an ' + 'absolute IRI.', 'jsonld.SyntaxError', {
                  code: 'invalid type mapping',
                  context: localCtx
                });
              }
              if (type.indexOf('_:') === 0) {
                throw new JsonLdError('Invalid JSON-LD syntax; an @context @type values must be an IRI, ' + 'not a blank node identifier.', 'jsonld.SyntaxError', {
                  code: 'invalid type mapping',
                  context: localCtx
                });
              }
            }
            mapping['@type'] = type;
          }
          if ('@container' in value) {
            var container = value['@container'];
            if (container !== '@list' && container !== '@set' && container !== '@index' && container !== '@language') {
              throw new JsonLdError('Invalid JSON-LD syntax; @context @container value must be ' + 'one of the following: @list, @set, @index, or @language.', 'jsonld.SyntaxError', {
                code: 'invalid container mapping',
                context: localCtx
              });
            }
            if (mapping.reverse && container !== '@index' && container !== '@set' && container !== null) {
              throw new JsonLdError('Invalid JSON-LD syntax; @context @container value for a @reverse ' + 'type definition must be @index or @set.', 'jsonld.SyntaxError', {
                code: 'invalid reverse property',
                context: localCtx
              });
            }
            mapping['@container'] = container;
          }
          if ('@language' in value && !('@type' in value)) {
            var language = value['@language'];
            if (language !== null && !_isString(language)) {
              throw new JsonLdError('Invalid JSON-LD syntax; @context @language value must be ' + 'a string or null.', 'jsonld.SyntaxError', {
                code: 'invalid language mapping',
                context: localCtx
              });
            }
            if (language !== null) {
              language = language.toLowerCase();
            }
            mapping['@language'] = language;
          }
          var id = mapping['@id'];
          if (id === '@context' || id === '@preserve') {
            throw new JsonLdError('Invalid JSON-LD syntax; @context and @preserve cannot be aliased.', 'jsonld.SyntaxError', {
              code: 'invalid keyword alias',
              context: localCtx
            });
          }
        }
        function _expandIri(activeCtx, value, relativeTo, localCtx, defined) {
          if (value === null || _isKeyword(value)) {
            return value;
          }
          value = String(value);
          if (localCtx && value in localCtx && defined[value] !== true) {
            _createTermDefinition(activeCtx, localCtx, value, defined);
          }
          relativeTo = relativeTo || {};
          if (relativeTo.vocab) {
            var mapping = activeCtx.mappings[value];
            if (mapping === null) {
              return null;
            }
            if (mapping) {
              return mapping['@id'];
            }
          }
          var colon = value.indexOf(':');
          if (colon !== -1) {
            var prefix = value.substr(0, colon);
            var suffix = value.substr(colon + 1);
            if (prefix === '_' || suffix.indexOf('//') === 0) {
              return value;
            }
            if (localCtx && prefix in localCtx) {
              _createTermDefinition(activeCtx, localCtx, prefix, defined);
            }
            var mapping = activeCtx.mappings[prefix];
            if (mapping) {
              return mapping['@id'] + suffix;
            }
            return value;
          }
          if (relativeTo.vocab && '@vocab' in activeCtx) {
            return activeCtx['@vocab'] + value;
          }
          var rval = value;
          if (relativeTo.base) {
            rval = jsonld.prependBase(activeCtx['@base'], rval);
          }
          return rval;
        }
        function _prependBase(base, iri) {
          if (base === null) {
            return iri;
          }
          if (iri.indexOf(':') !== -1) {
            return iri;
          }
          if (_isString(base)) {
            base = jsonld.url.parse(base || '');
          }
          var rel = jsonld.url.parse(iri);
          var transform = {protocol: base.protocol || ''};
          if (rel.authority !== null) {
            transform.authority = rel.authority;
            transform.path = rel.path;
            transform.query = rel.query;
          } else {
            transform.authority = base.authority;
            if (rel.path === '') {
              transform.path = base.path;
              if (rel.query !== null) {
                transform.query = rel.query;
              } else {
                transform.query = base.query;
              }
            } else {
              if (rel.path.indexOf('/') === 0) {
                transform.path = rel.path;
              } else {
                var path = base.path;
                if (rel.path !== '') {
                  path = path.substr(0, path.lastIndexOf('/') + 1);
                  if (path.length > 0 && path.substr(-1) !== '/') {
                    path += '/';
                  }
                  path += rel.path;
                }
                transform.path = path;
              }
              transform.query = rel.query;
            }
          }
          transform.path = _removeDotSegments(transform.path, !!transform.authority);
          var rval = transform.protocol;
          if (transform.authority !== null) {
            rval += '//' + transform.authority;
          }
          rval += transform.path;
          if (transform.query !== null) {
            rval += '?' + transform.query;
          }
          if (rel.fragment !== null) {
            rval += '#' + rel.fragment;
          }
          if (rval === '') {
            rval = './';
          }
          return rval;
        }
        function _removeBase(base, iri) {
          if (base === null) {
            return iri;
          }
          if (_isString(base)) {
            base = jsonld.url.parse(base || '');
          }
          var root = '';
          if (base.href !== '') {
            root += (base.protocol || '') + '//' + (base.authority || '');
          } else if (iri.indexOf('//')) {
            root += '//';
          }
          if (iri.indexOf(root) !== 0) {
            return iri;
          }
          var rel = jsonld.url.parse(iri.substr(root.length));
          var baseSegments = base.normalizedPath.split('/');
          var iriSegments = rel.normalizedPath.split('/');
          var last = (rel.fragment || rel.query) ? 0 : 1;
          while (baseSegments.length > 0 && iriSegments.length > last) {
            if (baseSegments[0] !== iriSegments[0]) {
              break;
            }
            baseSegments.shift();
            iriSegments.shift();
          }
          var rval = '';
          if (baseSegments.length > 0) {
            baseSegments.pop();
            for (var i = 0; i < baseSegments.length; ++i) {
              rval += '../';
            }
          }
          rval += iriSegments.join('/');
          if (rel.query !== null) {
            rval += '?' + rel.query;
          }
          if (rel.fragment !== null) {
            rval += '#' + rel.fragment;
          }
          if (rval === '') {
            rval = './';
          }
          return rval;
        }
        function _getInitialContext(options) {
          var base = jsonld.url.parse(options.base || '');
          return {
            '@base': base,
            mappings: {},
            inverse: null,
            getInverse: _createInverseContext,
            clone: _cloneActiveContext
          };
          function _createInverseContext() {
            var activeCtx = this;
            if (activeCtx.inverse) {
              return activeCtx.inverse;
            }
            var inverse = activeCtx.inverse = {};
            var defaultLanguage = activeCtx['@language'] || '@none';
            var mappings = activeCtx.mappings;
            var terms = Object.keys(mappings).sort(_compareShortestLeast);
            for (var i = 0; i < terms.length; ++i) {
              var term = terms[i];
              var mapping = mappings[term];
              if (mapping === null) {
                continue;
              }
              var container = mapping['@container'] || '@none';
              var ids = mapping['@id'];
              if (!_isArray(ids)) {
                ids = [ids];
              }
              for (var ii = 0; ii < ids.length; ++ii) {
                var iri = ids[ii];
                var entry = inverse[iri];
                if (!entry) {
                  inverse[iri] = entry = {};
                }
                if (!entry[container]) {
                  entry[container] = {
                    '@language': {},
                    '@type': {}
                  };
                }
                entry = entry[container];
                if (mapping.reverse) {
                  _addPreferredTerm(mapping, term, entry['@type'], '@reverse');
                } else if ('@type' in mapping) {
                  _addPreferredTerm(mapping, term, entry['@type'], mapping['@type']);
                } else if ('@language' in mapping) {
                  var language = mapping['@language'] || '@null';
                  _addPreferredTerm(mapping, term, entry['@language'], language);
                } else {
                  _addPreferredTerm(mapping, term, entry['@language'], defaultLanguage);
                  _addPreferredTerm(mapping, term, entry['@type'], '@none');
                  _addPreferredTerm(mapping, term, entry['@language'], '@none');
                }
              }
            }
            return inverse;
          }
          function _addPreferredTerm(mapping, term, entry, typeOrLanguageValue) {
            if (!(typeOrLanguageValue in entry)) {
              entry[typeOrLanguageValue] = term;
            }
          }
          function _cloneActiveContext() {
            var child = {};
            child['@base'] = this['@base'];
            child.mappings = _clone(this.mappings);
            child.clone = this.clone;
            child.inverse = null;
            child.getInverse = this.getInverse;
            if ('@language' in this) {
              child['@language'] = this['@language'];
            }
            if ('@vocab' in this) {
              child['@vocab'] = this['@vocab'];
            }
            return child;
          }
        }
        function _isKeyword(v) {
          if (!_isString(v)) {
            return false;
          }
          switch (v) {
            case '@base':
            case '@context':
            case '@container':
            case '@default':
            case '@embed':
            case '@explicit':
            case '@graph':
            case '@id':
            case '@index':
            case '@language':
            case '@list':
            case '@omitDefault':
            case '@preserve':
            case '@requireAll':
            case '@reverse':
            case '@set':
            case '@type':
            case '@value':
            case '@vocab':
              return true;
          }
          return false;
        }
        function _isObject(v) {
          return (Object.prototype.toString.call(v) === '[object Object]');
        }
        function _isEmptyObject(v) {
          return _isObject(v) && Object.keys(v).length === 0;
        }
        function _isArray(v) {
          return Array.isArray(v);
        }
        function _validateTypeValue(v) {
          if (_isString(v) || _isEmptyObject(v)) {
            return;
          }
          var isValid = false;
          if (_isArray(v)) {
            isValid = true;
            for (var i = 0; i < v.length; ++i) {
              if (!(_isString(v[i]))) {
                isValid = false;
                break;
              }
            }
          }
          if (!isValid) {
            throw new JsonLdError('Invalid JSON-LD syntax; "@type" value must a string, an array of ' + 'strings, or an empty object.', 'jsonld.SyntaxError', {
              code: 'invalid type value',
              value: v
            });
          }
        }
        function _isString(v) {
          return (typeof v === 'string' || Object.prototype.toString.call(v) === '[object String]');
        }
        function _isNumber(v) {
          return (typeof v === 'number' || Object.prototype.toString.call(v) === '[object Number]');
        }
        function _isDouble(v) {
          return _isNumber(v) && String(v).indexOf('.') !== -1;
        }
        function _isNumeric(v) {
          return !isNaN(parseFloat(v)) && isFinite(v);
        }
        function _isBoolean(v) {
          return (typeof v === 'boolean' || Object.prototype.toString.call(v) === '[object Boolean]');
        }
        function _isUndefined(v) {
          return (typeof v === 'undefined');
        }
        function _isSubject(v) {
          var rval = false;
          if (_isObject(v) && !(('@value' in v) || ('@set' in v) || ('@list' in v))) {
            var keyCount = Object.keys(v).length;
            rval = (keyCount > 1 || !('@id' in v));
          }
          return rval;
        }
        function _isSubjectReference(v) {
          return (_isObject(v) && Object.keys(v).length === 1 && ('@id' in v));
        }
        function _isValue(v) {
          return _isObject(v) && ('@value' in v);
        }
        function _isList(v) {
          return _isObject(v) && ('@list' in v);
        }
        function _isBlankNode(v) {
          var rval = false;
          if (_isObject(v)) {
            if ('@id' in v) {
              rval = (v['@id'].indexOf('_:') === 0);
            } else {
              rval = (Object.keys(v).length === 0 || !(('@value' in v) || ('@set' in v) || ('@list' in v)));
            }
          }
          return rval;
        }
        function _isAbsoluteIri(v) {
          return _isString(v) && v.indexOf(':') !== -1;
        }
        function _clone(value) {
          if (value && typeof value === 'object') {
            var rval;
            if (_isArray(value)) {
              rval = [];
              for (var i = 0; i < value.length; ++i) {
                rval[i] = _clone(value[i]);
              }
            } else if (_isObject(value)) {
              rval = {};
              for (var key in value) {
                rval[key] = _clone(value[key]);
              }
            } else {
              rval = value.toString();
            }
            return rval;
          }
          return value;
        }
        function _findContextUrls(input, urls, replace, base) {
          var count = Object.keys(urls).length;
          if (_isArray(input)) {
            for (var i = 0; i < input.length; ++i) {
              _findContextUrls(input[i], urls, replace, base);
            }
            return (count < Object.keys(urls).length);
          } else if (_isObject(input)) {
            for (var key in input) {
              if (key !== '@context') {
                _findContextUrls(input[key], urls, replace, base);
                continue;
              }
              var ctx = input[key];
              if (_isArray(ctx)) {
                var length = ctx.length;
                for (var i = 0; i < length; ++i) {
                  var _ctx = ctx[i];
                  if (_isString(_ctx)) {
                    _ctx = jsonld.prependBase(base, _ctx);
                    if (replace) {
                      _ctx = urls[_ctx];
                      if (_isArray(_ctx)) {
                        Array.prototype.splice.apply(ctx, [i, 1].concat(_ctx));
                        i += _ctx.length - 1;
                        length = ctx.length;
                      } else {
                        ctx[i] = _ctx;
                      }
                    } else if (!(_ctx in urls)) {
                      urls[_ctx] = false;
                    }
                  }
                }
              } else if (_isString(ctx)) {
                ctx = jsonld.prependBase(base, ctx);
                if (replace) {
                  input[key] = urls[ctx];
                } else if (!(ctx in urls)) {
                  urls[ctx] = false;
                }
              }
            }
            return (count < Object.keys(urls).length);
          }
          return false;
        }
        function _retrieveContextUrls(input, options, callback) {
          var error = null;
          var documentLoader = options.documentLoader;
          var retrieve = function(input, cycles, documentLoader, base, callback) {
            if (Object.keys(cycles).length > MAX_CONTEXT_URLS) {
              error = new JsonLdError('Maximum number of @context URLs exceeded.', 'jsonld.ContextUrlError', {
                code: 'loading remote context failed',
                max: MAX_CONTEXT_URLS
              });
              return callback(error);
            }
            var urls = {};
            var finished = function() {
              _findContextUrls(input, urls, true, base);
              callback(null, input);
            };
            if (!_findContextUrls(input, urls, false, base)) {
              finished();
            }
            var queue = [];
            for (var url in urls) {
              if (urls[url] === false) {
                queue.push(url);
              }
            }
            var count = queue.length;
            for (var i = 0; i < queue.length; ++i) {
              (function(url) {
                if (url in cycles) {
                  error = new JsonLdError('Cyclical @context URLs detected.', 'jsonld.ContextUrlError', {
                    code: 'recursive context inclusion',
                    url: url
                  });
                  return callback(error);
                }
                var _cycles = _clone(cycles);
                _cycles[url] = true;
                var done = function(err, remoteDoc) {
                  if (error) {
                    return;
                  }
                  var ctx = remoteDoc ? remoteDoc.document : null;
                  if (!err && _isString(ctx)) {
                    try {
                      ctx = JSON.parse(ctx);
                    } catch (ex) {
                      err = ex;
                    }
                  }
                  if (err) {
                    err = new JsonLdError('Dereferencing a URL did not result in a valid JSON-LD object. ' + 'Possible causes are an inaccessible URL perhaps due to ' + 'a same-origin policy (ensure the server uses CORS if you are ' + 'using client-side JavaScript), too many redirects, a ' + 'non-JSON response, or more than one HTTP Link Header was ' + 'provided for a remote context.', 'jsonld.InvalidUrl', {
                      code: 'loading remote context failed',
                      url: url,
                      cause: err
                    });
                  } else if (!_isObject(ctx)) {
                    err = new JsonLdError('Dereferencing a URL did not result in a JSON object. The ' + 'response was valid JSON, but it was not a JSON object.', 'jsonld.InvalidUrl', {
                      code: 'invalid remote context',
                      url: url,
                      cause: err
                    });
                  }
                  if (err) {
                    error = err;
                    return callback(error);
                  }
                  if (!('@context' in ctx)) {
                    ctx = {'@context': {}};
                  } else {
                    ctx = {'@context': ctx['@context']};
                  }
                  if (remoteDoc.contextUrl) {
                    if (!_isArray(ctx['@context'])) {
                      ctx['@context'] = [ctx['@context']];
                    }
                    ctx['@context'].push(remoteDoc.contextUrl);
                  }
                  retrieve(ctx, _cycles, documentLoader, url, function(err, ctx) {
                    if (err) {
                      return callback(err);
                    }
                    urls[url] = ctx['@context'];
                    count -= 1;
                    if (count === 0) {
                      finished();
                    }
                  });
                };
                var promise = documentLoader(url, done);
                if (promise && 'then' in promise) {
                  promise.then(done.bind(null, null), done);
                }
              }(queue[i]));
            }
          };
          retrieve(input, {}, documentLoader, options.base, callback);
        }
        if (!Object.keys) {
          Object.keys = function(o) {
            if (o !== Object(o)) {
              throw new TypeError('Object.keys called on non-object');
            }
            var rval = [];
            for (var p in o) {
              if (Object.prototype.hasOwnProperty.call(o, p)) {
                rval.push(p);
              }
            }
            return rval;
          };
        }
        function _parseNQuads(input) {
          var iri = '(?:<([^:]+:[^>]*)>)';
          var bnode = '(_:(?:[A-Za-z0-9]+))';
          var plain = '"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"';
          var datatype = '(?:\\^\\^' + iri + ')';
          var language = '(?:@([a-z]+(?:-[a-z0-9]+)*))';
          var literal = '(?:' + plain + '(?:' + datatype + '|' + language + ')?)';
          var comment = '(?:#.*)?';
          var ws = '[ \\t]+';
          var wso = '[ \\t]*';
          var eoln = /(?:\r\n)|(?:\n)|(?:\r)/g;
          var empty = new RegExp('^' + wso + comment + '$');
          var subject = '(?:' + iri + '|' + bnode + ')' + ws;
          var property = iri + ws;
          var object = '(?:' + iri + '|' + bnode + '|' + literal + ')' + wso;
          var graphName = '(?:\\.|(?:(?:' + iri + '|' + bnode + ')' + wso + '\\.))';
          var quad = new RegExp('^' + wso + subject + property + object + graphName + wso + comment + '$');
          var dataset = {};
          var lines = input.split(eoln);
          var lineNumber = 0;
          for (var li = 0; li < lines.length; ++li) {
            var line = lines[li];
            lineNumber++;
            if (empty.test(line)) {
              continue;
            }
            var match = line.match(quad);
            if (match === null) {
              throw new JsonLdError('Error while parsing N-Quads; invalid quad.', 'jsonld.ParseError', {line: lineNumber});
            }
            var triple = {};
            if (!_isUndefined(match[1])) {
              triple.subject = {
                type: 'IRI',
                value: match[1]
              };
            } else {
              triple.subject = {
                type: 'blank node',
                value: match[2]
              };
            }
            triple.predicate = {
              type: 'IRI',
              value: match[3]
            };
            if (!_isUndefined(match[4])) {
              triple.object = {
                type: 'IRI',
                value: match[4]
              };
            } else if (!_isUndefined(match[5])) {
              triple.object = {
                type: 'blank node',
                value: match[5]
              };
            } else {
              triple.object = {type: 'literal'};
              if (!_isUndefined(match[7])) {
                triple.object.datatype = match[7];
              } else if (!_isUndefined(match[8])) {
                triple.object.datatype = RDF_LANGSTRING;
                triple.object.language = match[8];
              } else {
                triple.object.datatype = XSD_STRING;
              }
              var unescaped = match[6].replace(/\\"/g, '"').replace(/\\t/g, '\t').replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\\\/g, '\\');
              triple.object.value = unescaped;
            }
            var name = '@default';
            if (!_isUndefined(match[9])) {
              name = match[9];
            } else if (!_isUndefined(match[10])) {
              name = match[10];
            }
            if (!(name in dataset)) {
              dataset[name] = [triple];
            } else {
              var unique = true;
              var triples = dataset[name];
              for (var ti = 0; unique && ti < triples.length; ++ti) {
                if (_compareRDFTriples(triples[ti], triple)) {
                  unique = false;
                }
              }
              if (unique) {
                triples.push(triple);
              }
            }
          }
          return dataset;
        }
        jsonld.registerRDFParser('application/nquads', _parseNQuads);
        function _toNQuads(dataset) {
          var quads = [];
          for (var graphName in dataset) {
            var triples = dataset[graphName];
            for (var ti = 0; ti < triples.length; ++ti) {
              var triple = triples[ti];
              if (graphName === '@default') {
                graphName = null;
              }
              quads.push(_toNQuad(triple, graphName));
            }
          }
          return quads.sort().join('');
        }
        function _toNQuad(triple, graphName) {
          var s = triple.subject;
          var p = triple.predicate;
          var o = triple.object;
          var g = graphName || null;
          if ('name' in triple && triple.name) {
            g = triple.name.value;
          }
          var quad = '';
          if (s.type === 'IRI') {
            quad += '<' + s.value + '>';
          } else {
            quad += s.value;
          }
          quad += ' ';
          if (p.type === 'IRI') {
            quad += '<' + p.value + '>';
          } else {
            quad += p.value;
          }
          quad += ' ';
          if (o.type === 'IRI') {
            quad += '<' + o.value + '>';
          } else if (o.type === 'blank node') {
            quad += o.value;
          } else {
            var escaped = o.value.replace(/\\/g, '\\\\').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\"/g, '\\"');
            quad += '"' + escaped + '"';
            if (o.datatype === RDF_LANGSTRING) {
              if (o.language) {
                quad += '@' + o.language;
              }
            } else if (o.datatype !== XSD_STRING) {
              quad += '^^<' + o.datatype + '>';
            }
          }
          if (g !== null && g !== undefined) {
            if (g.indexOf('_:') !== 0) {
              quad += ' <' + g + '>';
            } else {
              quad += ' ' + g;
            }
          }
          quad += ' .\n';
          return quad;
        }
        function _parseRdfaApiData(data) {
          var dataset = {};
          dataset['@default'] = [];
          var subjects = data.getSubjects();
          for (var si = 0; si < subjects.length; ++si) {
            var subject = subjects[si];
            if (subject === null) {
              continue;
            }
            var triples = data.getSubjectTriples(subject);
            if (triples === null) {
              continue;
            }
            var predicates = triples.predicates;
            for (var predicate in predicates) {
              var objects = predicates[predicate].objects;
              for (var oi = 0; oi < objects.length; ++oi) {
                var object = objects[oi];
                var triple = {};
                if (subject.indexOf('_:') === 0) {
                  triple.subject = {
                    type: 'blank node',
                    value: subject
                  };
                } else {
                  triple.subject = {
                    type: 'IRI',
                    value: subject
                  };
                }
                if (predicate.indexOf('_:') === 0) {
                  triple.predicate = {
                    type: 'blank node',
                    value: predicate
                  };
                } else {
                  triple.predicate = {
                    type: 'IRI',
                    value: predicate
                  };
                }
                var value = object.value;
                if (object.type === RDF_XML_LITERAL) {
                  if (!XMLSerializer) {
                    _defineXMLSerializer();
                  }
                  var serializer = new XMLSerializer();
                  value = '';
                  for (var x = 0; x < object.value.length; x++) {
                    if (object.value[x].nodeType === Node.ELEMENT_NODE) {
                      value += serializer.serializeToString(object.value[x]);
                    } else if (object.value[x].nodeType === Node.TEXT_NODE) {
                      value += object.value[x].nodeValue;
                    }
                  }
                }
                triple.object = {};
                if (object.type === RDF_OBJECT) {
                  if (object.value.indexOf('_:') === 0) {
                    triple.object.type = 'blank node';
                  } else {
                    triple.object.type = 'IRI';
                  }
                } else {
                  triple.object.type = 'literal';
                  if (object.type === RDF_PLAIN_LITERAL) {
                    if (object.language) {
                      triple.object.datatype = RDF_LANGSTRING;
                      triple.object.language = object.language;
                    } else {
                      triple.object.datatype = XSD_STRING;
                    }
                  } else {
                    triple.object.datatype = object.type;
                  }
                }
                triple.object.value = value;
                dataset['@default'].push(triple);
              }
            }
          }
          return dataset;
        }
        jsonld.registerRDFParser('rdfa-api', _parseRdfaApiData);
        function IdentifierIssuer(prefix) {
          this.prefix = prefix;
          this.counter = 0;
          this.existing = {};
        }
        jsonld.IdentifierIssuer = IdentifierIssuer;
        jsonld.UniqueNamer = IdentifierIssuer;
        IdentifierIssuer.prototype.clone = function() {
          var copy = new IdentifierIssuer(this.prefix);
          copy.counter = this.counter;
          copy.existing = _clone(this.existing);
          return copy;
        };
        IdentifierIssuer.prototype.getId = function(old) {
          if (old && old in this.existing) {
            return this.existing[old];
          }
          var identifier = this.prefix + this.counter;
          this.counter += 1;
          if (old) {
            this.existing[old] = identifier;
          }
          return identifier;
        };
        IdentifierIssuer.prototype.getName = IdentifierIssuer.prototype.getName;
        IdentifierIssuer.prototype.hasId = function(old) {
          return (old in this.existing);
        };
        IdentifierIssuer.prototype.isNamed = IdentifierIssuer.prototype.hasId;
        var Permutator = function(list) {
          this.list = list.sort();
          this.done = false;
          this.left = {};
          for (var i = 0; i < list.length; ++i) {
            this.left[list[i]] = true;
          }
        };
        Permutator.prototype.hasNext = function() {
          return !this.done;
        };
        Permutator.prototype.next = function() {
          var rval = this.list.slice();
          var k = null;
          var pos = 0;
          var length = this.list.length;
          for (var i = 0; i < length; ++i) {
            var element = this.list[i];
            var left = this.left[element];
            if ((k === null || element > k) && ((left && i > 0 && element > this.list[i - 1]) || (!left && i < (length - 1) && element > this.list[i + 1]))) {
              k = element;
              pos = i;
            }
          }
          if (k === null) {
            this.done = true;
          } else {
            var swap = this.left[k] ? pos - 1 : pos + 1;
            this.list[pos] = this.list[swap];
            this.list[swap] = k;
            for (var i = 0; i < length; ++i) {
              if (this.list[i] > k) {
                this.left[this.list[i]] = !this.left[this.list[i]];
              }
            }
          }
          return rval;
        };
        var NormalizeHash = function(algorithm) {
          if (!(this instanceof NormalizeHash)) {
            return new NormalizeHash(algorithm);
          }
          if (['URDNA2015', 'URGNA2012'].indexOf(algorithm) === -1) {
            throw new Error('Invalid RDF Dataset Normalization algorithm: ' + algorithm);
          }
          NormalizeHash._init.call(this, algorithm);
        };
        NormalizeHash.hashNQuads = function(algorithm, nquads) {
          var md = new NormalizeHash(algorithm);
          for (var i = 0; i < nquads.length; ++i) {
            md.update(nquads[i]);
          }
          return md.digest();
        };
        (function(_nodejs) {
          if (_nodejs) {
            var crypto = req('a1');
            NormalizeHash._init = function(algorithm) {
              if (algorithm === 'URDNA2015') {
                algorithm = 'sha256';
              } else {
                algorithm = 'sha1';
              }
              this.md = crypto.createHash(algorithm);
            };
            NormalizeHash.prototype.update = function(msg) {
              return this.md.update(msg, 'utf8');
            };
            NormalizeHash.prototype.digest = function() {
              return this.md.digest('hex');
            };
            return;
          }
          NormalizeHash._init = function(algorithm) {
            if (algorithm === 'URDNA2015') {
              algorithm = new sha256.Algorithm();
            } else {
              algorithm = new sha1.Algorithm();
            }
            this.md = new MessageDigest(algorithm);
          };
          NormalizeHash.prototype.update = function(msg) {
            return this.md.update(msg);
          };
          NormalizeHash.prototype.digest = function() {
            return this.md.digest().toHex();
          };
          var MessageDigest = function(algorithm) {
            if (!(this instanceof MessageDigest)) {
              return new MessageDigest(algorithm);
            }
            this._algorithm = algorithm;
            if (!MessageDigest._padding || MessageDigest._padding.length < this._algorithm.blockSize) {
              MessageDigest._padding = String.fromCharCode(128);
              var c = String.fromCharCode(0x00);
              var n = 64;
              while (n > 0) {
                if (n & 1) {
                  MessageDigest._padding += c;
                }
                n >>>= 1;
                if (n > 0) {
                  c += c;
                }
              }
            }
            this.start();
          };
          MessageDigest.prototype.start = function() {
            this.messageLength = 0;
            this.fullMessageLength = [];
            var int32s = this._algorithm.messageLengthSize / 4;
            for (var i = 0; i < int32s; ++i) {
              this.fullMessageLength.push(0);
            }
            this._input = new MessageDigest.ByteBuffer();
            this.state = this._algorithm.start();
            return this;
          };
          MessageDigest.prototype.update = function(msg) {
            msg = new MessageDigest.ByteBuffer(unescape(encodeURIComponent(msg)));
            this.messageLength += msg.length();
            var len = msg.length();
            len = [(len / 0x100000000) >>> 0, len >>> 0];
            for (var i = this.fullMessageLength.length - 1; i >= 0; --i) {
              this.fullMessageLength[i] += len[1];
              len[1] = len[0] + ((this.fullMessageLength[i] / 0x100000000) >>> 0);
              this.fullMessageLength[i] = this.fullMessageLength[i] >>> 0;
              len[0] = ((len[1] / 0x100000000) >>> 0);
            }
            this._input.putBytes(msg.bytes());
            while (this._input.length() >= this._algorithm.blockSize) {
              this.state = this._algorithm.digest(this.state, this._input);
            }
            if (this._input.read > 2048 || this._input.length() === 0) {
              this._input.compact();
            }
            return this;
          };
          MessageDigest.prototype.digest = function() {
            var finalBlock = new MessageDigest.ByteBuffer();
            finalBlock.putBytes(this._input.bytes());
            var remaining = (this.fullMessageLength[this.fullMessageLength.length - 1] + this._algorithm.messageLengthSize);
            var overflow = remaining & (this._algorithm.blockSize - 1);
            finalBlock.putBytes(MessageDigest._padding.substr(0, this._algorithm.blockSize - overflow));
            var messageLength = new MessageDigest.ByteBuffer();
            for (var i = 0; i < this.fullMessageLength.length; ++i) {
              messageLength.putInt32((this.fullMessageLength[i] << 3) | (this.fullMessageLength[i + 1] >>> 28));
            }
            this._algorithm.writeMessageLength(finalBlock, messageLength);
            var state = this._algorithm.digest(this.state.copy(), finalBlock);
            var rval = new MessageDigest.ByteBuffer();
            state.write(rval);
            return rval;
          };
          MessageDigest.ByteBuffer = function(data) {
            if (typeof data === 'string') {
              this.data = data;
            } else {
              this.data = '';
            }
            this.read = 0;
          };
          MessageDigest.ByteBuffer.prototype.putInt32 = function(i) {
            this.data += (String.fromCharCode(i >> 24 & 0xFF) + String.fromCharCode(i >> 16 & 0xFF) + String.fromCharCode(i >> 8 & 0xFF) + String.fromCharCode(i & 0xFF));
          };
          MessageDigest.ByteBuffer.prototype.getInt32 = function() {
            var rval = (this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3));
            this.read += 4;
            return rval;
          };
          MessageDigest.ByteBuffer.prototype.putBytes = function(bytes) {
            this.data += bytes;
          };
          MessageDigest.ByteBuffer.prototype.bytes = function() {
            return this.data.slice(this.read);
          };
          MessageDigest.ByteBuffer.prototype.length = function() {
            return this.data.length - this.read;
          };
          MessageDigest.ByteBuffer.prototype.compact = function() {
            this.data = this.data.slice(this.read);
            this.read = 0;
          };
          MessageDigest.ByteBuffer.prototype.toHex = function() {
            var rval = '';
            for (var i = this.read; i < this.data.length; ++i) {
              var b = this.data.charCodeAt(i);
              if (b < 16) {
                rval += '0';
              }
              rval += b.toString(16);
            }
            return rval;
          };
          var sha1 = {_w: null};
          sha1.Algorithm = function() {
            this.name = 'sha1', this.blockSize = 64;
            this.digestLength = 20;
            this.messageLengthSize = 8;
          };
          sha1.Algorithm.prototype.start = function() {
            if (!sha1._w) {
              sha1._w = new Array(80);
            }
            return sha1._createState();
          };
          sha1.Algorithm.prototype.writeMessageLength = function(finalBlock, messageLength) {
            finalBlock.putBytes(messageLength.bytes());
          };
          sha1.Algorithm.prototype.digest = function(s, input) {
            var t,
                a,
                b,
                c,
                d,
                e,
                f,
                i;
            var len = input.length();
            var _w = sha1._w;
            while (len >= 64) {
              a = s.h0;
              b = s.h1;
              c = s.h2;
              d = s.h3;
              e = s.h4;
              for (i = 0; i < 16; ++i) {
                t = input.getInt32();
                _w[i] = t;
                f = d ^ (b & (c ^ d));
                t = ((a << 5) | (a >>> 27)) + f + e + 0x5A827999 + t;
                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = t;
              }
              for (; i < 20; ++i) {
                t = (_w[i - 3] ^ _w[i - 8] ^ _w[i - 14] ^ _w[i - 16]);
                t = (t << 1) | (t >>> 31);
                _w[i] = t;
                f = d ^ (b & (c ^ d));
                t = ((a << 5) | (a >>> 27)) + f + e + 0x5A827999 + t;
                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = t;
              }
              for (; i < 32; ++i) {
                t = (_w[i - 3] ^ _w[i - 8] ^ _w[i - 14] ^ _w[i - 16]);
                t = (t << 1) | (t >>> 31);
                _w[i] = t;
                f = b ^ c ^ d;
                t = ((a << 5) | (a >>> 27)) + f + e + 0x6ED9EBA1 + t;
                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = t;
              }
              for (; i < 40; ++i) {
                t = (_w[i - 6] ^ _w[i - 16] ^ _w[i - 28] ^ _w[i - 32]);
                t = (t << 2) | (t >>> 30);
                _w[i] = t;
                f = b ^ c ^ d;
                t = ((a << 5) | (a >>> 27)) + f + e + 0x6ED9EBA1 + t;
                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = t;
              }
              for (; i < 60; ++i) {
                t = (_w[i - 6] ^ _w[i - 16] ^ _w[i - 28] ^ _w[i - 32]);
                t = (t << 2) | (t >>> 30);
                _w[i] = t;
                f = (b & c) | (d & (b ^ c));
                t = ((a << 5) | (a >>> 27)) + f + e + 0x8F1BBCDC + t;
                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = t;
              }
              for (; i < 80; ++i) {
                t = (_w[i - 6] ^ _w[i - 16] ^ _w[i - 28] ^ _w[i - 32]);
                t = (t << 2) | (t >>> 30);
                _w[i] = t;
                f = b ^ c ^ d;
                t = ((a << 5) | (a >>> 27)) + f + e + 0xCA62C1D6 + t;
                e = d;
                d = c;
                c = (b << 30) | (b >>> 2);
                b = a;
                a = t;
              }
              s.h0 = (s.h0 + a) | 0;
              s.h1 = (s.h1 + b) | 0;
              s.h2 = (s.h2 + c) | 0;
              s.h3 = (s.h3 + d) | 0;
              s.h4 = (s.h4 + e) | 0;
              len -= 64;
            }
            return s;
          };
          sha1._createState = function() {
            var state = {
              h0: 0x67452301,
              h1: 0xEFCDAB89,
              h2: 0x98BADCFE,
              h3: 0x10325476,
              h4: 0xC3D2E1F0
            };
            state.copy = function() {
              var rval = sha1._createState();
              rval.h0 = state.h0;
              rval.h1 = state.h1;
              rval.h2 = state.h2;
              rval.h3 = state.h3;
              rval.h4 = state.h4;
              return rval;
            };
            state.write = function(buffer) {
              buffer.putInt32(state.h0);
              buffer.putInt32(state.h1);
              buffer.putInt32(state.h2);
              buffer.putInt32(state.h3);
              buffer.putInt32(state.h4);
            };
            return state;
          };
          var sha256 = {
            _k: null,
            _w: null
          };
          sha256.Algorithm = function() {
            this.name = 'sha256', this.blockSize = 64;
            this.digestLength = 32;
            this.messageLengthSize = 8;
          };
          sha256.Algorithm.prototype.start = function() {
            if (!sha256._k) {
              sha256._init();
            }
            return sha256._createState();
          };
          sha256.Algorithm.prototype.writeMessageLength = function(finalBlock, messageLength) {
            finalBlock.putBytes(messageLength.bytes());
          };
          sha256.Algorithm.prototype.digest = function(s, input) {
            var t1,
                t2,
                s0,
                s1,
                ch,
                maj,
                i,
                a,
                b,
                c,
                d,
                e,
                f,
                g,
                h;
            var len = input.length();
            var _k = sha256._k;
            var _w = sha256._w;
            while (len >= 64) {
              for (i = 0; i < 16; ++i) {
                _w[i] = input.getInt32();
              }
              for (; i < 64; ++i) {
                t1 = _w[i - 2];
                t1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);
                t2 = _w[i - 15];
                t2 = ((t2 >>> 7) | (t2 << 25)) ^ ((t2 >>> 18) | (t2 << 14)) ^ (t2 >>> 3);
                _w[i] = (t1 + _w[i - 7] + t2 + _w[i - 16]) | 0;
              }
              a = s.h0;
              b = s.h1;
              c = s.h2;
              d = s.h3;
              e = s.h4;
              f = s.h5;
              g = s.h6;
              h = s.h7;
              for (i = 0; i < 64; ++i) {
                s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));
                ch = g ^ (e & (f ^ g));
                s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));
                maj = (a & b) | (c & (a ^ b));
                t1 = h + s1 + ch + _k[i] + _w[i];
                t2 = s0 + maj;
                h = g;
                g = f;
                f = e;
                e = (d + t1) | 0;
                d = c;
                c = b;
                b = a;
                a = (t1 + t2) | 0;
              }
              s.h0 = (s.h0 + a) | 0;
              s.h1 = (s.h1 + b) | 0;
              s.h2 = (s.h2 + c) | 0;
              s.h3 = (s.h3 + d) | 0;
              s.h4 = (s.h4 + e) | 0;
              s.h5 = (s.h5 + f) | 0;
              s.h6 = (s.h6 + g) | 0;
              s.h7 = (s.h7 + h) | 0;
              len -= 64;
            }
            return s;
          };
          sha256._createState = function() {
            var state = {
              h0: 0x6A09E667,
              h1: 0xBB67AE85,
              h2: 0x3C6EF372,
              h3: 0xA54FF53A,
              h4: 0x510E527F,
              h5: 0x9B05688C,
              h6: 0x1F83D9AB,
              h7: 0x5BE0CD19
            };
            state.copy = function() {
              var rval = sha256._createState();
              rval.h0 = state.h0;
              rval.h1 = state.h1;
              rval.h2 = state.h2;
              rval.h3 = state.h3;
              rval.h4 = state.h4;
              rval.h5 = state.h5;
              rval.h6 = state.h6;
              rval.h7 = state.h7;
              return rval;
            };
            state.write = function(buffer) {
              buffer.putInt32(state.h0);
              buffer.putInt32(state.h1);
              buffer.putInt32(state.h2);
              buffer.putInt32(state.h3);
              buffer.putInt32(state.h4);
              buffer.putInt32(state.h5);
              buffer.putInt32(state.h6);
              buffer.putInt32(state.h7);
            };
            return state;
          };
          sha256._init = function() {
            sha256._k = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
            sha256._w = new Array(64);
          };
        })(_nodejs);
        if (!XMLSerializer) {
          var _defineXMLSerializer = function() {
            XMLSerializer = req('a1').XMLSerializer;
          };
        }
        jsonld.url = {};
        jsonld.url.parsers = {
          simple: {
            keys: ['href', 'scheme', 'authority', 'path', 'query', 'fragment'],
            regex: /^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/
          },
          full: {
            keys: ['href', 'protocol', 'scheme', 'authority', 'auth', 'user', 'password', 'hostname', 'port', 'path', 'directory', 'file', 'query', 'fragment'],
            regex: /^(([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/
          }
        };
        jsonld.url.parse = function(str, parser) {
          var parsed = {};
          var o = jsonld.url.parsers[parser || 'full'];
          var m = o.regex.exec(str);
          var i = o.keys.length;
          while (i--) {
            parsed[o.keys[i]] = (m[i] === undefined) ? null : m[i];
          }
          parsed.normalizedPath = _removeDotSegments(parsed.path, !!parsed.authority);
          return parsed;
        };
        function _removeDotSegments(path, hasAuthority) {
          var rval = '';
          if (path.indexOf('/') === 0) {
            rval = '/';
          }
          var input = path.split('/');
          var output = [];
          while (input.length > 0) {
            if (input[0] === '.' || (input[0] === '' && input.length > 1)) {
              input.shift();
              continue;
            }
            if (input[0] === '..') {
              input.shift();
              if (hasAuthority || (output.length > 0 && output[output.length - 1] !== '..')) {
                output.pop();
              } else {
                output.push('..');
              }
              continue;
            }
            output.push(input.shift());
          }
          return rval + output.join('/');
        }
        if (_nodejs) {
          jsonld.useDocumentLoader('node');
        } else if (typeof XMLHttpRequest !== 'undefined') {
          jsonld.useDocumentLoader('xhr');
        }
        if (_nodejs) {
          jsonld.use = function(extension) {
            switch (extension) {
              case 'request':
                jsonld.request = req('a1');
                break;
              default:
                throw new JsonLdError('Unknown extension.', 'jsonld.UnknownExtension', {extension: extension});
            }
          };
          var _module = {
            exports: {},
            filename: __dirname
          };
          req('a1')(_module, 'version');
          jsonld.version = _module.exports.version;
        }
        return jsonld;
      };
      var factory = function() {
        return wrapper(function() {
          return factory();
        });
      };
      if (!_nodejs && (typeof define === 'function' && define.amd)) {
        define([], function() {
          wrapper(factory);
          return factory;
        });
      } else {
        wrapper(factory);
        if (typeof req === 'function' && typeof module !== 'undefined' && module.exports) {
          module.exports = factory;
        }
        if (_browser) {
          if (typeof jsonld === 'undefined') {
            jsonld = jsonldjs = factory;
          } else {
            jsonldjs = factory;
          }
        }
      }
      return factory;
    })();
  })(req('2e'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("85", ["a4"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('a4');
  global.define = __define;
  return module.exports;
});

$__System.register('f', ['9', '85'], function (_export) {
  'use strict';

  var loadJSON, jsonld, DCAT_CONTEXT, DCAT_CATALOG_FRAME, DCAT_DATASET_FRAME, UNKNOWN_LANG, i18n;

  /**
   * Load a DCAT catalog or a single dataset that we wrap into a catalog
   * and apply some transformations to the catalog data for further use.
   * The applied changes are CKAN repairs and language map creation.
   */

  _export('loadDCATCatalog', loadDCATCatalog);

  _export('loadCatalog', loadCatalog);

  /**
   * Load a DCAT catalog or a single dataset and return the unmodified
   * JSON-LD source, the frame, and the framed&compacted JSON-LD.
   */

  function loadDCATCatalog(url) {
    return loadJSON(url, ['application/ld+json']).then(function (raw) {
      return jsonld.frame(raw, DCAT_CATALOG_FRAME).then(function (framed) {
        return jsonld.compact(framed, framed['@context']);
      }).then(function (compacted) {
        if (compacted['@type'] === 'Catalog') {
          return { compacted: compacted, raw: raw, frame: DCAT_CATALOG_FRAME };
        } else {
          // we may have a single Dataset here, so we'll try to frame for that
          return jsonld.frame(url, DCAT_DATASET_FRAME).then(function (framed) {
            return jsonld.compact(framed, framed['@context']);
          }).then(function (compacted) {
            if (compacted['@type'] !== 'Dataset') {
              throw new Error('No DCAT data found');
            }
            return { compacted: compacted, raw: raw, frame: DCAT_DATASET_FRAME };
          });
        }
      });
    });
  }

  function loadCatalog(url) {
    return loadDCATCatalog(url).then(function (_ref) {
      var compacted = _ref.compacted;

      var catalog = undefined;
      if (compacted['@type'] === 'Catalog') {
        catalog = compacted;
      } else /*if (compacted['@type'] === 'Dataset')*/{
          catalog = {
            datasets: [compacted]
          };
        }

      // We create our own preferred structure:
      // title/description is always a language map where an untagged string is stored under the "unknown"
      // language key. This is not possible with JSON-LD framing alone.
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = catalog.datasets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var dataset = _step.value;
          var _arr = ['title', 'description'];

          for (var _i = 0; _i < _arr.length; _i++) {
            var key = _arr[_i];
            transform_i18n(dataset, key);
          }
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = dataset.distributions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var dist = _step2.value;
              var _arr2 = ['title', 'description'];

              for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
                var key = _arr2[_i2];
                transform_i18n(dist, key);
              }
              // repair CKAN data a bit...
              if (!dist.mediaType) {
                if (dist.format.toLowerCase() === 'geojson') {
                  dist.mediaType = 'application/vnd.geo+json';
                }
                if (dist.format.toLowerCase() === 'wms') {
                  // this doesn't actually exist, but wms endpoints would deliver application/xml which doesn't say much
                  dist.mediaType = 'application/wms+xml';
                }
              }
              // TODO remove once ckanext-dcat is fixed (properties are of string instead of resource type)
              if (dist['dcat:downloadURL']) {
                dist.downloadURL = dist['dcat:downloadURL'];
              }
              if (dist['dcat:accessURL']) {
                dist.accessURL = dist['dcat:accessURL'];
              }
              // convenience
              dist.url = dist.downloadURL || dist.accessURL;
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                _iterator2['return']();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
        // since this is not a valid JSON-LD doc anymore, we might as well remove the context now
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      delete catalog['@context'];
      return catalog;
    });
  }

  /**
   * Transforms %key% and %key%_i18n into a single %key% language map
   * where strings with unknown language get the language tag "unknown". 
   */
  function transform_i18n(obj, key) {
    if (obj[key]) {
      if (!obj[key + i18n]) {
        obj[key + i18n] = {};
      }
      obj[key + i18n][UNKNOWN_LANG] = obj[key];
    }
    if (obj[key + i18n]) {
      var map = {};
      for (var lang in obj[key + i18n]) {
        map[lang] = obj[key + i18n][lang];
      }
      obj[key] = map;
      delete obj[key + i18n];
    }
  }
  return {
    setters: [function (_2) {
      loadJSON = _2.loadJSON;
    }, function (_) {
      jsonld = _.promises;
    }],
    execute: function () {
      DCAT_CONTEXT = [
      // unmodified copy of https://github.com/ec-melodies/wp02-dcat/blob/master/context.jsonld
      // Note: This has to be kept in sync when changes are made to the context!
      // We embed the context here directly to save a network request.
      {
        "@language": "en",
        "xsd": "http://www.w3.org/2001/XMLSchema#",
        "dcat": "http://www.w3.org/ns/dcat#",
        "dct": "http://purl.org/dc/terms/",
        "locn": "http://www.w3.org/ns/locn#",
        "foaf": "http://xmlns.com/foaf/0.1/",
        "schema": "http://schema.org/",
        "label": "http://www.w3.org/2000/01/rdf-schema#label",
        "Catalog": "dcat:Catalog",
        "datasets": { "@id": "dcat:dataset", "@container": "@set" },
        "Dataset": "dcat:Dataset",
        "Location": "dct:Location",
        "geometry": { "@id": "locn:geometry", "@type": "gsp:wktLiteral" },
        "gsp": "http://www.opengis.net/ont/geosparql#",
        "PeriodOfTime": "dct:PeriodOfTime",
        "startDate": { "@id": "schema:startDate", "@type": "xsd:dateTime" },
        "endDate": { "@id": "schema:endDate", "@type": "xsd:dateTime" },
        "title": { "@id": "dct:title", "@container": "@language" },
        "description": { "@id": "dct:description", "@container": "@language" },
        "theme": { "@id": "dcat:theme", "@type": "@id" },
        "issued": { "@id": "dct:issued", "@type": "http://www.w3.org/2001/XMLSchema#dateTime" },
        "modified": { "@id": "dct:modified", "@type": "http://www.w3.org/2001/XMLSchema#dateTime" },
        "landingPage": { "@id": "dcat:landingPage", "@type": "@id" },
        "homepage": { "@id": "foaf:homepage", "@type": "@id" },
        "spatial": "dct:spatial",
        "temporal": "dct:temporal",
        "keywords": { "@id": "dcat:keyword", "@container": "@set" },
        "ssn": "http://purl.oclc.org/NET/ssnx/ssn#",
        "observedProperties": { "@id": "ssn:observedProperty", "@type": "@id", "@container": "@set" },
        "publisher": "dct:publisher",
        "Organization": "foaf:Organization",
        "Group": "foaf:Group",
        "name": { "@id": "foaf:name", "@language": null },
        "Distribution": "dcat:Distribution",
        "distributions": { "@id": "dcat:distribution", "@container": "@set" },
        "accessURL": { "@id": "dcat:accessURL", "@type": "@id" },
        "downloadURL": { "@id": "dcat:downloadURL", "@type": "@id" },
        "mediaType": { "@id": "dcat:mediaType", "@language": null },
        "format": { "@id": "dct:format", "@language": null },
        "isPartOf": { "@id": "dct:isPartOf", "@type": "@id" },
        "parts": { "@id": "dct:hasPart", "@type": "@id", "@container": "@set" }
      },

      // geometry override since we want the GeoJSON geometry, not the WKT one
      // Also, @language and title/description override is because CKAN
      // isn't giving us language-tagged strings which means that we
      // cannot create nice language maps by default.
      // To support both scenarios (with/without language tags),
      // there are two properties for each:
      // title, description - always a string with unknown language
      // title_i18n, description_i18n - always a language map
      // If a language map is given, then the simple string property probably doesn't exist.
      // If *all* DCAT feeds had language tags then we would only need the latter,
      // but for wider support, we do a little more effort.
      // Note that these dual fields get collapsed in a post-processing step, see loadCatalog().
      {
        "geometry": {
          "@id": "locn:geometry",
          "@type": "https://www.iana.org/assignments/media-types/application/vnd.geo+json"
        },
        "@language": null,
        "title": { "@id": "dct:title" },
        "description": { "@id": "dct:description" },
        "title_i18n": { "@id": "dct:title", "@container": "@language" },
        "description_i18n": { "@id": "dct:description", "@container": "@language" },
        "@base": null,
        "id": "@id"
      }];
      DCAT_CATALOG_FRAME = {
        "@context": DCAT_CONTEXT,
        "@type": "Catalog",
        "datasets": {
          "@type": "Dataset",
          "isPartOf": {
            "@embed": "@never",
            "@omitDefault": true
          },
          "parts": {
            "@embed": "@never",
            "@omitDefault": true
          },
          "distributions": {}
        }
      };
      DCAT_DATASET_FRAME = {
        "@context": DCAT_CONTEXT,
        "@type": "Dataset",
        "isPartOf": {
          "@embed": "@never",
          "@omitDefault": true
        },
        "parts": {
          "@embed": "@never",
          "@omitDefault": true
        },
        "distributions": {}
      };
      UNKNOWN_LANG = 'unknown';
      i18n = '_i18n';
    }
  };
});

$__System.register('a5', ['f', 'a'], function (_export) {
  'use strict';

  var dcat, Eventable, Catalogue;
  return {
    setters: [function (_f) {
      dcat = _f;
    }, function (_a) {
      Eventable = _a['default'];
    }],
    execute: function () {
      Catalogue = (function (_Eventable) {
        babelHelpers.inherits(Catalogue, _Eventable);

        function Catalogue() {
          babelHelpers.classCallCheck(this, Catalogue);

          babelHelpers.get(Object.getPrototypeOf(Catalogue.prototype), 'constructor', this).call(this);
          this.datasets = [];
        }

        /** 
         * Load a DCAT catalogue and replace the current datasets with the loaded datasets.
         */
        babelHelpers.createClass(Catalogue, [{
          key: 'loadFromDCAT',
          value: function loadFromDCAT(url) {
            var _this = this;

            this.datasets = [];
            this.fire('loading', { url: url });
            return dcat.loadCatalog(url).then(function (catalog) {
              _this.url = url;
              var datasets = catalog.datasets;
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = datasets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var dataset = _step.value;

                  _this.datasets.push(dataset);
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator['return']) {
                    _iterator['return']();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }

              _this.fire('load', { url: url, datasets: datasets });
            })['catch'](function (error) {
              _this.fire('loadError', { url: url, error: error });
              throw error;
            });
          }
        }]);
        return Catalogue;
      })(Eventable);

      _export('default', Catalogue);
    }
  };
});

$__System.register('a', ['9'], function (_export) {
  'use strict';

  var DefaultMap, Eventable;
  return {
    setters: [function (_) {
      DefaultMap = _.DefaultMap;
    }],
    execute: function () {
      Eventable = (function () {
        function Eventable() {
          babelHelpers.classCallCheck(this, Eventable);

          this.listeners = new DefaultMap(function () {
            return new Set();
          });
        }

        babelHelpers.createClass(Eventable, [{
          key: 'on',
          value: function on(events, fn) {
            events = Array.isArray(events) ? events : [events];
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = events[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _event = _step.value;

                this.listeners.get(_event).add(fn);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            return this;
          }
        }, {
          key: 'off',
          value: function off(event, fn) {
            if (!this.listeners.get(event)['delete'](fn)) {
              throw new Error('Event listener not found');
            }
          }
        }, {
          key: 'fire',
          value: function fire(event, data) {
            console.log('Event: \'' + event + '\', Class: ' + this.constructor.name + ', Data:', data);
            // create a copy before interation to avoid issues when adding listeners while iterating
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = new Set(this.listeners.get(event))[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var fn = _step2.value;

                fn(data);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                  _iterator2['return']();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
        }]);
        return Eventable;
      })();

      _export('default', Eventable);
    }
  };
});

$__System.register('a6', ['14', '16', '17', '19', '21', '22', '24', '32', '33', '38', '77', '78', 'a', 'a5', 'a0', '1a', '7c', '7a', '3d'], function (_export) {

  /**
   * Something like a main controller.
   * 
   * @fires App#dataLoading when some data has started loading
   * @fires App#dataLoad when some data has finished loading or an error occured
   */
  'use strict';

  var GoToSource, WMSView, GeoJSONView, CoverageModelObservationCompare, CoverageSubsetByPolygon, GeoJSON, CoverageCategoriesStatistics, CoverageRemapCategories, CatRemap, CoverageDeriveParameter, GeoCoverageView, CovJSON, Eventable, Catalogue, Workspace, CoverageData, CovCBOR, WMS, StatisticalCoverageView, App;
  return {
    setters: [function (_12) {
      GoToSource = _12['default'];
    }, function (_11) {
      WMSView = _11['default'];
    }, function (_10) {
      GeoJSONView = _10['default'];
    }, function (_9) {
      CoverageModelObservationCompare = _9['default'];
    }, function (_8) {
      CoverageSubsetByPolygon = _8['default'];
    }, function (_2) {
      GeoJSON = _2['default'];
    }, function (_7) {
      CoverageCategoriesStatistics = _7['default'];
    }, function (_6) {
      CoverageRemapCategories = _6['default'];
    }, function (_3) {
      CatRemap = _3['default'];
    }, function (_5) {
      CoverageDeriveParameter = _5['default'];
    }, function (_4) {
      GeoCoverageView = _4['default'];
    }, function (_) {
      CovJSON = _['default'];
    }, function (_a) {
      Eventable = _a['default'];
    }, function (_a5) {
      Catalogue = _a5['default'];
    }, function (_a0) {
      Workspace = _a0['default'];
    }, function (_a2) {
      CoverageData = _a2['default'];
    }, function (_c) {
      CovCBOR = _c['default'];
    }, function (_a3) {
      WMS = _a3['default'];
    }, function (_d) {
      StatisticalCoverageView = _d['default'];
    }],
    execute: function () {
      App = (function (_Eventable) {
        babelHelpers.inherits(App, _Eventable);

        function App(map) {
          babelHelpers.classCallCheck(this, App);

          babelHelpers.get(Object.getPrototypeOf(App.prototype), 'constructor', this).call(this);
          this.map = map;

          this.catalogue = new Catalogue();

          this.formats = [new CovJSON([GeoCoverageView, StatisticalCoverageView, CoverageDeriveParameter, CoverageRemapCategories, CoverageCategoriesStatistics, CoverageSubsetByPolygon, CoverageModelObservationCompare, GoToSource]), new CovCBOR([GeoCoverageView, StatisticalCoverageView, CoverageDeriveParameter, CoverageRemapCategories, CoverageCategoriesStatistics, CoverageSubsetByPolygon, CoverageModelObservationCompare, GoToSource]), new CoverageData([GeoCoverageView, StatisticalCoverageView, CoverageDeriveParameter, CoverageRemapCategories, CoverageCategoriesStatistics, CoverageSubsetByPolygon, CoverageModelObservationCompare]), new GeoJSON([GeoJSONView, GoToSource]), new WMS([WMSView, GoToSource]), new CatRemap([GoToSource])];

          this.workspace = new Workspace(this.formats);
          this.workspace.addStaticActionContext({ map: map });

          this._registerLoadingListeners();
        }

        /**
         * Listens for any kind of data loading event and re-fires
         * those as generic 'dataLoading' and 'dataLoad' events
         * to allow for UI elements like loading spinners.
         * 
         * Note that any consumer of those events should register itself
         * before any data loading occurs. This is because events will fire
         * in any order and the consumer has to keep track of the counts of
         * 'dataLoading' and 'dataLoad' events to determine whether all data
         * has finished loading.
         */
        babelHelpers.createClass(App, [{
          key: '_registerLoadingListeners',
          value: function _registerLoadingListeners() {
            var _this = this;

            // TODO how can we listen to Action class events?

            var fireLoadingEvent = function fireLoadingEvent() {
              return _this.fire('dataLoading');
            };
            var fireLoadEvent = function fireLoadEvent() {
              return _this.fire('dataLoad');
            };

            this.catalogue.on('loading', fireLoadingEvent).on(['load', 'loadError'], fireLoadEvent);
            this.workspace.on('distributionsLoading', fireLoadingEvent).on('distributionsLoad', fireLoadEvent);
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = this.formats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var format = _step.value;

                format.on('loading', fireLoadingEvent).on(['load', 'loadError'], fireLoadEvent).on('actionCreate', function (_ref) {
                  var action = _ref.action;

                  action.on('loading', fireLoadingEvent).on(['load', 'loadError'], fireLoadEvent);
                });
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
        }]);
        return App;
      })(Eventable);

      _export('default', App);
    }
  };
});

$__System.registerDynamic("a7", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    (function() {
      'use strict';
      if (self.fetch) {
        return;
      }
      function normalizeName(name) {
        if (typeof name !== 'string') {
          name = String(name);
        }
        if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
          throw new TypeError('Invalid character in header field name');
        }
        return name.toLowerCase();
      }
      function normalizeValue(value) {
        if (typeof value !== 'string') {
          value = String(value);
        }
        return value;
      }
      function Headers(headers) {
        this.map = {};
        if (headers instanceof Headers) {
          headers.forEach(function(value, name) {
            this.append(name, value);
          }, this);
        } else if (headers) {
          Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
          }, this);
        }
      }
      Headers.prototype.append = function(name, value) {
        name = normalizeName(name);
        value = normalizeValue(value);
        var list = this.map[name];
        if (!list) {
          list = [];
          this.map[name] = list;
        }
        list.push(value);
      };
      Headers.prototype['delete'] = function(name) {
        delete this.map[normalizeName(name)];
      };
      Headers.prototype.get = function(name) {
        var values = this.map[normalizeName(name)];
        return values ? values[0] : null;
      };
      Headers.prototype.getAll = function(name) {
        return this.map[normalizeName(name)] || [];
      };
      Headers.prototype.has = function(name) {
        return this.map.hasOwnProperty(normalizeName(name));
      };
      Headers.prototype.set = function(name, value) {
        this.map[normalizeName(name)] = [normalizeValue(value)];
      };
      Headers.prototype.forEach = function(callback, thisArg) {
        Object.getOwnPropertyNames(this.map).forEach(function(name) {
          this.map[name].forEach(function(value) {
            callback.call(thisArg, value, name, this);
          }, this);
        }, this);
      };
      function consumed(body) {
        if (body.bodyUsed) {
          return Promise.reject(new TypeError('Already read'));
        }
        body.bodyUsed = true;
      }
      function fileReaderReady(reader) {
        return new Promise(function(resolve, reject) {
          reader.onload = function() {
            resolve(reader.result);
          };
          reader.onerror = function() {
            reject(reader.error);
          };
        });
      }
      function readBlobAsArrayBuffer(blob) {
        var reader = new FileReader();
        reader.readAsArrayBuffer(blob);
        return fileReaderReady(reader);
      }
      function readBlobAsText(blob) {
        var reader = new FileReader();
        reader.readAsText(blob);
        return fileReaderReady(reader);
      }
      var support = {
        blob: 'FileReader' in self && 'Blob' in self && (function() {
          try {
            new Blob();
            return true;
          } catch (e) {
            return false;
          }
        })(),
        formData: 'FormData' in self,
        arrayBuffer: 'ArrayBuffer' in self
      };
      function Body() {
        this.bodyUsed = false;
        this._initBody = function(body) {
          this._bodyInit = body;
          if (typeof body === 'string') {
            this._bodyText = body;
          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
          } else if (!body) {
            this._bodyText = '';
          } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {} else {
            throw new Error('unsupported BodyInit type');
          }
        };
        if (support.blob) {
          this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return Promise.resolve(this._bodyBlob);
            } else if (this._bodyFormData) {
              throw new Error('could not read FormData body as blob');
            } else {
              return Promise.resolve(new Blob([this._bodyText]));
            }
          };
          this.arrayBuffer = function() {
            return this.blob().then(readBlobAsArrayBuffer);
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyFormData) {
              throw new Error('could not read FormData body as text');
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
        } else {
          this.text = function() {
            var rejected = consumed(this);
            return rejected ? rejected : Promise.resolve(this._bodyText);
          };
        }
        if (support.formData) {
          this.formData = function() {
            return this.text().then(decode);
          };
        }
        this.json = function() {
          return this.text().then(JSON.parse);
        };
        return this;
      }
      var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];
      function normalizeMethod(method) {
        var upcased = method.toUpperCase();
        return (methods.indexOf(upcased) > -1) ? upcased : method;
      }
      function Request(input, options) {
        options = options || {};
        var body = options.body;
        if (Request.prototype.isPrototypeOf(input)) {
          if (input.bodyUsed) {
            throw new TypeError('Already read');
          }
          this.url = input.url;
          this.credentials = input.credentials;
          if (!options.headers) {
            this.headers = new Headers(input.headers);
          }
          this.method = input.method;
          this.mode = input.mode;
          if (!body) {
            body = input._bodyInit;
            input.bodyUsed = true;
          }
        } else {
          this.url = input;
        }
        this.credentials = options.credentials || this.credentials || 'omit';
        if (options.headers || !this.headers) {
          this.headers = new Headers(options.headers);
        }
        this.method = normalizeMethod(options.method || this.method || 'GET');
        this.mode = options.mode || this.mode || null;
        this.referrer = null;
        if ((this.method === 'GET' || this.method === 'HEAD') && body) {
          throw new TypeError('Body not allowed for GET or HEAD requests');
        }
        this._initBody(body);
      }
      Request.prototype.clone = function() {
        return new Request(this);
      };
      function decode(body) {
        var form = new FormData();
        body.trim().split('&').forEach(function(bytes) {
          if (bytes) {
            var split = bytes.split('=');
            var name = split.shift().replace(/\+/g, ' ');
            var value = split.join('=').replace(/\+/g, ' ');
            form.append(decodeURIComponent(name), decodeURIComponent(value));
          }
        });
        return form;
      }
      function headers(xhr) {
        var head = new Headers();
        var pairs = xhr.getAllResponseHeaders().trim().split('\n');
        pairs.forEach(function(header) {
          var split = header.trim().split(':');
          var key = split.shift().trim();
          var value = split.join(':').trim();
          head.append(key, value);
        });
        return head;
      }
      Body.call(Request.prototype);
      function Response(bodyInit, options) {
        if (!options) {
          options = {};
        }
        this._initBody(bodyInit);
        this.type = 'default';
        this.status = options.status;
        this.ok = this.status >= 200 && this.status < 300;
        this.statusText = options.statusText;
        this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers);
        this.url = options.url || '';
      }
      Body.call(Response.prototype);
      Response.prototype.clone = function() {
        return new Response(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new Headers(this.headers),
          url: this.url
        });
      };
      Response.error = function() {
        var response = new Response(null, {
          status: 0,
          statusText: ''
        });
        response.type = 'error';
        return response;
      };
      var redirectStatuses = [301, 302, 303, 307, 308];
      Response.redirect = function(url, status) {
        if (redirectStatuses.indexOf(status) === -1) {
          throw new RangeError('Invalid status code');
        }
        return new Response(null, {
          status: status,
          headers: {location: url}
        });
      };
      self.Headers = Headers;
      self.Request = Request;
      self.Response = Response;
      self.fetch = function(input, init) {
        return new Promise(function(resolve, reject) {
          var request;
          if (Request.prototype.isPrototypeOf(input) && !init) {
            request = input;
          } else {
            request = new Request(input, init);
          }
          var xhr = new XMLHttpRequest();
          function responseURL() {
            if ('responseURL' in xhr) {
              return xhr.responseURL;
            }
            if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
              return xhr.getResponseHeader('X-Request-URL');
            }
            return;
          }
          xhr.onload = function() {
            var status = (xhr.status === 1223) ? 204 : xhr.status;
            if (status < 100 || status > 599) {
              reject(new TypeError('Network request failed'));
              return;
            }
            var options = {
              status: status,
              statusText: xhr.statusText,
              headers: headers(xhr),
              url: responseURL()
            };
            var body = 'response' in xhr ? xhr.response : xhr.responseText;
            resolve(new Response(body, options));
          };
          xhr.onerror = function() {
            reject(new TypeError('Network request failed'));
          };
          xhr.open(request.method, request.url, true);
          if (request.credentials === 'include') {
            xhr.withCredentials = true;
          }
          if ('responseType' in xhr && support.blob) {
            xhr.responseType = 'blob';
          }
          request.headers.forEach(function(value, name) {
            xhr.setRequestHeader(name, value);
          });
          xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
        });
      };
      self.fetch.polyfill = true;
    })();
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("a8", ["a7"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('a7');
  global.define = __define;
  return module.exports;
});

$__System.register('9', ['a8'], function (_export) {
  'use strict';

  var COVJSON_PREFIX, DefaultMap;

  _export('i18n', i18n);

  _export('sortByKey', sortByKey);

  //https://github.com/github/fetch#handling-http-error-statuses

  _export('loadJSON', loadJSON);

  _export('checkStatus', checkStatus);

  function i18n(prop) {
    if (!prop) return;
    // TODO be clever and select proper language
    if (prop.en) {
      return prop.en;
    } else {
      // random
      return prop[Object.keys(prop)[0]];
    }
  }

  function sortByKey(array, keyFn) {
    return array.sort(function (a, b) {
      var x = keyFn(a);
      var y = keyFn(b);
      return x < y ? -1 : x > y ? 1 : 0;
    });
  }

  function loadJSON(urlOrObject, additionalMediaTypes) {
    if (typeof urlOrObject === 'string') {
      var mt = additionalMediaTypes.map(function (m) {
        return m + '; q=1.0';
      });
      mt.push('application/json; q=0.5');
      mt = mt.join(',');
      return fetch(urlOrObject, {
        headers: new Headers({ Accept: mt })
      })['catch'](function (e) {
        // we only get a response object if there was no network/CORS error, fall-back
        e.response = { url: urlOrObject };
        throw e;
      }).then(checkStatus).then(function (response) {
        return response.json();
      });
    } else {
      return Promise.resolve(urlOrObject);
    }
  }

  function checkStatus(response) {
    if (response.ok) {
      // status 2xx
      return response;
    } else {
      var error = new Error(response.statusText);
      error.response = response;
      throw error;
    }
  }

  return {
    setters: [function (_a8) {}],
    execute: function () {
      COVJSON_PREFIX = 'http://coveragejson.org/def#';

      _export('COVJSON_PREFIX', COVJSON_PREFIX);

      /**
       * A Map which returns a default value for get(key) if key does not exist.
       */

      DefaultMap = (function () {
        function DefaultMap(defaultFactory, iterable) {
          babelHelpers.classCallCheck(this, DefaultMap);

          this._map = new Map(iterable);
          this.defaultFactory = defaultFactory;
        }

        babelHelpers.createClass(DefaultMap, [{
          key: 'get',
          value: function get(key) {
            if (!this._map.has(key)) {
              this._map.set(key, this.defaultFactory());
            }
            return this._map.get(key);
          }
        }, {
          key: 'set',
          value: function set(key, val) {
            this._map.set(key, val);
          }
        }, {
          key: 'delete',
          value: function _delete(key) {
            this._map['delete'](key);
          }
        }]);
        return DefaultMap;
      })();

      _export('DefaultMap', DefaultMap);
    }
  };
});

$__System.registerDynamic("a9", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  Object.defineProperty(exports, "__esModule", {value: true});
  var _slicedToArray = function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
  };
  exports.getCategory = getCategory;
  function getCategory(parameter, val) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;
    try {
      var _loop = function _loop() {
        var _step$value = _slicedToArray(_step.value, 2);
        var catId = _step$value[0];
        var vals = _step$value[1];
        if (vals.indexOf(val) !== -1) {
          var cat = parameter.observedProperty.categories.filter(function(c) {
            return c.id === catId;
          })[0];
          return {v: cat};
        }
      };
      for (var _iterator = parameter.categoryEncoding[Symbol.iterator](),
          _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _ret = _loop();
        if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object")
          return _ret.v;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("44", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  Object.defineProperty(exports, "__esModule", {value: true});
  exports.getLanguageTag = getLanguageTag;
  exports.getLanguageString = getLanguageString;
  var DEFAULT_LANGUAGE = 'en';
  function getLanguageTag(map) {
    var preferredLanguage = arguments.length <= 1 || arguments[1] === undefined ? DEFAULT_LANGUAGE : arguments[1];
    if (preferredLanguage in map) {
      return preferredLanguage;
    }
    var prefTag = preferredLanguage.split('-')[0];
    var matches = Object.keys(map).filter(function(tag) {
      return prefTag === tag.split('-')[0];
    });
    if (matches.length) {
      return matches[0];
    }
    return Object.keys(map)[0];
  }
  function getLanguageString(map) {
    var preferredLanguage = arguments.length <= 1 || arguments[1] === undefined ? DEFAULT_LANGUAGE : arguments[1];
    var tag = getLanguageTag(map, preferredLanguage);
    return map[tag];
  }
  global.define = __define;
  return module.exports;
});

$__System.register('aa', ['5', '44', 'a9'], function (_export) {
  /* */

  /**
   * A popup that contains the parameter values of the given coverage layers at the location of the popup.
   * 
   * The popup content is updated when one of the following occurs:
   * - popup is added to a map
   * - popup location is changed
   * - coverage layer is added or removed
   * - updateData() is called
   */
  'use strict';

  var L, i18n, getCategory, ValuePopup;

  // TODO move this to covutils
  function getUnitString(param, language) {
    if (param.observedProperty.categories || !param.unit) {
      return '';
    }
    if (param.unit.symbol) {
      var unit = param.unit.symbol.value || param.unit.symbol;
      var scheme = param.unit.symbol.type;
      if (scheme === 'http://www.opengis.net/def/uom/UCUM/') {
        if (unit === 'Cel') {
          unit = '°C';
        } else if (unit === '1') {
          unit = '';
        }
      }
      return unit;
    } else {
      return i18n.getLanguageString(param.unit.label, language);
    }
  }

  function getMetersPerPixel(map) {
    // from L.Control.Scale
    var bounds = map.getBounds();
    var centerLat = bounds.getCenter().lat;
    var halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180);
    var dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180;
    var size = map.getSize();
    var perpx = dist / size.x;
    return perpx;
  }
  return {
    setters: [function (_) {
      L = _['default'];
    }, function (_2) {
      i18n = _2.getLanguageString;
    }, function (_a9) {
      getCategory = _a9.getCategory;
    }],
    execute: function () {
      ValuePopup = (function (_L$Popup) {
        babelHelpers.inherits(ValuePopup, _L$Popup);

        /**
         * @param {number} [options.maxDistanceForPointsInPx=20]
         *   The maximum distance in pixels from the popup location for which point-data values should be included.
         * @param {Array<CoverageLayer>} [options.layers]
         *   An initial set of coverage layers.
         */

        function ValuePopup(options, source) {
          babelHelpers.classCallCheck(this, ValuePopup);

          babelHelpers.get(Object.getPrototypeOf(ValuePopup.prototype), 'constructor', this).call(this, options, source);
          var layers = this.options.layers || [];
          this._maxDistanceForPointsInPx = this.options.maxDistanceForPointsInPx || 20;
          this.coverageLayers = new Set(layers.filter(function (layer) {
            return layer.getValueAt;
          }));
        }

        babelHelpers.createClass(ValuePopup, [{
          key: 'addCoverageLayer',
          value: function addCoverageLayer(layer) {
            if (!layer.getValueAt) return;
            this.coverageLayers.add(layer);
            this.updateData();
            return this;
          }
        }, {
          key: 'removeCoverageLayer',
          value: function removeCoverageLayer(layer) {
            this.coverageLayers['delete'](layer);
            this.updateData();
            return this;
          }
        }, {
          key: 'onAdd',
          value: function onAdd(map) {
            this._map = map;
            babelHelpers.get(Object.getPrototypeOf(ValuePopup.prototype), 'onAdd', this).call(this, map);
            this.updateData();
          }
        }, {
          key: 'onRemove',
          value: function onRemove(map) {
            babelHelpers.get(Object.getPrototypeOf(ValuePopup.prototype), 'onRemove', this).call(this, map);
            this._map = null;
          }
        }, {
          key: 'setLatLng',
          value: function setLatLng(latlng) {
            babelHelpers.get(Object.getPrototypeOf(ValuePopup.prototype), 'setLatLng', this).call(this, latlng);
            this.updateData();
            return this;
          }

          /**
           * Returns whether there is any non-missing coverage data at the current popup location.
           * This function only works after the popup has been added to the map.
           */
        }, {
          key: 'hasData',
          value: function hasData() {
            return this._hasData;
          }
        }, {
          key: 'updateData',
          value: function updateData() {
            if (!this._map) return;
            var html = '';

            var latlng = this.getLatLng();

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = this.coverageLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var layer = _step.value;

                var maxDistance = getMetersPerPixel(this._map) * this._maxDistanceForPointsInPx;
                var val = layer.getValueAt(latlng, maxDistance);
                if (val == null) continue;
                var param = layer.parameter;

                var unit = getUnitString(param);
                if (param.categoryEncoding) {
                  var cat = getCategory(param, val);
                  val = i18n(cat.label);
                }
                html += '<div><strong>' + i18n(param.observedProperty.label) + '</strong>: ' + val + ' ' + unit + '</div>';
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                  _iterator['return']();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            if (!html) {
              this._hasData = false;
              html = 'No data.';
            }
            this._hasData = true;
            this.setContent(html);
            return this;
          }
        }]);
        return ValuePopup;
      })(L.Popup);

      _export('default', ValuePopup);
    }
  };
});

$__System.register('ab', ['5'], function (_export) {
  /* */

  /**
   * Makes L.Popup draggable and proxies all L.Draggable events.
   * 
   * @example
   * let DraggablePopup = DraggablePopupMixin(L.Popup)
   * let popup = new DraggablePopup().setContent('I am draggable!')
   */
  'use strict';

  var L;

  _export('default', DraggablePopupMixin);

  function DraggablePopupMixin(base) {
    return (function (_base) {
      babelHelpers.inherits(_class, _base);

      function _class() {
        babelHelpers.classCallCheck(this, _class);
        babelHelpers.get(Object.getPrototypeOf(_class.prototype), 'constructor', this).apply(this, arguments);
      }

      babelHelpers.createClass(_class, [{
        key: 'onAdd',
        value: function onAdd(map) {
          var _this = this;

          babelHelpers.get(Object.getPrototypeOf(_class.prototype), 'onAdd', this).call(this, map);
          this._draggable = new L.Draggable(this._container, this._wrapper);
          this._draggable.enable();
          this._draggable.on('drag', function (e) {
            // Popup.setContent() resets to the pre-drag position and doesn't use L.DomUtil.setPosition
            // the code below works around that
            var pos = L.DomUtil.getPosition(_this._wrapper.parentNode);
            var latlng = map.layerPointToLatLng(pos);
            _this.setLatLng(latlng);
            _this.fire('drag', e);
          });
          this._draggable.on('dragstart predrag dragend', function (e) {
            return _this.fire(e.type, e);
          });
        }
      }, {
        key: 'onRemove',
        value: function onRemove(map) {
          this._draggable.disable();
          babelHelpers.get(Object.getPrototypeOf(_class.prototype), 'onRemove', this).call(this, map);
        }
      }]);
      return _class;
    })(base);
  }

  return {
    setters: [function (_) {
      L = _['default'];
    }],
    execute: function () {}
  };
});

$__System.register('ac', ['ab', 'aa'], function (_export) {
  /* */

  /**
   * Like CoverageValuePopup but draggable and updates its content while dragging.
   */
  'use strict';

  var DraggablePopupMixin, ValuePopup, DraggableValuePopup;
  return {
    setters: [function (_ab) {
      DraggablePopupMixin = _ab['default'];
    }, function (_aa) {
      ValuePopup = _aa['default'];
    }],
    execute: function () {
      DraggableValuePopup = (function (_DraggablePopupMixin) {
        babelHelpers.inherits(DraggableValuePopup, _DraggablePopupMixin);

        function DraggableValuePopup() {
          babelHelpers.classCallCheck(this, DraggableValuePopup);
          babelHelpers.get(Object.getPrototypeOf(DraggableValuePopup.prototype), 'constructor', this).apply(this, arguments);
        }

        return DraggableValuePopup;
      })(DraggablePopupMixin(ValuePopup));

      _export('default', DraggableValuePopup);
    }
  };
});

$__System.register("ad", [], function() { return { setters: [], execute: function() {} } });

(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
(function() {
  var console = window.console || {
    error: function() {},
    warn: function() {}
  };
  function defineLeafletLoading(L) {
    L.Control.Loading = L.Control.extend({
      options: {
        position: 'topleft',
        separate: false,
        zoomControl: null,
        spinjs: false,
        spin: {
          lines: 7,
          length: 3,
          width: 3,
          radius: 5,
          rotate: 13,
          top: "83%"
        }
      },
      initialize: function(options) {
        L.setOptions(this, options);
        this._dataLoaders = {};
        if (this.options.zoomControl !== null) {
          this.zoomControl = this.options.zoomControl;
        }
      },
      onAdd: function(map) {
        if (this.options.spinjs && (typeof Spinner !== 'function')) {
          return console.error("Leaflet.loading cannot load because you didn't load spin.js (http://fgnass.github.io/spin.js/), even though you set it in options.");
        }
        this._addLayerListeners(map);
        this._addMapListeners(map);
        if (!this.options.separate && !this.zoomControl) {
          if (map.zoomControl) {
            this.zoomControl = map.zoomControl;
          } else if (map.zoomsliderControl) {
            this.zoomControl = map.zoomsliderControl;
          }
        }
        var classes = 'leaflet-control-loading';
        var container;
        if (this.zoomControl && !this.options.separate) {
          container = this.zoomControl._container;
          classes += ' leaflet-bar-part-bottom leaflet-bar-part last';
          L.DomUtil.addClass(this._getLastControlButton(), 'leaflet-bar-part-bottom');
        } else {
          container = L.DomUtil.create('div', 'leaflet-control-zoom leaflet-bar');
        }
        this._indicator = L.DomUtil.create('a', classes, container);
        if (this.options.spinjs) {
          this._spinner = new Spinner(this.options.spin).spin();
          this._indicator.appendChild(this._spinner.el);
        }
        return container;
      },
      onRemove: function(map) {
        this._removeLayerListeners(map);
        this._removeMapListeners(map);
      },
      removeFrom: function(map) {
        if (this.zoomControl && !this.options.separate) {
          this._container.removeChild(this._indicator);
          this._map = null;
          this.onRemove(map);
          return this;
        } else {
          return L.Control.prototype.removeFrom.call(this, map);
        }
      },
      addLoader: function(id) {
        this._dataLoaders[id] = true;
        this.updateIndicator();
      },
      removeLoader: function(id) {
        delete this._dataLoaders[id];
        this.updateIndicator();
      },
      updateIndicator: function() {
        if (this.isLoading()) {
          this._showIndicator();
        } else {
          this._hideIndicator();
        }
      },
      isLoading: function() {
        return this._countLoaders() > 0;
      },
      _countLoaders: function() {
        var size = 0,
            key;
        for (key in this._dataLoaders) {
          if (this._dataLoaders.hasOwnProperty(key))
            size++;
        }
        return size;
      },
      _showIndicator: function() {
        L.DomUtil.addClass(this._indicator, 'is-loading');
        if (!this.options.separate) {
          if (this.zoomControl instanceof L.Control.Zoom) {
            L.DomUtil.removeClass(this._getLastControlButton(), 'leaflet-bar-part-bottom');
          } else if (typeof L.Control.Zoomslider === 'function' && this.zoomControl instanceof L.Control.Zoomslider) {
            L.DomUtil.removeClass(this.zoomControl._ui.zoomOut, 'leaflet-bar-part-bottom');
          }
        }
      },
      _hideIndicator: function() {
        L.DomUtil.removeClass(this._indicator, 'is-loading');
        if (!this.options.separate) {
          if (this.zoomControl instanceof L.Control.Zoom) {
            L.DomUtil.addClass(this._getLastControlButton(), 'leaflet-bar-part-bottom');
          } else if (typeof L.Control.Zoomslider === 'function' && this.zoomControl instanceof L.Control.Zoomslider) {
            L.DomUtil.addClass(this.zoomControl._ui.zoomOut, 'leaflet-bar-part-bottom');
          }
        }
      },
      _getLastControlButton: function() {
        var container = this.zoomControl._container,
            index = container.children.length - 1;
        while (index > 0) {
          var button = container.children[index];
          if (!(this._indicator === button || button.offsetWidth === 0 || button.offsetHeight === 0)) {
            break;
          }
          index--;
        }
        return container.children[index];
      },
      _handleLoading: function(e) {
        this.addLoader(this.getEventId(e));
      },
      _handleLoad: function(e) {
        this.removeLoader(this.getEventId(e));
      },
      getEventId: function(e) {
        if (e.id) {
          return e.id;
        } else if (e.layer) {
          return e.layer._leaflet_id;
        }
        return e.target._leaflet_id;
      },
      _layerAdd: function(e) {
        if (!e.layer || !e.layer.on)
          return;
        try {
          e.layer.on({
            loading: this._handleLoading,
            load: this._handleLoad
          }, this);
        } catch (exception) {
          console.warn('L.Control.Loading: Tried and failed to add ' + ' event handlers to layer', e.layer);
          console.warn('L.Control.Loading: Full details', exception);
        }
      },
      _addLayerListeners: function(map) {
        map.eachLayer(function(layer) {
          if (!layer.on)
            return;
          layer.on({
            loading: this._handleLoading,
            load: this._handleLoad
          }, this);
        }, this);
        map.on('layeradd', this._layerAdd, this);
      },
      _removeLayerListeners: function(map) {
        map.eachLayer(function(layer) {
          if (!layer.off)
            return;
          layer.off({
            loading: this._handleLoading,
            load: this._handleLoad
          }, this);
        }, this);
        map.off('layeradd', this._layerAdd, this);
      },
      _addMapListeners: function(map) {
        map.on({
          baselayerchange: this._handleLoading,
          dataloading: this._handleLoading,
          dataload: this._handleLoad,
          layerremove: this._handleLoad
        }, this);
      },
      _removeMapListeners: function(map) {
        map.off({
          baselayerchange: this._handleLoading,
          dataloading: this._handleLoading,
          dataload: this._handleLoad,
          layerremove: this._handleLoad
        }, this);
      }
    });
    L.Map.addInitHook(function() {
      if (this.options.loadingControl) {
        this.loadingControl = new L.Control.Loading();
        this.addControl(this.loadingControl);
      }
    });
    L.Control.loading = function(options) {
      return new L.Control.Loading(options);
    };
  }
  if (typeof define === 'function' && define.amd) {
    define("ae", ["5"], function(L) {
      defineLeafletLoading(L);
    });
  } else {
    defineLeafletLoading(L);
  }
})();

_removeDefine();
})();
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("af", ["ae"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define("b0", ["5"], factory);
  } else if (typeof modules === 'object' && module.exports) {
    module.exports = factory(require('leaflet'));
  } else {
    factory(L);
  }
}(this, function(L) {
  'use strict';
  L.TileLayer.Provider = L.TileLayer.extend({initialize: function(arg, options) {
      var providers = L.TileLayer.Provider.providers;
      var parts = arg.split('.');
      var providerName = parts[0];
      var variantName = parts[1];
      if (!providers[providerName]) {
        throw 'No such provider (' + providerName + ')';
      }
      var provider = {
        url: providers[providerName].url,
        options: providers[providerName].options
      };
      if (variantName && 'variants' in providers[providerName]) {
        if (!(variantName in providers[providerName].variants)) {
          throw 'No such variant of ' + providerName + ' (' + variantName + ')';
        }
        var variant = providers[providerName].variants[variantName];
        var variantOptions;
        if (typeof variant === 'string') {
          variantOptions = {variant: variant};
        } else {
          variantOptions = variant.options;
        }
        provider = {
          url: variant.url || provider.url,
          options: L.Util.extend({}, provider.options, variantOptions)
        };
      }
      var forceHTTP = window.location.protocol === 'file:' || provider.options.forceHTTP;
      if (provider.url.indexOf('//') === 0 && forceHTTP) {
        provider.url = 'http:' + provider.url;
      }
      if (provider.options.retina) {
        if (options.detectRetina && L.Browser.retina) {
          options.detectRetina = false;
        } else {
          provider.options.retina = '';
        }
      }
      var attributionReplacer = function(attr) {
        if (attr.indexOf('{attribution.') === -1) {
          return attr;
        }
        return attr.replace(/\{attribution.(\w*)\}/, function(match, attributionName) {
          return attributionReplacer(providers[attributionName].options.attribution);
        });
      };
      provider.options.attribution = attributionReplacer(provider.options.attribution);
      var layerOpts = L.Util.extend({}, provider.options, options);
      L.TileLayer.prototype.initialize.call(this, provider.url, layerOpts);
    }});
  L.TileLayer.Provider.providers = {
    OpenStreetMap: {
      url: '//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
      options: {
        maxZoom: 19,
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
      },
      variants: {
        Mapnik: {},
        BlackAndWhite: {
          url: 'http://{s}.tiles.wmflabs.org/bw-mapnik/{z}/{x}/{y}.png',
          options: {maxZoom: 18}
        },
        DE: {
          url: 'http://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png',
          options: {maxZoom: 18}
        },
        France: {
          url: 'http://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png',
          options: {attribution: '&copy; Openstreetmap France | {attribution.OpenStreetMap}'}
        },
        HOT: {
          url: 'http://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png',
          options: {attribution: '{attribution.OpenStreetMap}, Tiles courtesy of <a href="http://hot.openstreetmap.org/" target="_blank">Humanitarian OpenStreetMap Team</a>'}
        }
      }
    },
    OpenSeaMap: {
      url: 'http://tiles.openseamap.org/seamark/{z}/{x}/{y}.png',
      options: {attribution: 'Map data: &copy; <a href="http://www.openseamap.org">OpenSeaMap</a> contributors'}
    },
    OpenTopoMap: {
      url: '//{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
      options: {
        maxZoom: 16,
        attribution: 'Map data: {attribution.OpenStreetMap}, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
      }
    },
    Thunderforest: {
      url: '//{s}.tile.thunderforest.com/{variant}/{z}/{x}/{y}.png',
      options: {
        attribution: '&copy; <a href="http://www.thunderforest.com/">Thunderforest</a>, {attribution.OpenStreetMap}',
        variant: 'cycle'
      },
      variants: {
        OpenCycleMap: 'cycle',
        Transport: {options: {
            variant: 'transport',
            maxZoom: 19
          }},
        TransportDark: {options: {
            variant: 'transport-dark',
            maxZoom: 19
          }},
        SpinalMap: {options: {
            variant: 'spinal-map',
            maxZoom: 11
          }},
        Landscape: 'landscape',
        Outdoors: 'outdoors',
        Pioneer: 'pioneer'
      }
    },
    OpenMapSurfer: {
      url: 'http://korona.geog.uni-heidelberg.de/tiles/{variant}/x={x}&y={y}&z={z}',
      options: {
        maxZoom: 20,
        variant: 'roads',
        attribution: 'Imagery from <a href="http://giscience.uni-hd.de/">GIScience Research Group @ University of Heidelberg</a> &mdash; Map data {attribution.OpenStreetMap}'
      },
      variants: {
        Roads: 'roads',
        AdminBounds: {options: {
            variant: 'adminb',
            maxZoom: 19
          }},
        Grayscale: {options: {
            variant: 'roadsg',
            maxZoom: 19
          }}
      }
    },
    Hydda: {
      url: 'http://{s}.tile.openstreetmap.se/hydda/{variant}/{z}/{x}/{y}.png',
      options: {
        variant: 'full',
        attribution: 'Tiles courtesy of <a href="http://openstreetmap.se/" target="_blank">OpenStreetMap Sweden</a> &mdash; Map data {attribution.OpenStreetMap}'
      },
      variants: {
        Full: 'full',
        Base: 'base',
        RoadsAndLabels: 'roads_and_labels'
      }
    },
    MapQuestOpen: {
      url: 'http://otile{s}.mqcdn.com/tiles/1.0.0/{type}/{z}/{x}/{y}.{ext}',
      options: {
        type: 'map',
        ext: 'jpg',
        attribution: 'Tiles Courtesy of <a href="http://www.mapquest.com/">MapQuest</a> &mdash; ' + 'Map data {attribution.OpenStreetMap}',
        subdomains: '1234'
      },
      variants: {
        OSM: {},
        Aerial: {options: {
            type: 'sat',
            attribution: 'Tiles Courtesy of <a href="http://www.mapquest.com/">MapQuest</a> &mdash; ' + 'Portions Courtesy NASA/JPL-Caltech and U.S. Depart. of Agriculture, Farm Service Agency'
          }},
        HybridOverlay: {options: {
            type: 'hyb',
            ext: 'png',
            opacity: 0.9
          }}
      }
    },
    MapBox: {
      url: '//api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}',
      options: {
        attribution: 'Imagery from <a href="http://mapbox.com/about/maps/">MapBox</a> &mdash; ' + 'Map data {attribution.OpenStreetMap}',
        subdomains: 'abcd'
      }
    },
    Stamen: {
      url: '//stamen-tiles-{s}.a.ssl.fastly.net/{variant}/{z}/{x}/{y}.{ext}',
      options: {
        attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, ' + '<a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; ' + 'Map data {attribution.OpenStreetMap}',
        subdomains: 'abcd',
        minZoom: 0,
        maxZoom: 20,
        variant: 'toner',
        ext: 'png'
      },
      variants: {
        Toner: 'toner',
        TonerBackground: 'toner-background',
        TonerHybrid: 'toner-hybrid',
        TonerLines: 'toner-lines',
        TonerLabels: 'toner-labels',
        TonerLite: 'toner-lite',
        Watercolor: {options: {
            variant: 'watercolor',
            minZoom: 1,
            maxZoom: 16
          }},
        Terrain: {options: {
            variant: 'terrain',
            minZoom: 4,
            maxZoom: 18,
            bounds: [[22, -132], [70, -56]]
          }},
        TerrainBackground: {options: {
            variant: 'terrain-background',
            minZoom: 4,
            maxZoom: 18,
            bounds: [[22, -132], [70, -56]]
          }},
        TopOSMRelief: {options: {
            variant: 'toposm-color-relief',
            ext: 'jpg',
            bounds: [[22, -132], [51, -56]]
          }},
        TopOSMFeatures: {options: {
            variant: 'toposm-features',
            bounds: [[22, -132], [51, -56]],
            opacity: 0.9
          }}
      }
    },
    Esri: {
      url: '//server.arcgisonline.com/ArcGIS/rest/services/{variant}/MapServer/tile/{z}/{y}/{x}',
      options: {
        variant: 'World_Street_Map',
        attribution: 'Tiles &copy; Esri'
      },
      variants: {
        WorldStreetMap: {options: {attribution: '{attribution.Esri} &mdash; ' + 'Source: Esri, DeLorme, NAVTEQ, USGS, Intermap, iPC, NRCAN, Esri Japan, METI, Esri China (Hong Kong), Esri (Thailand), TomTom, 2012'}},
        DeLorme: {options: {
            variant: 'Specialty/DeLorme_World_Base_Map',
            minZoom: 1,
            maxZoom: 11,
            attribution: '{attribution.Esri} &mdash; Copyright: &copy;2012 DeLorme'
          }},
        WorldTopoMap: {options: {
            variant: 'World_Topo_Map',
            attribution: '{attribution.Esri} &mdash; ' + 'Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community'
          }},
        WorldImagery: {options: {
            variant: 'World_Imagery',
            attribution: '{attribution.Esri} &mdash; ' + 'Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
          }},
        WorldTerrain: {options: {
            variant: 'World_Terrain_Base',
            maxZoom: 13,
            attribution: '{attribution.Esri} &mdash; ' + 'Source: USGS, Esri, TANA, DeLorme, and NPS'
          }},
        WorldShadedRelief: {options: {
            variant: 'World_Shaded_Relief',
            maxZoom: 13,
            attribution: '{attribution.Esri} &mdash; Source: Esri'
          }},
        WorldPhysical: {options: {
            variant: 'World_Physical_Map',
            maxZoom: 8,
            attribution: '{attribution.Esri} &mdash; Source: US National Park Service'
          }},
        OceanBasemap: {options: {
            variant: 'Ocean_Basemap',
            maxZoom: 13,
            attribution: '{attribution.Esri} &mdash; Sources: GEBCO, NOAA, CHS, OSU, UNH, CSUMB, National Geographic, DeLorme, NAVTEQ, and Esri'
          }},
        NatGeoWorldMap: {options: {
            variant: 'NatGeo_World_Map',
            maxZoom: 16,
            attribution: '{attribution.Esri} &mdash; National Geographic, Esri, DeLorme, NAVTEQ, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, iPC'
          }},
        WorldGrayCanvas: {options: {
            variant: 'Canvas/World_Light_Gray_Base',
            maxZoom: 16,
            attribution: '{attribution.Esri} &mdash; Esri, DeLorme, NAVTEQ'
          }}
      }
    },
    OpenWeatherMap: {
      url: 'http://{s}.tile.openweathermap.org/map/{variant}/{z}/{x}/{y}.png',
      options: {
        maxZoom: 19,
        attribution: 'Map data &copy; <a href="http://openweathermap.org">OpenWeatherMap</a>',
        opacity: 0.5
      },
      variants: {
        Clouds: 'clouds',
        CloudsClassic: 'clouds_cls',
        Precipitation: 'precipitation',
        PrecipitationClassic: 'precipitation_cls',
        Rain: 'rain',
        RainClassic: 'rain_cls',
        Pressure: 'pressure',
        PressureContour: 'pressure_cntr',
        Wind: 'wind',
        Temperature: 'temp',
        Snow: 'snow'
      }
    },
    HERE: {
      url: '//{s}.{base}.maps.cit.api.here.com/maptile/2.1/' + '{type}/{mapID}/{variant}/{z}/{x}/{y}/{size}/{format}?' + 'app_id={app_id}&app_code={app_code}&lg={language}',
      options: {
        attribution: 'Map &copy; 1987-2014 <a href="http://developer.here.com">HERE</a>',
        subdomains: '1234',
        mapID: 'newest',
        'app_id': '<insert your app_id here>',
        'app_code': '<insert your app_code here>',
        base: 'base',
        variant: 'normal.day',
        maxZoom: 20,
        type: 'maptile',
        language: 'eng',
        format: 'png8',
        size: '256'
      },
      variants: {
        normalDay: 'normal.day',
        normalDayCustom: 'normal.day.custom',
        normalDayGrey: 'normal.day.grey',
        normalDayMobile: 'normal.day.mobile',
        normalDayGreyMobile: 'normal.day.grey.mobile',
        normalDayTransit: 'normal.day.transit',
        normalDayTransitMobile: 'normal.day.transit.mobile',
        normalNight: 'normal.night',
        normalNightMobile: 'normal.night.mobile',
        normalNightGrey: 'normal.night.grey',
        normalNightGreyMobile: 'normal.night.grey.mobile',
        basicMap: {options: {type: 'basetile'}},
        mapLabels: {options: {
            type: 'labeltile',
            format: 'png'
          }},
        trafficFlow: {options: {
            base: 'traffic',
            type: 'flowtile'
          }},
        carnavDayGrey: 'carnav.day.grey',
        hybridDay: {options: {
            base: 'aerial',
            variant: 'hybrid.day'
          }},
        hybridDayMobile: {options: {
            base: 'aerial',
            variant: 'hybrid.day.mobile'
          }},
        pedestrianDay: 'pedestrian.day',
        pedestrianNight: 'pedestrian.night',
        satelliteDay: {options: {
            base: 'aerial',
            variant: 'satellite.day'
          }},
        terrainDay: {options: {
            base: 'aerial',
            variant: 'terrain.day'
          }},
        terrainDayMobile: {options: {
            base: 'aerial',
            variant: 'terrain.day.mobile'
          }}
      }
    },
    FreeMapSK: {
      url: 'http://t{s}.freemap.sk/T/{z}/{x}/{y}.jpeg',
      options: {
        minZoom: 8,
        maxZoom: 16,
        subdomains: '1234',
        bounds: [[47.204642, 15.996093], [49.830896, 22.576904]],
        attribution: '{attribution.OpenStreetMap}, vizualization CC-By-SA 2.0 <a href="http://freemap.sk">Freemap.sk</a>'
      }
    },
    MtbMap: {
      url: 'http://tile.mtbmap.cz/mtbmap_tiles/{z}/{x}/{y}.png',
      options: {attribution: '{attribution.OpenStreetMap} &amp; USGS'}
    },
    CartoDB: {
      url: 'http://{s}.basemaps.cartocdn.com/{variant}/{z}/{x}/{y}.png',
      options: {
        attribution: '{attribution.OpenStreetMap} &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
        subdomains: 'abcd',
        maxZoom: 19,
        variant: 'light_all'
      },
      variants: {
        Positron: 'light_all',
        PositronNoLabels: 'light_nolabels',
        PositronOnlyLabels: 'light_only_labels',
        DarkMatter: 'dark_all',
        DarkMatterNoLabels: 'dark_nolabels',
        DarkMatterOnlyLabels: 'dark_only_labels'
      }
    },
    HikeBike: {
      url: 'http://{s}.tiles.wmflabs.org/{variant}/{z}/{x}/{y}.png',
      options: {
        maxZoom: 19,
        attribution: '{attribution.OpenStreetMap}',
        variant: 'hikebike'
      },
      variants: {
        HikeBike: {},
        HillShading: {options: {
            maxZoom: 15,
            variant: 'hillshading'
          }}
      }
    },
    BasemapAT: {
      url: '//maps{s}.wien.gv.at/basemap/{variant}/normal/google3857/{z}/{y}/{x}.{format}',
      options: {
        maxZoom: 19,
        attribution: 'Datenquelle: <a href="www.basemap.at">basemap.at</a>',
        subdomains: ['', '1', '2', '3', '4'],
        format: 'png',
        bounds: [[46.358770, 8.782379], [49.037872, 17.189532]],
        variant: 'geolandbasemap'
      },
      variants: {
        basemap: 'geolandbasemap',
        grau: 'bmapgrau',
        overlay: 'bmapoverlay',
        highdpi: {options: {
            variant: 'bmaphidpi',
            format: 'jpeg'
          }},
        orthofoto: {options: {
            variant: 'bmaporthofoto30cm',
            format: 'jpeg'
          }}
      }
    },
    NASAGIBS: {
      url: '//map1.vis.earthdata.nasa.gov/wmts-webmerc/{variant}/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}',
      options: {
        attribution: 'Imagery provided by services from the Global Imagery Browse Services (GIBS), operated by the NASA/GSFC/Earth Science Data and Information System ' + '(<a href="https://earthdata.nasa.gov">ESDIS</a>) with funding provided by NASA/HQ.',
        bounds: [[-85.0511287776, -179.999999975], [85.0511287776, 179.999999975]],
        minZoom: 1,
        maxZoom: 9,
        format: 'jpg',
        time: '',
        tilematrixset: 'GoogleMapsCompatible_Level'
      },
      variants: {
        ModisTerraTrueColorCR: 'MODIS_Terra_CorrectedReflectance_TrueColor',
        ModisTerraBands367CR: 'MODIS_Terra_CorrectedReflectance_Bands367',
        ViirsEarthAtNight2012: {options: {
            variant: 'VIIRS_CityLights_2012',
            maxZoom: 8
          }},
        ModisTerraLSTDay: {options: {
            variant: 'MODIS_Terra_Land_Surface_Temp_Day',
            format: 'png',
            maxZoom: 7,
            opacity: 0.75
          }},
        ModisTerraSnowCover: {options: {
            variant: 'MODIS_Terra_Snow_Cover',
            format: 'png',
            maxZoom: 8,
            opacity: 0.75
          }},
        ModisTerraAOD: {options: {
            variant: 'MODIS_Terra_Aerosol',
            format: 'png',
            maxZoom: 6,
            opacity: 0.75
          }},
        ModisTerraChlorophyll: {options: {
            variant: 'MODIS_Terra_Chlorophyll_A',
            format: 'png',
            maxZoom: 7,
            opacity: 0.75
          }}
      }
    },
    NLS: {
      url: '//nls-{s}.tileserver.com/nls/{z}/{x}/{y}.jpg',
      options: {
        attribution: '<a href="http://geo.nls.uk/maps/">National Library of Scotland Historic Maps</a>',
        bounds: [[49.6, -12], [61.7, 3]],
        minZoom: 1,
        maxZoom: 18,
        subdomains: '0123'
      }
    }
  };
  L.tileLayer.provider = function(provider, options) {
    return new L.TileLayer.Provider(provider, options);
  };
  return L;
}));

_removeDefine();
})();
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("b1", ["b0"], function(main) {
  return main;
});

_removeDefine();
})();
$__System.register("b2", [], function() { return { setters: [], execute: function() {} } });

(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
(function(window, document, undefined) {
  var oldL = window.L,
      L = {};
  L.version = '0.7.7';
  if (typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = L;
  } else if (typeof define === 'function' && define.amd) {
    define("b3", [], L);
  }
  L.noConflict = function() {
    window.L = oldL;
    return this;
  };
  window.L = L;
  L.Util = {
    extend: function(dest) {
      var sources = Array.prototype.slice.call(arguments, 1),
          i,
          j,
          len,
          src;
      for (j = 0, len = sources.length; j < len; j++) {
        src = sources[j] || {};
        for (i in src) {
          if (src.hasOwnProperty(i)) {
            dest[i] = src[i];
          }
        }
      }
      return dest;
    },
    bind: function(fn, obj) {
      var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
      return function() {
        return fn.apply(obj, args || arguments);
      };
    },
    stamp: (function() {
      var lastId = 0,
          key = '_leaflet_id';
      return function(obj) {
        obj[key] = obj[key] || ++lastId;
        return obj[key];
      };
    }()),
    invokeEach: function(obj, method, context) {
      var i,
          args;
      if (typeof obj === 'object') {
        args = Array.prototype.slice.call(arguments, 3);
        for (i in obj) {
          method.apply(context, [i, obj[i]].concat(args));
        }
        return true;
      }
      return false;
    },
    limitExecByInterval: function(fn, time, context) {
      var lock,
          execOnUnlock;
      return function wrapperFn() {
        var args = arguments;
        if (lock) {
          execOnUnlock = true;
          return;
        }
        lock = true;
        setTimeout(function() {
          lock = false;
          if (execOnUnlock) {
            wrapperFn.apply(context, args);
            execOnUnlock = false;
          }
        }, time);
        fn.apply(context, args);
      };
    },
    falseFn: function() {
      return false;
    },
    formatNum: function(num, digits) {
      var pow = Math.pow(10, digits || 5);
      return Math.round(num * pow) / pow;
    },
    trim: function(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
    },
    splitWords: function(str) {
      return L.Util.trim(str).split(/\s+/);
    },
    setOptions: function(obj, options) {
      obj.options = L.extend({}, obj.options, options);
      return obj.options;
    },
    getParamString: function(obj, existingUrl, uppercase) {
      var params = [];
      for (var i in obj) {
        params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
      }
      return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
    },
    template: function(str, data) {
      return str.replace(/\{ *([\w_]+) *\}/g, function(str, key) {
        var value = data[key];
        if (value === undefined) {
          throw new Error('No value provided for variable ' + str);
        } else if (typeof value === 'function') {
          value = value(data);
        }
        return value;
      });
    },
    isArray: Array.isArray || function(obj) {
      return (Object.prototype.toString.call(obj) === '[object Array]');
    },
    emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
  };
  (function() {
    function getPrefixed(name) {
      var i,
          fn,
          prefixes = ['webkit', 'moz', 'o', 'ms'];
      for (i = 0; i < prefixes.length && !fn; i++) {
        fn = window[prefixes[i] + name];
      }
      return fn;
    }
    var lastTime = 0;
    function timeoutDefer(fn) {
      var time = +new Date(),
          timeToCall = Math.max(0, 16 - (time - lastTime));
      lastTime = time + timeToCall;
      return window.setTimeout(fn, timeToCall);
    }
    var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
    var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function(id) {
      window.clearTimeout(id);
    };
    L.Util.requestAnimFrame = function(fn, context, immediate, element) {
      fn = L.bind(fn, context);
      if (immediate && requestFn === timeoutDefer) {
        fn();
      } else {
        return requestFn.call(window, fn, element);
      }
    };
    L.Util.cancelAnimFrame = function(id) {
      if (id) {
        cancelFn.call(window, id);
      }
    };
  }());
  L.extend = L.Util.extend;
  L.bind = L.Util.bind;
  L.stamp = L.Util.stamp;
  L.setOptions = L.Util.setOptions;
  L.Class = function() {};
  L.Class.extend = function(props) {
    var NewClass = function() {
      if (this.initialize) {
        this.initialize.apply(this, arguments);
      }
      if (this._initHooks) {
        this.callInitHooks();
      }
    };
    var F = function() {};
    F.prototype = this.prototype;
    var proto = new F();
    proto.constructor = NewClass;
    NewClass.prototype = proto;
    for (var i in this) {
      if (this.hasOwnProperty(i) && i !== 'prototype') {
        NewClass[i] = this[i];
      }
    }
    if (props.statics) {
      L.extend(NewClass, props.statics);
      delete props.statics;
    }
    if (props.includes) {
      L.Util.extend.apply(null, [proto].concat(props.includes));
      delete props.includes;
    }
    if (props.options && proto.options) {
      props.options = L.extend({}, proto.options, props.options);
    }
    L.extend(proto, props);
    proto._initHooks = [];
    var parent = this;
    NewClass.__super__ = parent.prototype;
    proto.callInitHooks = function() {
      if (this._initHooksCalled) {
        return;
      }
      if (parent.prototype.callInitHooks) {
        parent.prototype.callInitHooks.call(this);
      }
      this._initHooksCalled = true;
      for (var i = 0,
          len = proto._initHooks.length; i < len; i++) {
        proto._initHooks[i].call(this);
      }
    };
    return NewClass;
  };
  L.Class.include = function(props) {
    L.extend(this.prototype, props);
  };
  L.Class.mergeOptions = function(options) {
    L.extend(this.prototype.options, options);
  };
  L.Class.addInitHook = function(fn) {
    var args = Array.prototype.slice.call(arguments, 1);
    var init = typeof fn === 'function' ? fn : function() {
      this[fn].apply(this, args);
    };
    this.prototype._initHooks = this.prototype._initHooks || [];
    this.prototype._initHooks.push(init);
  };
  var eventsKey = '_leaflet_events';
  L.Mixin = {};
  L.Mixin.Events = {
    addEventListener: function(types, fn, context) {
      if (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) {
        return this;
      }
      var events = this[eventsKey] = this[eventsKey] || {},
          contextId = context && context !== this && L.stamp(context),
          i,
          len,
          event,
          type,
          indexKey,
          indexLenKey,
          typeIndex;
      types = L.Util.splitWords(types);
      for (i = 0, len = types.length; i < len; i++) {
        event = {
          action: fn,
          context: context || this
        };
        type = types[i];
        if (contextId) {
          indexKey = type + '_idx';
          indexLenKey = indexKey + '_len';
          typeIndex = events[indexKey] = events[indexKey] || {};
          if (!typeIndex[contextId]) {
            typeIndex[contextId] = [];
            events[indexLenKey] = (events[indexLenKey] || 0) + 1;
          }
          typeIndex[contextId].push(event);
        } else {
          events[type] = events[type] || [];
          events[type].push(event);
        }
      }
      return this;
    },
    hasEventListeners: function(type) {
      var events = this[eventsKey];
      return !!events && ((type in events && events[type].length > 0) || (type + '_idx' in events && events[type + '_idx_len'] > 0));
    },
    removeEventListener: function(types, fn, context) {
      if (!this[eventsKey]) {
        return this;
      }
      if (!types) {
        return this.clearAllEventListeners();
      }
      if (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) {
        return this;
      }
      var events = this[eventsKey],
          contextId = context && context !== this && L.stamp(context),
          i,
          len,
          type,
          listeners,
          j,
          indexKey,
          indexLenKey,
          typeIndex,
          removed;
      types = L.Util.splitWords(types);
      for (i = 0, len = types.length; i < len; i++) {
        type = types[i];
        indexKey = type + '_idx';
        indexLenKey = indexKey + '_len';
        typeIndex = events[indexKey];
        if (!fn) {
          delete events[type];
          delete events[indexKey];
          delete events[indexLenKey];
        } else {
          listeners = contextId && typeIndex ? typeIndex[contextId] : events[type];
          if (listeners) {
            for (j = listeners.length - 1; j >= 0; j--) {
              if ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {
                removed = listeners.splice(j, 1);
                removed[0].action = L.Util.falseFn;
              }
            }
            if (context && typeIndex && (listeners.length === 0)) {
              delete typeIndex[contextId];
              events[indexLenKey]--;
            }
          }
        }
      }
      return this;
    },
    clearAllEventListeners: function() {
      delete this[eventsKey];
      return this;
    },
    fireEvent: function(type, data) {
      if (!this.hasEventListeners(type)) {
        return this;
      }
      var event = L.Util.extend({}, data, {
        type: type,
        target: this
      });
      var events = this[eventsKey],
          listeners,
          i,
          len,
          typeIndex,
          contextId;
      if (events[type]) {
        listeners = events[type].slice();
        for (i = 0, len = listeners.length; i < len; i++) {
          listeners[i].action.call(listeners[i].context, event);
        }
      }
      typeIndex = events[type + '_idx'];
      for (contextId in typeIndex) {
        listeners = typeIndex[contextId].slice();
        if (listeners) {
          for (i = 0, len = listeners.length; i < len; i++) {
            listeners[i].action.call(listeners[i].context, event);
          }
        }
      }
      return this;
    },
    addOneTimeEventListener: function(types, fn, context) {
      if (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) {
        return this;
      }
      var handler = L.bind(function() {
        this.removeEventListener(types, fn, context).removeEventListener(types, handler, context);
      }, this);
      return this.addEventListener(types, fn, context).addEventListener(types, handler, context);
    }
  };
  L.Mixin.Events.on = L.Mixin.Events.addEventListener;
  L.Mixin.Events.off = L.Mixin.Events.removeEventListener;
  L.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;
  L.Mixin.Events.fire = L.Mixin.Events.fireEvent;
  (function() {
    var ie = 'ActiveXObject' in window,
        ielt9 = ie && !document.addEventListener,
        ua = navigator.userAgent.toLowerCase(),
        webkit = ua.indexOf('webkit') !== -1,
        chrome = ua.indexOf('chrome') !== -1,
        phantomjs = ua.indexOf('phantom') !== -1,
        android = ua.indexOf('android') !== -1,
        android23 = ua.search('android [23]') !== -1,
        gecko = ua.indexOf('gecko') !== -1,
        mobile = typeof orientation !== undefined + '',
        msPointer = !window.PointerEvent && window.MSPointerEvent,
        pointer = (window.PointerEvent && window.navigator.pointerEnabled) || msPointer,
        retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) || ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') && window.matchMedia('(min-resolution:144dpi)').matches),
        doc = document.documentElement,
        ie3d = ie && ('transition' in doc.style),
        webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
        gecko3d = 'MozPerspective' in doc.style,
        opera3d = 'OTransition' in doc.style,
        any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;
    var touch = !window.L_NO_TOUCH && !phantomjs && (pointer || 'ontouchstart' in window || (window.DocumentTouch && document instanceof window.DocumentTouch));
    L.Browser = {
      ie: ie,
      ielt9: ielt9,
      webkit: webkit,
      gecko: gecko && !webkit && !window.opera && !ie,
      android: android,
      android23: android23,
      chrome: chrome,
      ie3d: ie3d,
      webkit3d: webkit3d,
      gecko3d: gecko3d,
      opera3d: opera3d,
      any3d: any3d,
      mobile: mobile,
      mobileWebkit: mobile && webkit,
      mobileWebkit3d: mobile && webkit3d,
      mobileOpera: mobile && window.opera,
      touch: touch,
      msPointer: msPointer,
      pointer: pointer,
      retina: retina
    };
  }());
  L.Point = function(x, y, round) {
    this.x = (round ? Math.round(x) : x);
    this.y = (round ? Math.round(y) : y);
  };
  L.Point.prototype = {
    clone: function() {
      return new L.Point(this.x, this.y);
    },
    add: function(point) {
      return this.clone()._add(L.point(point));
    },
    _add: function(point) {
      this.x += point.x;
      this.y += point.y;
      return this;
    },
    subtract: function(point) {
      return this.clone()._subtract(L.point(point));
    },
    _subtract: function(point) {
      this.x -= point.x;
      this.y -= point.y;
      return this;
    },
    divideBy: function(num) {
      return this.clone()._divideBy(num);
    },
    _divideBy: function(num) {
      this.x /= num;
      this.y /= num;
      return this;
    },
    multiplyBy: function(num) {
      return this.clone()._multiplyBy(num);
    },
    _multiplyBy: function(num) {
      this.x *= num;
      this.y *= num;
      return this;
    },
    round: function() {
      return this.clone()._round();
    },
    _round: function() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    },
    floor: function() {
      return this.clone()._floor();
    },
    _floor: function() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    },
    distanceTo: function(point) {
      point = L.point(point);
      var x = point.x - this.x,
          y = point.y - this.y;
      return Math.sqrt(x * x + y * y);
    },
    equals: function(point) {
      point = L.point(point);
      return point.x === this.x && point.y === this.y;
    },
    contains: function(point) {
      point = L.point(point);
      return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
    },
    toString: function() {
      return 'Point(' + L.Util.formatNum(this.x) + ', ' + L.Util.formatNum(this.y) + ')';
    }
  };
  L.point = function(x, y, round) {
    if (x instanceof L.Point) {
      return x;
    }
    if (L.Util.isArray(x)) {
      return new L.Point(x[0], x[1]);
    }
    if (x === undefined || x === null) {
      return x;
    }
    return new L.Point(x, y, round);
  };
  L.Bounds = function(a, b) {
    if (!a) {
      return;
    }
    var points = b ? [a, b] : a;
    for (var i = 0,
        len = points.length; i < len; i++) {
      this.extend(points[i]);
    }
  };
  L.Bounds.prototype = {
    extend: function(point) {
      point = L.point(point);
      if (!this.min && !this.max) {
        this.min = point.clone();
        this.max = point.clone();
      } else {
        this.min.x = Math.min(point.x, this.min.x);
        this.max.x = Math.max(point.x, this.max.x);
        this.min.y = Math.min(point.y, this.min.y);
        this.max.y = Math.max(point.y, this.max.y);
      }
      return this;
    },
    getCenter: function(round) {
      return new L.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
    },
    getBottomLeft: function() {
      return new L.Point(this.min.x, this.max.y);
    },
    getTopRight: function() {
      return new L.Point(this.max.x, this.min.y);
    },
    getSize: function() {
      return this.max.subtract(this.min);
    },
    contains: function(obj) {
      var min,
          max;
      if (typeof obj[0] === 'number' || obj instanceof L.Point) {
        obj = L.point(obj);
      } else {
        obj = L.bounds(obj);
      }
      if (obj instanceof L.Bounds) {
        min = obj.min;
        max = obj.max;
      } else {
        min = max = obj;
      }
      return (min.x >= this.min.x) && (max.x <= this.max.x) && (min.y >= this.min.y) && (max.y <= this.max.y);
    },
    intersects: function(bounds) {
      bounds = L.bounds(bounds);
      var min = this.min,
          max = this.max,
          min2 = bounds.min,
          max2 = bounds.max,
          xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
          yIntersects = (max2.y >= min.y) && (min2.y <= max.y);
      return xIntersects && yIntersects;
    },
    isValid: function() {
      return !!(this.min && this.max);
    }
  };
  L.bounds = function(a, b) {
    if (!a || a instanceof L.Bounds) {
      return a;
    }
    return new L.Bounds(a, b);
  };
  L.Transformation = function(a, b, c, d) {
    this._a = a;
    this._b = b;
    this._c = c;
    this._d = d;
  };
  L.Transformation.prototype = {
    transform: function(point, scale) {
      return this._transform(point.clone(), scale);
    },
    _transform: function(point, scale) {
      scale = scale || 1;
      point.x = scale * (this._a * point.x + this._b);
      point.y = scale * (this._c * point.y + this._d);
      return point;
    },
    untransform: function(point, scale) {
      scale = scale || 1;
      return new L.Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);
    }
  };
  L.DomUtil = {
    get: function(id) {
      return (typeof id === 'string' ? document.getElementById(id) : id);
    },
    getStyle: function(el, style) {
      var value = el.style[style];
      if (!value && el.currentStyle) {
        value = el.currentStyle[style];
      }
      if ((!value || value === 'auto') && document.defaultView) {
        var css = document.defaultView.getComputedStyle(el, null);
        value = css ? css[style] : null;
      }
      return value === 'auto' ? null : value;
    },
    getViewportOffset: function(element) {
      var top = 0,
          left = 0,
          el = element,
          docBody = document.body,
          docEl = document.documentElement,
          pos;
      do {
        top += el.offsetTop || 0;
        left += el.offsetLeft || 0;
        top += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;
        left += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;
        pos = L.DomUtil.getStyle(el, 'position');
        if (el.offsetParent === docBody && pos === 'absolute') {
          break;
        }
        if (pos === 'fixed') {
          top += docBody.scrollTop || docEl.scrollTop || 0;
          left += docBody.scrollLeft || docEl.scrollLeft || 0;
          break;
        }
        if (pos === 'relative' && !el.offsetLeft) {
          var width = L.DomUtil.getStyle(el, 'width'),
              maxWidth = L.DomUtil.getStyle(el, 'max-width'),
              r = el.getBoundingClientRect();
          if (width !== 'none' || maxWidth !== 'none') {
            left += r.left + el.clientLeft;
          }
          top += r.top + (docBody.scrollTop || docEl.scrollTop || 0);
          break;
        }
        el = el.offsetParent;
      } while (el);
      el = element;
      do {
        if (el === docBody) {
          break;
        }
        top -= el.scrollTop || 0;
        left -= el.scrollLeft || 0;
        el = el.parentNode;
      } while (el);
      return new L.Point(left, top);
    },
    documentIsLtr: function() {
      if (!L.DomUtil._docIsLtrCached) {
        L.DomUtil._docIsLtrCached = true;
        L.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';
      }
      return L.DomUtil._docIsLtr;
    },
    create: function(tagName, className, container) {
      var el = document.createElement(tagName);
      el.className = className;
      if (container) {
        container.appendChild(el);
      }
      return el;
    },
    hasClass: function(el, name) {
      if (el.classList !== undefined) {
        return el.classList.contains(name);
      }
      var className = L.DomUtil._getClass(el);
      return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
    },
    addClass: function(el, name) {
      if (el.classList !== undefined) {
        var classes = L.Util.splitWords(name);
        for (var i = 0,
            len = classes.length; i < len; i++) {
          el.classList.add(classes[i]);
        }
      } else if (!L.DomUtil.hasClass(el, name)) {
        var className = L.DomUtil._getClass(el);
        L.DomUtil._setClass(el, (className ? className + ' ' : '') + name);
      }
    },
    removeClass: function(el, name) {
      if (el.classList !== undefined) {
        el.classList.remove(name);
      } else {
        L.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
      }
    },
    _setClass: function(el, name) {
      if (el.className.baseVal === undefined) {
        el.className = name;
      } else {
        el.className.baseVal = name;
      }
    },
    _getClass: function(el) {
      return el.className.baseVal === undefined ? el.className : el.className.baseVal;
    },
    setOpacity: function(el, value) {
      if ('opacity' in el.style) {
        el.style.opacity = value;
      } else if ('filter' in el.style) {
        var filter = false,
            filterName = 'DXImageTransform.Microsoft.Alpha';
        try {
          filter = el.filters.item(filterName);
        } catch (e) {
          if (value === 1) {
            return;
          }
        }
        value = Math.round(value * 100);
        if (filter) {
          filter.Enabled = (value !== 100);
          filter.Opacity = value;
        } else {
          el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
        }
      }
    },
    testProp: function(props) {
      var style = document.documentElement.style;
      for (var i = 0; i < props.length; i++) {
        if (props[i] in style) {
          return props[i];
        }
      }
      return false;
    },
    getTranslateString: function(point) {
      var is3d = L.Browser.webkit3d,
          open = 'translate' + (is3d ? '3d' : '') + '(',
          close = (is3d ? ',0' : '') + ')';
      return open + point.x + 'px,' + point.y + 'px' + close;
    },
    getScaleString: function(scale, origin) {
      var preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),
          scaleStr = ' scale(' + scale + ') ';
      return preTranslateStr + scaleStr;
    },
    setPosition: function(el, point, disable3D) {
      el._leaflet_pos = point;
      if (!disable3D && L.Browser.any3d) {
        el.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(point);
      } else {
        el.style.left = point.x + 'px';
        el.style.top = point.y + 'px';
      }
    },
    getPosition: function(el) {
      return el._leaflet_pos;
    }
  };
  L.DomUtil.TRANSFORM = L.DomUtil.testProp(['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);
  L.DomUtil.TRANSITION = L.DomUtil.testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);
  L.DomUtil.TRANSITION_END = L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ? L.DomUtil.TRANSITION + 'End' : 'transitionend';
  (function() {
    if ('onselectstart' in document) {
      L.extend(L.DomUtil, {
        disableTextSelection: function() {
          L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
        },
        enableTextSelection: function() {
          L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
        }
      });
    } else {
      var userSelectProperty = L.DomUtil.testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);
      L.extend(L.DomUtil, {
        disableTextSelection: function() {
          if (userSelectProperty) {
            var style = document.documentElement.style;
            this._userSelect = style[userSelectProperty];
            style[userSelectProperty] = 'none';
          }
        },
        enableTextSelection: function() {
          if (userSelectProperty) {
            document.documentElement.style[userSelectProperty] = this._userSelect;
            delete this._userSelect;
          }
        }
      });
    }
    L.extend(L.DomUtil, {
      disableImageDrag: function() {
        L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
      },
      enableImageDrag: function() {
        L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
      }
    });
  })();
  L.LatLng = function(lat, lng, alt) {
    lat = parseFloat(lat);
    lng = parseFloat(lng);
    if (isNaN(lat) || isNaN(lng)) {
      throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
    }
    this.lat = lat;
    this.lng = lng;
    if (alt !== undefined) {
      this.alt = parseFloat(alt);
    }
  };
  L.extend(L.LatLng, {
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,
    MAX_MARGIN: 1.0E-9
  });
  L.LatLng.prototype = {
    equals: function(obj) {
      if (!obj) {
        return false;
      }
      obj = L.latLng(obj);
      var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));
      return margin <= L.LatLng.MAX_MARGIN;
    },
    toString: function(precision) {
      return 'LatLng(' + L.Util.formatNum(this.lat, precision) + ', ' + L.Util.formatNum(this.lng, precision) + ')';
    },
    distanceTo: function(other) {
      other = L.latLng(other);
      var R = 6378137,
          d2r = L.LatLng.DEG_TO_RAD,
          dLat = (other.lat - this.lat) * d2r,
          dLon = (other.lng - this.lng) * d2r,
          lat1 = this.lat * d2r,
          lat2 = other.lat * d2r,
          sin1 = Math.sin(dLat / 2),
          sin2 = Math.sin(dLon / 2);
      var a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    },
    wrap: function(a, b) {
      var lng = this.lng;
      a = a || -180;
      b = b || 180;
      lng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);
      return new L.LatLng(this.lat, lng);
    }
  };
  L.latLng = function(a, b) {
    if (a instanceof L.LatLng) {
      return a;
    }
    if (L.Util.isArray(a)) {
      if (typeof a[0] === 'number' || typeof a[0] === 'string') {
        return new L.LatLng(a[0], a[1], a[2]);
      } else {
        return null;
      }
    }
    if (a === undefined || a === null) {
      return a;
    }
    if (typeof a === 'object' && 'lat' in a) {
      return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);
    }
    if (b === undefined) {
      return null;
    }
    return new L.LatLng(a, b);
  };
  L.LatLngBounds = function(southWest, northEast) {
    if (!southWest) {
      return;
    }
    var latlngs = northEast ? [southWest, northEast] : southWest;
    for (var i = 0,
        len = latlngs.length; i < len; i++) {
      this.extend(latlngs[i]);
    }
  };
  L.LatLngBounds.prototype = {
    extend: function(obj) {
      if (!obj) {
        return this;
      }
      var latLng = L.latLng(obj);
      if (latLng !== null) {
        obj = latLng;
      } else {
        obj = L.latLngBounds(obj);
      }
      if (obj instanceof L.LatLng) {
        if (!this._southWest && !this._northEast) {
          this._southWest = new L.LatLng(obj.lat, obj.lng);
          this._northEast = new L.LatLng(obj.lat, obj.lng);
        } else {
          this._southWest.lat = Math.min(obj.lat, this._southWest.lat);
          this._southWest.lng = Math.min(obj.lng, this._southWest.lng);
          this._northEast.lat = Math.max(obj.lat, this._northEast.lat);
          this._northEast.lng = Math.max(obj.lng, this._northEast.lng);
        }
      } else if (obj instanceof L.LatLngBounds) {
        this.extend(obj._southWest);
        this.extend(obj._northEast);
      }
      return this;
    },
    pad: function(bufferRatio) {
      var sw = this._southWest,
          ne = this._northEast,
          heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
          widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
      return new L.LatLngBounds(new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
    },
    getCenter: function() {
      return new L.LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
    },
    getSouthWest: function() {
      return this._southWest;
    },
    getNorthEast: function() {
      return this._northEast;
    },
    getNorthWest: function() {
      return new L.LatLng(this.getNorth(), this.getWest());
    },
    getSouthEast: function() {
      return new L.LatLng(this.getSouth(), this.getEast());
    },
    getWest: function() {
      return this._southWest.lng;
    },
    getSouth: function() {
      return this._southWest.lat;
    },
    getEast: function() {
      return this._northEast.lng;
    },
    getNorth: function() {
      return this._northEast.lat;
    },
    contains: function(obj) {
      if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {
        obj = L.latLng(obj);
      } else {
        obj = L.latLngBounds(obj);
      }
      var sw = this._southWest,
          ne = this._northEast,
          sw2,
          ne2;
      if (obj instanceof L.LatLngBounds) {
        sw2 = obj.getSouthWest();
        ne2 = obj.getNorthEast();
      } else {
        sw2 = ne2 = obj;
      }
      return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) && (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
    },
    intersects: function(bounds) {
      bounds = L.latLngBounds(bounds);
      var sw = this._southWest,
          ne = this._northEast,
          sw2 = bounds.getSouthWest(),
          ne2 = bounds.getNorthEast(),
          latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
          lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);
      return latIntersects && lngIntersects;
    },
    toBBoxString: function() {
      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
    },
    equals: function(bounds) {
      if (!bounds) {
        return false;
      }
      bounds = L.latLngBounds(bounds);
      return this._southWest.equals(bounds.getSouthWest()) && this._northEast.equals(bounds.getNorthEast());
    },
    isValid: function() {
      return !!(this._southWest && this._northEast);
    }
  };
  L.latLngBounds = function(a, b) {
    if (!a || a instanceof L.LatLngBounds) {
      return a;
    }
    return new L.LatLngBounds(a, b);
  };
  L.Projection = {};
  L.Projection.SphericalMercator = {
    MAX_LATITUDE: 85.0511287798,
    project: function(latlng) {
      var d = L.LatLng.DEG_TO_RAD,
          max = this.MAX_LATITUDE,
          lat = Math.max(Math.min(max, latlng.lat), -max),
          x = latlng.lng * d,
          y = lat * d;
      y = Math.log(Math.tan((Math.PI / 4) + (y / 2)));
      return new L.Point(x, y);
    },
    unproject: function(point) {
      var d = L.LatLng.RAD_TO_DEG,
          lng = point.x * d,
          lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;
      return new L.LatLng(lat, lng);
    }
  };
  L.Projection.LonLat = {
    project: function(latlng) {
      return new L.Point(latlng.lng, latlng.lat);
    },
    unproject: function(point) {
      return new L.LatLng(point.y, point.x);
    }
  };
  L.CRS = {
    latLngToPoint: function(latlng, zoom) {
      var projectedPoint = this.projection.project(latlng),
          scale = this.scale(zoom);
      return this.transformation._transform(projectedPoint, scale);
    },
    pointToLatLng: function(point, zoom) {
      var scale = this.scale(zoom),
          untransformedPoint = this.transformation.untransform(point, scale);
      return this.projection.unproject(untransformedPoint);
    },
    project: function(latlng) {
      return this.projection.project(latlng);
    },
    scale: function(zoom) {
      return 256 * Math.pow(2, zoom);
    },
    getSize: function(zoom) {
      var s = this.scale(zoom);
      return L.point(s, s);
    }
  };
  L.CRS.Simple = L.extend({}, L.CRS, {
    projection: L.Projection.LonLat,
    transformation: new L.Transformation(1, 0, -1, 0),
    scale: function(zoom) {
      return Math.pow(2, zoom);
    }
  });
  L.CRS.EPSG3857 = L.extend({}, L.CRS, {
    code: 'EPSG:3857',
    projection: L.Projection.SphericalMercator,
    transformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),
    project: function(latlng) {
      var projectedPoint = this.projection.project(latlng),
          earthRadius = 6378137;
      return projectedPoint.multiplyBy(earthRadius);
    }
  });
  L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {code: 'EPSG:900913'});
  L.CRS.EPSG4326 = L.extend({}, L.CRS, {
    code: 'EPSG:4326',
    projection: L.Projection.LonLat,
    transformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)
  });
  L.Map = L.Class.extend({
    includes: L.Mixin.Events,
    options: {
      crs: L.CRS.EPSG3857,
      fadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,
      trackResize: true,
      markerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d
    },
    initialize: function(id, options) {
      options = L.setOptions(this, options);
      this._initContainer(id);
      this._initLayout();
      this._onResize = L.bind(this._onResize, this);
      this._initEvents();
      if (options.maxBounds) {
        this.setMaxBounds(options.maxBounds);
      }
      if (options.center && options.zoom !== undefined) {
        this.setView(L.latLng(options.center), options.zoom, {reset: true});
      }
      this._handlers = [];
      this._layers = {};
      this._zoomBoundLayers = {};
      this._tileLayersNum = 0;
      this.callInitHooks();
      this._addLayers(options.layers);
    },
    setView: function(center, zoom) {
      zoom = zoom === undefined ? this.getZoom() : zoom;
      this._resetView(L.latLng(center), this._limitZoom(zoom));
      return this;
    },
    setZoom: function(zoom, options) {
      if (!this._loaded) {
        this._zoom = this._limitZoom(zoom);
        return this;
      }
      return this.setView(this.getCenter(), zoom, {zoom: options});
    },
    zoomIn: function(delta, options) {
      return this.setZoom(this._zoom + (delta || 1), options);
    },
    zoomOut: function(delta, options) {
      return this.setZoom(this._zoom - (delta || 1), options);
    },
    setZoomAround: function(latlng, zoom, options) {
      var scale = this.getZoomScale(zoom),
          viewHalf = this.getSize().divideBy(2),
          containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),
          centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
          newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
      return this.setView(newCenter, zoom, {zoom: options});
    },
    fitBounds: function(bounds, options) {
      options = options || {};
      bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);
      var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
          paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),
          zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
      zoom = (options.maxZoom) ? Math.min(options.maxZoom, zoom) : zoom;
      var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),
          swPoint = this.project(bounds.getSouthWest(), zoom),
          nePoint = this.project(bounds.getNorthEast(), zoom),
          center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);
      return this.setView(center, zoom, options);
    },
    fitWorld: function(options) {
      return this.fitBounds([[-90, -180], [90, 180]], options);
    },
    panTo: function(center, options) {
      return this.setView(center, this._zoom, {pan: options});
    },
    panBy: function(offset) {
      this.fire('movestart');
      this._rawPanBy(L.point(offset));
      this.fire('move');
      return this.fire('moveend');
    },
    setMaxBounds: function(bounds) {
      bounds = L.latLngBounds(bounds);
      this.options.maxBounds = bounds;
      if (!bounds) {
        return this.off('moveend', this._panInsideMaxBounds, this);
      }
      if (this._loaded) {
        this._panInsideMaxBounds();
      }
      return this.on('moveend', this._panInsideMaxBounds, this);
    },
    panInsideBounds: function(bounds, options) {
      var center = this.getCenter(),
          newCenter = this._limitCenter(center, this._zoom, bounds);
      if (center.equals(newCenter)) {
        return this;
      }
      return this.panTo(newCenter, options);
    },
    addLayer: function(layer) {
      var id = L.stamp(layer);
      if (this._layers[id]) {
        return this;
      }
      this._layers[id] = layer;
      if (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {
        this._zoomBoundLayers[id] = layer;
        this._updateZoomLevels();
      }
      if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
        this._tileLayersNum++;
        this._tileLayersToLoad++;
        layer.on('load', this._onTileLayerLoad, this);
      }
      if (this._loaded) {
        this._layerAdd(layer);
      }
      return this;
    },
    removeLayer: function(layer) {
      var id = L.stamp(layer);
      if (!this._layers[id]) {
        return this;
      }
      if (this._loaded) {
        layer.onRemove(this);
      }
      delete this._layers[id];
      if (this._loaded) {
        this.fire('layerremove', {layer: layer});
      }
      if (this._zoomBoundLayers[id]) {
        delete this._zoomBoundLayers[id];
        this._updateZoomLevels();
      }
      if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
        this._tileLayersNum--;
        this._tileLayersToLoad--;
        layer.off('load', this._onTileLayerLoad, this);
      }
      return this;
    },
    hasLayer: function(layer) {
      if (!layer) {
        return false;
      }
      return (L.stamp(layer) in this._layers);
    },
    eachLayer: function(method, context) {
      for (var i in this._layers) {
        method.call(context, this._layers[i]);
      }
      return this;
    },
    invalidateSize: function(options) {
      if (!this._loaded) {
        return this;
      }
      options = L.extend({
        animate: false,
        pan: true
      }, options === true ? {animate: true} : options);
      var oldSize = this.getSize();
      this._sizeChanged = true;
      this._initialCenter = null;
      var newSize = this.getSize(),
          oldCenter = oldSize.divideBy(2).round(),
          newCenter = newSize.divideBy(2).round(),
          offset = oldCenter.subtract(newCenter);
      if (!offset.x && !offset.y) {
        return this;
      }
      if (options.animate && options.pan) {
        this.panBy(offset);
      } else {
        if (options.pan) {
          this._rawPanBy(offset);
        }
        this.fire('move');
        if (options.debounceMoveend) {
          clearTimeout(this._sizeTimer);
          this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
        } else {
          this.fire('moveend');
        }
      }
      return this.fire('resize', {
        oldSize: oldSize,
        newSize: newSize
      });
    },
    addHandler: function(name, HandlerClass) {
      if (!HandlerClass) {
        return this;
      }
      var handler = this[name] = new HandlerClass(this);
      this._handlers.push(handler);
      if (this.options[name]) {
        handler.enable();
      }
      return this;
    },
    remove: function() {
      if (this._loaded) {
        this.fire('unload');
      }
      this._initEvents('off');
      try {
        delete this._container._leaflet;
      } catch (e) {
        this._container._leaflet = undefined;
      }
      this._clearPanes();
      if (this._clearControlPos) {
        this._clearControlPos();
      }
      this._clearHandlers();
      return this;
    },
    getCenter: function() {
      this._checkIfLoaded();
      if (this._initialCenter && !this._moved()) {
        return this._initialCenter;
      }
      return this.layerPointToLatLng(this._getCenterLayerPoint());
    },
    getZoom: function() {
      return this._zoom;
    },
    getBounds: function() {
      var bounds = this.getPixelBounds(),
          sw = this.unproject(bounds.getBottomLeft()),
          ne = this.unproject(bounds.getTopRight());
      return new L.LatLngBounds(sw, ne);
    },
    getMinZoom: function() {
      return this.options.minZoom === undefined ? (this._layersMinZoom === undefined ? 0 : this._layersMinZoom) : this.options.minZoom;
    },
    getMaxZoom: function() {
      return this.options.maxZoom === undefined ? (this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) : this.options.maxZoom;
    },
    getBoundsZoom: function(bounds, inside, padding) {
      bounds = L.latLngBounds(bounds);
      var zoom = this.getMinZoom() - (inside ? 1 : 0),
          maxZoom = this.getMaxZoom(),
          size = this.getSize(),
          nw = bounds.getNorthWest(),
          se = bounds.getSouthEast(),
          zoomNotFound = true,
          boundsSize;
      padding = L.point(padding || [0, 0]);
      do {
        zoom++;
        boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);
        zoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;
      } while (zoomNotFound && zoom <= maxZoom);
      if (zoomNotFound && inside) {
        return null;
      }
      return inside ? zoom : zoom - 1;
    },
    getSize: function() {
      if (!this._size || this._sizeChanged) {
        this._size = new L.Point(this._container.clientWidth, this._container.clientHeight);
        this._sizeChanged = false;
      }
      return this._size.clone();
    },
    getPixelBounds: function() {
      var topLeftPoint = this._getTopLeftPoint();
      return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
    },
    getPixelOrigin: function() {
      this._checkIfLoaded();
      return this._initialTopLeftPoint;
    },
    getPanes: function() {
      return this._panes;
    },
    getContainer: function() {
      return this._container;
    },
    getZoomScale: function(toZoom) {
      var crs = this.options.crs;
      return crs.scale(toZoom) / crs.scale(this._zoom);
    },
    getScaleZoom: function(scale) {
      return this._zoom + (Math.log(scale) / Math.LN2);
    },
    project: function(latlng, zoom) {
      zoom = zoom === undefined ? this._zoom : zoom;
      return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
    },
    unproject: function(point, zoom) {
      zoom = zoom === undefined ? this._zoom : zoom;
      return this.options.crs.pointToLatLng(L.point(point), zoom);
    },
    layerPointToLatLng: function(point) {
      var projectedPoint = L.point(point).add(this.getPixelOrigin());
      return this.unproject(projectedPoint);
    },
    latLngToLayerPoint: function(latlng) {
      var projectedPoint = this.project(L.latLng(latlng))._round();
      return projectedPoint._subtract(this.getPixelOrigin());
    },
    containerPointToLayerPoint: function(point) {
      return L.point(point).subtract(this._getMapPanePos());
    },
    layerPointToContainerPoint: function(point) {
      return L.point(point).add(this._getMapPanePos());
    },
    containerPointToLatLng: function(point) {
      var layerPoint = this.containerPointToLayerPoint(L.point(point));
      return this.layerPointToLatLng(layerPoint);
    },
    latLngToContainerPoint: function(latlng) {
      return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
    },
    mouseEventToContainerPoint: function(e) {
      return L.DomEvent.getMousePosition(e, this._container);
    },
    mouseEventToLayerPoint: function(e) {
      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
    },
    mouseEventToLatLng: function(e) {
      return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
    },
    _initContainer: function(id) {
      var container = this._container = L.DomUtil.get(id);
      if (!container) {
        throw new Error('Map container not found.');
      } else if (container._leaflet) {
        throw new Error('Map container is already initialized.');
      }
      container._leaflet = true;
    },
    _initLayout: function() {
      var container = this._container;
      L.DomUtil.addClass(container, 'leaflet-container' + (L.Browser.touch ? ' leaflet-touch' : '') + (L.Browser.retina ? ' leaflet-retina' : '') + (L.Browser.ielt9 ? ' leaflet-oldie' : '') + (this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));
      var position = L.DomUtil.getStyle(container, 'position');
      if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
        container.style.position = 'relative';
      }
      this._initPanes();
      if (this._initControlPos) {
        this._initControlPos();
      }
    },
    _initPanes: function() {
      var panes = this._panes = {};
      this._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);
      this._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);
      panes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);
      panes.shadowPane = this._createPane('leaflet-shadow-pane');
      panes.overlayPane = this._createPane('leaflet-overlay-pane');
      panes.markerPane = this._createPane('leaflet-marker-pane');
      panes.popupPane = this._createPane('leaflet-popup-pane');
      var zoomHide = ' leaflet-zoom-hide';
      if (!this.options.markerZoomAnimation) {
        L.DomUtil.addClass(panes.markerPane, zoomHide);
        L.DomUtil.addClass(panes.shadowPane, zoomHide);
        L.DomUtil.addClass(panes.popupPane, zoomHide);
      }
    },
    _createPane: function(className, container) {
      return L.DomUtil.create('div', className, container || this._panes.objectsPane);
    },
    _clearPanes: function() {
      this._container.removeChild(this._mapPane);
    },
    _addLayers: function(layers) {
      layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];
      for (var i = 0,
          len = layers.length; i < len; i++) {
        this.addLayer(layers[i]);
      }
    },
    _resetView: function(center, zoom, preserveMapOffset, afterZoomAnim) {
      var zoomChanged = (this._zoom !== zoom);
      if (!afterZoomAnim) {
        this.fire('movestart');
        if (zoomChanged) {
          this.fire('zoomstart');
        }
      }
      this._zoom = zoom;
      this._initialCenter = center;
      this._initialTopLeftPoint = this._getNewTopLeftPoint(center);
      if (!preserveMapOffset) {
        L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));
      } else {
        this._initialTopLeftPoint._add(this._getMapPanePos());
      }
      this._tileLayersToLoad = this._tileLayersNum;
      var loading = !this._loaded;
      this._loaded = true;
      this.fire('viewreset', {hard: !preserveMapOffset});
      if (loading) {
        this.fire('load');
        this.eachLayer(this._layerAdd, this);
      }
      this.fire('move');
      if (zoomChanged || afterZoomAnim) {
        this.fire('zoomend');
      }
      this.fire('moveend', {hard: !preserveMapOffset});
    },
    _rawPanBy: function(offset) {
      L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
    },
    _getZoomSpan: function() {
      return this.getMaxZoom() - this.getMinZoom();
    },
    _updateZoomLevels: function() {
      var i,
          minZoom = Infinity,
          maxZoom = -Infinity,
          oldZoomSpan = this._getZoomSpan();
      for (i in this._zoomBoundLayers) {
        var layer = this._zoomBoundLayers[i];
        if (!isNaN(layer.options.minZoom)) {
          minZoom = Math.min(minZoom, layer.options.minZoom);
        }
        if (!isNaN(layer.options.maxZoom)) {
          maxZoom = Math.max(maxZoom, layer.options.maxZoom);
        }
      }
      if (i === undefined) {
        this._layersMaxZoom = this._layersMinZoom = undefined;
      } else {
        this._layersMaxZoom = maxZoom;
        this._layersMinZoom = minZoom;
      }
      if (oldZoomSpan !== this._getZoomSpan()) {
        this.fire('zoomlevelschange');
      }
    },
    _panInsideMaxBounds: function() {
      this.panInsideBounds(this.options.maxBounds);
    },
    _checkIfLoaded: function() {
      if (!this._loaded) {
        throw new Error('Set map center and zoom first.');
      }
    },
    _initEvents: function(onOff) {
      if (!L.DomEvent) {
        return;
      }
      onOff = onOff || 'on';
      L.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);
      var events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter', 'mouseleave', 'mousemove', 'contextmenu'],
          i,
          len;
      for (i = 0, len = events.length; i < len; i++) {
        L.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);
      }
      if (this.options.trackResize) {
        L.DomEvent[onOff](window, 'resize', this._onResize, this);
      }
    },
    _onResize: function() {
      L.Util.cancelAnimFrame(this._resizeRequest);
      this._resizeRequest = L.Util.requestAnimFrame(function() {
        this.invalidateSize({debounceMoveend: true});
      }, this, false, this._container);
    },
    _onMouseClick: function(e) {
      if (!this._loaded || (!e._simulated && ((this.dragging && this.dragging.moved()) || (this.boxZoom && this.boxZoom.moved()))) || L.DomEvent._skipped(e)) {
        return;
      }
      this.fire('preclick');
      this._fireMouseEvent(e);
    },
    _fireMouseEvent: function(e) {
      if (!this._loaded || L.DomEvent._skipped(e)) {
        return;
      }
      var type = e.type;
      type = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));
      if (!this.hasEventListeners(type)) {
        return;
      }
      if (type === 'contextmenu') {
        L.DomEvent.preventDefault(e);
      }
      var containerPoint = this.mouseEventToContainerPoint(e),
          layerPoint = this.containerPointToLayerPoint(containerPoint),
          latlng = this.layerPointToLatLng(layerPoint);
      this.fire(type, {
        latlng: latlng,
        layerPoint: layerPoint,
        containerPoint: containerPoint,
        originalEvent: e
      });
    },
    _onTileLayerLoad: function() {
      this._tileLayersToLoad--;
      if (this._tileLayersNum && !this._tileLayersToLoad) {
        this.fire('tilelayersload');
      }
    },
    _clearHandlers: function() {
      for (var i = 0,
          len = this._handlers.length; i < len; i++) {
        this._handlers[i].disable();
      }
    },
    whenReady: function(callback, context) {
      if (this._loaded) {
        callback.call(context || this, this);
      } else {
        this.on('load', callback, context);
      }
      return this;
    },
    _layerAdd: function(layer) {
      layer.onAdd(this);
      this.fire('layeradd', {layer: layer});
    },
    _getMapPanePos: function() {
      return L.DomUtil.getPosition(this._mapPane);
    },
    _moved: function() {
      var pos = this._getMapPanePos();
      return pos && !pos.equals([0, 0]);
    },
    _getTopLeftPoint: function() {
      return this.getPixelOrigin().subtract(this._getMapPanePos());
    },
    _getNewTopLeftPoint: function(center, zoom) {
      var viewHalf = this.getSize()._divideBy(2);
      return this.project(center, zoom)._subtract(viewHalf)._round();
    },
    _latLngToNewLayerPoint: function(latlng, newZoom, newCenter) {
      var topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());
      return this.project(latlng, newZoom)._subtract(topLeft);
    },
    _getCenterLayerPoint: function() {
      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
    },
    _getCenterOffset: function(latlng) {
      return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
    },
    _limitCenter: function(center, zoom, bounds) {
      if (!bounds) {
        return center;
      }
      var centerPoint = this.project(center, zoom),
          viewHalf = this.getSize().divideBy(2),
          viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
          offset = this._getBoundsOffset(viewBounds, bounds, zoom);
      return this.unproject(centerPoint.add(offset), zoom);
    },
    _limitOffset: function(offset, bounds) {
      if (!bounds) {
        return offset;
      }
      var viewBounds = this.getPixelBounds(),
          newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
      return offset.add(this._getBoundsOffset(newBounds, bounds));
    },
    _getBoundsOffset: function(pxBounds, maxBounds, zoom) {
      var nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),
          seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),
          dx = this._rebound(nwOffset.x, -seOffset.x),
          dy = this._rebound(nwOffset.y, -seOffset.y);
      return new L.Point(dx, dy);
    },
    _rebound: function(left, right) {
      return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
    },
    _limitZoom: function(zoom) {
      var min = this.getMinZoom(),
          max = this.getMaxZoom();
      return Math.max(min, Math.min(max, zoom));
    }
  });
  L.map = function(id, options) {
    return new L.Map(id, options);
  };
  L.Projection.Mercator = {
    MAX_LATITUDE: 85.0840591556,
    R_MINOR: 6356752.314245179,
    R_MAJOR: 6378137,
    project: function(latlng) {
      var d = L.LatLng.DEG_TO_RAD,
          max = this.MAX_LATITUDE,
          lat = Math.max(Math.min(max, latlng.lat), -max),
          r = this.R_MAJOR,
          r2 = this.R_MINOR,
          x = latlng.lng * d * r,
          y = lat * d,
          tmp = r2 / r,
          eccent = Math.sqrt(1.0 - tmp * tmp),
          con = eccent * Math.sin(y);
      con = Math.pow((1 - con) / (1 + con), eccent * 0.5);
      var ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;
      y = -r * Math.log(ts);
      return new L.Point(x, y);
    },
    unproject: function(point) {
      var d = L.LatLng.RAD_TO_DEG,
          r = this.R_MAJOR,
          r2 = this.R_MINOR,
          lng = point.x * d / r,
          tmp = r2 / r,
          eccent = Math.sqrt(1 - (tmp * tmp)),
          ts = Math.exp(-point.y / r),
          phi = (Math.PI / 2) - 2 * Math.atan(ts),
          numIter = 15,
          tol = 1e-7,
          i = numIter,
          dphi = 0.1,
          con;
      while ((Math.abs(dphi) > tol) && (--i > 0)) {
        con = eccent * Math.sin(phi);
        dphi = (Math.PI / 2) - 2 * Math.atan(ts * Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;
        phi += dphi;
      }
      return new L.LatLng(phi * d, lng);
    }
  };
  L.CRS.EPSG3395 = L.extend({}, L.CRS, {
    code: 'EPSG:3395',
    projection: L.Projection.Mercator,
    transformation: (function() {
      var m = L.Projection.Mercator,
          r = m.R_MAJOR,
          scale = 0.5 / (Math.PI * r);
      return new L.Transformation(scale, 0.5, -scale, 0.5);
    }())
  });
  L.TileLayer = L.Class.extend({
    includes: L.Mixin.Events,
    options: {
      minZoom: 0,
      maxZoom: 18,
      tileSize: 256,
      subdomains: 'abc',
      errorTileUrl: '',
      attribution: '',
      zoomOffset: 0,
      opacity: 1,
      unloadInvisibleTiles: L.Browser.mobile,
      updateWhenIdle: L.Browser.mobile
    },
    initialize: function(url, options) {
      options = L.setOptions(this, options);
      if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {
        options.tileSize = Math.floor(options.tileSize / 2);
        options.zoomOffset++;
        if (options.minZoom > 0) {
          options.minZoom--;
        }
        this.options.maxZoom--;
      }
      if (options.bounds) {
        options.bounds = L.latLngBounds(options.bounds);
      }
      this._url = url;
      var subdomains = this.options.subdomains;
      if (typeof subdomains === 'string') {
        this.options.subdomains = subdomains.split('');
      }
    },
    onAdd: function(map) {
      this._map = map;
      this._animated = map._zoomAnimated;
      this._initContainer();
      map.on({
        'viewreset': this._reset,
        'moveend': this._update
      }, this);
      if (this._animated) {
        map.on({
          'zoomanim': this._animateZoom,
          'zoomend': this._endZoomAnim
        }, this);
      }
      if (!this.options.updateWhenIdle) {
        this._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);
        map.on('move', this._limitedUpdate, this);
      }
      this._reset();
      this._update();
    },
    addTo: function(map) {
      map.addLayer(this);
      return this;
    },
    onRemove: function(map) {
      this._container.parentNode.removeChild(this._container);
      map.off({
        'viewreset': this._reset,
        'moveend': this._update
      }, this);
      if (this._animated) {
        map.off({
          'zoomanim': this._animateZoom,
          'zoomend': this._endZoomAnim
        }, this);
      }
      if (!this.options.updateWhenIdle) {
        map.off('move', this._limitedUpdate, this);
      }
      this._container = null;
      this._map = null;
    },
    bringToFront: function() {
      var pane = this._map._panes.tilePane;
      if (this._container) {
        pane.appendChild(this._container);
        this._setAutoZIndex(pane, Math.max);
      }
      return this;
    },
    bringToBack: function() {
      var pane = this._map._panes.tilePane;
      if (this._container) {
        pane.insertBefore(this._container, pane.firstChild);
        this._setAutoZIndex(pane, Math.min);
      }
      return this;
    },
    getAttribution: function() {
      return this.options.attribution;
    },
    getContainer: function() {
      return this._container;
    },
    setOpacity: function(opacity) {
      this.options.opacity = opacity;
      if (this._map) {
        this._updateOpacity();
      }
      return this;
    },
    setZIndex: function(zIndex) {
      this.options.zIndex = zIndex;
      this._updateZIndex();
      return this;
    },
    setUrl: function(url, noRedraw) {
      this._url = url;
      if (!noRedraw) {
        this.redraw();
      }
      return this;
    },
    redraw: function() {
      if (this._map) {
        this._reset({hard: true});
        this._update();
      }
      return this;
    },
    _updateZIndex: function() {
      if (this._container && this.options.zIndex !== undefined) {
        this._container.style.zIndex = this.options.zIndex;
      }
    },
    _setAutoZIndex: function(pane, compare) {
      var layers = pane.children,
          edgeZIndex = -compare(Infinity, -Infinity),
          zIndex,
          i,
          len;
      for (i = 0, len = layers.length; i < len; i++) {
        if (layers[i] !== this._container) {
          zIndex = parseInt(layers[i].style.zIndex, 10);
          if (!isNaN(zIndex)) {
            edgeZIndex = compare(edgeZIndex, zIndex);
          }
        }
      }
      this.options.zIndex = this._container.style.zIndex = (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);
    },
    _updateOpacity: function() {
      var i,
          tiles = this._tiles;
      if (L.Browser.ielt9) {
        for (i in tiles) {
          L.DomUtil.setOpacity(tiles[i], this.options.opacity);
        }
      } else {
        L.DomUtil.setOpacity(this._container, this.options.opacity);
      }
    },
    _initContainer: function() {
      var tilePane = this._map._panes.tilePane;
      if (!this._container) {
        this._container = L.DomUtil.create('div', 'leaflet-layer');
        this._updateZIndex();
        if (this._animated) {
          var className = 'leaflet-tile-container';
          this._bgBuffer = L.DomUtil.create('div', className, this._container);
          this._tileContainer = L.DomUtil.create('div', className, this._container);
        } else {
          this._tileContainer = this._container;
        }
        tilePane.appendChild(this._container);
        if (this.options.opacity < 1) {
          this._updateOpacity();
        }
      }
    },
    _reset: function(e) {
      for (var key in this._tiles) {
        this.fire('tileunload', {tile: this._tiles[key]});
      }
      this._tiles = {};
      this._tilesToLoad = 0;
      if (this.options.reuseTiles) {
        this._unusedTiles = [];
      }
      this._tileContainer.innerHTML = '';
      if (this._animated && e && e.hard) {
        this._clearBgBuffer();
      }
      this._initContainer();
    },
    _getTileSize: function() {
      var map = this._map,
          zoom = map.getZoom() + this.options.zoomOffset,
          zoomN = this.options.maxNativeZoom,
          tileSize = this.options.tileSize;
      if (zoomN && zoom > zoomN) {
        tileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);
      }
      return tileSize;
    },
    _update: function() {
      if (!this._map) {
        return;
      }
      var map = this._map,
          bounds = map.getPixelBounds(),
          zoom = map.getZoom(),
          tileSize = this._getTileSize();
      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
        return;
      }
      var tileBounds = L.bounds(bounds.min.divideBy(tileSize)._floor(), bounds.max.divideBy(tileSize)._floor());
      this._addTilesFromCenterOut(tileBounds);
      if (this.options.unloadInvisibleTiles || this.options.reuseTiles) {
        this._removeOtherTiles(tileBounds);
      }
    },
    _addTilesFromCenterOut: function(bounds) {
      var queue = [],
          center = bounds.getCenter();
      var j,
          i,
          point;
      for (j = bounds.min.y; j <= bounds.max.y; j++) {
        for (i = bounds.min.x; i <= bounds.max.x; i++) {
          point = new L.Point(i, j);
          if (this._tileShouldBeLoaded(point)) {
            queue.push(point);
          }
        }
      }
      var tilesToLoad = queue.length;
      if (tilesToLoad === 0) {
        return;
      }
      queue.sort(function(a, b) {
        return a.distanceTo(center) - b.distanceTo(center);
      });
      var fragment = document.createDocumentFragment();
      if (!this._tilesToLoad) {
        this.fire('loading');
      }
      this._tilesToLoad += tilesToLoad;
      for (i = 0; i < tilesToLoad; i++) {
        this._addTile(queue[i], fragment);
      }
      this._tileContainer.appendChild(fragment);
    },
    _tileShouldBeLoaded: function(tilePoint) {
      if ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {
        return false;
      }
      var options = this.options;
      if (!options.continuousWorld) {
        var limit = this._getWrapTileNum();
        if ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) || tilePoint.y < 0 || tilePoint.y >= limit.y) {
          return false;
        }
      }
      if (options.bounds) {
        var tileSize = this._getTileSize(),
            nwPoint = tilePoint.multiplyBy(tileSize),
            sePoint = nwPoint.add([tileSize, tileSize]),
            nw = this._map.unproject(nwPoint),
            se = this._map.unproject(sePoint);
        if (!options.continuousWorld && !options.noWrap) {
          nw = nw.wrap();
          se = se.wrap();
        }
        if (!options.bounds.intersects([nw, se])) {
          return false;
        }
      }
      return true;
    },
    _removeOtherTiles: function(bounds) {
      var kArr,
          x,
          y,
          key;
      for (key in this._tiles) {
        kArr = key.split(':');
        x = parseInt(kArr[0], 10);
        y = parseInt(kArr[1], 10);
        if (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {
          this._removeTile(key);
        }
      }
    },
    _removeTile: function(key) {
      var tile = this._tiles[key];
      this.fire('tileunload', {
        tile: tile,
        url: tile.src
      });
      if (this.options.reuseTiles) {
        L.DomUtil.removeClass(tile, 'leaflet-tile-loaded');
        this._unusedTiles.push(tile);
      } else if (tile.parentNode === this._tileContainer) {
        this._tileContainer.removeChild(tile);
      }
      if (!L.Browser.android) {
        tile.onload = null;
        tile.src = L.Util.emptyImageUrl;
      }
      delete this._tiles[key];
    },
    _addTile: function(tilePoint, container) {
      var tilePos = this._getTilePos(tilePoint);
      var tile = this._getTile();
      L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);
      this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;
      this._loadTile(tile, tilePoint);
      if (tile.parentNode !== this._tileContainer) {
        container.appendChild(tile);
      }
    },
    _getZoomForUrl: function() {
      var options = this.options,
          zoom = this._map.getZoom();
      if (options.zoomReverse) {
        zoom = options.maxZoom - zoom;
      }
      zoom += options.zoomOffset;
      return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;
    },
    _getTilePos: function(tilePoint) {
      var origin = this._map.getPixelOrigin(),
          tileSize = this._getTileSize();
      return tilePoint.multiplyBy(tileSize).subtract(origin);
    },
    getTileUrl: function(tilePoint) {
      return L.Util.template(this._url, L.extend({
        s: this._getSubdomain(tilePoint),
        z: tilePoint.z,
        x: tilePoint.x,
        y: tilePoint.y
      }, this.options));
    },
    _getWrapTileNum: function() {
      var crs = this._map.options.crs,
          size = crs.getSize(this._map.getZoom());
      return size.divideBy(this._getTileSize())._floor();
    },
    _adjustTilePoint: function(tilePoint) {
      var limit = this._getWrapTileNum();
      if (!this.options.continuousWorld && !this.options.noWrap) {
        tilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;
      }
      if (this.options.tms) {
        tilePoint.y = limit.y - tilePoint.y - 1;
      }
      tilePoint.z = this._getZoomForUrl();
    },
    _getSubdomain: function(tilePoint) {
      var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
      return this.options.subdomains[index];
    },
    _getTile: function() {
      if (this.options.reuseTiles && this._unusedTiles.length > 0) {
        var tile = this._unusedTiles.pop();
        this._resetTile(tile);
        return tile;
      }
      return this._createTile();
    },
    _resetTile: function() {},
    _createTile: function() {
      var tile = L.DomUtil.create('img', 'leaflet-tile');
      tile.style.width = tile.style.height = this._getTileSize() + 'px';
      tile.galleryimg = 'no';
      tile.onselectstart = tile.onmousemove = L.Util.falseFn;
      if (L.Browser.ielt9 && this.options.opacity !== undefined) {
        L.DomUtil.setOpacity(tile, this.options.opacity);
      }
      if (L.Browser.mobileWebkit3d) {
        tile.style.WebkitBackfaceVisibility = 'hidden';
      }
      return tile;
    },
    _loadTile: function(tile, tilePoint) {
      tile._layer = this;
      tile.onload = this._tileOnLoad;
      tile.onerror = this._tileOnError;
      this._adjustTilePoint(tilePoint);
      tile.src = this.getTileUrl(tilePoint);
      this.fire('tileloadstart', {
        tile: tile,
        url: tile.src
      });
    },
    _tileLoaded: function() {
      this._tilesToLoad--;
      if (this._animated) {
        L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');
      }
      if (!this._tilesToLoad) {
        this.fire('load');
        if (this._animated) {
          clearTimeout(this._clearBgBufferTimer);
          this._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);
        }
      }
    },
    _tileOnLoad: function() {
      var layer = this._layer;
      if (this.src !== L.Util.emptyImageUrl) {
        L.DomUtil.addClass(this, 'leaflet-tile-loaded');
        layer.fire('tileload', {
          tile: this,
          url: this.src
        });
      }
      layer._tileLoaded();
    },
    _tileOnError: function() {
      var layer = this._layer;
      layer.fire('tileerror', {
        tile: this,
        url: this.src
      });
      var newUrl = layer.options.errorTileUrl;
      if (newUrl) {
        this.src = newUrl;
      }
      layer._tileLoaded();
    }
  });
  L.tileLayer = function(url, options) {
    return new L.TileLayer(url, options);
  };
  L.TileLayer.WMS = L.TileLayer.extend({
    defaultWmsParams: {
      service: 'WMS',
      request: 'GetMap',
      version: '1.1.1',
      layers: '',
      styles: '',
      format: 'image/jpeg',
      transparent: false
    },
    initialize: function(url, options) {
      this._url = url;
      var wmsParams = L.extend({}, this.defaultWmsParams),
          tileSize = options.tileSize || this.options.tileSize;
      if (options.detectRetina && L.Browser.retina) {
        wmsParams.width = wmsParams.height = tileSize * 2;
      } else {
        wmsParams.width = wmsParams.height = tileSize;
      }
      for (var i in options) {
        if (!this.options.hasOwnProperty(i) && i !== 'crs') {
          wmsParams[i] = options[i];
        }
      }
      this.wmsParams = wmsParams;
      L.setOptions(this, options);
    },
    onAdd: function(map) {
      this._crs = this.options.crs || map.options.crs;
      this._wmsVersion = parseFloat(this.wmsParams.version);
      var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
      this.wmsParams[projectionKey] = this._crs.code;
      L.TileLayer.prototype.onAdd.call(this, map);
    },
    getTileUrl: function(tilePoint) {
      var map = this._map,
          tileSize = this.options.tileSize,
          nwPoint = tilePoint.multiplyBy(tileSize),
          sePoint = nwPoint.add([tileSize, tileSize]),
          nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),
          se = this._crs.project(map.unproject(sePoint, tilePoint.z)),
          bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ? [se.y, nw.x, nw.y, se.x].join(',') : [nw.x, se.y, se.x, nw.y].join(','),
          url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});
      return url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;
    },
    setParams: function(params, noRedraw) {
      L.extend(this.wmsParams, params);
      if (!noRedraw) {
        this.redraw();
      }
      return this;
    }
  });
  L.tileLayer.wms = function(url, options) {
    return new L.TileLayer.WMS(url, options);
  };
  L.TileLayer.Canvas = L.TileLayer.extend({
    options: {async: false},
    initialize: function(options) {
      L.setOptions(this, options);
    },
    redraw: function() {
      if (this._map) {
        this._reset({hard: true});
        this._update();
      }
      for (var i in this._tiles) {
        this._redrawTile(this._tiles[i]);
      }
      return this;
    },
    _redrawTile: function(tile) {
      this.drawTile(tile, tile._tilePoint, this._map._zoom);
    },
    _createTile: function() {
      var tile = L.DomUtil.create('canvas', 'leaflet-tile');
      tile.width = tile.height = this.options.tileSize;
      tile.onselectstart = tile.onmousemove = L.Util.falseFn;
      return tile;
    },
    _loadTile: function(tile, tilePoint) {
      tile._layer = this;
      tile._tilePoint = tilePoint;
      this._redrawTile(tile);
      if (!this.options.async) {
        this.tileDrawn(tile);
      }
    },
    drawTile: function() {},
    tileDrawn: function(tile) {
      this._tileOnLoad.call(tile);
    }
  });
  L.tileLayer.canvas = function(options) {
    return new L.TileLayer.Canvas(options);
  };
  L.ImageOverlay = L.Class.extend({
    includes: L.Mixin.Events,
    options: {opacity: 1},
    initialize: function(url, bounds, options) {
      this._url = url;
      this._bounds = L.latLngBounds(bounds);
      L.setOptions(this, options);
    },
    onAdd: function(map) {
      this._map = map;
      if (!this._image) {
        this._initImage();
      }
      map._panes.overlayPane.appendChild(this._image);
      map.on('viewreset', this._reset, this);
      if (map.options.zoomAnimation && L.Browser.any3d) {
        map.on('zoomanim', this._animateZoom, this);
      }
      this._reset();
    },
    onRemove: function(map) {
      map.getPanes().overlayPane.removeChild(this._image);
      map.off('viewreset', this._reset, this);
      if (map.options.zoomAnimation) {
        map.off('zoomanim', this._animateZoom, this);
      }
    },
    addTo: function(map) {
      map.addLayer(this);
      return this;
    },
    setOpacity: function(opacity) {
      this.options.opacity = opacity;
      this._updateOpacity();
      return this;
    },
    bringToFront: function() {
      if (this._image) {
        this._map._panes.overlayPane.appendChild(this._image);
      }
      return this;
    },
    bringToBack: function() {
      var pane = this._map._panes.overlayPane;
      if (this._image) {
        pane.insertBefore(this._image, pane.firstChild);
      }
      return this;
    },
    setUrl: function(url) {
      this._url = url;
      this._image.src = this._url;
    },
    getAttribution: function() {
      return this.options.attribution;
    },
    _initImage: function() {
      this._image = L.DomUtil.create('img', 'leaflet-image-layer');
      if (this._map.options.zoomAnimation && L.Browser.any3d) {
        L.DomUtil.addClass(this._image, 'leaflet-zoom-animated');
      } else {
        L.DomUtil.addClass(this._image, 'leaflet-zoom-hide');
      }
      this._updateOpacity();
      L.extend(this._image, {
        galleryimg: 'no',
        onselectstart: L.Util.falseFn,
        onmousemove: L.Util.falseFn,
        onload: L.bind(this._onImageLoad, this),
        src: this._url
      });
    },
    _animateZoom: function(e) {
      var map = this._map,
          image = this._image,
          scale = map.getZoomScale(e.zoom),
          nw = this._bounds.getNorthWest(),
          se = this._bounds.getSouthEast(),
          topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),
          size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),
          origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));
      image.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';
    },
    _reset: function() {
      var image = this._image,
          topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
          size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);
      L.DomUtil.setPosition(image, topLeft);
      image.style.width = size.x + 'px';
      image.style.height = size.y + 'px';
    },
    _onImageLoad: function() {
      this.fire('load');
    },
    _updateOpacity: function() {
      L.DomUtil.setOpacity(this._image, this.options.opacity);
    }
  });
  L.imageOverlay = function(url, bounds, options) {
    return new L.ImageOverlay(url, bounds, options);
  };
  L.Icon = L.Class.extend({
    options: {className: ''},
    initialize: function(options) {
      L.setOptions(this, options);
    },
    createIcon: function(oldIcon) {
      return this._createIcon('icon', oldIcon);
    },
    createShadow: function(oldIcon) {
      return this._createIcon('shadow', oldIcon);
    },
    _createIcon: function(name, oldIcon) {
      var src = this._getIconUrl(name);
      if (!src) {
        if (name === 'icon') {
          throw new Error('iconUrl not set in Icon options (see the docs).');
        }
        return null;
      }
      var img;
      if (!oldIcon || oldIcon.tagName !== 'IMG') {
        img = this._createImg(src);
      } else {
        img = this._createImg(src, oldIcon);
      }
      this._setIconStyles(img, name);
      return img;
    },
    _setIconStyles: function(img, name) {
      var options = this.options,
          size = L.point(options[name + 'Size']),
          anchor;
      if (name === 'shadow') {
        anchor = L.point(options.shadowAnchor || options.iconAnchor);
      } else {
        anchor = L.point(options.iconAnchor);
      }
      if (!anchor && size) {
        anchor = size.divideBy(2, true);
      }
      img.className = 'leaflet-marker-' + name + ' ' + options.className;
      if (anchor) {
        img.style.marginLeft = (-anchor.x) + 'px';
        img.style.marginTop = (-anchor.y) + 'px';
      }
      if (size) {
        img.style.width = size.x + 'px';
        img.style.height = size.y + 'px';
      }
    },
    _createImg: function(src, el) {
      el = el || document.createElement('img');
      el.src = src;
      return el;
    },
    _getIconUrl: function(name) {
      if (L.Browser.retina && this.options[name + 'RetinaUrl']) {
        return this.options[name + 'RetinaUrl'];
      }
      return this.options[name + 'Url'];
    }
  });
  L.icon = function(options) {
    return new L.Icon(options);
  };
  L.Icon.Default = L.Icon.extend({
    options: {
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    },
    _getIconUrl: function(name) {
      var key = name + 'Url';
      if (this.options[key]) {
        return this.options[key];
      }
      if (L.Browser.retina && name === 'icon') {
        name += '-2x';
      }
      var path = L.Icon.Default.imagePath;
      if (!path) {
        throw new Error('Couldn\'t autodetect L.Icon.Default.imagePath, set it manually.');
      }
      return path + '/marker-' + name + '.png';
    }
  });
  L.Icon.Default.imagePath = (function() {
    var scripts = document.getElementsByTagName('script'),
        leafletRe = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;
    var i,
        len,
        src,
        matches,
        path;
    for (i = 0, len = scripts.length; i < len; i++) {
      src = scripts[i].src;
      matches = src.match(leafletRe);
      if (matches) {
        path = src.split(leafletRe)[0];
        return (path ? path + '/' : '') + 'images';
      }
    }
  }());
  L.Marker = L.Class.extend({
    includes: L.Mixin.Events,
    options: {
      icon: new L.Icon.Default(),
      title: '',
      alt: '',
      clickable: true,
      draggable: false,
      keyboard: true,
      zIndexOffset: 0,
      opacity: 1,
      riseOnHover: false,
      riseOffset: 250
    },
    initialize: function(latlng, options) {
      L.setOptions(this, options);
      this._latlng = L.latLng(latlng);
    },
    onAdd: function(map) {
      this._map = map;
      map.on('viewreset', this.update, this);
      this._initIcon();
      this.update();
      this.fire('add');
      if (map.options.zoomAnimation && map.options.markerZoomAnimation) {
        map.on('zoomanim', this._animateZoom, this);
      }
    },
    addTo: function(map) {
      map.addLayer(this);
      return this;
    },
    onRemove: function(map) {
      if (this.dragging) {
        this.dragging.disable();
      }
      this._removeIcon();
      this._removeShadow();
      this.fire('remove');
      map.off({
        'viewreset': this.update,
        'zoomanim': this._animateZoom
      }, this);
      this._map = null;
    },
    getLatLng: function() {
      return this._latlng;
    },
    setLatLng: function(latlng) {
      this._latlng = L.latLng(latlng);
      this.update();
      return this.fire('move', {latlng: this._latlng});
    },
    setZIndexOffset: function(offset) {
      this.options.zIndexOffset = offset;
      this.update();
      return this;
    },
    setIcon: function(icon) {
      this.options.icon = icon;
      if (this._map) {
        this._initIcon();
        this.update();
      }
      if (this._popup) {
        this.bindPopup(this._popup);
      }
      return this;
    },
    update: function() {
      if (this._icon) {
        this._setPos(this._map.latLngToLayerPoint(this._latlng).round());
      }
      return this;
    },
    _initIcon: function() {
      var options = this.options,
          map = this._map,
          animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),
          classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';
      var icon = options.icon.createIcon(this._icon),
          addIcon = false;
      if (icon !== this._icon) {
        if (this._icon) {
          this._removeIcon();
        }
        addIcon = true;
        if (options.title) {
          icon.title = options.title;
        }
        if (options.alt) {
          icon.alt = options.alt;
        }
      }
      L.DomUtil.addClass(icon, classToAdd);
      if (options.keyboard) {
        icon.tabIndex = '0';
      }
      this._icon = icon;
      this._initInteraction();
      if (options.riseOnHover) {
        L.DomEvent.on(icon, 'mouseover', this._bringToFront, this).on(icon, 'mouseout', this._resetZIndex, this);
      }
      var newShadow = options.icon.createShadow(this._shadow),
          addShadow = false;
      if (newShadow !== this._shadow) {
        this._removeShadow();
        addShadow = true;
      }
      if (newShadow) {
        L.DomUtil.addClass(newShadow, classToAdd);
      }
      this._shadow = newShadow;
      if (options.opacity < 1) {
        this._updateOpacity();
      }
      var panes = this._map._panes;
      if (addIcon) {
        panes.markerPane.appendChild(this._icon);
      }
      if (newShadow && addShadow) {
        panes.shadowPane.appendChild(this._shadow);
      }
    },
    _removeIcon: function() {
      if (this.options.riseOnHover) {
        L.DomEvent.off(this._icon, 'mouseover', this._bringToFront).off(this._icon, 'mouseout', this._resetZIndex);
      }
      this._map._panes.markerPane.removeChild(this._icon);
      this._icon = null;
    },
    _removeShadow: function() {
      if (this._shadow) {
        this._map._panes.shadowPane.removeChild(this._shadow);
      }
      this._shadow = null;
    },
    _setPos: function(pos) {
      L.DomUtil.setPosition(this._icon, pos);
      if (this._shadow) {
        L.DomUtil.setPosition(this._shadow, pos);
      }
      this._zIndex = pos.y + this.options.zIndexOffset;
      this._resetZIndex();
    },
    _updateZIndex: function(offset) {
      this._icon.style.zIndex = this._zIndex + offset;
    },
    _animateZoom: function(opt) {
      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
      this._setPos(pos);
    },
    _initInteraction: function() {
      if (!this.options.clickable) {
        return;
      }
      var icon = this._icon,
          events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];
      L.DomUtil.addClass(icon, 'leaflet-clickable');
      L.DomEvent.on(icon, 'click', this._onMouseClick, this);
      L.DomEvent.on(icon, 'keypress', this._onKeyPress, this);
      for (var i = 0; i < events.length; i++) {
        L.DomEvent.on(icon, events[i], this._fireMouseEvent, this);
      }
      if (L.Handler.MarkerDrag) {
        this.dragging = new L.Handler.MarkerDrag(this);
        if (this.options.draggable) {
          this.dragging.enable();
        }
      }
    },
    _onMouseClick: function(e) {
      var wasDragged = this.dragging && this.dragging.moved();
      if (this.hasEventListeners(e.type) || wasDragged) {
        L.DomEvent.stopPropagation(e);
      }
      if (wasDragged) {
        return;
      }
      if ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) {
        return;
      }
      this.fire(e.type, {
        originalEvent: e,
        latlng: this._latlng
      });
    },
    _onKeyPress: function(e) {
      if (e.keyCode === 13) {
        this.fire('click', {
          originalEvent: e,
          latlng: this._latlng
        });
      }
    },
    _fireMouseEvent: function(e) {
      this.fire(e.type, {
        originalEvent: e,
        latlng: this._latlng
      });
      if (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {
        L.DomEvent.preventDefault(e);
      }
      if (e.type !== 'mousedown') {
        L.DomEvent.stopPropagation(e);
      } else {
        L.DomEvent.preventDefault(e);
      }
    },
    setOpacity: function(opacity) {
      this.options.opacity = opacity;
      if (this._map) {
        this._updateOpacity();
      }
      return this;
    },
    _updateOpacity: function() {
      L.DomUtil.setOpacity(this._icon, this.options.opacity);
      if (this._shadow) {
        L.DomUtil.setOpacity(this._shadow, this.options.opacity);
      }
    },
    _bringToFront: function() {
      this._updateZIndex(this.options.riseOffset);
    },
    _resetZIndex: function() {
      this._updateZIndex(0);
    }
  });
  L.marker = function(latlng, options) {
    return new L.Marker(latlng, options);
  };
  L.DivIcon = L.Icon.extend({
    options: {
      iconSize: [12, 12],
      className: 'leaflet-div-icon',
      html: false
    },
    createIcon: function(oldIcon) {
      var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
          options = this.options;
      if (options.html !== false) {
        div.innerHTML = options.html;
      } else {
        div.innerHTML = '';
      }
      if (options.bgPos) {
        div.style.backgroundPosition = (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';
      }
      this._setIconStyles(div, 'icon');
      return div;
    },
    createShadow: function() {
      return null;
    }
  });
  L.divIcon = function(options) {
    return new L.DivIcon(options);
  };
  L.Map.mergeOptions({closePopupOnClick: true});
  L.Popup = L.Class.extend({
    includes: L.Mixin.Events,
    options: {
      minWidth: 50,
      maxWidth: 300,
      autoPan: true,
      closeButton: true,
      offset: [0, 7],
      autoPanPadding: [5, 5],
      keepInView: false,
      className: '',
      zoomAnimation: true
    },
    initialize: function(options, source) {
      L.setOptions(this, options);
      this._source = source;
      this._animated = L.Browser.any3d && this.options.zoomAnimation;
      this._isOpen = false;
    },
    onAdd: function(map) {
      this._map = map;
      if (!this._container) {
        this._initLayout();
      }
      var animFade = map.options.fadeAnimation;
      if (animFade) {
        L.DomUtil.setOpacity(this._container, 0);
      }
      map._panes.popupPane.appendChild(this._container);
      map.on(this._getEvents(), this);
      this.update();
      if (animFade) {
        L.DomUtil.setOpacity(this._container, 1);
      }
      this.fire('open');
      map.fire('popupopen', {popup: this});
      if (this._source) {
        this._source.fire('popupopen', {popup: this});
      }
    },
    addTo: function(map) {
      map.addLayer(this);
      return this;
    },
    openOn: function(map) {
      map.openPopup(this);
      return this;
    },
    onRemove: function(map) {
      map._panes.popupPane.removeChild(this._container);
      L.Util.falseFn(this._container.offsetWidth);
      map.off(this._getEvents(), this);
      if (map.options.fadeAnimation) {
        L.DomUtil.setOpacity(this._container, 0);
      }
      this._map = null;
      this.fire('close');
      map.fire('popupclose', {popup: this});
      if (this._source) {
        this._source.fire('popupclose', {popup: this});
      }
    },
    getLatLng: function() {
      return this._latlng;
    },
    setLatLng: function(latlng) {
      this._latlng = L.latLng(latlng);
      if (this._map) {
        this._updatePosition();
        this._adjustPan();
      }
      return this;
    },
    getContent: function() {
      return this._content;
    },
    setContent: function(content) {
      this._content = content;
      this.update();
      return this;
    },
    update: function() {
      if (!this._map) {
        return;
      }
      this._container.style.visibility = 'hidden';
      this._updateContent();
      this._updateLayout();
      this._updatePosition();
      this._container.style.visibility = '';
      this._adjustPan();
    },
    _getEvents: function() {
      var events = {viewreset: this._updatePosition};
      if (this._animated) {
        events.zoomanim = this._zoomAnimation;
      }
      if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
        events.preclick = this._close;
      }
      if (this.options.keepInView) {
        events.moveend = this._adjustPan;
      }
      return events;
    },
    _close: function() {
      if (this._map) {
        this._map.closePopup(this);
      }
    },
    _initLayout: function() {
      var prefix = 'leaflet-popup',
          containerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' + (this._animated ? 'animated' : 'hide'),
          container = this._container = L.DomUtil.create('div', containerClass),
          closeButton;
      if (this.options.closeButton) {
        closeButton = this._closeButton = L.DomUtil.create('a', prefix + '-close-button', container);
        closeButton.href = '#close';
        closeButton.innerHTML = '&#215;';
        L.DomEvent.disableClickPropagation(closeButton);
        L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
      }
      var wrapper = this._wrapper = L.DomUtil.create('div', prefix + '-content-wrapper', container);
      L.DomEvent.disableClickPropagation(wrapper);
      this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);
      L.DomEvent.disableScrollPropagation(this._contentNode);
      L.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);
      this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
      this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
    },
    _updateContent: function() {
      if (!this._content) {
        return;
      }
      if (typeof this._content === 'string') {
        this._contentNode.innerHTML = this._content;
      } else {
        while (this._contentNode.hasChildNodes()) {
          this._contentNode.removeChild(this._contentNode.firstChild);
        }
        this._contentNode.appendChild(this._content);
      }
      this.fire('contentupdate');
    },
    _updateLayout: function() {
      var container = this._contentNode,
          style = container.style;
      style.width = '';
      style.whiteSpace = 'nowrap';
      var width = container.offsetWidth;
      width = Math.min(width, this.options.maxWidth);
      width = Math.max(width, this.options.minWidth);
      style.width = (width + 1) + 'px';
      style.whiteSpace = '';
      style.height = '';
      var height = container.offsetHeight,
          maxHeight = this.options.maxHeight,
          scrolledClass = 'leaflet-popup-scrolled';
      if (maxHeight && height > maxHeight) {
        style.height = maxHeight + 'px';
        L.DomUtil.addClass(container, scrolledClass);
      } else {
        L.DomUtil.removeClass(container, scrolledClass);
      }
      this._containerWidth = this._container.offsetWidth;
    },
    _updatePosition: function() {
      if (!this._map) {
        return;
      }
      var pos = this._map.latLngToLayerPoint(this._latlng),
          animated = this._animated,
          offset = L.point(this.options.offset);
      if (animated) {
        L.DomUtil.setPosition(this._container, pos);
      }
      this._containerBottom = -offset.y - (animated ? 0 : pos.y);
      this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);
      this._container.style.bottom = this._containerBottom + 'px';
      this._container.style.left = this._containerLeft + 'px';
    },
    _zoomAnimation: function(opt) {
      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);
      L.DomUtil.setPosition(this._container, pos);
    },
    _adjustPan: function() {
      if (!this.options.autoPan) {
        return;
      }
      var map = this._map,
          containerHeight = this._container.offsetHeight,
          containerWidth = this._containerWidth,
          layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);
      if (this._animated) {
        layerPos._add(L.DomUtil.getPosition(this._container));
      }
      var containerPos = map.layerPointToContainerPoint(layerPos),
          padding = L.point(this.options.autoPanPadding),
          paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
          paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
          size = map.getSize(),
          dx = 0,
          dy = 0;
      if (containerPos.x + containerWidth + paddingBR.x > size.x) {
        dx = containerPos.x + containerWidth - size.x + paddingBR.x;
      }
      if (containerPos.x - dx - paddingTL.x < 0) {
        dx = containerPos.x - paddingTL.x;
      }
      if (containerPos.y + containerHeight + paddingBR.y > size.y) {
        dy = containerPos.y + containerHeight - size.y + paddingBR.y;
      }
      if (containerPos.y - dy - paddingTL.y < 0) {
        dy = containerPos.y - paddingTL.y;
      }
      if (dx || dy) {
        map.fire('autopanstart').panBy([dx, dy]);
      }
    },
    _onCloseButtonClick: function(e) {
      this._close();
      L.DomEvent.stop(e);
    }
  });
  L.popup = function(options, source) {
    return new L.Popup(options, source);
  };
  L.Map.include({
    openPopup: function(popup, latlng, options) {
      this.closePopup();
      if (!(popup instanceof L.Popup)) {
        var content = popup;
        popup = new L.Popup(options).setLatLng(latlng).setContent(content);
      }
      popup._isOpen = true;
      this._popup = popup;
      return this.addLayer(popup);
    },
    closePopup: function(popup) {
      if (!popup || popup === this._popup) {
        popup = this._popup;
        this._popup = null;
      }
      if (popup) {
        this.removeLayer(popup);
        popup._isOpen = false;
      }
      return this;
    }
  });
  L.Marker.include({
    openPopup: function() {
      if (this._popup && this._map && !this._map.hasLayer(this._popup)) {
        this._popup.setLatLng(this._latlng);
        this._map.openPopup(this._popup);
      }
      return this;
    },
    closePopup: function() {
      if (this._popup) {
        this._popup._close();
      }
      return this;
    },
    togglePopup: function() {
      if (this._popup) {
        if (this._popup._isOpen) {
          this.closePopup();
        } else {
          this.openPopup();
        }
      }
      return this;
    },
    bindPopup: function(content, options) {
      var anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);
      anchor = anchor.add(L.Popup.prototype.options.offset);
      if (options && options.offset) {
        anchor = anchor.add(options.offset);
      }
      options = L.extend({offset: anchor}, options);
      if (!this._popupHandlersAdded) {
        this.on('click', this.togglePopup, this).on('remove', this.closePopup, this).on('move', this._movePopup, this);
        this._popupHandlersAdded = true;
      }
      if (content instanceof L.Popup) {
        L.setOptions(content, options);
        this._popup = content;
        content._source = this;
      } else {
        this._popup = new L.Popup(options, this).setContent(content);
      }
      return this;
    },
    setPopupContent: function(content) {
      if (this._popup) {
        this._popup.setContent(content);
      }
      return this;
    },
    unbindPopup: function() {
      if (this._popup) {
        this._popup = null;
        this.off('click', this.togglePopup, this).off('remove', this.closePopup, this).off('move', this._movePopup, this);
        this._popupHandlersAdded = false;
      }
      return this;
    },
    getPopup: function() {
      return this._popup;
    },
    _movePopup: function(e) {
      this._popup.setLatLng(e.latlng);
    }
  });
  L.LayerGroup = L.Class.extend({
    initialize: function(layers) {
      this._layers = {};
      var i,
          len;
      if (layers) {
        for (i = 0, len = layers.length; i < len; i++) {
          this.addLayer(layers[i]);
        }
      }
    },
    addLayer: function(layer) {
      var id = this.getLayerId(layer);
      this._layers[id] = layer;
      if (this._map) {
        this._map.addLayer(layer);
      }
      return this;
    },
    removeLayer: function(layer) {
      var id = layer in this._layers ? layer : this.getLayerId(layer);
      if (this._map && this._layers[id]) {
        this._map.removeLayer(this._layers[id]);
      }
      delete this._layers[id];
      return this;
    },
    hasLayer: function(layer) {
      if (!layer) {
        return false;
      }
      return (layer in this._layers || this.getLayerId(layer) in this._layers);
    },
    clearLayers: function() {
      this.eachLayer(this.removeLayer, this);
      return this;
    },
    invoke: function(methodName) {
      var args = Array.prototype.slice.call(arguments, 1),
          i,
          layer;
      for (i in this._layers) {
        layer = this._layers[i];
        if (layer[methodName]) {
          layer[methodName].apply(layer, args);
        }
      }
      return this;
    },
    onAdd: function(map) {
      this._map = map;
      this.eachLayer(map.addLayer, map);
    },
    onRemove: function(map) {
      this.eachLayer(map.removeLayer, map);
      this._map = null;
    },
    addTo: function(map) {
      map.addLayer(this);
      return this;
    },
    eachLayer: function(method, context) {
      for (var i in this._layers) {
        method.call(context, this._layers[i]);
      }
      return this;
    },
    getLayer: function(id) {
      return this._layers[id];
    },
    getLayers: function() {
      var layers = [];
      for (var i in this._layers) {
        layers.push(this._layers[i]);
      }
      return layers;
    },
    setZIndex: function(zIndex) {
      return this.invoke('setZIndex', zIndex);
    },
    getLayerId: function(layer) {
      return L.stamp(layer);
    }
  });
  L.layerGroup = function(layers) {
    return new L.LayerGroup(layers);
  };
  L.FeatureGroup = L.LayerGroup.extend({
    includes: L.Mixin.Events,
    statics: {EVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'},
    addLayer: function(layer) {
      if (this.hasLayer(layer)) {
        return this;
      }
      if ('on' in layer) {
        layer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);
      }
      L.LayerGroup.prototype.addLayer.call(this, layer);
      if (this._popupContent && layer.bindPopup) {
        layer.bindPopup(this._popupContent, this._popupOptions);
      }
      return this.fire('layeradd', {layer: layer});
    },
    removeLayer: function(layer) {
      if (!this.hasLayer(layer)) {
        return this;
      }
      if (layer in this._layers) {
        layer = this._layers[layer];
      }
      if ('off' in layer) {
        layer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);
      }
      L.LayerGroup.prototype.removeLayer.call(this, layer);
      if (this._popupContent) {
        this.invoke('unbindPopup');
      }
      return this.fire('layerremove', {layer: layer});
    },
    bindPopup: function(content, options) {
      this._popupContent = content;
      this._popupOptions = options;
      return this.invoke('bindPopup', content, options);
    },
    openPopup: function(latlng) {
      for (var id in this._layers) {
        this._layers[id].openPopup(latlng);
        break;
      }
      return this;
    },
    setStyle: function(style) {
      return this.invoke('setStyle', style);
    },
    bringToFront: function() {
      return this.invoke('bringToFront');
    },
    bringToBack: function() {
      return this.invoke('bringToBack');
    },
    getBounds: function() {
      var bounds = new L.LatLngBounds();
      this.eachLayer(function(layer) {
        bounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());
      });
      return bounds;
    },
    _propagateEvent: function(e) {
      e = L.extend({
        layer: e.target,
        target: this
      }, e);
      this.fire(e.type, e);
    }
  });
  L.featureGroup = function(layers) {
    return new L.FeatureGroup(layers);
  };
  L.Path = L.Class.extend({
    includes: [L.Mixin.Events],
    statics: {CLIP_PADDING: (function() {
        var max = L.Browser.mobile ? 1280 : 2000,
            target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;
        return Math.max(0, Math.min(0.5, target));
      })()},
    options: {
      stroke: true,
      color: '#0033ff',
      dashArray: null,
      lineCap: null,
      lineJoin: null,
      weight: 5,
      opacity: 0.5,
      fill: false,
      fillColor: null,
      fillOpacity: 0.2,
      clickable: true
    },
    initialize: function(options) {
      L.setOptions(this, options);
    },
    onAdd: function(map) {
      this._map = map;
      if (!this._container) {
        this._initElements();
        this._initEvents();
      }
      this.projectLatlngs();
      this._updatePath();
      if (this._container) {
        this._map._pathRoot.appendChild(this._container);
      }
      this.fire('add');
      map.on({
        'viewreset': this.projectLatlngs,
        'moveend': this._updatePath
      }, this);
    },
    addTo: function(map) {
      map.addLayer(this);
      return this;
    },
    onRemove: function(map) {
      map._pathRoot.removeChild(this._container);
      this.fire('remove');
      this._map = null;
      if (L.Browser.vml) {
        this._container = null;
        this._stroke = null;
        this._fill = null;
      }
      map.off({
        'viewreset': this.projectLatlngs,
        'moveend': this._updatePath
      }, this);
    },
    projectLatlngs: function() {},
    setStyle: function(style) {
      L.setOptions(this, style);
      if (this._container) {
        this._updateStyle();
      }
      return this;
    },
    redraw: function() {
      if (this._map) {
        this.projectLatlngs();
        this._updatePath();
      }
      return this;
    }
  });
  L.Map.include({_updatePathViewport: function() {
      var p = L.Path.CLIP_PADDING,
          size = this.getSize(),
          panePos = L.DomUtil.getPosition(this._mapPane),
          min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),
          max = min.add(size.multiplyBy(1 + p * 2)._round());
      this._pathViewport = new L.Bounds(min, max);
    }});
  L.Path.SVG_NS = 'http://www.w3.org/2000/svg';
  L.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);
  L.Path = L.Path.extend({
    statics: {SVG: L.Browser.svg},
    bringToFront: function() {
      var root = this._map._pathRoot,
          path = this._container;
      if (path && root.lastChild !== path) {
        root.appendChild(path);
      }
      return this;
    },
    bringToBack: function() {
      var root = this._map._pathRoot,
          path = this._container,
          first = root.firstChild;
      if (path && first !== path) {
        root.insertBefore(path, first);
      }
      return this;
    },
    getPathString: function() {},
    _createElement: function(name) {
      return document.createElementNS(L.Path.SVG_NS, name);
    },
    _initElements: function() {
      this._map._initPathRoot();
      this._initPath();
      this._initStyle();
    },
    _initPath: function() {
      this._container = this._createElement('g');
      this._path = this._createElement('path');
      if (this.options.className) {
        L.DomUtil.addClass(this._path, this.options.className);
      }
      this._container.appendChild(this._path);
    },
    _initStyle: function() {
      if (this.options.stroke) {
        this._path.setAttribute('stroke-linejoin', 'round');
        this._path.setAttribute('stroke-linecap', 'round');
      }
      if (this.options.fill) {
        this._path.setAttribute('fill-rule', 'evenodd');
      }
      if (this.options.pointerEvents) {
        this._path.setAttribute('pointer-events', this.options.pointerEvents);
      }
      if (!this.options.clickable && !this.options.pointerEvents) {
        this._path.setAttribute('pointer-events', 'none');
      }
      this._updateStyle();
    },
    _updateStyle: function() {
      if (this.options.stroke) {
        this._path.setAttribute('stroke', this.options.color);
        this._path.setAttribute('stroke-opacity', this.options.opacity);
        this._path.setAttribute('stroke-width', this.options.weight);
        if (this.options.dashArray) {
          this._path.setAttribute('stroke-dasharray', this.options.dashArray);
        } else {
          this._path.removeAttribute('stroke-dasharray');
        }
        if (this.options.lineCap) {
          this._path.setAttribute('stroke-linecap', this.options.lineCap);
        }
        if (this.options.lineJoin) {
          this._path.setAttribute('stroke-linejoin', this.options.lineJoin);
        }
      } else {
        this._path.setAttribute('stroke', 'none');
      }
      if (this.options.fill) {
        this._path.setAttribute('fill', this.options.fillColor || this.options.color);
        this._path.setAttribute('fill-opacity', this.options.fillOpacity);
      } else {
        this._path.setAttribute('fill', 'none');
      }
    },
    _updatePath: function() {
      var str = this.getPathString();
      if (!str) {
        str = 'M0 0';
      }
      this._path.setAttribute('d', str);
    },
    _initEvents: function() {
      if (this.options.clickable) {
        if (L.Browser.svg || !L.Browser.vml) {
          L.DomUtil.addClass(this._path, 'leaflet-clickable');
        }
        L.DomEvent.on(this._container, 'click', this._onMouseClick, this);
        var events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'mousemove', 'contextmenu'];
        for (var i = 0; i < events.length; i++) {
          L.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);
        }
      }
    },
    _onMouseClick: function(e) {
      if (this._map.dragging && this._map.dragging.moved()) {
        return;
      }
      this._fireMouseEvent(e);
    },
    _fireMouseEvent: function(e) {
      if (!this._map || !this.hasEventListeners(e.type)) {
        return;
      }
      var map = this._map,
          containerPoint = map.mouseEventToContainerPoint(e),
          layerPoint = map.containerPointToLayerPoint(containerPoint),
          latlng = map.layerPointToLatLng(layerPoint);
      this.fire(e.type, {
        latlng: latlng,
        layerPoint: layerPoint,
        containerPoint: containerPoint,
        originalEvent: e
      });
      if (e.type === 'contextmenu') {
        L.DomEvent.preventDefault(e);
      }
      if (e.type !== 'mousemove') {
        L.DomEvent.stopPropagation(e);
      }
    }
  });
  L.Map.include({
    _initPathRoot: function() {
      if (!this._pathRoot) {
        this._pathRoot = L.Path.prototype._createElement('svg');
        this._panes.overlayPane.appendChild(this._pathRoot);
        if (this.options.zoomAnimation && L.Browser.any3d) {
          L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');
          this.on({
            'zoomanim': this._animatePathZoom,
            'zoomend': this._endPathZoom
          });
        } else {
          L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');
        }
        this.on('moveend', this._updateSvgViewport);
        this._updateSvgViewport();
      }
    },
    _animatePathZoom: function(e) {
      var scale = this.getZoomScale(e.zoom),
          offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);
      this._pathRoot.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';
      this._pathZooming = true;
    },
    _endPathZoom: function() {
      this._pathZooming = false;
    },
    _updateSvgViewport: function() {
      if (this._pathZooming) {
        return;
      }
      this._updatePathViewport();
      var vp = this._pathViewport,
          min = vp.min,
          max = vp.max,
          width = max.x - min.x,
          height = max.y - min.y,
          root = this._pathRoot,
          pane = this._panes.overlayPane;
      if (L.Browser.mobileWebkit) {
        pane.removeChild(root);
      }
      L.DomUtil.setPosition(root, min);
      root.setAttribute('width', width);
      root.setAttribute('height', height);
      root.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));
      if (L.Browser.mobileWebkit) {
        pane.appendChild(root);
      }
    }
  });
  L.Path.include({
    bindPopup: function(content, options) {
      if (content instanceof L.Popup) {
        this._popup = content;
      } else {
        if (!this._popup || options) {
          this._popup = new L.Popup(options, this);
        }
        this._popup.setContent(content);
      }
      if (!this._popupHandlersAdded) {
        this.on('click', this._openPopup, this).on('remove', this.closePopup, this);
        this._popupHandlersAdded = true;
      }
      return this;
    },
    unbindPopup: function() {
      if (this._popup) {
        this._popup = null;
        this.off('click', this._openPopup).off('remove', this.closePopup);
        this._popupHandlersAdded = false;
      }
      return this;
    },
    openPopup: function(latlng) {
      if (this._popup) {
        latlng = latlng || this._latlng || this._latlngs[Math.floor(this._latlngs.length / 2)];
        this._openPopup({latlng: latlng});
      }
      return this;
    },
    closePopup: function() {
      if (this._popup) {
        this._popup._close();
      }
      return this;
    },
    _openPopup: function(e) {
      this._popup.setLatLng(e.latlng);
      this._map.openPopup(this._popup);
    }
  });
  L.Browser.vml = !L.Browser.svg && (function() {
    try {
      var div = document.createElement('div');
      div.innerHTML = '<v:shape adj="1"/>';
      var shape = div.firstChild;
      shape.style.behavior = 'url(#default#VML)';
      return shape && (typeof shape.adj === 'object');
    } catch (e) {
      return false;
    }
  }());
  L.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({
    statics: {
      VML: true,
      CLIP_PADDING: 0.02
    },
    _createElement: (function() {
      try {
        document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
        return function(name) {
          return document.createElement('<lvml:' + name + ' class="lvml">');
        };
      } catch (e) {
        return function(name) {
          return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
      }
    }()),
    _initPath: function() {
      var container = this._container = this._createElement('shape');
      L.DomUtil.addClass(container, 'leaflet-vml-shape' + (this.options.className ? ' ' + this.options.className : ''));
      if (this.options.clickable) {
        L.DomUtil.addClass(container, 'leaflet-clickable');
      }
      container.coordsize = '1 1';
      this._path = this._createElement('path');
      container.appendChild(this._path);
      this._map._pathRoot.appendChild(container);
    },
    _initStyle: function() {
      this._updateStyle();
    },
    _updateStyle: function() {
      var stroke = this._stroke,
          fill = this._fill,
          options = this.options,
          container = this._container;
      container.stroked = options.stroke;
      container.filled = options.fill;
      if (options.stroke) {
        if (!stroke) {
          stroke = this._stroke = this._createElement('stroke');
          stroke.endcap = 'round';
          container.appendChild(stroke);
        }
        stroke.weight = options.weight + 'px';
        stroke.color = options.color;
        stroke.opacity = options.opacity;
        if (options.dashArray) {
          stroke.dashStyle = L.Util.isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');
        } else {
          stroke.dashStyle = '';
        }
        if (options.lineCap) {
          stroke.endcap = options.lineCap.replace('butt', 'flat');
        }
        if (options.lineJoin) {
          stroke.joinstyle = options.lineJoin;
        }
      } else if (stroke) {
        container.removeChild(stroke);
        this._stroke = null;
      }
      if (options.fill) {
        if (!fill) {
          fill = this._fill = this._createElement('fill');
          container.appendChild(fill);
        }
        fill.color = options.fillColor || options.color;
        fill.opacity = options.fillOpacity;
      } else if (fill) {
        container.removeChild(fill);
        this._fill = null;
      }
    },
    _updatePath: function() {
      var style = this._container.style;
      style.display = 'none';
      this._path.v = this.getPathString() + ' ';
      style.display = '';
    }
  });
  L.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {_initPathRoot: function() {
      if (this._pathRoot) {
        return;
      }
      var root = this._pathRoot = document.createElement('div');
      root.className = 'leaflet-vml-container';
      this._panes.overlayPane.appendChild(root);
      this.on('moveend', this._updatePathViewport);
      this._updatePathViewport();
    }});
  L.Browser.canvas = (function() {
    return !!document.createElement('canvas').getContext;
  }());
  L.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({
    statics: {
      CANVAS: true,
      SVG: false
    },
    redraw: function() {
      if (this._map) {
        this.projectLatlngs();
        this._requestUpdate();
      }
      return this;
    },
    setStyle: function(style) {
      L.setOptions(this, style);
      if (this._map) {
        this._updateStyle();
        this._requestUpdate();
      }
      return this;
    },
    onRemove: function(map) {
      map.off('viewreset', this.projectLatlngs, this).off('moveend', this._updatePath, this);
      if (this.options.clickable) {
        this._map.off('click', this._onClick, this);
        this._map.off('mousemove', this._onMouseMove, this);
      }
      this._requestUpdate();
      this.fire('remove');
      this._map = null;
    },
    _requestUpdate: function() {
      if (this._map && !L.Path._updateRequest) {
        L.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);
      }
    },
    _fireMapMoveEnd: function() {
      L.Path._updateRequest = null;
      this.fire('moveend');
    },
    _initElements: function() {
      this._map._initPathRoot();
      this._ctx = this._map._canvasCtx;
    },
    _updateStyle: function() {
      var options = this.options;
      if (options.stroke) {
        this._ctx.lineWidth = options.weight;
        this._ctx.strokeStyle = options.color;
      }
      if (options.fill) {
        this._ctx.fillStyle = options.fillColor || options.color;
      }
      if (options.lineCap) {
        this._ctx.lineCap = options.lineCap;
      }
      if (options.lineJoin) {
        this._ctx.lineJoin = options.lineJoin;
      }
    },
    _drawPath: function() {
      var i,
          j,
          len,
          len2,
          point,
          drawMethod;
      this._ctx.beginPath();
      for (i = 0, len = this._parts.length; i < len; i++) {
        for (j = 0, len2 = this._parts[i].length; j < len2; j++) {
          point = this._parts[i][j];
          drawMethod = (j === 0 ? 'move' : 'line') + 'To';
          this._ctx[drawMethod](point.x, point.y);
        }
        if (this instanceof L.Polygon) {
          this._ctx.closePath();
        }
      }
    },
    _checkIfEmpty: function() {
      return !this._parts.length;
    },
    _updatePath: function() {
      if (this._checkIfEmpty()) {
        return;
      }
      var ctx = this._ctx,
          options = this.options;
      this._drawPath();
      ctx.save();
      this._updateStyle();
      if (options.fill) {
        ctx.globalAlpha = options.fillOpacity;
        ctx.fill(options.fillRule || 'evenodd');
      }
      if (options.stroke) {
        ctx.globalAlpha = options.opacity;
        ctx.stroke();
      }
      ctx.restore();
    },
    _initEvents: function() {
      if (this.options.clickable) {
        this._map.on('mousemove', this._onMouseMove, this);
        this._map.on('click dblclick contextmenu', this._fireMouseEvent, this);
      }
    },
    _fireMouseEvent: function(e) {
      if (this._containsPoint(e.layerPoint)) {
        this.fire(e.type, e);
      }
    },
    _onMouseMove: function(e) {
      if (!this._map || this._map._animatingZoom) {
        return;
      }
      if (this._containsPoint(e.layerPoint)) {
        this._ctx.canvas.style.cursor = 'pointer';
        this._mouseInside = true;
        this.fire('mouseover', e);
      } else if (this._mouseInside) {
        this._ctx.canvas.style.cursor = '';
        this._mouseInside = false;
        this.fire('mouseout', e);
      }
    }
  });
  L.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {
    _initPathRoot: function() {
      var root = this._pathRoot,
          ctx;
      if (!root) {
        root = this._pathRoot = document.createElement('canvas');
        root.style.position = 'absolute';
        ctx = this._canvasCtx = root.getContext('2d');
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        this._panes.overlayPane.appendChild(root);
        if (this.options.zoomAnimation) {
          this._pathRoot.className = 'leaflet-zoom-animated';
          this.on('zoomanim', this._animatePathZoom);
          this.on('zoomend', this._endPathZoom);
        }
        this.on('moveend', this._updateCanvasViewport);
        this._updateCanvasViewport();
      }
    },
    _updateCanvasViewport: function() {
      if (this._pathZooming) {
        return;
      }
      this._updatePathViewport();
      var vp = this._pathViewport,
          min = vp.min,
          size = vp.max.subtract(min),
          root = this._pathRoot;
      L.DomUtil.setPosition(root, min);
      root.width = size.x;
      root.height = size.y;
      root.getContext('2d').translate(-min.x, -min.y);
    }
  });
  L.LineUtil = {
    simplify: function(points, tolerance) {
      if (!tolerance || !points.length) {
        return points.slice();
      }
      var sqTolerance = tolerance * tolerance;
      points = this._reducePoints(points, sqTolerance);
      points = this._simplifyDP(points, sqTolerance);
      return points;
    },
    pointToSegmentDistance: function(p, p1, p2) {
      return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
    },
    closestPointOnSegment: function(p, p1, p2) {
      return this._sqClosestPointOnSegment(p, p1, p2);
    },
    _simplifyDP: function(points, sqTolerance) {
      var len = points.length,
          ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
          markers = new ArrayConstructor(len);
      markers[0] = markers[len - 1] = 1;
      this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
      var i,
          newPoints = [];
      for (i = 0; i < len; i++) {
        if (markers[i]) {
          newPoints.push(points[i]);
        }
      }
      return newPoints;
    },
    _simplifyDPStep: function(points, markers, sqTolerance, first, last) {
      var maxSqDist = 0,
          index,
          i,
          sqDist;
      for (i = first + 1; i <= last - 1; i++) {
        sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);
        if (sqDist > maxSqDist) {
          index = i;
          maxSqDist = sqDist;
        }
      }
      if (maxSqDist > sqTolerance) {
        markers[index] = 1;
        this._simplifyDPStep(points, markers, sqTolerance, first, index);
        this._simplifyDPStep(points, markers, sqTolerance, index, last);
      }
    },
    _reducePoints: function(points, sqTolerance) {
      var reducedPoints = [points[0]];
      for (var i = 1,
          prev = 0,
          len = points.length; i < len; i++) {
        if (this._sqDist(points[i], points[prev]) > sqTolerance) {
          reducedPoints.push(points[i]);
          prev = i;
        }
      }
      if (prev < len - 1) {
        reducedPoints.push(points[len - 1]);
      }
      return reducedPoints;
    },
    clipSegment: function(a, b, bounds, useLastCode) {
      var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
          codeB = this._getBitCode(b, bounds),
          codeOut,
          p,
          newCode;
      this._lastCode = codeB;
      while (true) {
        if (!(codeA | codeB)) {
          return [a, b];
        } else if (codeA & codeB) {
          return false;
        } else {
          codeOut = codeA || codeB;
          p = this._getEdgeIntersection(a, b, codeOut, bounds);
          newCode = this._getBitCode(p, bounds);
          if (codeOut === codeA) {
            a = p;
            codeA = newCode;
          } else {
            b = p;
            codeB = newCode;
          }
        }
      }
    },
    _getEdgeIntersection: function(a, b, code, bounds) {
      var dx = b.x - a.x,
          dy = b.y - a.y,
          min = bounds.min,
          max = bounds.max;
      if (code & 8) {
        return new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);
      } else if (code & 4) {
        return new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);
      } else if (code & 2) {
        return new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);
      } else if (code & 1) {
        return new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);
      }
    },
    _getBitCode: function(p, bounds) {
      var code = 0;
      if (p.x < bounds.min.x) {
        code |= 1;
      } else if (p.x > bounds.max.x) {
        code |= 2;
      }
      if (p.y < bounds.min.y) {
        code |= 4;
      } else if (p.y > bounds.max.y) {
        code |= 8;
      }
      return code;
    },
    _sqDist: function(p1, p2) {
      var dx = p2.x - p1.x,
          dy = p2.y - p1.y;
      return dx * dx + dy * dy;
    },
    _sqClosestPointOnSegment: function(p, p1, p2, sqDist) {
      var x = p1.x,
          y = p1.y,
          dx = p2.x - x,
          dy = p2.y - y,
          dot = dx * dx + dy * dy,
          t;
      if (dot > 0) {
        t = ((p.x - x) * dx + (p.y - y) * dy) / dot;
        if (t > 1) {
          x = p2.x;
          y = p2.y;
        } else if (t > 0) {
          x += dx * t;
          y += dy * t;
        }
      }
      dx = p.x - x;
      dy = p.y - y;
      return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
    }
  };
  L.Polyline = L.Path.extend({
    initialize: function(latlngs, options) {
      L.Path.prototype.initialize.call(this, options);
      this._latlngs = this._convertLatLngs(latlngs);
    },
    options: {
      smoothFactor: 1.0,
      noClip: false
    },
    projectLatlngs: function() {
      this._originalPoints = [];
      for (var i = 0,
          len = this._latlngs.length; i < len; i++) {
        this._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);
      }
    },
    getPathString: function() {
      for (var i = 0,
          len = this._parts.length,
          str = ''; i < len; i++) {
        str += this._getPathPartStr(this._parts[i]);
      }
      return str;
    },
    getLatLngs: function() {
      return this._latlngs;
    },
    setLatLngs: function(latlngs) {
      this._latlngs = this._convertLatLngs(latlngs);
      return this.redraw();
    },
    addLatLng: function(latlng) {
      this._latlngs.push(L.latLng(latlng));
      return this.redraw();
    },
    spliceLatLngs: function() {
      var removed = [].splice.apply(this._latlngs, arguments);
      this._convertLatLngs(this._latlngs, true);
      this.redraw();
      return removed;
    },
    closestLayerPoint: function(p) {
      var minDistance = Infinity,
          parts = this._parts,
          p1,
          p2,
          minPoint = null;
      for (var j = 0,
          jLen = parts.length; j < jLen; j++) {
        var points = parts[j];
        for (var i = 1,
            len = points.length; i < len; i++) {
          p1 = points[i - 1];
          p2 = points[i];
          var sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);
          if (sqDist < minDistance) {
            minDistance = sqDist;
            minPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);
          }
        }
      }
      if (minPoint) {
        minPoint.distance = Math.sqrt(minDistance);
      }
      return minPoint;
    },
    getBounds: function() {
      return new L.LatLngBounds(this.getLatLngs());
    },
    _convertLatLngs: function(latlngs, overwrite) {
      var i,
          len,
          target = overwrite ? latlngs : [];
      for (i = 0, len = latlngs.length; i < len; i++) {
        if (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {
          return;
        }
        target[i] = L.latLng(latlngs[i]);
      }
      return target;
    },
    _initEvents: function() {
      L.Path.prototype._initEvents.call(this);
    },
    _getPathPartStr: function(points) {
      var round = L.Path.VML;
      for (var j = 0,
          len2 = points.length,
          str = '',
          p; j < len2; j++) {
        p = points[j];
        if (round) {
          p._round();
        }
        str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
      }
      return str;
    },
    _clipPoints: function() {
      var points = this._originalPoints,
          len = points.length,
          i,
          k,
          segment;
      if (this.options.noClip) {
        this._parts = [points];
        return;
      }
      this._parts = [];
      var parts = this._parts,
          vp = this._map._pathViewport,
          lu = L.LineUtil;
      for (i = 0, k = 0; i < len - 1; i++) {
        segment = lu.clipSegment(points[i], points[i + 1], vp, i);
        if (!segment) {
          continue;
        }
        parts[k] = parts[k] || [];
        parts[k].push(segment[0]);
        if ((segment[1] !== points[i + 1]) || (i === len - 2)) {
          parts[k].push(segment[1]);
          k++;
        }
      }
    },
    _simplifyPoints: function() {
      var parts = this._parts,
          lu = L.LineUtil;
      for (var i = 0,
          len = parts.length; i < len; i++) {
        parts[i] = lu.simplify(parts[i], this.options.smoothFactor);
      }
    },
    _updatePath: function() {
      if (!this._map) {
        return;
      }
      this._clipPoints();
      this._simplifyPoints();
      L.Path.prototype._updatePath.call(this);
    }
  });
  L.polyline = function(latlngs, options) {
    return new L.Polyline(latlngs, options);
  };
  L.PolyUtil = {};
  L.PolyUtil.clipPolygon = function(points, bounds) {
    var clippedPoints,
        edges = [1, 4, 2, 8],
        i,
        j,
        k,
        a,
        b,
        len,
        edge,
        p,
        lu = L.LineUtil;
    for (i = 0, len = points.length; i < len; i++) {
      points[i]._code = lu._getBitCode(points[i], bounds);
    }
    for (k = 0; k < 4; k++) {
      edge = edges[k];
      clippedPoints = [];
      for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
        a = points[i];
        b = points[j];
        if (!(a._code & edge)) {
          if (b._code & edge) {
            p = lu._getEdgeIntersection(b, a, edge, bounds);
            p._code = lu._getBitCode(p, bounds);
            clippedPoints.push(p);
          }
          clippedPoints.push(a);
        } else if (!(b._code & edge)) {
          p = lu._getEdgeIntersection(b, a, edge, bounds);
          p._code = lu._getBitCode(p, bounds);
          clippedPoints.push(p);
        }
      }
      points = clippedPoints;
    }
    return points;
  };
  L.Polygon = L.Polyline.extend({
    options: {fill: true},
    initialize: function(latlngs, options) {
      L.Polyline.prototype.initialize.call(this, latlngs, options);
      this._initWithHoles(latlngs);
    },
    _initWithHoles: function(latlngs) {
      var i,
          len,
          hole;
      if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
        this._latlngs = this._convertLatLngs(latlngs[0]);
        this._holes = latlngs.slice(1);
        for (i = 0, len = this._holes.length; i < len; i++) {
          hole = this._holes[i] = this._convertLatLngs(this._holes[i]);
          if (hole[0].equals(hole[hole.length - 1])) {
            hole.pop();
          }
        }
      }
      latlngs = this._latlngs;
      if (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {
        latlngs.pop();
      }
    },
    projectLatlngs: function() {
      L.Polyline.prototype.projectLatlngs.call(this);
      this._holePoints = [];
      if (!this._holes) {
        return;
      }
      var i,
          j,
          len,
          len2;
      for (i = 0, len = this._holes.length; i < len; i++) {
        this._holePoints[i] = [];
        for (j = 0, len2 = this._holes[i].length; j < len2; j++) {
          this._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);
        }
      }
    },
    setLatLngs: function(latlngs) {
      if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
        this._initWithHoles(latlngs);
        return this.redraw();
      } else {
        return L.Polyline.prototype.setLatLngs.call(this, latlngs);
      }
    },
    _clipPoints: function() {
      var points = this._originalPoints,
          newParts = [];
      this._parts = [points].concat(this._holePoints);
      if (this.options.noClip) {
        return;
      }
      for (var i = 0,
          len = this._parts.length; i < len; i++) {
        var clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);
        if (clipped.length) {
          newParts.push(clipped);
        }
      }
      this._parts = newParts;
    },
    _getPathPartStr: function(points) {
      var str = L.Polyline.prototype._getPathPartStr.call(this, points);
      return str + (L.Browser.svg ? 'z' : 'x');
    }
  });
  L.polygon = function(latlngs, options) {
    return new L.Polygon(latlngs, options);
  };
  (function() {
    function createMulti(Klass) {
      return L.FeatureGroup.extend({
        initialize: function(latlngs, options) {
          this._layers = {};
          this._options = options;
          this.setLatLngs(latlngs);
        },
        setLatLngs: function(latlngs) {
          var i = 0,
              len = latlngs.length;
          this.eachLayer(function(layer) {
            if (i < len) {
              layer.setLatLngs(latlngs[i++]);
            } else {
              this.removeLayer(layer);
            }
          }, this);
          while (i < len) {
            this.addLayer(new Klass(latlngs[i++], this._options));
          }
          return this;
        },
        getLatLngs: function() {
          var latlngs = [];
          this.eachLayer(function(layer) {
            latlngs.push(layer.getLatLngs());
          });
          return latlngs;
        }
      });
    }
    L.MultiPolyline = createMulti(L.Polyline);
    L.MultiPolygon = createMulti(L.Polygon);
    L.multiPolyline = function(latlngs, options) {
      return new L.MultiPolyline(latlngs, options);
    };
    L.multiPolygon = function(latlngs, options) {
      return new L.MultiPolygon(latlngs, options);
    };
  }());
  L.Rectangle = L.Polygon.extend({
    initialize: function(latLngBounds, options) {
      L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
    },
    setBounds: function(latLngBounds) {
      this.setLatLngs(this._boundsToLatLngs(latLngBounds));
    },
    _boundsToLatLngs: function(latLngBounds) {
      latLngBounds = L.latLngBounds(latLngBounds);
      return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];
    }
  });
  L.rectangle = function(latLngBounds, options) {
    return new L.Rectangle(latLngBounds, options);
  };
  L.Circle = L.Path.extend({
    initialize: function(latlng, radius, options) {
      L.Path.prototype.initialize.call(this, options);
      this._latlng = L.latLng(latlng);
      this._mRadius = radius;
    },
    options: {fill: true},
    setLatLng: function(latlng) {
      this._latlng = L.latLng(latlng);
      return this.redraw();
    },
    setRadius: function(radius) {
      this._mRadius = radius;
      return this.redraw();
    },
    projectLatlngs: function() {
      var lngRadius = this._getLngRadius(),
          latlng = this._latlng,
          pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);
      this._point = this._map.latLngToLayerPoint(latlng);
      this._radius = Math.max(this._point.x - pointLeft.x, 1);
    },
    getBounds: function() {
      var lngRadius = this._getLngRadius(),
          latRadius = (this._mRadius / 40075017) * 360,
          latlng = this._latlng;
      return new L.LatLngBounds([latlng.lat - latRadius, latlng.lng - lngRadius], [latlng.lat + latRadius, latlng.lng + lngRadius]);
    },
    getLatLng: function() {
      return this._latlng;
    },
    getPathString: function() {
      var p = this._point,
          r = this._radius;
      if (this._checkIfEmpty()) {
        return '';
      }
      if (L.Browser.svg) {
        return 'M' + p.x + ',' + (p.y - r) + 'A' + r + ',' + r + ',0,1,1,' + (p.x - 0.1) + ',' + (p.y - r) + ' z';
      } else {
        p._round();
        r = Math.round(r);
        return 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);
      }
    },
    getRadius: function() {
      return this._mRadius;
    },
    _getLatRadius: function() {
      return (this._mRadius / 40075017) * 360;
    },
    _getLngRadius: function() {
      return this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);
    },
    _checkIfEmpty: function() {
      if (!this._map) {
        return false;
      }
      var vp = this._map._pathViewport,
          r = this._radius,
          p = this._point;
      return p.x - r > vp.max.x || p.y - r > vp.max.y || p.x + r < vp.min.x || p.y + r < vp.min.y;
    }
  });
  L.circle = function(latlng, radius, options) {
    return new L.Circle(latlng, radius, options);
  };
  L.CircleMarker = L.Circle.extend({
    options: {
      radius: 10,
      weight: 2
    },
    initialize: function(latlng, options) {
      L.Circle.prototype.initialize.call(this, latlng, null, options);
      this._radius = this.options.radius;
    },
    projectLatlngs: function() {
      this._point = this._map.latLngToLayerPoint(this._latlng);
    },
    _updateStyle: function() {
      L.Circle.prototype._updateStyle.call(this);
      this.setRadius(this.options.radius);
    },
    setLatLng: function(latlng) {
      L.Circle.prototype.setLatLng.call(this, latlng);
      if (this._popup && this._popup._isOpen) {
        this._popup.setLatLng(latlng);
      }
      return this;
    },
    setRadius: function(radius) {
      this.options.radius = this._radius = radius;
      return this.redraw();
    },
    getRadius: function() {
      return this._radius;
    }
  });
  L.circleMarker = function(latlng, options) {
    return new L.CircleMarker(latlng, options);
  };
  L.Polyline.include(!L.Path.CANVAS ? {} : {_containsPoint: function(p, closed) {
      var i,
          j,
          k,
          len,
          len2,
          dist,
          part,
          w = this.options.weight / 2;
      if (L.Browser.touch) {
        w += 10;
      }
      for (i = 0, len = this._parts.length; i < len; i++) {
        part = this._parts[i];
        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
          if (!closed && (j === 0)) {
            continue;
          }
          dist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);
          if (dist <= w) {
            return true;
          }
        }
      }
      return false;
    }});
  L.Polygon.include(!L.Path.CANVAS ? {} : {_containsPoint: function(p) {
      var inside = false,
          part,
          p1,
          p2,
          i,
          j,
          k,
          len,
          len2;
      if (L.Polyline.prototype._containsPoint.call(this, p, true)) {
        return true;
      }
      for (i = 0, len = this._parts.length; i < len; i++) {
        part = this._parts[i];
        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
          p1 = part[j];
          p2 = part[k];
          if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
            inside = !inside;
          }
        }
      }
      return inside;
    }});
  L.Circle.include(!L.Path.CANVAS ? {} : {
    _drawPath: function() {
      var p = this._point;
      this._ctx.beginPath();
      this._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);
    },
    _containsPoint: function(p) {
      var center = this._point,
          w2 = this.options.stroke ? this.options.weight / 2 : 0;
      return (p.distanceTo(center) <= this._radius + w2);
    }
  });
  L.CircleMarker.include(!L.Path.CANVAS ? {} : {_updateStyle: function() {
      L.Path.prototype._updateStyle.call(this);
    }});
  L.GeoJSON = L.FeatureGroup.extend({
    initialize: function(geojson, options) {
      L.setOptions(this, options);
      this._layers = {};
      if (geojson) {
        this.addData(geojson);
      }
    },
    addData: function(geojson) {
      var features = L.Util.isArray(geojson) ? geojson : geojson.features,
          i,
          len,
          feature;
      if (features) {
        for (i = 0, len = features.length; i < len; i++) {
          feature = features[i];
          if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
            this.addData(features[i]);
          }
        }
        return this;
      }
      var options = this.options;
      if (options.filter && !options.filter(geojson)) {
        return;
      }
      var layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);
      layer.feature = L.GeoJSON.asFeature(geojson);
      layer.defaultOptions = layer.options;
      this.resetStyle(layer);
      if (options.onEachFeature) {
        options.onEachFeature(geojson, layer);
      }
      return this.addLayer(layer);
    },
    resetStyle: function(layer) {
      var style = this.options.style;
      if (style) {
        L.Util.extend(layer.options, layer.defaultOptions);
        this._setLayerStyle(layer, style);
      }
    },
    setStyle: function(style) {
      this.eachLayer(function(layer) {
        this._setLayerStyle(layer, style);
      }, this);
    },
    _setLayerStyle: function(layer, style) {
      if (typeof style === 'function') {
        style = style(layer.feature);
      }
      if (layer.setStyle) {
        layer.setStyle(style);
      }
    }
  });
  L.extend(L.GeoJSON, {
    geometryToLayer: function(geojson, pointToLayer, coordsToLatLng, vectorOptions) {
      var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
          coords = geometry.coordinates,
          layers = [],
          latlng,
          latlngs,
          i,
          len;
      coordsToLatLng = coordsToLatLng || this.coordsToLatLng;
      switch (geometry.type) {
        case 'Point':
          latlng = coordsToLatLng(coords);
          return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);
        case 'MultiPoint':
          for (i = 0, len = coords.length; i < len; i++) {
            latlng = coordsToLatLng(coords[i]);
            layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
          }
          return new L.FeatureGroup(layers);
        case 'LineString':
          latlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);
          return new L.Polyline(latlngs, vectorOptions);
        case 'Polygon':
          if (coords.length === 2 && !coords[1].length) {
            throw new Error('Invalid GeoJSON object.');
          }
          latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
          return new L.Polygon(latlngs, vectorOptions);
        case 'MultiLineString':
          latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
          return new L.MultiPolyline(latlngs, vectorOptions);
        case 'MultiPolygon':
          latlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);
          return new L.MultiPolygon(latlngs, vectorOptions);
        case 'GeometryCollection':
          for (i = 0, len = geometry.geometries.length; i < len; i++) {
            layers.push(this.geometryToLayer({
              geometry: geometry.geometries[i],
              type: 'Feature',
              properties: geojson.properties
            }, pointToLayer, coordsToLatLng, vectorOptions));
          }
          return new L.FeatureGroup(layers);
        default:
          throw new Error('Invalid GeoJSON object.');
      }
    },
    coordsToLatLng: function(coords) {
      return new L.LatLng(coords[1], coords[0], coords[2]);
    },
    coordsToLatLngs: function(coords, levelsDeep, coordsToLatLng) {
      var latlng,
          i,
          len,
          latlngs = [];
      for (i = 0, len = coords.length; i < len; i++) {
        latlng = levelsDeep ? this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) : (coordsToLatLng || this.coordsToLatLng)(coords[i]);
        latlngs.push(latlng);
      }
      return latlngs;
    },
    latLngToCoords: function(latlng) {
      var coords = [latlng.lng, latlng.lat];
      if (latlng.alt !== undefined) {
        coords.push(latlng.alt);
      }
      return coords;
    },
    latLngsToCoords: function(latLngs) {
      var coords = [];
      for (var i = 0,
          len = latLngs.length; i < len; i++) {
        coords.push(L.GeoJSON.latLngToCoords(latLngs[i]));
      }
      return coords;
    },
    getFeature: function(layer, newGeometry) {
      return layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);
    },
    asFeature: function(geoJSON) {
      if (geoJSON.type === 'Feature') {
        return geoJSON;
      }
      return {
        type: 'Feature',
        properties: {},
        geometry: geoJSON
      };
    }
  });
  var PointToGeoJSON = {toGeoJSON: function() {
      return L.GeoJSON.getFeature(this, {
        type: 'Point',
        coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
      });
    }};
  L.Marker.include(PointToGeoJSON);
  L.Circle.include(PointToGeoJSON);
  L.CircleMarker.include(PointToGeoJSON);
  L.Polyline.include({toGeoJSON: function() {
      return L.GeoJSON.getFeature(this, {
        type: 'LineString',
        coordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())
      });
    }});
  L.Polygon.include({toGeoJSON: function() {
      var coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],
          i,
          len,
          hole;
      coords[0].push(coords[0][0]);
      if (this._holes) {
        for (i = 0, len = this._holes.length; i < len; i++) {
          hole = L.GeoJSON.latLngsToCoords(this._holes[i]);
          hole.push(hole[0]);
          coords.push(hole);
        }
      }
      return L.GeoJSON.getFeature(this, {
        type: 'Polygon',
        coordinates: coords
      });
    }});
  (function() {
    function multiToGeoJSON(type) {
      return function() {
        var coords = [];
        this.eachLayer(function(layer) {
          coords.push(layer.toGeoJSON().geometry.coordinates);
        });
        return L.GeoJSON.getFeature(this, {
          type: type,
          coordinates: coords
        });
      };
    }
    L.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});
    L.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});
    L.LayerGroup.include({toGeoJSON: function() {
        var geometry = this.feature && this.feature.geometry,
            jsons = [],
            json;
        if (geometry && geometry.type === 'MultiPoint') {
          return multiToGeoJSON('MultiPoint').call(this);
        }
        var isGeometryCollection = geometry && geometry.type === 'GeometryCollection';
        this.eachLayer(function(layer) {
          if (layer.toGeoJSON) {
            json = layer.toGeoJSON();
            jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
          }
        });
        if (isGeometryCollection) {
          return L.GeoJSON.getFeature(this, {
            geometries: jsons,
            type: 'GeometryCollection'
          });
        }
        return {
          type: 'FeatureCollection',
          features: jsons
        };
      }});
  }());
  L.geoJson = function(geojson, options) {
    return new L.GeoJSON(geojson, options);
  };
  L.DomEvent = {
    addListener: function(obj, type, fn, context) {
      var id = L.stamp(fn),
          key = '_leaflet_' + type + id,
          handler,
          originalHandler,
          newType;
      if (obj[key]) {
        return this;
      }
      handler = function(e) {
        return fn.call(context || obj, e || L.DomEvent._getEvent());
      };
      if (L.Browser.pointer && type.indexOf('touch') === 0) {
        return this.addPointerListener(obj, type, handler, id);
      }
      if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
        this.addDoubleTapListener(obj, handler, id);
      }
      if ('addEventListener' in obj) {
        if (type === 'mousewheel') {
          obj.addEventListener('DOMMouseScroll', handler, false);
          obj.addEventListener(type, handler, false);
        } else if ((type === 'mouseenter') || (type === 'mouseleave')) {
          originalHandler = handler;
          newType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');
          handler = function(e) {
            if (!L.DomEvent._checkMouse(obj, e)) {
              return;
            }
            return originalHandler(e);
          };
          obj.addEventListener(newType, handler, false);
        } else if (type === 'click' && L.Browser.android) {
          originalHandler = handler;
          handler = function(e) {
            return L.DomEvent._filterClick(e, originalHandler);
          };
          obj.addEventListener(type, handler, false);
        } else {
          obj.addEventListener(type, handler, false);
        }
      } else if ('attachEvent' in obj) {
        obj.attachEvent('on' + type, handler);
      }
      obj[key] = handler;
      return this;
    },
    removeListener: function(obj, type, fn) {
      var id = L.stamp(fn),
          key = '_leaflet_' + type + id,
          handler = obj[key];
      if (!handler) {
        return this;
      }
      if (L.Browser.pointer && type.indexOf('touch') === 0) {
        this.removePointerListener(obj, type, id);
      } else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
        this.removeDoubleTapListener(obj, id);
      } else if ('removeEventListener' in obj) {
        if (type === 'mousewheel') {
          obj.removeEventListener('DOMMouseScroll', handler, false);
          obj.removeEventListener(type, handler, false);
        } else if ((type === 'mouseenter') || (type === 'mouseleave')) {
          obj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);
        } else {
          obj.removeEventListener(type, handler, false);
        }
      } else if ('detachEvent' in obj) {
        obj.detachEvent('on' + type, handler);
      }
      obj[key] = null;
      return this;
    },
    stopPropagation: function(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        e.cancelBubble = true;
      }
      L.DomEvent._skipped(e);
      return this;
    },
    disableScrollPropagation: function(el) {
      var stop = L.DomEvent.stopPropagation;
      return L.DomEvent.on(el, 'mousewheel', stop).on(el, 'MozMousePixelScroll', stop);
    },
    disableClickPropagation: function(el) {
      var stop = L.DomEvent.stopPropagation;
      for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
        L.DomEvent.on(el, L.Draggable.START[i], stop);
      }
      return L.DomEvent.on(el, 'click', L.DomEvent._fakeStop).on(el, 'dblclick', stop);
    },
    preventDefault: function(e) {
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }
      return this;
    },
    stop: function(e) {
      return L.DomEvent.preventDefault(e).stopPropagation(e);
    },
    getMousePosition: function(e, container) {
      if (!container) {
        return new L.Point(e.clientX, e.clientY);
      }
      var rect = container.getBoundingClientRect();
      return new L.Point(e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop);
    },
    getWheelDelta: function(e) {
      var delta = 0;
      if (e.wheelDelta) {
        delta = e.wheelDelta / 120;
      }
      if (e.detail) {
        delta = -e.detail / 3;
      }
      return delta;
    },
    _skipEvents: {},
    _fakeStop: function(e) {
      L.DomEvent._skipEvents[e.type] = true;
    },
    _skipped: function(e) {
      var skipped = this._skipEvents[e.type];
      this._skipEvents[e.type] = false;
      return skipped;
    },
    _checkMouse: function(el, e) {
      var related = e.relatedTarget;
      if (!related) {
        return true;
      }
      try {
        while (related && (related !== el)) {
          related = related.parentNode;
        }
      } catch (err) {
        return false;
      }
      return (related !== el);
    },
    _getEvent: function() {
      var e = window.event;
      if (!e) {
        var caller = arguments.callee.caller;
        while (caller) {
          e = caller['arguments'][0];
          if (e && window.Event === e.constructor) {
            break;
          }
          caller = caller.caller;
        }
      }
      return e;
    },
    _filterClick: function(e, handler) {
      var timeStamp = (e.timeStamp || e.originalEvent.timeStamp),
          elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);
      if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
        L.DomEvent.stop(e);
        return;
      }
      L.DomEvent._lastClick = timeStamp;
      return handler(e);
    }
  };
  L.DomEvent.on = L.DomEvent.addListener;
  L.DomEvent.off = L.DomEvent.removeListener;
  L.Draggable = L.Class.extend({
    includes: L.Mixin.Events,
    statics: {
      START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
      END: {
        mousedown: 'mouseup',
        touchstart: 'touchend',
        pointerdown: 'touchend',
        MSPointerDown: 'touchend'
      },
      MOVE: {
        mousedown: 'mousemove',
        touchstart: 'touchmove',
        pointerdown: 'touchmove',
        MSPointerDown: 'touchmove'
      }
    },
    initialize: function(element, dragStartTarget) {
      this._element = element;
      this._dragStartTarget = dragStartTarget || element;
    },
    enable: function() {
      if (this._enabled) {
        return;
      }
      for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
        L.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
      }
      this._enabled = true;
    },
    disable: function() {
      if (!this._enabled) {
        return;
      }
      for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
        L.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
      }
      this._enabled = false;
      this._moved = false;
    },
    _onDown: function(e) {
      this._moved = false;
      if (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) {
        return;
      }
      L.DomEvent.stopPropagation(e);
      if (L.Draggable._disabled) {
        return;
      }
      L.DomUtil.disableImageDrag();
      L.DomUtil.disableTextSelection();
      if (this._moving) {
        return;
      }
      var first = e.touches ? e.touches[0] : e;
      this._startPoint = new L.Point(first.clientX, first.clientY);
      this._startPos = this._newPos = L.DomUtil.getPosition(this._element);
      L.DomEvent.on(document, L.Draggable.MOVE[e.type], this._onMove, this).on(document, L.Draggable.END[e.type], this._onUp, this);
    },
    _onMove: function(e) {
      if (e.touches && e.touches.length > 1) {
        this._moved = true;
        return;
      }
      var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
          newPoint = new L.Point(first.clientX, first.clientY),
          offset = newPoint.subtract(this._startPoint);
      if (!offset.x && !offset.y) {
        return;
      }
      if (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) {
        return;
      }
      L.DomEvent.preventDefault(e);
      if (!this._moved) {
        this.fire('dragstart');
        this._moved = true;
        this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);
        L.DomUtil.addClass(document.body, 'leaflet-dragging');
        this._lastTarget = e.target || e.srcElement;
        L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
      }
      this._newPos = this._startPos.add(offset);
      this._moving = true;
      L.Util.cancelAnimFrame(this._animRequest);
      this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);
    },
    _updatePosition: function() {
      this.fire('predrag');
      L.DomUtil.setPosition(this._element, this._newPos);
      this.fire('drag');
    },
    _onUp: function() {
      L.DomUtil.removeClass(document.body, 'leaflet-dragging');
      if (this._lastTarget) {
        L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
        this._lastTarget = null;
      }
      for (var i in L.Draggable.MOVE) {
        L.DomEvent.off(document, L.Draggable.MOVE[i], this._onMove).off(document, L.Draggable.END[i], this._onUp);
      }
      L.DomUtil.enableImageDrag();
      L.DomUtil.enableTextSelection();
      if (this._moved && this._moving) {
        L.Util.cancelAnimFrame(this._animRequest);
        this.fire('dragend', {distance: this._newPos.distanceTo(this._startPos)});
      }
      this._moving = false;
    }
  });
  L.Handler = L.Class.extend({
    initialize: function(map) {
      this._map = map;
    },
    enable: function() {
      if (this._enabled) {
        return;
      }
      this._enabled = true;
      this.addHooks();
    },
    disable: function() {
      if (!this._enabled) {
        return;
      }
      this._enabled = false;
      this.removeHooks();
    },
    enabled: function() {
      return !!this._enabled;
    }
  });
  L.Map.mergeOptions({
    dragging: true,
    inertia: !L.Browser.android23,
    inertiaDeceleration: 3400,
    inertiaMaxSpeed: Infinity,
    inertiaThreshold: L.Browser.touch ? 32 : 18,
    easeLinearity: 0.25,
    worldCopyJump: false
  });
  L.Map.Drag = L.Handler.extend({
    addHooks: function() {
      if (!this._draggable) {
        var map = this._map;
        this._draggable = new L.Draggable(map._mapPane, map._container);
        this._draggable.on({
          'dragstart': this._onDragStart,
          'drag': this._onDrag,
          'dragend': this._onDragEnd
        }, this);
        if (map.options.worldCopyJump) {
          this._draggable.on('predrag', this._onPreDrag, this);
          map.on('viewreset', this._onViewReset, this);
          map.whenReady(this._onViewReset, this);
        }
      }
      this._draggable.enable();
    },
    removeHooks: function() {
      this._draggable.disable();
    },
    moved: function() {
      return this._draggable && this._draggable._moved;
    },
    _onDragStart: function() {
      var map = this._map;
      if (map._panAnim) {
        map._panAnim.stop();
      }
      map.fire('movestart').fire('dragstart');
      if (map.options.inertia) {
        this._positions = [];
        this._times = [];
      }
    },
    _onDrag: function() {
      if (this._map.options.inertia) {
        var time = this._lastTime = +new Date(),
            pos = this._lastPos = this._draggable._newPos;
        this._positions.push(pos);
        this._times.push(time);
        if (time - this._times[0] > 200) {
          this._positions.shift();
          this._times.shift();
        }
      }
      this._map.fire('move').fire('drag');
    },
    _onViewReset: function() {
      var pxCenter = this._map.getSize()._divideBy(2),
          pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
      this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
      this._worldWidth = this._map.project([0, 180]).x;
    },
    _onPreDrag: function() {
      var worldWidth = this._worldWidth,
          halfWidth = Math.round(worldWidth / 2),
          dx = this._initialWorldOffset,
          x = this._draggable._newPos.x,
          newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
          newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
          newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
      this._draggable._newPos.x = newX;
    },
    _onDragEnd: function(e) {
      var map = this._map,
          options = map.options,
          delay = +new Date() - this._lastTime,
          noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];
      map.fire('dragend', e);
      if (noInertia) {
        map.fire('moveend');
      } else {
        var direction = this._lastPos.subtract(this._positions[0]),
            duration = (this._lastTime + delay - this._times[0]) / 1000,
            ease = options.easeLinearity,
            speedVector = direction.multiplyBy(ease / duration),
            speed = speedVector.distanceTo([0, 0]),
            limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
            limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),
            decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
            offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
        if (!offset.x || !offset.y) {
          map.fire('moveend');
        } else {
          offset = map._limitOffset(offset, map.options.maxBounds);
          L.Util.requestAnimFrame(function() {
            map.panBy(offset, {
              duration: decelerationDuration,
              easeLinearity: ease,
              noMoveStart: true
            });
          });
        }
      }
    }
  });
  L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);
  L.Map.mergeOptions({doubleClickZoom: true});
  L.Map.DoubleClickZoom = L.Handler.extend({
    addHooks: function() {
      this._map.on('dblclick', this._onDoubleClick, this);
    },
    removeHooks: function() {
      this._map.off('dblclick', this._onDoubleClick, this);
    },
    _onDoubleClick: function(e) {
      var map = this._map,
          zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);
      if (map.options.doubleClickZoom === 'center') {
        map.setZoom(zoom);
      } else {
        map.setZoomAround(e.containerPoint, zoom);
      }
    }
  });
  L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);
  L.Map.mergeOptions({scrollWheelZoom: true});
  L.Map.ScrollWheelZoom = L.Handler.extend({
    addHooks: function() {
      L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);
      L.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
      this._delta = 0;
    },
    removeHooks: function() {
      L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);
      L.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
    },
    _onWheelScroll: function(e) {
      var delta = L.DomEvent.getWheelDelta(e);
      this._delta += delta;
      this._lastMousePos = this._map.mouseEventToContainerPoint(e);
      if (!this._startTime) {
        this._startTime = +new Date();
      }
      var left = Math.max(40 - (+new Date() - this._startTime), 0);
      clearTimeout(this._timer);
      this._timer = setTimeout(L.bind(this._performZoom, this), left);
      L.DomEvent.preventDefault(e);
      L.DomEvent.stopPropagation(e);
    },
    _performZoom: function() {
      var map = this._map,
          delta = this._delta,
          zoom = map.getZoom();
      delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
      delta = Math.max(Math.min(delta, 4), -4);
      delta = map._limitZoom(zoom + delta) - zoom;
      this._delta = 0;
      this._startTime = null;
      if (!delta) {
        return;
      }
      if (map.options.scrollWheelZoom === 'center') {
        map.setZoom(zoom + delta);
      } else {
        map.setZoomAround(this._lastMousePos, zoom + delta);
      }
    }
  });
  L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);
  L.extend(L.DomEvent, {
    _touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
    _touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',
    addDoubleTapListener: function(obj, handler, id) {
      var last,
          doubleTap = false,
          delay = 250,
          touch,
          pre = '_leaflet_',
          touchstart = this._touchstart,
          touchend = this._touchend,
          trackedTouches = [];
      function onTouchStart(e) {
        var count;
        if (L.Browser.pointer) {
          trackedTouches.push(e.pointerId);
          count = trackedTouches.length;
        } else {
          count = e.touches.length;
        }
        if (count > 1) {
          return;
        }
        var now = Date.now(),
            delta = now - (last || now);
        touch = e.touches ? e.touches[0] : e;
        doubleTap = (delta > 0 && delta <= delay);
        last = now;
      }
      function onTouchEnd(e) {
        if (L.Browser.pointer) {
          var idx = trackedTouches.indexOf(e.pointerId);
          if (idx === -1) {
            return;
          }
          trackedTouches.splice(idx, 1);
        }
        if (doubleTap) {
          if (L.Browser.pointer) {
            var newTouch = {},
                prop;
            for (var i in touch) {
              prop = touch[i];
              if (typeof prop === 'function') {
                newTouch[i] = prop.bind(touch);
              } else {
                newTouch[i] = prop;
              }
            }
            touch = newTouch;
          }
          touch.type = 'dblclick';
          handler(touch);
          last = null;
        }
      }
      obj[pre + touchstart + id] = onTouchStart;
      obj[pre + touchend + id] = onTouchEnd;
      var endElement = L.Browser.pointer ? document.documentElement : obj;
      obj.addEventListener(touchstart, onTouchStart, false);
      endElement.addEventListener(touchend, onTouchEnd, false);
      if (L.Browser.pointer) {
        endElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);
      }
      return this;
    },
    removeDoubleTapListener: function(obj, id) {
      var pre = '_leaflet_';
      obj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);
      (L.Browser.pointer ? document.documentElement : obj).removeEventListener(this._touchend, obj[pre + this._touchend + id], false);
      if (L.Browser.pointer) {
        document.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id], false);
      }
      return this;
    }
  });
  L.extend(L.DomEvent, {
    POINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',
    POINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',
    POINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',
    POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',
    _pointers: [],
    _pointerDocumentListener: false,
    addPointerListener: function(obj, type, handler, id) {
      switch (type) {
        case 'touchstart':
          return this.addPointerListenerStart(obj, type, handler, id);
        case 'touchend':
          return this.addPointerListenerEnd(obj, type, handler, id);
        case 'touchmove':
          return this.addPointerListenerMove(obj, type, handler, id);
        default:
          throw 'Unknown touch event type';
      }
    },
    addPointerListenerStart: function(obj, type, handler, id) {
      var pre = '_leaflet_',
          pointers = this._pointers;
      var cb = function(e) {
        if (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
          L.DomEvent.preventDefault(e);
        }
        var alreadyInArray = false;
        for (var i = 0; i < pointers.length; i++) {
          if (pointers[i].pointerId === e.pointerId) {
            alreadyInArray = true;
            break;
          }
        }
        if (!alreadyInArray) {
          pointers.push(e);
        }
        e.touches = pointers.slice();
        e.changedTouches = [e];
        handler(e);
      };
      obj[pre + 'touchstart' + id] = cb;
      obj.addEventListener(this.POINTER_DOWN, cb, false);
      if (!this._pointerDocumentListener) {
        var internalCb = function(e) {
          for (var i = 0; i < pointers.length; i++) {
            if (pointers[i].pointerId === e.pointerId) {
              pointers.splice(i, 1);
              break;
            }
          }
        };
        document.documentElement.addEventListener(this.POINTER_UP, internalCb, false);
        document.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);
        this._pointerDocumentListener = true;
      }
      return this;
    },
    addPointerListenerMove: function(obj, type, handler, id) {
      var pre = '_leaflet_',
          touches = this._pointers;
      function cb(e) {
        if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) {
          return;
        }
        for (var i = 0; i < touches.length; i++) {
          if (touches[i].pointerId === e.pointerId) {
            touches[i] = e;
            break;
          }
        }
        e.touches = touches.slice();
        e.changedTouches = [e];
        handler(e);
      }
      obj[pre + 'touchmove' + id] = cb;
      obj.addEventListener(this.POINTER_MOVE, cb, false);
      return this;
    },
    addPointerListenerEnd: function(obj, type, handler, id) {
      var pre = '_leaflet_',
          touches = this._pointers;
      var cb = function(e) {
        for (var i = 0; i < touches.length; i++) {
          if (touches[i].pointerId === e.pointerId) {
            touches.splice(i, 1);
            break;
          }
        }
        e.touches = touches.slice();
        e.changedTouches = [e];
        handler(e);
      };
      obj[pre + 'touchend' + id] = cb;
      obj.addEventListener(this.POINTER_UP, cb, false);
      obj.addEventListener(this.POINTER_CANCEL, cb, false);
      return this;
    },
    removePointerListener: function(obj, type, id) {
      var pre = '_leaflet_',
          cb = obj[pre + type + id];
      switch (type) {
        case 'touchstart':
          obj.removeEventListener(this.POINTER_DOWN, cb, false);
          break;
        case 'touchmove':
          obj.removeEventListener(this.POINTER_MOVE, cb, false);
          break;
        case 'touchend':
          obj.removeEventListener(this.POINTER_UP, cb, false);
          obj.removeEventListener(this.POINTER_CANCEL, cb, false);
          break;
      }
      return this;
    }
  });
  L.Map.mergeOptions({
    touchZoom: L.Browser.touch && !L.Browser.android23,
    bounceAtZoomLimits: true
  });
  L.Map.TouchZoom = L.Handler.extend({
    addHooks: function() {
      L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
    },
    removeHooks: function() {
      L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
    },
    _onTouchStart: function(e) {
      var map = this._map;
      if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
        return;
      }
      var p1 = map.mouseEventToLayerPoint(e.touches[0]),
          p2 = map.mouseEventToLayerPoint(e.touches[1]),
          viewCenter = map._getCenterLayerPoint();
      this._startCenter = p1.add(p2)._divideBy(2);
      this._startDist = p1.distanceTo(p2);
      this._moved = false;
      this._zooming = true;
      this._centerOffset = viewCenter.subtract(this._startCenter);
      if (map._panAnim) {
        map._panAnim.stop();
      }
      L.DomEvent.on(document, 'touchmove', this._onTouchMove, this).on(document, 'touchend', this._onTouchEnd, this);
      L.DomEvent.preventDefault(e);
    },
    _onTouchMove: function(e) {
      var map = this._map;
      if (!e.touches || e.touches.length !== 2 || !this._zooming) {
        return;
      }
      var p1 = map.mouseEventToLayerPoint(e.touches[0]),
          p2 = map.mouseEventToLayerPoint(e.touches[1]);
      this._scale = p1.distanceTo(p2) / this._startDist;
      this._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);
      if (this._scale === 1) {
        return;
      }
      if (!map.options.bounceAtZoomLimits) {
        if ((map.getZoom() === map.getMinZoom() && this._scale < 1) || (map.getZoom() === map.getMaxZoom() && this._scale > 1)) {
          return;
        }
      }
      if (!this._moved) {
        L.DomUtil.addClass(map._mapPane, 'leaflet-touching');
        map.fire('movestart').fire('zoomstart');
        this._moved = true;
      }
      L.Util.cancelAnimFrame(this._animRequest);
      this._animRequest = L.Util.requestAnimFrame(this._updateOnMove, this, true, this._map._container);
      L.DomEvent.preventDefault(e);
    },
    _updateOnMove: function() {
      var map = this._map,
          origin = this._getScaleOrigin(),
          center = map.layerPointToLatLng(origin),
          zoom = map.getScaleZoom(this._scale);
      map._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);
    },
    _onTouchEnd: function() {
      if (!this._moved || !this._zooming) {
        this._zooming = false;
        return;
      }
      var map = this._map;
      this._zooming = false;
      L.DomUtil.removeClass(map._mapPane, 'leaflet-touching');
      L.Util.cancelAnimFrame(this._animRequest);
      L.DomEvent.off(document, 'touchmove', this._onTouchMove).off(document, 'touchend', this._onTouchEnd);
      var origin = this._getScaleOrigin(),
          center = map.layerPointToLatLng(origin),
          oldZoom = map.getZoom(),
          floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,
          roundZoomDelta = (floatZoomDelta > 0 ? Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),
          zoom = map._limitZoom(oldZoom + roundZoomDelta),
          scale = map.getZoomScale(zoom) / this._scale;
      map._animateZoom(center, zoom, origin, scale);
    },
    _getScaleOrigin: function() {
      var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);
      return this._startCenter.add(centerOffset);
    }
  });
  L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);
  L.Map.mergeOptions({
    tap: true,
    tapTolerance: 15
  });
  L.Map.Tap = L.Handler.extend({
    addHooks: function() {
      L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
    },
    removeHooks: function() {
      L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
    },
    _onDown: function(e) {
      if (!e.touches) {
        return;
      }
      L.DomEvent.preventDefault(e);
      this._fireClick = true;
      if (e.touches.length > 1) {
        this._fireClick = false;
        clearTimeout(this._holdTimeout);
        return;
      }
      var first = e.touches[0],
          el = first.target;
      this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);
      if (el.tagName && el.tagName.toLowerCase() === 'a') {
        L.DomUtil.addClass(el, 'leaflet-active');
      }
      this._holdTimeout = setTimeout(L.bind(function() {
        if (this._isTapValid()) {
          this._fireClick = false;
          this._onUp();
          this._simulateEvent('contextmenu', first);
        }
      }, this), 1000);
      L.DomEvent.on(document, 'touchmove', this._onMove, this).on(document, 'touchend', this._onUp, this);
    },
    _onUp: function(e) {
      clearTimeout(this._holdTimeout);
      L.DomEvent.off(document, 'touchmove', this._onMove, this).off(document, 'touchend', this._onUp, this);
      if (this._fireClick && e && e.changedTouches) {
        var first = e.changedTouches[0],
            el = first.target;
        if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
          L.DomUtil.removeClass(el, 'leaflet-active');
        }
        if (this._isTapValid()) {
          this._simulateEvent('click', first);
        }
      }
    },
    _isTapValid: function() {
      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
    },
    _onMove: function(e) {
      var first = e.touches[0];
      this._newPos = new L.Point(first.clientX, first.clientY);
    },
    _simulateEvent: function(type, e) {
      var simulatedEvent = document.createEvent('MouseEvents');
      simulatedEvent._simulated = true;
      e.target._simulatedClick = true;
      simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);
      e.target.dispatchEvent(simulatedEvent);
    }
  });
  if (L.Browser.touch && !L.Browser.pointer) {
    L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
  }
  L.Map.mergeOptions({boxZoom: true});
  L.Map.BoxZoom = L.Handler.extend({
    initialize: function(map) {
      this._map = map;
      this._container = map._container;
      this._pane = map._panes.overlayPane;
      this._moved = false;
    },
    addHooks: function() {
      L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
    },
    removeHooks: function() {
      L.DomEvent.off(this._container, 'mousedown', this._onMouseDown);
      this._moved = false;
    },
    moved: function() {
      return this._moved;
    },
    _onMouseDown: function(e) {
      this._moved = false;
      if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) {
        return false;
      }
      L.DomUtil.disableTextSelection();
      L.DomUtil.disableImageDrag();
      this._startLayerPoint = this._map.mouseEventToLayerPoint(e);
      L.DomEvent.on(document, 'mousemove', this._onMouseMove, this).on(document, 'mouseup', this._onMouseUp, this).on(document, 'keydown', this._onKeyDown, this);
    },
    _onMouseMove: function(e) {
      if (!this._moved) {
        this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);
        L.DomUtil.setPosition(this._box, this._startLayerPoint);
        this._container.style.cursor = 'crosshair';
        this._map.fire('boxzoomstart');
      }
      var startPoint = this._startLayerPoint,
          box = this._box,
          layerPoint = this._map.mouseEventToLayerPoint(e),
          offset = layerPoint.subtract(startPoint),
          newPos = new L.Point(Math.min(layerPoint.x, startPoint.x), Math.min(layerPoint.y, startPoint.y));
      L.DomUtil.setPosition(box, newPos);
      this._moved = true;
      box.style.width = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';
      box.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';
    },
    _finish: function() {
      if (this._moved) {
        this._pane.removeChild(this._box);
        this._container.style.cursor = '';
      }
      L.DomUtil.enableTextSelection();
      L.DomUtil.enableImageDrag();
      L.DomEvent.off(document, 'mousemove', this._onMouseMove).off(document, 'mouseup', this._onMouseUp).off(document, 'keydown', this._onKeyDown);
    },
    _onMouseUp: function(e) {
      this._finish();
      var map = this._map,
          layerPoint = map.mouseEventToLayerPoint(e);
      if (this._startLayerPoint.equals(layerPoint)) {
        return;
      }
      var bounds = new L.LatLngBounds(map.layerPointToLatLng(this._startLayerPoint), map.layerPointToLatLng(layerPoint));
      map.fitBounds(bounds);
      map.fire('boxzoomend', {boxZoomBounds: bounds});
    },
    _onKeyDown: function(e) {
      if (e.keyCode === 27) {
        this._finish();
      }
    }
  });
  L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);
  L.Map.mergeOptions({
    keyboard: true,
    keyboardPanOffset: 80,
    keyboardZoomOffset: 1
  });
  L.Map.Keyboard = L.Handler.extend({
    keyCodes: {
      left: [37],
      right: [39],
      down: [40],
      up: [38],
      zoomIn: [187, 107, 61, 171],
      zoomOut: [189, 109, 173]
    },
    initialize: function(map) {
      this._map = map;
      this._setPanOffset(map.options.keyboardPanOffset);
      this._setZoomOffset(map.options.keyboardZoomOffset);
    },
    addHooks: function() {
      var container = this._map._container;
      if (container.tabIndex === -1) {
        container.tabIndex = '0';
      }
      L.DomEvent.on(container, 'focus', this._onFocus, this).on(container, 'blur', this._onBlur, this).on(container, 'mousedown', this._onMouseDown, this);
      this._map.on('focus', this._addHooks, this).on('blur', this._removeHooks, this);
    },
    removeHooks: function() {
      this._removeHooks();
      var container = this._map._container;
      L.DomEvent.off(container, 'focus', this._onFocus, this).off(container, 'blur', this._onBlur, this).off(container, 'mousedown', this._onMouseDown, this);
      this._map.off('focus', this._addHooks, this).off('blur', this._removeHooks, this);
    },
    _onMouseDown: function() {
      if (this._focused) {
        return;
      }
      var body = document.body,
          docEl = document.documentElement,
          top = body.scrollTop || docEl.scrollTop,
          left = body.scrollLeft || docEl.scrollLeft;
      this._map._container.focus();
      window.scrollTo(left, top);
    },
    _onFocus: function() {
      this._focused = true;
      this._map.fire('focus');
    },
    _onBlur: function() {
      this._focused = false;
      this._map.fire('blur');
    },
    _setPanOffset: function(pan) {
      var keys = this._panKeys = {},
          codes = this.keyCodes,
          i,
          len;
      for (i = 0, len = codes.left.length; i < len; i++) {
        keys[codes.left[i]] = [-1 * pan, 0];
      }
      for (i = 0, len = codes.right.length; i < len; i++) {
        keys[codes.right[i]] = [pan, 0];
      }
      for (i = 0, len = codes.down.length; i < len; i++) {
        keys[codes.down[i]] = [0, pan];
      }
      for (i = 0, len = codes.up.length; i < len; i++) {
        keys[codes.up[i]] = [0, -1 * pan];
      }
    },
    _setZoomOffset: function(zoom) {
      var keys = this._zoomKeys = {},
          codes = this.keyCodes,
          i,
          len;
      for (i = 0, len = codes.zoomIn.length; i < len; i++) {
        keys[codes.zoomIn[i]] = zoom;
      }
      for (i = 0, len = codes.zoomOut.length; i < len; i++) {
        keys[codes.zoomOut[i]] = -zoom;
      }
    },
    _addHooks: function() {
      L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
    },
    _removeHooks: function() {
      L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
    },
    _onKeyDown: function(e) {
      var key = e.keyCode,
          map = this._map;
      if (key in this._panKeys) {
        if (map._panAnim && map._panAnim._inProgress) {
          return;
        }
        map.panBy(this._panKeys[key]);
        if (map.options.maxBounds) {
          map.panInsideBounds(map.options.maxBounds);
        }
      } else if (key in this._zoomKeys) {
        map.setZoom(map.getZoom() + this._zoomKeys[key]);
      } else {
        return;
      }
      L.DomEvent.stop(e);
    }
  });
  L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);
  L.Handler.MarkerDrag = L.Handler.extend({
    initialize: function(marker) {
      this._marker = marker;
    },
    addHooks: function() {
      var icon = this._marker._icon;
      if (!this._draggable) {
        this._draggable = new L.Draggable(icon, icon);
      }
      this._draggable.on('dragstart', this._onDragStart, this).on('drag', this._onDrag, this).on('dragend', this._onDragEnd, this);
      this._draggable.enable();
      L.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');
    },
    removeHooks: function() {
      this._draggable.off('dragstart', this._onDragStart, this).off('drag', this._onDrag, this).off('dragend', this._onDragEnd, this);
      this._draggable.disable();
      L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
    },
    moved: function() {
      return this._draggable && this._draggable._moved;
    },
    _onDragStart: function() {
      this._marker.closePopup().fire('movestart').fire('dragstart');
    },
    _onDrag: function() {
      var marker = this._marker,
          shadow = marker._shadow,
          iconPos = L.DomUtil.getPosition(marker._icon),
          latlng = marker._map.layerPointToLatLng(iconPos);
      if (shadow) {
        L.DomUtil.setPosition(shadow, iconPos);
      }
      marker._latlng = latlng;
      marker.fire('move', {latlng: latlng}).fire('drag');
    },
    _onDragEnd: function(e) {
      this._marker.fire('moveend').fire('dragend', e);
    }
  });
  L.Control = L.Class.extend({
    options: {position: 'topright'},
    initialize: function(options) {
      L.setOptions(this, options);
    },
    getPosition: function() {
      return this.options.position;
    },
    setPosition: function(position) {
      var map = this._map;
      if (map) {
        map.removeControl(this);
      }
      this.options.position = position;
      if (map) {
        map.addControl(this);
      }
      return this;
    },
    getContainer: function() {
      return this._container;
    },
    addTo: function(map) {
      this._map = map;
      var container = this._container = this.onAdd(map),
          pos = this.getPosition(),
          corner = map._controlCorners[pos];
      L.DomUtil.addClass(container, 'leaflet-control');
      if (pos.indexOf('bottom') !== -1) {
        corner.insertBefore(container, corner.firstChild);
      } else {
        corner.appendChild(container);
      }
      return this;
    },
    removeFrom: function(map) {
      var pos = this.getPosition(),
          corner = map._controlCorners[pos];
      corner.removeChild(this._container);
      this._map = null;
      if (this.onRemove) {
        this.onRemove(map);
      }
      return this;
    },
    _refocusOnMap: function() {
      if (this._map) {
        this._map.getContainer().focus();
      }
    }
  });
  L.control = function(options) {
    return new L.Control(options);
  };
  L.Map.include({
    addControl: function(control) {
      control.addTo(this);
      return this;
    },
    removeControl: function(control) {
      control.removeFrom(this);
      return this;
    },
    _initControlPos: function() {
      var corners = this._controlCorners = {},
          l = 'leaflet-',
          container = this._controlContainer = L.DomUtil.create('div', l + 'control-container', this._container);
      function createCorner(vSide, hSide) {
        var className = l + vSide + ' ' + l + hSide;
        corners[vSide + hSide] = L.DomUtil.create('div', className, container);
      }
      createCorner('top', 'left');
      createCorner('top', 'right');
      createCorner('bottom', 'left');
      createCorner('bottom', 'right');
    },
    _clearControlPos: function() {
      this._container.removeChild(this._controlContainer);
    }
  });
  L.Control.Zoom = L.Control.extend({
    options: {
      position: 'topleft',
      zoomInText: '+',
      zoomInTitle: 'Zoom in',
      zoomOutText: '-',
      zoomOutTitle: 'Zoom out'
    },
    onAdd: function(map) {
      var zoomName = 'leaflet-control-zoom',
          container = L.DomUtil.create('div', zoomName + ' leaflet-bar');
      this._map = map;
      this._zoomInButton = this._createButton(this.options.zoomInText, this.options.zoomInTitle, zoomName + '-in', container, this._zoomIn, this);
      this._zoomOutButton = this._createButton(this.options.zoomOutText, this.options.zoomOutTitle, zoomName + '-out', container, this._zoomOut, this);
      this._updateDisabled();
      map.on('zoomend zoomlevelschange', this._updateDisabled, this);
      return container;
    },
    onRemove: function(map) {
      map.off('zoomend zoomlevelschange', this._updateDisabled, this);
    },
    _zoomIn: function(e) {
      this._map.zoomIn(e.shiftKey ? 3 : 1);
    },
    _zoomOut: function(e) {
      this._map.zoomOut(e.shiftKey ? 3 : 1);
    },
    _createButton: function(html, title, className, container, fn, context) {
      var link = L.DomUtil.create('a', className, container);
      link.innerHTML = html;
      link.href = '#';
      link.title = title;
      var stop = L.DomEvent.stopPropagation;
      L.DomEvent.on(link, 'click', stop).on(link, 'mousedown', stop).on(link, 'dblclick', stop).on(link, 'click', L.DomEvent.preventDefault).on(link, 'click', fn, context).on(link, 'click', this._refocusOnMap, context);
      return link;
    },
    _updateDisabled: function() {
      var map = this._map,
          className = 'leaflet-disabled';
      L.DomUtil.removeClass(this._zoomInButton, className);
      L.DomUtil.removeClass(this._zoomOutButton, className);
      if (map._zoom === map.getMinZoom()) {
        L.DomUtil.addClass(this._zoomOutButton, className);
      }
      if (map._zoom === map.getMaxZoom()) {
        L.DomUtil.addClass(this._zoomInButton, className);
      }
    }
  });
  L.Map.mergeOptions({zoomControl: true});
  L.Map.addInitHook(function() {
    if (this.options.zoomControl) {
      this.zoomControl = new L.Control.Zoom();
      this.addControl(this.zoomControl);
    }
  });
  L.control.zoom = function(options) {
    return new L.Control.Zoom(options);
  };
  L.Control.Attribution = L.Control.extend({
    options: {
      position: 'bottomright',
      prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
    },
    initialize: function(options) {
      L.setOptions(this, options);
      this._attributions = {};
    },
    onAdd: function(map) {
      this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
      L.DomEvent.disableClickPropagation(this._container);
      for (var i in map._layers) {
        if (map._layers[i].getAttribution) {
          this.addAttribution(map._layers[i].getAttribution());
        }
      }
      map.on('layeradd', this._onLayerAdd, this).on('layerremove', this._onLayerRemove, this);
      this._update();
      return this._container;
    },
    onRemove: function(map) {
      map.off('layeradd', this._onLayerAdd).off('layerremove', this._onLayerRemove);
    },
    setPrefix: function(prefix) {
      this.options.prefix = prefix;
      this._update();
      return this;
    },
    addAttribution: function(text) {
      if (!text) {
        return;
      }
      if (!this._attributions[text]) {
        this._attributions[text] = 0;
      }
      this._attributions[text]++;
      this._update();
      return this;
    },
    removeAttribution: function(text) {
      if (!text) {
        return;
      }
      if (this._attributions[text]) {
        this._attributions[text]--;
        this._update();
      }
      return this;
    },
    _update: function() {
      if (!this._map) {
        return;
      }
      var attribs = [];
      for (var i in this._attributions) {
        if (this._attributions[i]) {
          attribs.push(i);
        }
      }
      var prefixAndAttribs = [];
      if (this.options.prefix) {
        prefixAndAttribs.push(this.options.prefix);
      }
      if (attribs.length) {
        prefixAndAttribs.push(attribs.join(', '));
      }
      this._container.innerHTML = prefixAndAttribs.join(' | ');
    },
    _onLayerAdd: function(e) {
      if (e.layer.getAttribution) {
        this.addAttribution(e.layer.getAttribution());
      }
    },
    _onLayerRemove: function(e) {
      if (e.layer.getAttribution) {
        this.removeAttribution(e.layer.getAttribution());
      }
    }
  });
  L.Map.mergeOptions({attributionControl: true});
  L.Map.addInitHook(function() {
    if (this.options.attributionControl) {
      this.attributionControl = (new L.Control.Attribution()).addTo(this);
    }
  });
  L.control.attribution = function(options) {
    return new L.Control.Attribution(options);
  };
  L.Control.Scale = L.Control.extend({
    options: {
      position: 'bottomleft',
      maxWidth: 100,
      metric: true,
      imperial: true,
      updateWhenIdle: false
    },
    onAdd: function(map) {
      this._map = map;
      var className = 'leaflet-control-scale',
          container = L.DomUtil.create('div', className),
          options = this.options;
      this._addScales(options, className, container);
      map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
      map.whenReady(this._update, this);
      return container;
    },
    onRemove: function(map) {
      map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
    },
    _addScales: function(options, className, container) {
      if (options.metric) {
        this._mScale = L.DomUtil.create('div', className + '-line', container);
      }
      if (options.imperial) {
        this._iScale = L.DomUtil.create('div', className + '-line', container);
      }
    },
    _update: function() {
      var bounds = this._map.getBounds(),
          centerLat = bounds.getCenter().lat,
          halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),
          dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,
          size = this._map.getSize(),
          options = this.options,
          maxMeters = 0;
      if (size.x > 0) {
        maxMeters = dist * (options.maxWidth / size.x);
      }
      this._updateScales(options, maxMeters);
    },
    _updateScales: function(options, maxMeters) {
      if (options.metric && maxMeters) {
        this._updateMetric(maxMeters);
      }
      if (options.imperial && maxMeters) {
        this._updateImperial(maxMeters);
      }
    },
    _updateMetric: function(maxMeters) {
      var meters = this._getRoundNum(maxMeters);
      this._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';
      this._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';
    },
    _updateImperial: function(maxMeters) {
      var maxFeet = maxMeters * 3.2808399,
          scale = this._iScale,
          maxMiles,
          miles,
          feet;
      if (maxFeet > 5280) {
        maxMiles = maxFeet / 5280;
        miles = this._getRoundNum(maxMiles);
        scale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';
        scale.innerHTML = miles + ' mi';
      } else {
        feet = this._getRoundNum(maxFeet);
        scale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';
        scale.innerHTML = feet + ' ft';
      }
    },
    _getScaleWidth: function(ratio) {
      return Math.round(this.options.maxWidth * ratio) - 10;
    },
    _getRoundNum: function(num) {
      var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
          d = num / pow10;
      d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
      return pow10 * d;
    }
  });
  L.control.scale = function(options) {
    return new L.Control.Scale(options);
  };
  L.Control.Layers = L.Control.extend({
    options: {
      collapsed: true,
      position: 'topright',
      autoZIndex: true
    },
    initialize: function(baseLayers, overlays, options) {
      L.setOptions(this, options);
      this._layers = {};
      this._lastZIndex = 0;
      this._handlingClick = false;
      for (var i in baseLayers) {
        this._addLayer(baseLayers[i], i);
      }
      for (i in overlays) {
        this._addLayer(overlays[i], i, true);
      }
    },
    onAdd: function(map) {
      this._initLayout();
      this._update();
      map.on('layeradd', this._onLayerChange, this).on('layerremove', this._onLayerChange, this);
      return this._container;
    },
    onRemove: function(map) {
      map.off('layeradd', this._onLayerChange, this).off('layerremove', this._onLayerChange, this);
    },
    addBaseLayer: function(layer, name) {
      this._addLayer(layer, name);
      this._update();
      return this;
    },
    addOverlay: function(layer, name) {
      this._addLayer(layer, name, true);
      this._update();
      return this;
    },
    removeLayer: function(layer) {
      var id = L.stamp(layer);
      delete this._layers[id];
      this._update();
      return this;
    },
    _initLayout: function() {
      var className = 'leaflet-control-layers',
          container = this._container = L.DomUtil.create('div', className);
      container.setAttribute('aria-haspopup', true);
      if (!L.Browser.touch) {
        L.DomEvent.disableClickPropagation(container).disableScrollPropagation(container);
      } else {
        L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
      }
      var form = this._form = L.DomUtil.create('form', className + '-list');
      if (this.options.collapsed) {
        if (!L.Browser.android) {
          L.DomEvent.on(container, 'mouseover', this._expand, this).on(container, 'mouseout', this._collapse, this);
        }
        var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
        link.href = '#';
        link.title = 'Layers';
        if (L.Browser.touch) {
          L.DomEvent.on(link, 'click', L.DomEvent.stop).on(link, 'click', this._expand, this);
        } else {
          L.DomEvent.on(link, 'focus', this._expand, this);
        }
        L.DomEvent.on(form, 'click', function() {
          setTimeout(L.bind(this._onInputClick, this), 0);
        }, this);
        this._map.on('click', this._collapse, this);
      } else {
        this._expand();
      }
      this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
      this._separator = L.DomUtil.create('div', className + '-separator', form);
      this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);
      container.appendChild(form);
    },
    _addLayer: function(layer, name, overlay) {
      var id = L.stamp(layer);
      this._layers[id] = {
        layer: layer,
        name: name,
        overlay: overlay
      };
      if (this.options.autoZIndex && layer.setZIndex) {
        this._lastZIndex++;
        layer.setZIndex(this._lastZIndex);
      }
    },
    _update: function() {
      if (!this._container) {
        return;
      }
      this._baseLayersList.innerHTML = '';
      this._overlaysList.innerHTML = '';
      var baseLayersPresent = false,
          overlaysPresent = false,
          i,
          obj;
      for (i in this._layers) {
        obj = this._layers[i];
        this._addItem(obj);
        overlaysPresent = overlaysPresent || obj.overlay;
        baseLayersPresent = baseLayersPresent || !obj.overlay;
      }
      this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
    },
    _onLayerChange: function(e) {
      var obj = this._layers[L.stamp(e.layer)];
      if (!obj) {
        return;
      }
      if (!this._handlingClick) {
        this._update();
      }
      var type = obj.overlay ? (e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') : (e.type === 'layeradd' ? 'baselayerchange' : null);
      if (type) {
        this._map.fire(type, obj);
      }
    },
    _createRadioElement: function(name, checked) {
      var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"';
      if (checked) {
        radioHtml += ' checked="checked"';
      }
      radioHtml += '/>';
      var radioFragment = document.createElement('div');
      radioFragment.innerHTML = radioHtml;
      return radioFragment.firstChild;
    },
    _addItem: function(obj) {
      var label = document.createElement('label'),
          input,
          checked = this._map.hasLayer(obj.layer);
      if (obj.overlay) {
        input = document.createElement('input');
        input.type = 'checkbox';
        input.className = 'leaflet-control-layers-selector';
        input.defaultChecked = checked;
      } else {
        input = this._createRadioElement('leaflet-base-layers', checked);
      }
      input.layerId = L.stamp(obj.layer);
      L.DomEvent.on(input, 'click', this._onInputClick, this);
      var name = document.createElement('span');
      name.innerHTML = ' ' + obj.name;
      label.appendChild(input);
      label.appendChild(name);
      var container = obj.overlay ? this._overlaysList : this._baseLayersList;
      container.appendChild(label);
      return label;
    },
    _onInputClick: function() {
      var i,
          input,
          obj,
          inputs = this._form.getElementsByTagName('input'),
          inputsLen = inputs.length;
      this._handlingClick = true;
      for (i = 0; i < inputsLen; i++) {
        input = inputs[i];
        obj = this._layers[input.layerId];
        if (input.checked && !this._map.hasLayer(obj.layer)) {
          this._map.addLayer(obj.layer);
        } else if (!input.checked && this._map.hasLayer(obj.layer)) {
          this._map.removeLayer(obj.layer);
        }
      }
      this._handlingClick = false;
      this._refocusOnMap();
    },
    _expand: function() {
      L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
    },
    _collapse: function() {
      this._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');
    }
  });
  L.control.layers = function(baseLayers, overlays, options) {
    return new L.Control.Layers(baseLayers, overlays, options);
  };
  L.PosAnimation = L.Class.extend({
    includes: L.Mixin.Events,
    run: function(el, newPos, duration, easeLinearity) {
      this.stop();
      this._el = el;
      this._inProgress = true;
      this._newPos = newPos;
      this.fire('start');
      el.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) + 's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';
      L.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
      L.DomUtil.setPosition(el, newPos);
      L.Util.falseFn(el.offsetWidth);
      this._stepTimer = setInterval(L.bind(this._onStep, this), 50);
    },
    stop: function() {
      if (!this._inProgress) {
        return;
      }
      L.DomUtil.setPosition(this._el, this._getPos());
      this._onTransitionEnd();
      L.Util.falseFn(this._el.offsetWidth);
    },
    _onStep: function() {
      var stepPos = this._getPos();
      if (!stepPos) {
        this._onTransitionEnd();
        return;
      }
      this._el._leaflet_pos = stepPos;
      this.fire('step');
    },
    _transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,
    _getPos: function() {
      var left,
          top,
          matches,
          el = this._el,
          style = window.getComputedStyle(el);
      if (L.Browser.any3d) {
        matches = style[L.DomUtil.TRANSFORM].match(this._transformRe);
        if (!matches) {
          return;
        }
        left = parseFloat(matches[1]);
        top = parseFloat(matches[2]);
      } else {
        left = parseFloat(style.left);
        top = parseFloat(style.top);
      }
      return new L.Point(left, top, true);
    },
    _onTransitionEnd: function() {
      L.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
      if (!this._inProgress) {
        return;
      }
      this._inProgress = false;
      this._el.style[L.DomUtil.TRANSITION] = '';
      this._el._leaflet_pos = this._newPos;
      clearInterval(this._stepTimer);
      this.fire('step').fire('end');
    }
  });
  L.Map.include({
    setView: function(center, zoom, options) {
      zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
      center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
      options = options || {};
      if (this._panAnim) {
        this._panAnim.stop();
      }
      if (this._loaded && !options.reset && options !== true) {
        if (options.animate !== undefined) {
          options.zoom = L.extend({animate: options.animate}, options.zoom);
          options.pan = L.extend({animate: options.animate}, options.pan);
        }
        var animated = (this._zoom !== zoom) ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);
        if (animated) {
          clearTimeout(this._sizeTimer);
          return this;
        }
      }
      this._resetView(center, zoom);
      return this;
    },
    panBy: function(offset, options) {
      offset = L.point(offset).round();
      options = options || {};
      if (!offset.x && !offset.y) {
        return this;
      }
      if (!this._panAnim) {
        this._panAnim = new L.PosAnimation();
        this._panAnim.on({
          'step': this._onPanTransitionStep,
          'end': this._onPanTransitionEnd
        }, this);
      }
      if (!options.noMoveStart) {
        this.fire('movestart');
      }
      if (options.animate !== false) {
        L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');
        var newPos = this._getMapPanePos().subtract(offset);
        this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
      } else {
        this._rawPanBy(offset);
        this.fire('move').fire('moveend');
      }
      return this;
    },
    _onPanTransitionStep: function() {
      this.fire('move');
    },
    _onPanTransitionEnd: function() {
      L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
      this.fire('moveend');
    },
    _tryAnimatedPan: function(center, options) {
      var offset = this._getCenterOffset(center)._floor();
      if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
        return false;
      }
      this.panBy(offset, options);
      return true;
    }
  });
  L.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({
    run: function(el, newPos, duration, easeLinearity) {
      this.stop();
      this._el = el;
      this._inProgress = true;
      this._duration = duration || 0.25;
      this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
      this._startPos = L.DomUtil.getPosition(el);
      this._offset = newPos.subtract(this._startPos);
      this._startTime = +new Date();
      this.fire('start');
      this._animate();
    },
    stop: function() {
      if (!this._inProgress) {
        return;
      }
      this._step();
      this._complete();
    },
    _animate: function() {
      this._animId = L.Util.requestAnimFrame(this._animate, this);
      this._step();
    },
    _step: function() {
      var elapsed = (+new Date()) - this._startTime,
          duration = this._duration * 1000;
      if (elapsed < duration) {
        this._runFrame(this._easeOut(elapsed / duration));
      } else {
        this._runFrame(1);
        this._complete();
      }
    },
    _runFrame: function(progress) {
      var pos = this._startPos.add(this._offset.multiplyBy(progress));
      L.DomUtil.setPosition(this._el, pos);
      this.fire('step');
    },
    _complete: function() {
      L.Util.cancelAnimFrame(this._animId);
      this._inProgress = false;
      this.fire('end');
    },
    _easeOut: function(t) {
      return 1 - Math.pow(1 - t, this._easeOutPower);
    }
  });
  L.Map.mergeOptions({
    zoomAnimation: true,
    zoomAnimationThreshold: 4
  });
  if (L.DomUtil.TRANSITION) {
    L.Map.addInitHook(function() {
      this._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION && L.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;
      if (this._zoomAnimated) {
        L.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
      }
    });
  }
  L.Map.include(!L.DomUtil.TRANSITION ? {} : {
    _catchTransitionEnd: function(e) {
      if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
        this._onZoomTransitionEnd();
      }
    },
    _nothingToAnimate: function() {
      return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
    },
    _tryAnimatedZoom: function(center, zoom, options) {
      if (this._animatingZoom) {
        return true;
      }
      options = options || {};
      if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {
        return false;
      }
      var scale = this.getZoomScale(zoom),
          offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),
          origin = this._getCenterLayerPoint()._add(offset);
      if (options.animate !== true && !this.getSize().contains(offset)) {
        return false;
      }
      this.fire('movestart').fire('zoomstart');
      this._animateZoom(center, zoom, origin, scale, null, true);
      return true;
    },
    _animateZoom: function(center, zoom, origin, scale, delta, backwards, forTouchZoom) {
      if (!forTouchZoom) {
        this._animatingZoom = true;
      }
      L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');
      this._animateToCenter = center;
      this._animateToZoom = zoom;
      if (L.Draggable) {
        L.Draggable._disabled = true;
      }
      L.Util.requestAnimFrame(function() {
        this.fire('zoomanim', {
          center: center,
          zoom: zoom,
          origin: origin,
          scale: scale,
          delta: delta,
          backwards: backwards
        });
        setTimeout(L.bind(this._onZoomTransitionEnd, this), 250);
      }, this);
    },
    _onZoomTransitionEnd: function() {
      if (!this._animatingZoom) {
        return;
      }
      this._animatingZoom = false;
      L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');
      L.Util.requestAnimFrame(function() {
        this._resetView(this._animateToCenter, this._animateToZoom, true, true);
        if (L.Draggable) {
          L.Draggable._disabled = false;
        }
      }, this);
    }
  });
  L.TileLayer.include({
    _animateZoom: function(e) {
      if (!this._animating) {
        this._animating = true;
        this._prepareBgBuffer();
      }
      var bg = this._bgBuffer,
          transform = L.DomUtil.TRANSFORM,
          initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],
          scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);
      bg.style[transform] = e.backwards ? scaleStr + ' ' + initialTransform : initialTransform + ' ' + scaleStr;
    },
    _endZoomAnim: function() {
      var front = this._tileContainer,
          bg = this._bgBuffer;
      front.style.visibility = '';
      front.parentNode.appendChild(front);
      L.Util.falseFn(bg.offsetWidth);
      var zoom = this._map.getZoom();
      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
        this._clearBgBuffer();
      }
      this._animating = false;
    },
    _clearBgBuffer: function() {
      var map = this._map;
      if (map && !map._animatingZoom && !map.touchZoom._zooming) {
        this._bgBuffer.innerHTML = '';
        this._bgBuffer.style[L.DomUtil.TRANSFORM] = '';
      }
    },
    _prepareBgBuffer: function() {
      var front = this._tileContainer,
          bg = this._bgBuffer;
      var bgLoaded = this._getLoadedTilesPercentage(bg),
          frontLoaded = this._getLoadedTilesPercentage(front);
      if (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {
        front.style.visibility = 'hidden';
        this._stopLoadingImages(front);
        return;
      }
      bg.style.visibility = 'hidden';
      bg.style[L.DomUtil.TRANSFORM] = '';
      this._tileContainer = bg;
      bg = this._bgBuffer = front;
      this._stopLoadingImages(bg);
      clearTimeout(this._clearBgBufferTimer);
    },
    _getLoadedTilesPercentage: function(container) {
      var tiles = container.getElementsByTagName('img'),
          i,
          len,
          count = 0;
      for (i = 0, len = tiles.length; i < len; i++) {
        if (tiles[i].complete) {
          count++;
        }
      }
      return count / len;
    },
    _stopLoadingImages: function(container) {
      var tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),
          i,
          len,
          tile;
      for (i = 0, len = tiles.length; i < len; i++) {
        tile = tiles[i];
        if (!tile.complete) {
          tile.onload = L.Util.falseFn;
          tile.onerror = L.Util.falseFn;
          tile.src = L.Util.emptyImageUrl;
          tile.parentNode.removeChild(tile);
        }
      }
    }
  });
  L.Map.include({
    _defaultLocateOptions: {
      watch: false,
      setView: false,
      maxZoom: Infinity,
      timeout: 10000,
      maximumAge: 0,
      enableHighAccuracy: false
    },
    locate: function(options) {
      options = this._locateOptions = L.extend(this._defaultLocateOptions, options);
      if (!navigator.geolocation) {
        this._handleGeolocationError({
          code: 0,
          message: 'Geolocation not supported.'
        });
        return this;
      }
      var onResponse = L.bind(this._handleGeolocationResponse, this),
          onError = L.bind(this._handleGeolocationError, this);
      if (options.watch) {
        this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
      } else {
        navigator.geolocation.getCurrentPosition(onResponse, onError, options);
      }
      return this;
    },
    stopLocate: function() {
      if (navigator.geolocation) {
        navigator.geolocation.clearWatch(this._locationWatchId);
      }
      if (this._locateOptions) {
        this._locateOptions.setView = false;
      }
      return this;
    },
    _handleGeolocationError: function(error) {
      var c = error.code,
          message = error.message || (c === 1 ? 'permission denied' : (c === 2 ? 'position unavailable' : 'timeout'));
      if (this._locateOptions.setView && !this._loaded) {
        this.fitWorld();
      }
      this.fire('locationerror', {
        code: c,
        message: 'Geolocation error: ' + message + '.'
      });
    },
    _handleGeolocationResponse: function(pos) {
      var lat = pos.coords.latitude,
          lng = pos.coords.longitude,
          latlng = new L.LatLng(lat, lng),
          latAccuracy = 180 * pos.coords.accuracy / 40075017,
          lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),
          bounds = L.latLngBounds([lat - latAccuracy, lng - lngAccuracy], [lat + latAccuracy, lng + lngAccuracy]),
          options = this._locateOptions;
      if (options.setView) {
        var zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);
        this.setView(latlng, zoom);
      }
      var data = {
        latlng: latlng,
        bounds: bounds,
        timestamp: pos.timestamp
      };
      for (var i in pos.coords) {
        if (typeof pos.coords[i] === 'number') {
          data[i] = pos.coords[i];
        }
      }
      this.fire('locationfound', data);
    }
  });
}(window, document));

_removeDefine();
})();
(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("5", ["b3"], function(main) {
  return main;
});

_removeDefine();
})();
$__System.register("13", [], function() { return { setters: [], execute: function() {} } });

$__System.registerDynamic("b4", ["b5"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ITERATOR = req('b5')('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function() {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function() {
      throw 2;
    });
  } catch (e) {}
  module.exports = function(exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING)
      return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[ITERATOR]();
      iter.next = function() {
        safe = true;
      };
      arr[ITERATOR] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b6", ["b7", "b8", "b9", "b5"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var global = req('b7'),
      $ = req('b8'),
      DESCRIPTORS = req('b9'),
      SPECIES = req('b5')('species');
  module.exports = function(KEY) {
    var C = global[KEY];
    if (DESCRIPTORS && C && !C[SPECIES])
      $.setDesc(C, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ba", ["bb"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var redefine = req('bb');
  module.exports = function(target, src) {
    for (var key in src)
      redefine(target, key, src[key]);
    return target;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bc", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bd", ["bc"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('bc');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("be", ["bd"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? process : req('bd');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2e", ["be"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('be');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bf", ["c0", "b7"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = req('c0'),
      document = req('b7').document,
      is = isObject(document) && isObject(document.createElement);
  module.exports = function(it) {
    return is ? document.createElement(it) : {};
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c1", ["b7"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('b7').document && document.documentElement;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);
      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);
      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }
    return fn.apply(that, args);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c3", ["c4", "c2", "c1", "bf", "b7", "c5", "2e"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var ctx = req('c4'),
        invoke = req('c2'),
        html = req('c1'),
        cel = req('bf'),
        global = req('b7'),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function() {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listner = function(event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i)
          args.push(arguments[i++]);
        queue[++counter] = function() {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if (req('c5')(process) == 'process') {
        defer = function(id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel;
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function(id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listner, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function(id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })(req('2e'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c6", ["b7", "c3", "c5", "2e"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var global = req('b7'),
        macrotask = req('c3').set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        Promise = global.Promise,
        isNode = req('c5')(process) == 'process',
        head,
        last,
        notify;
    var flush = function() {
      var parent,
          domain,
          fn;
      if (isNode && (parent = process.domain)) {
        process.domain = null;
        parent.exit();
      }
      while (head) {
        domain = head.domain;
        fn = head.fn;
        if (domain)
          domain.enter();
        fn();
        if (domain)
          domain.exit();
        head = head.next;
      }
      last = undefined;
      if (parent)
        parent.enter();
    };
    if (isNode) {
      notify = function() {
        process.nextTick(flush);
      };
    } else if (Observer) {
      var toggle = 1,
          node = document.createTextNode('');
      new Observer(flush).observe(node, {characterData: true});
      notify = function() {
        node.data = toggle = -toggle;
      };
    } else if (Promise && Promise.resolve) {
      notify = function() {
        Promise.resolve().then(flush);
      };
    } else {
      notify = function() {
        macrotask.call(global, flush);
      };
    }
    module.exports = function asap(fn) {
      var task = {
        fn: fn,
        next: undefined,
        domain: isNode && process.domain
      };
      if (last)
        last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  })(req('2e'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c7", ["c8", "c9", "b5"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = req('c8'),
      aFunction = req('c9'),
      SPECIES = req('b5')('species');
  module.exports = function(O, D) {
    var C = anObject(O).constructor,
        S;
    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ca", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("cb", ["b8", "c0", "c8", "c4"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getDesc = req('b8').getDesc,
      isObject = req('c0'),
      anObject = req('c8');
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = req('c4')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("cc", ["cd", "b5", "ce", "cf"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = req('cd'),
      ITERATOR = req('b5')('iterator'),
      Iterators = req('ce');
  module.exports = req('cf').getIteratorMethod = function(it) {
    if (it != undefined)
      return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d0", ["ce", "b5"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Iterators = req('ce'),
      ITERATOR = req('b5')('iterator'),
      ArrayProto = Array.prototype;
  module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d1", ["c8"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = req('c8');
  module.exports = function(iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined)
        anObject(ret.call(iterator));
      throw e;
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d2", ["c4", "d1", "d0", "c8", "d3", "cc"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = req('c4'),
      call = req('d1'),
      isArrayIter = req('d0'),
      anObject = req('c8'),
      toLength = req('d3'),
      getIterFn = req('cc');
  module.exports = function(iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function')
      throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn))
      for (length = toLength(iterable.length); length > index; index++) {
        entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      }
    else
      for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
        call(iterator, f, step.value, entries);
      }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d4", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c8", ["c0"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = req('c0');
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d5", ["b8", "d6", "b7", "c4", "cd", "d7", "c0", "c8", "c9", "d4", "d2", "cb", "ca", "b5", "c7", "c6", "b9", "ba", "d8", "b6", "cf", "b4", "2e"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var $ = req('b8'),
        LIBRARY = req('d6'),
        global = req('b7'),
        ctx = req('c4'),
        classof = req('cd'),
        $export = req('d7'),
        isObject = req('c0'),
        anObject = req('c8'),
        aFunction = req('c9'),
        strictNew = req('d4'),
        forOf = req('d2'),
        setProto = req('cb').set,
        same = req('ca'),
        SPECIES = req('b5')('species'),
        speciesConstructor = req('c7'),
        asap = req('c6'),
        PROMISE = 'Promise',
        process = global.process,
        isNode = classof(process) == 'process',
        P = global[PROMISE],
        Wrapper;
    var testResolve = function(sub) {
      var test = new P(function() {});
      if (sub)
        test.constructor = Object;
      return P.resolve(test) === test;
    };
    var USE_NATIVE = function() {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = P && P.resolve && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
        if (!(P2.resolve(5).then(function() {}) instanceof P2)) {
          works = false;
        }
        if (works && req('b9')) {
          var thenableThenGotten = false;
          P.resolve($.setDesc({}, 'then', {get: function() {
              thenableThenGotten = true;
            }}));
          works = thenableThenGotten;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    var sameConstructor = function(a, b) {
      if (LIBRARY && a === P && b === Wrapper)
        return true;
      return same(a, b);
    };
    var getConstructor = function(C) {
      var S = anObject(C)[SPECIES];
      return S != undefined ? S : C;
    };
    var isThenable = function(it) {
      var then;
      return isObject(it) && typeof(then = it.then) == 'function' ? then : false;
    };
    var PromiseCapability = function(C) {
      var resolve,
          reject;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined)
          throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aFunction(resolve), this.reject = aFunction(reject);
    };
    var perform = function(exec) {
      try {
        exec();
      } catch (e) {
        return {error: e};
      }
    };
    var notify = function(record, isReject) {
      if (record.n)
        return;
      record.n = true;
      var chain = record.c;
      asap(function() {
        var value = record.v,
            ok = record.s == 1,
            i = 0;
        var run = function(reaction) {
          var handler = ok ? reaction.ok : reaction.fail,
              resolve = reaction.resolve,
              reject = reaction.reject,
              result,
              then;
          try {
            if (handler) {
              if (!ok)
                record.h = true;
              result = handler === true ? value : handler(value);
              if (result === reaction.promise) {
                reject(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(result)) {
                then.call(result, resolve, reject);
              } else
                resolve(result);
            } else
              reject(value);
          } catch (e) {
            reject(e);
          }
        };
        while (chain.length > i)
          run(chain[i++]);
        chain.length = 0;
        record.n = false;
        if (isReject)
          setTimeout(function() {
            var promise = record.p,
                handler,
                console;
            if (isUnhandled(promise)) {
              if (isNode) {
                process.emit('unhandledRejection', value, promise);
              } else if (handler = global.onunhandledrejection) {
                handler({
                  promise: promise,
                  reason: value
                });
              } else if ((console = global.console) && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            }
            record.a = undefined;
          }, 1);
      });
    };
    var isUnhandled = function(promise) {
      var record = promise._d,
          chain = record.a || record.c,
          i = 0,
          reaction;
      if (record.h)
        return false;
      while (chain.length > i) {
        reaction = chain[i++];
        if (reaction.fail || !isUnhandled(reaction.promise))
          return false;
      }
      return true;
    };
    var $reject = function(value) {
      var record = this;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      notify(record, true);
    };
    var $resolve = function(value) {
      var record = this,
          then;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      try {
        if (record.p === value)
          throw TypeError("Promise can't be resolved itself");
        if (then = isThenable(value)) {
          asap(function() {
            var wrapper = {
              r: record,
              d: false
            };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          record.v = value;
          record.s = 1;
          notify(record, false);
        }
      } catch (e) {
        $reject.call({
          r: record,
          d: false
        }, e);
      }
    };
    if (!USE_NATIVE) {
      P = function Promise(executor) {
        aFunction(executor);
        var record = this._d = {
          p: strictNew(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false,
          n: false
        };
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      req('ba')(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var reaction = new PromiseCapability(speciesConstructor(this, P)),
              promise = reaction.promise,
              record = this._d;
          reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
          reaction.fail = typeof onRejected == 'function' && onRejected;
          record.c.push(reaction);
          if (record.a)
            record.a.push(reaction);
          if (record.s)
            notify(record, false);
          return promise;
        },
        'catch': function(onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
    req('d8')(P, PROMISE);
    req('b6')(PROMISE);
    Wrapper = req('cf')[PROMISE];
    $export($export.S + $export.F * !USE_NATIVE, PROMISE, {reject: function reject(r) {
        var capability = new PromiseCapability(this),
            $$reject = capability.reject;
        $$reject(r);
        return capability.promise;
      }});
    $export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {resolve: function resolve(x) {
        if (x instanceof P && sameConstructor(x.constructor, this))
          return x;
        var capability = new PromiseCapability(this),
            $$resolve = capability.resolve;
        $$resolve(x);
        return capability.promise;
      }});
    $export($export.S + $export.F * !(USE_NATIVE && req('b4')(function(iter) {
      P.all(iter)['catch'](function() {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            resolve = capability.resolve,
            reject = capability.reject,
            values = [];
        var abrupt = perform(function() {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining)
            $.each.call(values, function(promise, index) {
              var alreadyCalled = false;
              C.resolve(promise).then(function(value) {
                if (alreadyCalled)
                  return;
                alreadyCalled = true;
                results[index] = value;
                --remaining || resolve(results);
              }, reject);
            });
          else
            resolve(results);
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      },
      race: function race(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            reject = capability.reject;
        var abrupt = perform(function() {
          forOf(iterable, false, function(promise) {
            C.resolve(promise).then(capability.resolve, reject);
          });
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      }
    });
  })(req('2e'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d9", ["da", "db"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var IObject = req('da'),
      defined = req('db');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("dc", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("dd", ["de", "dc", "ce", "d9", "df"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var addToUnscopables = req('de'),
      step = req('dc'),
      Iterators = req('ce'),
      toIObject = req('d9');
  module.exports = req('df')(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e0", ["dd", "b7", "e1", "ce", "b5"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  req('dd');
  var global = req('b7'),
      hide = req('e1'),
      Iterators = req('ce'),
      ITERATOR = req('b5')('iterator'),
      NL = global.NodeList,
      HTC = global.HTMLCollection,
      NLProto = NL && NL.prototype,
      HTCProto = HTC && HTC.prototype,
      ArrayValues = Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  if (NLProto && !NLProto[ITERATOR])
    hide(NLProto, ITERATOR, ArrayValues);
  if (HTCProto && !HTCProto[ITERATOR])
    hide(HTCProto, ITERATOR, ArrayValues);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d8", ["b8", "e2", "b5"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var def = req('b8').setDesc,
      has = req('e2'),
      TAG = req('b5')('toStringTag');
  module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      def(it, TAG, {
        configurable: true,
        value: tag
      });
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e3", ["b8", "e4", "d8", "e1", "b5"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = req('b8'),
      descriptor = req('e4'),
      setToStringTag = req('d8'),
      IteratorPrototype = {};
  req('e1')(IteratorPrototype, req('b5')('iterator'), function() {
    return this;
  });
  module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
    setToStringTag(Constructor, NAME + ' Iterator');
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ce", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {};
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e2", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d6", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = false;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("df", ["d6", "d7", "bb", "e1", "e2", "ce", "e3", "d8", "b8", "b5"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var LIBRARY = req('d6'),
      $export = req('d7'),
      redefine = req('bb'),
      hide = req('e1'),
      has = req('e2'),
      Iterators = req('ce'),
      $iterCreate = req('e3'),
      setToStringTag = req('d8'),
      getProto = req('b8').getProto,
      ITERATOR = req('b5')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function() {
    return this;
  };
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function(kind) {
      if (!BUGGY && kind in proto)
        return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        methods,
        key;
    if ($native) {
      var IteratorPrototype = getProto($default.call(new Base));
      setToStringTag(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR))
        hide(IteratorPrototype, ITERATOR, returnThis);
      if (DEF_VALUES && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
    }
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: !DEF_VALUES ? $default : getMethod('entries')
      };
      if (FORCED)
        for (key in methods) {
          if (!(key in proto))
            redefine(proto, key, methods[key]);
        }
      else
        $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e5", ["e6", "db"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = req('e6'),
      defined = req('db');
  module.exports = function(TO_STRING) {
    return function(that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l)
        return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e7", ["e5", "df"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $at = req('e5')(true);
  req('df')(String, 'String', function(iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function() {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length)
      return {
        value: undefined,
        done: true
      };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("cd", ["c5", "b5"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = req('c5'),
      TAG = req('b5')('toStringTag'),
      ARG = cof(function() {
        return arguments;
      }()) == 'Arguments';
  module.exports = function(it) {
    var O,
        T,
        B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e8", ["cd", "b5", "bb"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var classof = req('cd'),
      test = {};
  test[req('b5')('toStringTag')] = 'z';
  if (test + '' != '[object z]') {
    req('bb')(Object.prototype, 'toString', function toString() {
      return '[object ' + classof(this) + ']';
    }, true);
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e9", ["e8", "e7", "e0", "d5", "cf"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  req('e8');
  req('e7');
  req('e0');
  req('d5');
  module.exports = req('cf').Promise;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("de", ["b5", "e1"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var UNSCOPABLES = req('b5')('unscopables'),
      ArrayProto = Array.prototype;
  if (ArrayProto[UNSCOPABLES] == undefined)
    req('e1')(ArrayProto, UNSCOPABLES, {});
  module.exports = function(key) {
    ArrayProto[UNSCOPABLES][key] = true;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ea", ["c5"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = req('c5');
  module.exports = Array.isArray || function(arg) {
    return cof(arg) == 'Array';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("eb", ["c0", "ea", "b5"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = req('c0'),
      isArray = req('ea'),
      SPECIES = req('b5')('species');
  module.exports = function(original, length) {
    var C;
    if (isArray(original)) {
      C = original.constructor;
      if (typeof C == 'function' && (C === Array || isArray(C.prototype)))
        C = undefined;
      if (isObject(C)) {
        C = C[SPECIES];
        if (C === null)
          C = undefined;
      }
    }
    return new (C === undefined ? Array : C)(length);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ec", ["db"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var defined = req('db');
  module.exports = function(it) {
    return Object(defined(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("da", ["c5"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = req('c5');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ed", ["c4", "da", "ec", "d3", "eb"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = req('c4'),
      IObject = req('da'),
      toObject = req('ec'),
      toLength = req('d3'),
      asc = req('eb');
  module.exports = function(TYPE) {
    var IS_MAP = TYPE == 1,
        IS_FILTER = TYPE == 2,
        IS_SOME = TYPE == 3,
        IS_EVERY = TYPE == 4,
        IS_FIND_INDEX = TYPE == 6,
        NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function($this, callbackfn, that) {
      var O = toObject($this),
          self = IObject(O),
          f = ctx(callbackfn, that, 3),
          length = toLength(self.length),
          index = 0,
          result = IS_MAP ? asc($this, length) : IS_FILTER ? asc($this, 0) : undefined,
          val,
          res;
      for (; length > index; index++)
        if (NO_HOLES || index in self) {
          val = self[index];
          res = f(val, index, O);
          if (TYPE) {
            if (IS_MAP)
              result[index] = res;
            else if (res)
              switch (TYPE) {
                case 3:
                  return true;
                case 5:
                  return val;
                case 6:
                  return index;
                case 2:
                  result.push(val);
              }
            else if (IS_EVERY)
              return false;
          }
        }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ee", ["d7", "ed", "de"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $export = req('d7'),
      $find = req('ed')(5),
      KEY = 'find',
      forced = true;
  if (KEY in [])
    Array(1)[KEY](function() {
      forced = false;
    });
  $export($export.P + $export.F * forced, 'Array', {find: function find(callbackfn) {
      return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    }});
  req('de')(KEY);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ef", ["ee", "cf"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  req('ee');
  module.exports = req('cf').Array.find;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f0", ["d7", "d3", "f1", "f2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $export = req('d7'),
      toLength = req('d3'),
      context = req('f1'),
      ENDS_WITH = 'endsWith',
      $endsWith = ''[ENDS_WITH];
  $export($export.P + $export.F * req('f2')(ENDS_WITH), 'String', {endsWith: function endsWith(searchString) {
      var that = context(this, searchString, ENDS_WITH),
          $$ = arguments,
          endPosition = $$.length > 1 ? $$[1] : undefined,
          len = toLength(that.length),
          end = endPosition === undefined ? len : Math.min(toLength(endPosition), len),
          search = String(searchString);
      return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f3", ["f0", "cf"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  req('f0');
  module.exports = req('cf').String.endsWith;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f2", ["b5"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var MATCH = req('b5')('match');
  module.exports = function(KEY) {
    var re = /./;
    try {
      '/./'[KEY](re);
    } catch (e) {
      try {
        re[MATCH] = false;
        return !'/./'[KEY](re);
      } catch (f) {}
    }
    return true;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("db", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f4", ["b7"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = req('b7'),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b5", ["f4", "f5", "b7"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var store = req('f4')('wks'),
      uid = req('f5'),
      Symbol = req('b7').Symbol;
  module.exports = function(name) {
    return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c5", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c0", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f6", ["c0", "c5", "b5"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = req('c0'),
      cof = req('c5'),
      MATCH = req('b5')('match');
  module.exports = function(it) {
    var isRegExp;
    return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f1", ["f6", "db"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isRegExp = req('f6'),
      defined = req('db');
  module.exports = function(that, searchString, NAME) {
    if (isRegExp(searchString))
      throw TypeError('String#' + NAME + " doesn't accept regex!");
    return String(defined(that));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e6", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d3", ["e6"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = req('e6'),
      min = Math.min;
  module.exports = function(it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c9", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("c4", ["c9"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var aFunction = req('c9');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f5", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var id = 0,
      px = Math.random();
  module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("bb", ["b7", "e1", "f5", "cf"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = req('b7'),
      hide = req('e1'),
      SRC = req('f5')('src'),
      TO_STRING = 'toString',
      $toString = Function[TO_STRING],
      TPL = ('' + $toString).split(TO_STRING);
  req('cf').inspectSource = function(it) {
    return $toString.call(it);
  };
  (module.exports = function(O, key, val, safe) {
    if (typeof val == 'function') {
      val.hasOwnProperty(SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
      val.hasOwnProperty('name') || hide(val, 'name', key);
    }
    if (O === global) {
      O[key] = val;
    } else {
      if (!safe)
        delete O[key];
      hide(O, key, val);
    }
  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || $toString.call(this);
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f7", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b9", ["f7"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = !req('f7')(function() {
    return Object.defineProperty({}, 'a', {get: function() {
        return 7;
      }}).a != 7;
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e4", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b8", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e1", ["b8", "e4", "b9"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = req('b8'),
      createDesc = req('e4');
  module.exports = req('b9') ? function(object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("cf", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = module.exports = {version: '1.2.6'};
  if (typeof __e == 'number')
    __e = core;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b7", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("d7", ["b7", "cf", "e1", "bb", "c4"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = req('b7'),
      core = req('cf'),
      hide = req('e1'),
      redefine = req('bb'),
      ctx = req('c4'),
      PROTOTYPE = 'prototype';
  var $export = function(type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE],
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}),
        key,
        own,
        out,
        exp;
    if (IS_GLOBAL)
      source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      out = (own ? target : source)[key];
      exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (target && !own)
        redefine(target, key, out);
      if (exports[key] != out)
        hide(exports, key, exp);
      if (IS_PROTO && expProto[key] != out)
        expProto[key] = out;
    }
  };
  global.core = core;
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f8", ["d7", "d3", "f1", "f2"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $export = req('d7'),
      toLength = req('d3'),
      context = req('f1'),
      STARTS_WITH = 'startsWith',
      $startsWith = ''[STARTS_WITH];
  $export($export.P + $export.F * req('f2')(STARTS_WITH), 'String', {startsWith: function startsWith(searchString) {
      var that = context(this, searchString, STARTS_WITH),
          $$ = arguments,
          index = toLength(Math.min($$.length > 1 ? $$[1] : undefined, that.length)),
          search = String(searchString);
      return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f9", ["f8", "cf"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  req('f8');
  module.exports = req('cf').String.startsWith;
  global.define = __define;
  return module.exports;
});

$__System.register('1', ['2', '3', '4', '5', '6', '8', '9', '12', '13', 'f9', 'f3', 'ef', 'e9', 'b2', 'b1', 'af', 'ad', 'ac', 'a6'], function (_export) {

  // Xmas magic
  'use strict';

  var L, $, HTML, i18n, DefaultMap, Sidebar, DraggableValuePopup, App, year, MELODIES_DCAT_CATALOG_URL, map, baseLayerLabels, baseLayers, id, layer, baseMaps, layerControl, SmartLayerControl, app, catalogUrl, url, sidebar;

  function letItSnow() {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      var _loop = function () {
        var node = _step.value;

        if (node.style.opacity === '1') setTimeout(function () {
          return node.style.display = 'none';
        }, 3500);else node.style.display = 'block';
        setTimeout(function () {
          return node.style.opacity = node.style.opacity === '1' ? '0' : '1';
        }, 100);
      };

      for (var _iterator = document.querySelectorAll('.snow')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        _loop();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
  return {
    setters: [function (_9) {}, function (_7) {}, function (_6) {}, function (_2) {
      L = _2['default'];
    }, function (_5) {}, function (_8) {
      $ = _8.$;
      HTML = _8.HTML;
    }, function (_3) {
      i18n = _3.i18n;
      DefaultMap = _3.DefaultMap;
    }, function (_4) {
      Sidebar = _4['default'];
    }, function (_) {}, function (_f9) {}, function (_f3) {}, function (_ef) {}, function (_e9) {}, function (_b2) {}, function (_b1) {}, function (_af) {}, function (_ad) {}, function (_ac) {
      DraggableValuePopup = _ac['default'];
    }, function (_a6) {
      App = _a6['default'];
    }],
    execute: function () {
      $('body').add(HTML('\n  <div id="snow1" class="snow"></div>\n  <div id="snow2" class="snow"></div>\n  <div id="snow3" class="snow"></div>\n'));document.getElementById('map').addEventListener('keypress', function (e) {
        if (String.fromCharCode(e.charCode) == 's') letItSnow();
      }, false);
      year = new Date().getFullYear();

      if (new Date(year + '-12-22') <= new Date() && new Date() <= new Date(year + '-01-03')) letItSnow();
      // end of Xmas magic

      MELODIES_DCAT_CATALOG_URL = 'http://ckan-demo.melodiesproject.eu';
      map = L.map('map', {
        loadingControl: true,
        // initial center and zoom has to be set before layers can be added
        center: [10, 0],
        zoom: 2
      });

      // Layer control and base layer setup
      baseLayerLabels = {
        'Hydda.Base': 'Hydda',
        'OpenStreetMap': 'OpenStreetMap',
        'OpenStreetMap.BlackAndWhite': 'OpenStreetMap (B/W)',
        'OpenTopoMap': 'OpenTopoMap',
        'MapQuestOpen.Aerial': 'MapQuestOpen Aerial'
      };
      baseLayers = {};

      for (id in baseLayerLabels) {
        layer = L.tileLayer.provider(id);

        baseLayers[baseLayerLabels[id]] = layer;
      }
      baseLayers[baseLayerLabels['MapQuestOpen.Aerial']].addTo(map);

      baseMaps = [{
        groupName: 'Base Maps',
        expanded: true,
        layers: baseLayers
      }];
      layerControl = L.Control.styledLayerControl(baseMaps, [], {
        container_width: "300px",
        container_maxHeight: "500px",
        collapsed: false
      });

      map.addControl(layerControl);

      /**
       * Proxy around StyledLayerControl that keeps track of groups and layers
       * to allow some added features:
       * - once a group has no layers anymore, it gets removed
       * - allow renaming of groups by re-adding them under the new name
       */

      SmartLayerControl = (function () {
        function SmartLayerControl(styledLayerControl) {
          babelHelpers.classCallCheck(this, SmartLayerControl);

          this._control = styledLayerControl;
          this._groups = new DefaultMap(function () {
            return [];
          });
          this._layers = new Map();
        }

        babelHelpers.createClass(SmartLayerControl, [{
          key: 'addOverlay',
          value: function addOverlay(layer, name, options) {
            var groupName = options.groupName;
            this._groups.get(groupName).push({ layer: layer, name: name });
            this._layers.set(layer, groupName);
            this._control.addOverlay(layer, name, options);
          }
        }, {
          key: 'removeLayer',
          value: function removeLayer(layer) {
            this._control.removeLayer(layer);
            var groupName = this._layers.get(layer);
            this._layers['delete'](layer);
            var group = this._groups.get(groupName);
            var newGroup = group.filter(function (obj) {
              return obj.layer !== layer;
            });
            this._groups.set(groupName, newGroup);
            if (newGroup.length === 0) {
              this._control.removeGroup(groupName);
              this._groups['delete'](groupName);
            }
          }
        }, {
          key: 'renameGroup',
          value: function renameGroup(oldName, newName) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = this._groups.get(oldName).slice()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var _step2$value = _step2.value;
                var layer = _step2$value.layer;
                var _name = _step2$value.name;

                this.removeLayer(layer);
                this.addOverlay(layer, _name, { groupName: newName, expanded: true });
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                  _iterator2['return']();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
        }, {
          key: 'getLayers',
          value: function getLayers() {
            return [].concat(babelHelpers.toConsumableArray(this._layers.keys()));
          }
        }]);
        return SmartLayerControl;
      })();

      map.layerControl = new SmartLayerControl(layerControl);

      map.on('click', function (e) {
        new DraggableValuePopup({
          layers: map.layerControl.getLayers(),
          className: 'leaflet-popup-draggable'
        }).setLatLng(e.latlng).openOn(map);
      });

      app = new App(map);

      app.on('dataLoading', function () {
        return map.fire('dataloading');
      });
      app.on('dataLoad', function () {
        return map.fire('dataload');
      });
      app.workspace.on('titleChange', function (_ref) {
        var oldTitle = _ref.oldTitle;
        var newTitle = _ref.newTitle;

        // by convention, group names are dataset titles
        map.layerControl.renameGroup(i18n(oldTitle), i18n(newTitle));
      });

      // Sidebar setup
      catalogUrl = undefined;

      if (window.location.hash) {
        url = window.location.hash.substr(1);

        if (url.toLowerCase().startsWith('http://') || url.toLowerCase().startsWith('https://')) {
          catalogUrl = url;
        }
      }
      if (!catalogUrl) {
        catalogUrl = MELODIES_DCAT_CATALOG_URL;
      }

      sidebar = new Sidebar(map, { app: app, layerControl: layerControl });

      app.catalogue.loadFromDCAT(catalogUrl).then(function () {
        sidebar.open(sidebar.panes.Search);
      })['catch'](function () {
        sidebar.open(sidebar.panes.Search);
      });
    }
  };
});

$__System.register('app/css/snow.css!github:systemjs/plugin-css@0.1.21', [], false, function() {});
$__System.register('app/css/styledLayerControl/styledLayerControl.css!github:systemjs/plugin-css@0.1.21', [], false, function() {});
$__System.register('app/css/style.css!github:systemjs/plugin-css@0.1.21', [], false, function() {});
$__System.register('github:Turbo87/sidebar-v2@master/css/leaflet-sidebar.css!github:systemjs/plugin-css@0.1.21', [], false, function() {});
$__System.register('github:guygriffiths/category-remapper-js@master/css/remapper.css!github:systemjs/plugin-css@0.1.21', [], false, function() {});
$__System.register('npm:c3@0.4.11-rc4/c3.css!github:systemjs/plugin-css@0.1.21', [], false, function() {});
$__System.register('npm:c3@0.4.10/c3.css!github:systemjs/plugin-css@0.1.21', [], false, function() {});
$__System.register('github:ebrelsford/Leaflet.loading@0.1.18/src/Control.Loading.css!github:systemjs/plugin-css@0.1.21', [], false, function() {});
$__System.register('github:Leaflet/Leaflet@0.7.7/dist/leaflet.css!github:systemjs/plugin-css@0.1.21', [], false, function() {});
$__System.register('github:twbs/bootstrap@3.3.6/css/bootstrap.css!github:systemjs/plugin-css@0.1.21', [], false, function() {});
(function(c){if (typeof document == 'undefined') return; var d=document,a='appendChild',i='styleSheet',s=d.createElement('style');s.type='text/css';d.getElementsByTagName('head')[0][a](s);s[i]?s[i].cssText=c:s[a](d.createTextNode(c));})
(".snow{display:none;height:100%;left:0;position:absolute;top:0;width:100%;z-index:1;pointer-events:none;opacity:0;transition:opacity 3s}#snow1{background-image:url(http://www.wearewebstars.dk/codepen/img/s1.png);animation:snow1 5s linear infinite}#snow2{background-image:url(http://www.wearewebstars.dk/codepen/img/s2.png);animation:snow2 20s linear infinite}#snow3{background-image:url(http://www.wearewebstars.dk/codepen/img/s3.png);animation:snow3 30s linear infinite}@keyframes snow1{from{background-position:0 0}to{background-position:500px 500px}}@keyframes snow2{from{background-position:0 0}to{background-position:400px 800px}}@keyframes snow3{from{background-position:0 0}to{background-position:-600px 900px}}.ac-container{width:auto;margin:10px auto 10px auto;text-align:left;overflow-y:auto;overflow-x:hidden;height:auto}.ac-container label{font-family:BebasNeueRegular,'Arial Narrow',Arial,sans-serif;padding:5px 20px;position:relative;z-index:20;display:block;cursor:pointer;color:#777;text-shadow:1px 1px 1px rgba(255,255,255,.8);line-height:30px;font-size:17px;background:#fff;background:-moz-linear-gradient(top,#fff 1%,#eaeaea 100%);background:-webkit-gradient(linear,left top,left bottom,color-stop(1%,#fff),color-stop(100%,#eaeaea));background:-webkit-linear-gradient(top,#fff 1%,#eaeaea 100%);background:-o-linear-gradient(top,#fff 1%,#eaeaea 100%);background:-ms-linear-gradient(top,#fff 1%,#eaeaea 100%);background:linear-gradient(top,#fff 1%,#eaeaea 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#ffffff', endColorstr='#eaeaea', GradientType=0 );box-shadow:0 0 0 1px rgba(155,155,155,.3),1px 0 0 0 rgba(255,255,255,.9) inset,0 2px 2px rgba(0,0,0,.1);box-sizing:content-box;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.ac-container label:hover{background:#fff}.ac-container input.menu:checked+label,.ac-container input.menu:checked+label:hover{background:#c6e1ec;color:#3d7489;text-shadow:0 1px 1px rgba(255,255,255,.6);box-shadow:0 0 0 1px rgba(155,155,155,.3),0 2px 2px rgba(0,0,0,.1)}.ac-container input.menu:checked+label:after,.ac-container label:hover:after{content:'';position:absolute;width:24px;height:24px;right:13px;top:7px;background:transparent url(app/css/styledLayerControl/images/arrow_down.png) no-repeat center center}.ac-container input.menu:checked+label:after{background-image:url(app/css/styledLayerControl/images/arrow_up.png)}.ac-container input.menu{display:none}.ac-container article{background:rgba(255,255,255,.5);margin-top:-1px;overflow:hidden;height:0;position:relative;z-index:10;-webkit-transition:height .3s ease-in-out,box-shadow .6s linear;-moz-transition:height .3s ease-in-out,box-shadow .6s linear;-o-transition:height .3s ease-in-out,box-shadow .6s linear;-ms-transition:height .3s ease-in-out,box-shadow .6s linear;transition:height .3s ease-in-out,box-shadow .6s linear}.ac-container input.menu:checked~article{-webkit-transition:height .5s ease-in-out,box-shadow .1s linear;-moz-transition:height .5s ease-in-out,box-shadow .1s linear;-o-transition:height .5s ease-in-out,box-shadow .1s linear;-ms-transition:height .5s ease-in-out,box-shadow .1s linear;transition:height .5s ease-in-out,box-shadow .1s linear;box-shadow:0 0 0 1px rgba(155,155,155,.3)}.ac-container input.menu:checked~article.ac-large{height:auto;max-height:200px;padding-top:5px;overflow-y:auto}.menu-item-radio{font-family:Ubuntu-Regular,Arial,sans-serif;font-size:13px}.menu-item-checkbox{font-family:Ubuntu-Regular,Arial,sans-serif;font-size:13px}.bt_delete{position:relative;float:right;background-image:url(app/css/styledLayerControl/images/delete.png);background-color:transparent;background-repeat:no-repeat;background-position:0 0;border:none;cursor:pointer;height:16px;width:16px;vertical-align:middle}.leaflet-control-layers{padding:6px 8px;font:14px/16px Arial,Helvetica,sans-serif;background:#fff;background:rgba(255,255,255,.8);box-shadow:0 0 15px rgba(0,0,0,.2);border-radius:5px}input[type=radio].leaflet-control-layers-selector,input[type=checkbox].leaflet-control-layers-selector{margin:3px 3px 0 5px}body,html{height:100%;margin:0}#map{height:100%}.info{padding:6px 8px;font:14px/16px Arial,Helvetica,sans-serif;background:#fff;background:rgba(255,255,255,.8);box-shadow:0 0 15px rgba(0,0,0,.2);border-radius:5px}.external{background-image:linear-gradient(transparent,transparent),url(data:image/svg+xml,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2210%22%20height%3D%2210%22%3E%3Cg%20transform%3D%22translate%28-826.429%20-698.791%29%22%3E%3Crect%20width%3D%225.982%22%20height%3D%225.982%22%20x%3D%22826.929%22%20y%3D%22702.309%22%20fill%3D%22%23fff%22%20stroke%3D%22%2306c%22%2F%3E%3Cg%3E%3Cpath%20d%3D%22M831.194%20698.791h5.234v5.391l-1.571%201.545-1.31-1.31-2.725%202.725-2.689-2.689%202.808-2.808-1.311-1.311z%22%20fill%3D%22%2306f%22%2F%3E%3Cpath%20d%3D%22M835.424%20699.795l.022%204.885-1.817-1.817-2.881%202.881-1.228-1.228%202.881-2.881-1.851-1.851z%22%20fill%3D%22%23fff%22%2F%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E);background-position:right center;background-repeat:no-repeat;padding-right:13px}.dataset-spatial-minimap{height:120px}.code-nowrap{word-wrap:normal;white-space:pre}.leaflet-popup-draggable .leaflet-popup-content-wrapper{cursor:move}.sidebar{position:absolute;top:0;bottom:0;width:100%;overflow:hidden;z-index:2000}.sidebar.collapsed{width:40px}@media (min-width:768px){.sidebar{top:10px;bottom:10px;transition:width .5s}}@media (min-width:768px) and (max-width:991px){.sidebar{width:305px}}@media (min-width:992px) and (max-width:1199px){.sidebar{width:390px}}@media (min-width:1200px){.sidebar{width:460px}}.sidebar-left{left:0}@media (min-width:768px){.sidebar-left{left:10px}}.sidebar-right{right:0}@media (min-width:768px){.sidebar-right{right:10px}}.sidebar-tabs{top:0;bottom:0;height:100%;background-color:#fff}.sidebar-left .sidebar-tabs{left:0}.sidebar-right .sidebar-tabs{right:0}.sidebar-tabs,.sidebar-tabs>ul{position:absolute;width:40px;margin:0;padding:0}.sidebar-tabs>li,.sidebar-tabs>ul>li{width:100%;height:40px;color:#333;font-size:12pt;overflow:hidden;transition:all 80ms}.sidebar-tabs>li:hover,.sidebar-tabs>ul>li:hover{color:#000;background-color:#eee}.sidebar-tabs>li.active,.sidebar-tabs>ul>li.active{color:#fff;background-color:#0074d9}.sidebar-tabs>li.disabled,.sidebar-tabs>ul>li.disabled{color:rgba(51,51,51,.4)}.sidebar-tabs>li.disabled:hover,.sidebar-tabs>ul>li.disabled:hover{background:0 0}.sidebar-tabs>li.disabled>a,.sidebar-tabs>ul>li.disabled>a{cursor:default}.sidebar-tabs>li>a,.sidebar-tabs>ul>li>a{display:block;width:100%;height:100%;line-height:40px;color:inherit;text-decoration:none;text-align:center}.sidebar-tabs>ul+ul{bottom:0}.sidebar-content{position:absolute;top:0;bottom:0;background-color:rgba(255,255,255,.95);overflow-x:hidden;overflow-y:auto}.sidebar-left .sidebar-content{left:40px;right:0}.sidebar-right .sidebar-content{left:0;right:40px}.sidebar.collapsed>.sidebar-content{overflow-y:hidden}.sidebar-pane{display:none;left:0;right:0;box-sizing:border-box;padding:10px 20px}.sidebar-pane.active{display:block}@media (min-width:768px) and (max-width:991px){.sidebar-pane{min-width:265px}}@media (min-width:992px) and (max-width:1199px){.sidebar-pane{min-width:350px}}@media (min-width:1200px){.sidebar-pane{min-width:420px}}.sidebar-header{margin:-10px -20px 0;height:40px;padding:0 20px;line-height:40px;font-size:14.4pt;color:#fff;background-color:#0074d9}.sidebar-right .sidebar-header{padding-left:40px}.sidebar-close{position:absolute;top:0;width:40px;height:40px;text-align:center;cursor:pointer}.sidebar-left .sidebar-close{right:0}.sidebar-right .sidebar-close{left:0}.sidebar-left~.sidebar-map{margin-left:40px}@media (min-width:768px){.sidebar-left~.sidebar-map{margin-left:0}}.sidebar-right~.sidebar-map{margin-right:40px}@media (min-width:768px){.sidebar-right~.sidebar-map{margin-right:0}}.sidebar{box-shadow:0 1px 5px rgba(0,0,0,.65)}.sidebar.leaflet-touch{box-shadow:none;border-right:2px solid rgba(0,0,0,.2)}@media (min-width:768px){.sidebar{border-radius:4px}.sidebar.leaflet-touch{border:2px solid rgba(0,0,0,.2)}}@media (min-width:768px){.sidebar-left~.sidebar-map .leaflet-left{transition:left .5s}}@media (min-width:768px) and (max-width:991px){.sidebar-left~.sidebar-map .leaflet-left{left:315px}}@media (min-width:992px) and (max-width:1199px){.sidebar-left~.sidebar-map .leaflet-left{left:400px}}@media (min-width:1200px){.sidebar-left~.sidebar-map .leaflet-left{left:470px}}@media (min-width:768px){.sidebar-left.collapsed~.sidebar-map .leaflet-left{left:50px}}@media (min-width:768px){.sidebar-right~.sidebar-map .leaflet-right{transition:right .5s}}@media (min-width:768px) and (max-width:991px){.sidebar-right~.sidebar-map .leaflet-right{right:315px}}@media (min-width:992px) and (max-width:1199px){.sidebar-right~.sidebar-map .leaflet-right{right:400px}}@media (min-width:1200px){.sidebar-right~.sidebar-map .leaflet-right{right:470px}}@media (min-width:768px){.sidebar-right.collapsed~.sidebar-map .leaflet-right{right:50px}}.jsplumb-connector{z-index:9040}.jsplumb-endpoint{z-index:9050}.jsplumb-overlay{z-index:9060}.main-remapper{position:fixed;width:100%;height:100%;left:0;top:0;z-index:1000}.remap-froms,.remap-tos{position:absolute;top:0;left:0;width:250px;height:100%;background-color:rgba(150,220,255,.8);color:#000;text-align:right}.remap-tos{left:auto;right:0;width:250px;overflow:hidden;color:#000;text-align:left}.centrecontent{position:absolute;opacity:.8;bottom:0;height:100%;left:250px;right:250px;background:#fff;text-align:center;vertical-align:bottom}.buttonholder{position:absolute;bottom:0;background-color:rgba(255,255,255,0);left:250px;right:250px;text-align:center}.cancel-remap-button,.remap-button{font-size:20pt;padding:20px;margin:20px}.map-from,.map-to{margin:2px;border-style:solid;border-width:thin;font-family:sans-serif;background-color:rgba(0,210,255,1)}.map-from{padding-right:10px}.map-to{padding-left:10px}.c3 svg{font:10px sans-serif;-webkit-tap-highlight-color:transparent}.c3 line,.c3 path{fill:none;stroke:#000}.c3 text{-webkit-user-select:none;-moz-user-select:none;user-select:none}.c3-bars path,.c3-event-rect,.c3-legend-item-tile,.c3-xgrid-focus,.c3-ygrid{shape-rendering:crispEdges}.c3-chart-arc path{stroke:#fff}.c3-chart-arc text{fill:#fff;font-size:13px}.c3-grid line{stroke:#aaa}.c3-grid text{fill:#aaa}.c3-xgrid,.c3-ygrid{stroke-dasharray:3 3}.c3-text.c3-empty{fill:grey;font-size:2em}.c3-line{stroke-width:1px}.c3-circle._expanded_{stroke-width:1px;stroke:#fff}.c3-selected-circle{fill:#fff;stroke-width:2px}.c3-bar{stroke-width:0}.c3-bar._expanded_{fill-opacity:.75}.c3-target.c3-focused{opacity:1}.c3-target.c3-focused path.c3-line,.c3-target.c3-focused path.c3-step{stroke-width:2px}.c3-target.c3-defocused{opacity:.3!important}.c3-region{fill:#4682b4;fill-opacity:.1}.c3-brush .extent{fill-opacity:.1}.c3-legend-item{font-size:12px}.c3-legend-item-hidden{opacity:.15}.c3-legend-background{opacity:.75;fill:#fff;stroke:#d3d3d3;stroke-width:1}.c3-title{font:14px sans-serif}.c3-tooltip-container{z-index:10}.c3-tooltip{border-collapse:collapse;border-spacing:0;background-color:#fff;empty-cells:show;-webkit-box-shadow:7px 7px 12px -9px #777;-moz-box-shadow:7px 7px 12px -9px #777;box-shadow:7px 7px 12px -9px #777;opacity:.9}.c3-tooltip tr{border:1px solid #CCC}.c3-tooltip th{background-color:#aaa;font-size:14px;padding:2px 5px;text-align:left;color:#FFF}.c3-tooltip td{font-size:13px;padding:3px 6px;background-color:#fff;border-left:1px dotted #999}.c3-tooltip td>span{display:inline-block;width:10px;height:10px;margin-right:6px}.c3-tooltip td.value{text-align:right}.c3-area{stroke-width:0;opacity:.2}.c3-chart-arcs-title{dominant-baseline:middle;font-size:1.3em}.c3-chart-arcs .c3-chart-arcs-background{fill:#e0e0e0;stroke:none}.c3-chart-arcs .c3-chart-arcs-gauge-unit{fill:#000;font-size:16px}.c3-chart-arcs .c3-chart-arcs-gauge-max{fill:#777}.c3-chart-arcs .c3-chart-arcs-gauge-min{fill:#777}.c3-chart-arc .c3-gauge-value{fill:#000}.c3 svg{font:10px sans-serif}.c3 line,.c3 path{fill:none;stroke:#000}.c3 text{-webkit-user-select:none;-moz-user-select:none;user-select:none}.c3-bars path,.c3-event-rect,.c3-legend-item-tile,.c3-xgrid-focus,.c3-ygrid{shape-rendering:crispEdges}.c3-chart-arc path{stroke:#fff}.c3-chart-arc text{fill:#fff;font-size:13px}.c3-grid line{stroke:#aaa}.c3-grid text{fill:#aaa}.c3-xgrid,.c3-ygrid{stroke-dasharray:3 3}.c3-text.c3-empty{fill:grey;font-size:2em}.c3-line{stroke-width:1px}.c3-circle._expanded_{stroke-width:1px;stroke:#fff}.c3-selected-circle{fill:#fff;stroke-width:2px}.c3-bar{stroke-width:0}.c3-bar._expanded_{fill-opacity:.75}.c3-target.c3-focused{opacity:1}.c3-target.c3-focused path.c3-line,.c3-target.c3-focused path.c3-step{stroke-width:2px}.c3-target.c3-defocused{opacity:.3!important}.c3-region{fill:#4682b4;fill-opacity:.1}.c3-brush .extent{fill-opacity:.1}.c3-legend-item{font-size:12px}.c3-legend-item-hidden{opacity:.15}.c3-legend-background{opacity:.75;fill:#fff;stroke:#d3d3d3;stroke-width:1}.c3-tooltip-container{z-index:10}.c3-tooltip{border-collapse:collapse;border-spacing:0;background-color:#fff;empty-cells:show;-webkit-box-shadow:7px 7px 12px -9px #777;-moz-box-shadow:7px 7px 12px -9px #777;box-shadow:7px 7px 12px -9px #777;opacity:.9}.c3-tooltip tr{border:1px solid #CCC}.c3-tooltip th{background-color:#aaa;font-size:14px;padding:2px 5px;text-align:left;color:#FFF}.c3-tooltip td{font-size:13px;padding:3px 6px;background-color:#fff;border-left:1px dotted #999}.c3-tooltip td>span{display:inline-block;width:10px;height:10px;margin-right:6px}.c3-tooltip td.value{text-align:right}.c3-area{stroke-width:0;opacity:.2}.c3-chart-arcs-title{dominant-baseline:middle;font-size:1.3em}.c3-chart-arcs .c3-chart-arcs-background{fill:#e0e0e0;stroke:none}.c3-chart-arcs .c3-chart-arcs-gauge-unit{fill:#000;font-size:16px}.c3-chart-arcs .c3-chart-arcs-gauge-max{fill:#777}.c3-chart-arcs .c3-chart-arcs-gauge-min{fill:#777}.c3-chart-arc .c3-gauge-value{fill:#000}.leaflet-control-loading:empty{background-image:url(data:image/gif;base64,R0lGODlhEAAQAPQAAP///wAAAPDw8IqKiuDg4EZGRnp6egAAAFhYWCQkJKysrL6+vhQUFJycnAQEBDY2NmhoaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH+GkNyZWF0ZWQgd2l0aCBhamF4bG9hZC5pbmZvACH5BAAKAAAAIf8LTkVUU0NBUEUyLjADAQAAACwAAAAAEAAQAAAFdyAgAgIJIeWoAkRCCMdBkKtIHIngyMKsErPBYbADpkSCwhDmQCBethRB6Vj4kFCkQPG4IlWDgrNRIwnO4UKBXDufzQvDMaoSDBgFb886MiQadgNABAokfCwzBA8LCg0Egl8jAggGAA1kBIA1BAYzlyILczULC2UhACH5BAAKAAEALAAAAAAQABAAAAV2ICACAmlAZTmOREEIyUEQjLKKxPHADhEvqxlgcGgkGI1DYSVAIAWMx+lwSKkICJ0QsHi9RgKBwnVTiRQQgwF4I4UFDQQEwi6/3YSGWRRmjhEETAJfIgMFCnAKM0KDV4EEEAQLiF18TAYNXDaSe3x6mjidN1s3IQAh+QQACgACACwAAAAAEAAQAAAFeCAgAgLZDGU5jgRECEUiCI+yioSDwDJyLKsXoHFQxBSHAoAAFBhqtMJg8DgQBgfrEsJAEAg4YhZIEiwgKtHiMBgtpg3wbUZXGO7kOb1MUKRFMysCChAoggJCIg0GC2aNe4gqQldfL4l/Ag1AXySJgn5LcoE3QXI3IQAh+QQACgADACwAAAAAEAAQAAAFdiAgAgLZNGU5joQhCEjxIssqEo8bC9BRjy9Ag7GILQ4QEoE0gBAEBcOpcBA0DoxSK/e8LRIHn+i1cK0IyKdg0VAoljYIg+GgnRrwVS/8IAkICyosBIQpBAMoKy9dImxPhS+GKkFrkX+TigtLlIyKXUF+NjagNiEAIfkEAAoABAAsAAAAABAAEAAABWwgIAICaRhlOY4EIgjH8R7LKhKHGwsMvb4AAy3WODBIBBKCsYA9TjuhDNDKEVSERezQEL0WrhXucRUQGuik7bFlngzqVW9LMl9XWvLdjFaJtDFqZ1cEZUB0dUgvL3dgP4WJZn4jkomWNpSTIyEAIfkEAAoABQAsAAAAABAAEAAABX4gIAICuSxlOY6CIgiD8RrEKgqGOwxwUrMlAoSwIzAGpJpgoSDAGifDY5kopBYDlEpAQBwevxfBtRIUGi8xwWkDNBCIwmC9Vq0aiQQDQuK+VgQPDXV9hCJjBwcFYU5pLwwHXQcMKSmNLQcIAExlbH8JBwttaX0ABAcNbWVbKyEAIfkEAAoABgAsAAAAABAAEAAABXkgIAICSRBlOY7CIghN8zbEKsKoIjdFzZaEgUBHKChMJtRwcWpAWoWnifm6ESAMhO8lQK0EEAV3rFopIBCEcGwDKAqPh4HUrY4ICHH1dSoTFgcHUiZjBhAJB2AHDykpKAwHAwdzf19KkASIPl9cDgcnDkdtNwiMJCshACH5BAAKAAcALAAAAAAQABAAAAV3ICACAkkQZTmOAiosiyAoxCq+KPxCNVsSMRgBsiClWrLTSWFoIQZHl6pleBh6suxKMIhlvzbAwkBWfFWrBQTxNLq2RG2yhSUkDs2b63AYDAoJXAcFRwADeAkJDX0AQCsEfAQMDAIPBz0rCgcxky0JRWE1AmwpKyEAIfkEAAoACAAsAAAAABAAEAAABXkgIAICKZzkqJ4nQZxLqZKv4NqNLKK2/Q4Ek4lFXChsg5ypJjs1II3gEDUSRInEGYAw6B6zM4JhrDAtEosVkLUtHA7RHaHAGJQEjsODcEg0FBAFVgkQJQ1pAwcDDw8KcFtSInwJAowCCA6RIwqZAgkPNgVpWndjdyohACH5BAAKAAkALAAAAAAQABAAAAV5ICACAimc5KieLEuUKvm2xAKLqDCfC2GaO9eL0LABWTiBYmA06W6kHgvCqEJiAIJiu3gcvgUsscHUERm+kaCxyxa+zRPk0SgJEgfIvbAdIAQLCAYlCj4DBw0IBQsMCjIqBAcPAooCBg9pKgsJLwUFOhCZKyQDA3YqIQAh+QQACgAKACwAAAAAEAAQAAAFdSAgAgIpnOSonmxbqiThCrJKEHFbo8JxDDOZYFFb+A41E4H4OhkOipXwBElYITDAckFEOBgMQ3arkMkUBdxIUGZpEb7kaQBRlASPg0FQQHAbEEMGDSVEAA1QBhAED1E0NgwFAooCDWljaQIQCE5qMHcNhCkjIQAh+QQACgALACwAAAAAEAAQAAAFeSAgAgIpnOSoLgxxvqgKLEcCC65KEAByKK8cSpA4DAiHQ/DkKhGKh4ZCtCyZGo6F6iYYPAqFgYy02xkSaLEMV34tELyRYNEsCQyHlvWkGCzsPgMCEAY7Cg04Uk48LAsDhRA8MVQPEF0GAgqYYwSRlycNcWskCkApIyEAOwAAAAAAAAAAAA==);background-repeat:no-repeat}.leaflet-control-loading,.leaflet-control-zoom a.leaflet-control-loading,.leaflet-control-zoomslider a.leaflet-control-loading{display:none}.leaflet-control-loading.is-loading,.leaflet-control-zoom a.leaflet-control-loading.is-loading,.leaflet-control-zoomslider a.leaflet-control-loading.is-loading{display:block}.leaflet-bar-part-bottom{border-bottom:medium none;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.leaflet-image-layer,.leaflet-layer,.leaflet-map-pane,.leaflet-marker-icon,.leaflet-marker-pane,.leaflet-marker-shadow,.leaflet-overlay-pane,.leaflet-overlay-pane svg,.leaflet-popup-pane,.leaflet-shadow-pane,.leaflet-tile,.leaflet-tile-container,.leaflet-tile-pane,.leaflet-zoom-box{position:absolute;left:0;top:0}.leaflet-container{overflow:hidden;-ms-touch-action:none;touch-action:none}.leaflet-marker-icon,.leaflet-marker-shadow,.leaflet-tile{-webkit-user-select:none;-moz-user-select:none;user-select:none;-webkit-user-drag:none}.leaflet-marker-icon,.leaflet-marker-shadow{display:block}.leaflet-container img{max-width:none!important}.leaflet-container img.leaflet-image-layer{max-width:15000px!important}.leaflet-tile{filter:inherit;visibility:hidden}.leaflet-tile-loaded{visibility:inherit}.leaflet-zoom-box{width:0;height:0}.leaflet-overlay-pane svg{-moz-user-select:none}.leaflet-tile-pane{z-index:2}.leaflet-objects-pane{z-index:3}.leaflet-overlay-pane{z-index:4}.leaflet-shadow-pane{z-index:5}.leaflet-marker-pane{z-index:6}.leaflet-popup-pane{z-index:7}.leaflet-vml-shape{width:1px;height:1px}.lvml{behavior:url(#default#VML);display:inline-block;position:absolute}.leaflet-control{position:relative;z-index:7;pointer-events:auto}.leaflet-bottom,.leaflet-top{position:absolute;z-index:1000;pointer-events:none}.leaflet-top{top:0}.leaflet-right{right:0}.leaflet-bottom{bottom:0}.leaflet-left{left:0}.leaflet-control{float:left;clear:both}.leaflet-right .leaflet-control{float:right}.leaflet-top .leaflet-control{margin-top:10px}.leaflet-bottom .leaflet-control{margin-bottom:10px}.leaflet-left .leaflet-control{margin-left:10px}.leaflet-right .leaflet-control{margin-right:10px}.leaflet-fade-anim .leaflet-popup,.leaflet-fade-anim .leaflet-tile{opacity:0;-webkit-transition:opacity .2s linear;-moz-transition:opacity .2s linear;-o-transition:opacity .2s linear;transition:opacity .2s linear}.leaflet-fade-anim .leaflet-map-pane .leaflet-popup,.leaflet-fade-anim .leaflet-tile-loaded{opacity:1}.leaflet-zoom-anim .leaflet-zoom-animated{-webkit-transition:-webkit-transform .25s cubic-bezier(0,0,.25,1);-moz-transition:-moz-transform .25s cubic-bezier(0,0,.25,1);-o-transition:-o-transform .25s cubic-bezier(0,0,.25,1);transition:transform .25s cubic-bezier(0,0,.25,1)}.leaflet-pan-anim .leaflet-tile,.leaflet-touching .leaflet-zoom-animated,.leaflet-zoom-anim .leaflet-tile{-webkit-transition:none;-moz-transition:none;-o-transition:none;transition:none}.leaflet-zoom-anim .leaflet-zoom-hide{visibility:hidden}.leaflet-clickable{cursor:pointer}.leaflet-container{cursor:-webkit-grab;cursor:-moz-grab}.leaflet-control,.leaflet-popup-pane{cursor:auto}.leaflet-dragging .leaflet-clickable,.leaflet-dragging .leaflet-container{cursor:move;cursor:-webkit-grabbing;cursor:-moz-grabbing}.leaflet-container{background:#ddd;outline:0}.leaflet-container a{color:#0078A8}.leaflet-container a.leaflet-active{outline:2px solid orange}.leaflet-zoom-box{border:2px dotted #38f;background:rgba(255,255,255,.5)}.leaflet-container{font:12px/1.5 \"Helvetica Neue\",Arial,Helvetica,sans-serif}.leaflet-bar{box-shadow:0 1px 5px rgba(0,0,0,.65);border-radius:4px}.leaflet-bar a,.leaflet-bar a:hover{background-color:#fff;border-bottom:1px solid #ccc;width:26px;height:26px;line-height:26px;display:block;text-align:center;text-decoration:none;color:#000}.leaflet-bar a,.leaflet-control-layers-toggle{background-position:50% 50%;background-repeat:no-repeat;display:block}.leaflet-bar a:hover{background-color:#f4f4f4}.leaflet-bar a:first-child{border-top-left-radius:4px;border-top-right-radius:4px}.leaflet-bar a:last-child{border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-bottom:none}.leaflet-bar a.leaflet-disabled{cursor:default;background-color:#f4f4f4;color:#bbb}.leaflet-touch .leaflet-bar a{width:30px;height:30px;line-height:30px}.leaflet-control-zoom-in,.leaflet-control-zoom-out{font:700 18px 'Lucida Console',Monaco,monospace;text-indent:1px}.leaflet-control-zoom-out{font-size:20px}.leaflet-touch .leaflet-control-zoom-in{font-size:22px}.leaflet-touch .leaflet-control-zoom-out{font-size:24px}.leaflet-control-layers{box-shadow:0 1px 5px rgba(0,0,0,.4);background:#fff;border-radius:5px}.leaflet-control-layers-toggle{background-image:url(jspm_packages/github/Leaflet/Leaflet@0.7.7/dist/images/layers.png);width:36px;height:36px}.leaflet-retina .leaflet-control-layers-toggle{background-image:url(jspm_packages/github/Leaflet/Leaflet@0.7.7/dist/images/layers-2x.png);background-size:26px 26px}.leaflet-touch .leaflet-control-layers-toggle{width:44px;height:44px}.leaflet-control-layers .leaflet-control-layers-list,.leaflet-control-layers-expanded .leaflet-control-layers-toggle{display:none}.leaflet-control-layers-expanded .leaflet-control-layers-list{display:block;position:relative}.leaflet-control-layers-expanded{padding:6px 10px 6px 6px;color:#333;background:#fff}.leaflet-control-layers-selector{margin-top:2px;position:relative;top:1px}.leaflet-control-layers label{display:block}.leaflet-control-layers-separator{height:0;border-top:1px solid #ddd;margin:5px -10px 5px -6px}.leaflet-container .leaflet-control-attribution{background:#fff;background:rgba(255,255,255,.7);margin:0}.leaflet-control-attribution,.leaflet-control-scale-line{padding:0 5px;color:#333}.leaflet-control-attribution a{text-decoration:none}.leaflet-control-attribution a:hover{text-decoration:underline}.leaflet-container .leaflet-control-attribution,.leaflet-container .leaflet-control-scale{font-size:11px}.leaflet-left .leaflet-control-scale{margin-left:5px}.leaflet-bottom .leaflet-control-scale{margin-bottom:5px}.leaflet-control-scale-line{border:2px solid #777;border-top:none;line-height:1.1;padding:2px 5px 1px;font-size:11px;white-space:nowrap;overflow:hidden;-moz-box-sizing:content-box;box-sizing:content-box;background:#fff;background:rgba(255,255,255,.5)}.leaflet-control-scale-line:not(:first-child){border-top:2px solid #777;border-bottom:none;margin-top:-2px}.leaflet-control-scale-line:not(:first-child):not(:last-child){border-bottom:2px solid #777}.leaflet-touch .leaflet-bar,.leaflet-touch .leaflet-control-attribution,.leaflet-touch .leaflet-control-layers{box-shadow:none}.leaflet-touch .leaflet-bar,.leaflet-touch .leaflet-control-layers{border:2px solid rgba(0,0,0,.2);background-clip:padding-box}.leaflet-popup{position:absolute;text-align:center}.leaflet-popup-content-wrapper{padding:1px;text-align:left;border-radius:12px}.leaflet-popup-content{margin:13px 19px;line-height:1.4}.leaflet-popup-content p{margin:18px 0}.leaflet-popup-tip-container{margin:0 auto;width:40px;height:20px;position:relative;overflow:hidden}.leaflet-popup-tip{width:17px;height:17px;padding:1px;margin:-10px auto 0;-webkit-transform:rotate(45deg);-moz-transform:rotate(45deg);-ms-transform:rotate(45deg);-o-transform:rotate(45deg);transform:rotate(45deg)}.leaflet-popup-content-wrapper,.leaflet-popup-tip{background:#fff;box-shadow:0 3px 14px rgba(0,0,0,.4)}.leaflet-container a.leaflet-popup-close-button{position:absolute;top:0;right:0;padding:4px 4px 0 0;text-align:center;width:18px;height:14px;font:16px/14px Tahoma,Verdana,sans-serif;color:#c3c3c3;text-decoration:none;font-weight:700;background:0 0}.leaflet-container a.leaflet-popup-close-button:hover{color:#999}.leaflet-popup-scrolled{overflow:auto;border-bottom:1px solid #ddd;border-top:1px solid #ddd}.leaflet-oldie .leaflet-popup-content-wrapper{zoom:1}.leaflet-oldie .leaflet-popup-tip{width:24px;margin:0 auto;-ms-filter:\"progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)\";filter:progid:DXImageTransform.Microsoft.Matrix(M11=.70710678, M12=.70710678, M21=-.70710678, M22=.70710678)}.leaflet-oldie .leaflet-popup-tip-container{margin-top:-1px}.leaflet-oldie .leaflet-control-layers,.leaflet-oldie .leaflet-control-zoom,.leaflet-oldie .leaflet-popup-content-wrapper,.leaflet-oldie .leaflet-popup-tip{border:1px solid #999}.leaflet-div-icon{background:#fff;border:1px solid #666}/*!\n * Bootstrap v3.3.6 (http://getbootstrap.com)\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n *//*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */html{font-family:sans-serif;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{margin:.67em 0;font-size:2em}mark{color:#000;background:#ff0}small{font-size:80%}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{height:0;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{margin:0;font:inherit;color:inherit}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}input{line-height:normal}input[type=radio],input[type=checkbox]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;-webkit-appearance:textfield}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{padding:.35em .625em .75em;margin:0 2px;border:1px solid silver}legend{padding:0;border:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-spacing:0;border-collapse:collapse}td,th{padding:0}/*! Source: https://github.com/h5bp/html5-boilerplate/blob/master/src/css/main.css */@media print{*,:after,:before{color:#000!important;text-shadow:none!important;background:0 0!important;-webkit-box-shadow:none!important;box-shadow:none!important}a,a:visited{text-decoration:underline}a[href]:after{content:\" (\" attr(href) \")\"}abbr[title]:after{content:\" (\" attr(title) \")\"}a[href^=\"#\"]:after,a[href^=\"javascript:\"]:after{content:\"\"}blockquote,pre{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}img{max-width:100%!important}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}.navbar{display:none}.btn>.caret,.dropup>.btn>.caret{border-top-color:#000!important}.label{border:1px solid #000}.table{border-collapse:collapse!important}.table td,.table th{background-color:#fff!important}.table-bordered td,.table-bordered th{border:1px solid #ddd!important}}@font-face{font-family:'Glyphicons Halflings';src:url(jspm_packages/github/twbs/bootstrap@3.3.6/fonts/glyphicons-halflings-regular.eot);src:url(jspm_packages/github/twbs/bootstrap@3.3.6/fonts/glyphicons-halflings-regular.eot?#iefix) format('embedded-opentype'),url(jspm_packages/github/twbs/bootstrap@3.3.6/fonts/glyphicons-halflings-regular.woff2) format('woff2'),url(jspm_packages/github/twbs/bootstrap@3.3.6/fonts/glyphicons-halflings-regular.woff) format('woff'),url(jspm_packages/github/twbs/bootstrap@3.3.6/fonts/glyphicons-halflings-regular.ttf) format('truetype'),url(jspm_packages/github/twbs/bootstrap@3.3.6/fonts/glyphicons-halflings-regular.svg#glyphicons_halflingsregular) format('svg')}.glyphicon{position:relative;top:1px;display:inline-block;font-family:'Glyphicons Halflings';font-style:normal;font-weight:400;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.glyphicon-asterisk:before{content:\"\\002a\"}.glyphicon-plus:before{content:\"\\002b\"}.glyphicon-eur:before,.glyphicon-euro:before{content:\"\\20ac\"}.glyphicon-minus:before{content:\"\\2212\"}.glyphicon-cloud:before{content:\"\\2601\"}.glyphicon-envelope:before{content:\"\\2709\"}.glyphicon-pencil:before{content:\"\\270f\"}.glyphicon-glass:before{content:\"\\e001\"}.glyphicon-music:before{content:\"\\e002\"}.glyphicon-search:before{content:\"\\e003\"}.glyphicon-heart:before{content:\"\\e005\"}.glyphicon-star:before{content:\"\\e006\"}.glyphicon-star-empty:before{content:\"\\e007\"}.glyphicon-user:before{content:\"\\e008\"}.glyphicon-film:before{content:\"\\e009\"}.glyphicon-th-large:before{content:\"\\e010\"}.glyphicon-th:before{content:\"\\e011\"}.glyphicon-th-list:before{content:\"\\e012\"}.glyphicon-ok:before{content:\"\\e013\"}.glyphicon-remove:before{content:\"\\e014\"}.glyphicon-zoom-in:before{content:\"\\e015\"}.glyphicon-zoom-out:before{content:\"\\e016\"}.glyphicon-off:before{content:\"\\e017\"}.glyphicon-signal:before{content:\"\\e018\"}.glyphicon-cog:before{content:\"\\e019\"}.glyphicon-trash:before{content:\"\\e020\"}.glyphicon-home:before{content:\"\\e021\"}.glyphicon-file:before{content:\"\\e022\"}.glyphicon-time:before{content:\"\\e023\"}.glyphicon-road:before{content:\"\\e024\"}.glyphicon-download-alt:before{content:\"\\e025\"}.glyphicon-download:before{content:\"\\e026\"}.glyphicon-upload:before{content:\"\\e027\"}.glyphicon-inbox:before{content:\"\\e028\"}.glyphicon-play-circle:before{content:\"\\e029\"}.glyphicon-repeat:before{content:\"\\e030\"}.glyphicon-refresh:before{content:\"\\e031\"}.glyphicon-list-alt:before{content:\"\\e032\"}.glyphicon-lock:before{content:\"\\e033\"}.glyphicon-flag:before{content:\"\\e034\"}.glyphicon-headphones:before{content:\"\\e035\"}.glyphicon-volume-off:before{content:\"\\e036\"}.glyphicon-volume-down:before{content:\"\\e037\"}.glyphicon-volume-up:before{content:\"\\e038\"}.glyphicon-qrcode:before{content:\"\\e039\"}.glyphicon-barcode:before{content:\"\\e040\"}.glyphicon-tag:before{content:\"\\e041\"}.glyphicon-tags:before{content:\"\\e042\"}.glyphicon-book:before{content:\"\\e043\"}.glyphicon-bookmark:before{content:\"\\e044\"}.glyphicon-print:before{content:\"\\e045\"}.glyphicon-camera:before{content:\"\\e046\"}.glyphicon-font:before{content:\"\\e047\"}.glyphicon-bold:before{content:\"\\e048\"}.glyphicon-italic:before{content:\"\\e049\"}.glyphicon-text-height:before{content:\"\\e050\"}.glyphicon-text-width:before{content:\"\\e051\"}.glyphicon-align-left:before{content:\"\\e052\"}.glyphicon-align-center:before{content:\"\\e053\"}.glyphicon-align-right:before{content:\"\\e054\"}.glyphicon-align-justify:before{content:\"\\e055\"}.glyphicon-list:before{content:\"\\e056\"}.glyphicon-indent-left:before{content:\"\\e057\"}.glyphicon-indent-right:before{content:\"\\e058\"}.glyphicon-facetime-video:before{content:\"\\e059\"}.glyphicon-picture:before{content:\"\\e060\"}.glyphicon-map-marker:before{content:\"\\e062\"}.glyphicon-adjust:before{content:\"\\e063\"}.glyphicon-tint:before{content:\"\\e064\"}.glyphicon-edit:before{content:\"\\e065\"}.glyphicon-share:before{content:\"\\e066\"}.glyphicon-check:before{content:\"\\e067\"}.glyphicon-move:before{content:\"\\e068\"}.glyphicon-step-backward:before{content:\"\\e069\"}.glyphicon-fast-backward:before{content:\"\\e070\"}.glyphicon-backward:before{content:\"\\e071\"}.glyphicon-play:before{content:\"\\e072\"}.glyphicon-pause:before{content:\"\\e073\"}.glyphicon-stop:before{content:\"\\e074\"}.glyphicon-forward:before{content:\"\\e075\"}.glyphicon-fast-forward:before{content:\"\\e076\"}.glyphicon-step-forward:before{content:\"\\e077\"}.glyphicon-eject:before{content:\"\\e078\"}.glyphicon-chevron-left:before{content:\"\\e079\"}.glyphicon-chevron-right:before{content:\"\\e080\"}.glyphicon-plus-sign:before{content:\"\\e081\"}.glyphicon-minus-sign:before{content:\"\\e082\"}.glyphicon-remove-sign:before{content:\"\\e083\"}.glyphicon-ok-sign:before{content:\"\\e084\"}.glyphicon-question-sign:before{content:\"\\e085\"}.glyphicon-info-sign:before{content:\"\\e086\"}.glyphicon-screenshot:before{content:\"\\e087\"}.glyphicon-remove-circle:before{content:\"\\e088\"}.glyphicon-ok-circle:before{content:\"\\e089\"}.glyphicon-ban-circle:before{content:\"\\e090\"}.glyphicon-arrow-left:before{content:\"\\e091\"}.glyphicon-arrow-right:before{content:\"\\e092\"}.glyphicon-arrow-up:before{content:\"\\e093\"}.glyphicon-arrow-down:before{content:\"\\e094\"}.glyphicon-share-alt:before{content:\"\\e095\"}.glyphicon-resize-full:before{content:\"\\e096\"}.glyphicon-resize-small:before{content:\"\\e097\"}.glyphicon-exclamation-sign:before{content:\"\\e101\"}.glyphicon-gift:before{content:\"\\e102\"}.glyphicon-leaf:before{content:\"\\e103\"}.glyphicon-fire:before{content:\"\\e104\"}.glyphicon-eye-open:before{content:\"\\e105\"}.glyphicon-eye-close:before{content:\"\\e106\"}.glyphicon-warning-sign:before{content:\"\\e107\"}.glyphicon-plane:before{content:\"\\e108\"}.glyphicon-calendar:before{content:\"\\e109\"}.glyphicon-random:before{content:\"\\e110\"}.glyphicon-comment:before{content:\"\\e111\"}.glyphicon-magnet:before{content:\"\\e112\"}.glyphicon-chevron-up:before{content:\"\\e113\"}.glyphicon-chevron-down:before{content:\"\\e114\"}.glyphicon-retweet:before{content:\"\\e115\"}.glyphicon-shopping-cart:before{content:\"\\e116\"}.glyphicon-folder-close:before{content:\"\\e117\"}.glyphicon-folder-open:before{content:\"\\e118\"}.glyphicon-resize-vertical:before{content:\"\\e119\"}.glyphicon-resize-horizontal:before{content:\"\\e120\"}.glyphicon-hdd:before{content:\"\\e121\"}.glyphicon-bullhorn:before{content:\"\\e122\"}.glyphicon-bell:before{content:\"\\e123\"}.glyphicon-certificate:before{content:\"\\e124\"}.glyphicon-thumbs-up:before{content:\"\\e125\"}.glyphicon-thumbs-down:before{content:\"\\e126\"}.glyphicon-hand-right:before{content:\"\\e127\"}.glyphicon-hand-left:before{content:\"\\e128\"}.glyphicon-hand-up:before{content:\"\\e129\"}.glyphicon-hand-down:before{content:\"\\e130\"}.glyphicon-circle-arrow-right:before{content:\"\\e131\"}.glyphicon-circle-arrow-left:before{content:\"\\e132\"}.glyphicon-circle-arrow-up:before{content:\"\\e133\"}.glyphicon-circle-arrow-down:before{content:\"\\e134\"}.glyphicon-globe:before{content:\"\\e135\"}.glyphicon-wrench:before{content:\"\\e136\"}.glyphicon-tasks:before{content:\"\\e137\"}.glyphicon-filter:before{content:\"\\e138\"}.glyphicon-briefcase:before{content:\"\\e139\"}.glyphicon-fullscreen:before{content:\"\\e140\"}.glyphicon-dashboard:before{content:\"\\e141\"}.glyphicon-paperclip:before{content:\"\\e142\"}.glyphicon-heart-empty:before{content:\"\\e143\"}.glyphicon-link:before{content:\"\\e144\"}.glyphicon-phone:before{content:\"\\e145\"}.glyphicon-pushpin:before{content:\"\\e146\"}.glyphicon-usd:before{content:\"\\e148\"}.glyphicon-gbp:before{content:\"\\e149\"}.glyphicon-sort:before{content:\"\\e150\"}.glyphicon-sort-by-alphabet:before{content:\"\\e151\"}.glyphicon-sort-by-alphabet-alt:before{content:\"\\e152\"}.glyphicon-sort-by-order:before{content:\"\\e153\"}.glyphicon-sort-by-order-alt:before{content:\"\\e154\"}.glyphicon-sort-by-attributes:before{content:\"\\e155\"}.glyphicon-sort-by-attributes-alt:before{content:\"\\e156\"}.glyphicon-unchecked:before{content:\"\\e157\"}.glyphicon-expand:before{content:\"\\e158\"}.glyphicon-collapse-down:before{content:\"\\e159\"}.glyphicon-collapse-up:before{content:\"\\e160\"}.glyphicon-log-in:before{content:\"\\e161\"}.glyphicon-flash:before{content:\"\\e162\"}.glyphicon-log-out:before{content:\"\\e163\"}.glyphicon-new-window:before{content:\"\\e164\"}.glyphicon-record:before{content:\"\\e165\"}.glyphicon-save:before{content:\"\\e166\"}.glyphicon-open:before{content:\"\\e167\"}.glyphicon-saved:before{content:\"\\e168\"}.glyphicon-import:before{content:\"\\e169\"}.glyphicon-export:before{content:\"\\e170\"}.glyphicon-send:before{content:\"\\e171\"}.glyphicon-floppy-disk:before{content:\"\\e172\"}.glyphicon-floppy-saved:before{content:\"\\e173\"}.glyphicon-floppy-remove:before{content:\"\\e174\"}.glyphicon-floppy-save:before{content:\"\\e175\"}.glyphicon-floppy-open:before{content:\"\\e176\"}.glyphicon-credit-card:before{content:\"\\e177\"}.glyphicon-transfer:before{content:\"\\e178\"}.glyphicon-cutlery:before{content:\"\\e179\"}.glyphicon-header:before{content:\"\\e180\"}.glyphicon-compressed:before{content:\"\\e181\"}.glyphicon-earphone:before{content:\"\\e182\"}.glyphicon-phone-alt:before{content:\"\\e183\"}.glyphicon-tower:before{content:\"\\e184\"}.glyphicon-stats:before{content:\"\\e185\"}.glyphicon-sd-video:before{content:\"\\e186\"}.glyphicon-hd-video:before{content:\"\\e187\"}.glyphicon-subtitles:before{content:\"\\e188\"}.glyphicon-sound-stereo:before{content:\"\\e189\"}.glyphicon-sound-dolby:before{content:\"\\e190\"}.glyphicon-sound-5-1:before{content:\"\\e191\"}.glyphicon-sound-6-1:before{content:\"\\e192\"}.glyphicon-sound-7-1:before{content:\"\\e193\"}.glyphicon-copyright-mark:before{content:\"\\e194\"}.glyphicon-registration-mark:before{content:\"\\e195\"}.glyphicon-cloud-download:before{content:\"\\e197\"}.glyphicon-cloud-upload:before{content:\"\\e198\"}.glyphicon-tree-conifer:before{content:\"\\e199\"}.glyphicon-tree-deciduous:before{content:\"\\e200\"}.glyphicon-cd:before{content:\"\\e201\"}.glyphicon-save-file:before{content:\"\\e202\"}.glyphicon-open-file:before{content:\"\\e203\"}.glyphicon-level-up:before{content:\"\\e204\"}.glyphicon-copy:before{content:\"\\e205\"}.glyphicon-paste:before{content:\"\\e206\"}.glyphicon-alert:before{content:\"\\e209\"}.glyphicon-equalizer:before{content:\"\\e210\"}.glyphicon-king:before{content:\"\\e211\"}.glyphicon-queen:before{content:\"\\e212\"}.glyphicon-pawn:before{content:\"\\e213\"}.glyphicon-bishop:before{content:\"\\e214\"}.glyphicon-knight:before{content:\"\\e215\"}.glyphicon-baby-formula:before{content:\"\\e216\"}.glyphicon-tent:before{content:\"\\26fa\"}.glyphicon-blackboard:before{content:\"\\e218\"}.glyphicon-bed:before{content:\"\\e219\"}.glyphicon-apple:before{content:\"\\f8ff\"}.glyphicon-erase:before{content:\"\\e221\"}.glyphicon-hourglass:before{content:\"\\231b\"}.glyphicon-lamp:before{content:\"\\e223\"}.glyphicon-duplicate:before{content:\"\\e224\"}.glyphicon-piggy-bank:before{content:\"\\e225\"}.glyphicon-scissors:before{content:\"\\e226\"}.glyphicon-bitcoin:before{content:\"\\e227\"}.glyphicon-btc:before{content:\"\\e227\"}.glyphicon-xbt:before{content:\"\\e227\"}.glyphicon-yen:before{content:\"\\00a5\"}.glyphicon-jpy:before{content:\"\\00a5\"}.glyphicon-ruble:before{content:\"\\20bd\"}.glyphicon-rub:before{content:\"\\20bd\"}.glyphicon-scale:before{content:\"\\e230\"}.glyphicon-ice-lolly:before{content:\"\\e231\"}.glyphicon-ice-lolly-tasted:before{content:\"\\e232\"}.glyphicon-education:before{content:\"\\e233\"}.glyphicon-option-horizontal:before{content:\"\\e234\"}.glyphicon-option-vertical:before{content:\"\\e235\"}.glyphicon-menu-hamburger:before{content:\"\\e236\"}.glyphicon-modal-window:before{content:\"\\e237\"}.glyphicon-oil:before{content:\"\\e238\"}.glyphicon-grain:before{content:\"\\e239\"}.glyphicon-sunglasses:before{content:\"\\e240\"}.glyphicon-text-size:before{content:\"\\e241\"}.glyphicon-text-color:before{content:\"\\e242\"}.glyphicon-text-background:before{content:\"\\e243\"}.glyphicon-object-align-top:before{content:\"\\e244\"}.glyphicon-object-align-bottom:before{content:\"\\e245\"}.glyphicon-object-align-horizontal:before{content:\"\\e246\"}.glyphicon-object-align-left:before{content:\"\\e247\"}.glyphicon-object-align-vertical:before{content:\"\\e248\"}.glyphicon-object-align-right:before{content:\"\\e249\"}.glyphicon-triangle-right:before{content:\"\\e250\"}.glyphicon-triangle-left:before{content:\"\\e251\"}.glyphicon-triangle-bottom:before{content:\"\\e252\"}.glyphicon-triangle-top:before{content:\"\\e253\"}.glyphicon-console:before{content:\"\\e254\"}.glyphicon-superscript:before{content:\"\\e255\"}.glyphicon-subscript:before{content:\"\\e256\"}.glyphicon-menu-left:before{content:\"\\e257\"}.glyphicon-menu-right:before{content:\"\\e258\"}.glyphicon-menu-down:before{content:\"\\e259\"}.glyphicon-menu-up:before{content:\"\\e260\"}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}:after,:before{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html{font-size:10px;-webkit-tap-highlight-color:transparent}body{font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;line-height:1.42857143;color:#333;background-color:#fff}button,input,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit}a{color:#337ab7;text-decoration:none}a:focus,a:hover{color:#23527c;text-decoration:underline}a:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}figure{margin:0}img{vertical-align:middle}.carousel-inner>.item>a>img,.carousel-inner>.item>img,.img-responsive,.thumbnail a>img,.thumbnail>img{display:block;max-width:100%;height:auto}.img-rounded{border-radius:6px}.img-thumbnail{display:inline-block;max-width:100%;height:auto;padding:4px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out}.img-circle{border-radius:50%}hr{margin-top:20px;margin-bottom:20px;border:0;border-top:1px solid #eee}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}[role=button]{cursor:pointer}.h1,.h2,.h3,.h4,.h5,.h6,h1,h2,h3,h4,h5,h6{font-family:inherit;font-weight:500;line-height:1.1;color:inherit}.h1 .small,.h1 small,.h2 .small,.h2 small,.h3 .small,.h3 small,.h4 .small,.h4 small,.h5 .small,.h5 small,.h6 .small,.h6 small,h1 .small,h1 small,h2 .small,h2 small,h3 .small,h3 small,h4 .small,h4 small,h5 .small,h5 small,h6 .small,h6 small{font-weight:400;line-height:1;color:#777}.h1,.h2,.h3,h1,h2,h3{margin-top:20px;margin-bottom:10px}.h1 .small,.h1 small,.h2 .small,.h2 small,.h3 .small,.h3 small,h1 .small,h1 small,h2 .small,h2 small,h3 .small,h3 small{font-size:65%}.h4,.h5,.h6,h4,h5,h6{margin-top:10px;margin-bottom:10px}.h4 .small,.h4 small,.h5 .small,.h5 small,.h6 .small,.h6 small,h4 .small,h4 small,h5 .small,h5 small,h6 .small,h6 small{font-size:75%}.h1,h1{font-size:36px}.h2,h2{font-size:30px}.h3,h3{font-size:24px}.h4,h4{font-size:18px}.h5,h5{font-size:14px}.h6,h6{font-size:12px}p{margin:0 0 10px}.lead{margin-bottom:20px;font-size:16px;font-weight:300;line-height:1.4}@media (min-width:768px){.lead{font-size:21px}}.small,small{font-size:85%}.mark,mark{padding:.2em;background-color:#fcf8e3}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.text-justify{text-align:justify}.text-nowrap{white-space:nowrap}.text-lowercase{text-transform:lowercase}.text-uppercase{text-transform:uppercase}.text-capitalize{text-transform:capitalize}.text-muted{color:#777}.text-primary{color:#337ab7}a.text-primary:focus,a.text-primary:hover{color:#286090}.text-success{color:#3c763d}a.text-success:focus,a.text-success:hover{color:#2b542c}.text-info{color:#31708f}a.text-info:focus,a.text-info:hover{color:#245269}.text-warning{color:#8a6d3b}a.text-warning:focus,a.text-warning:hover{color:#66512c}.text-danger{color:#a94442}a.text-danger:focus,a.text-danger:hover{color:#843534}.bg-primary{color:#fff;background-color:#337ab7}a.bg-primary:focus,a.bg-primary:hover{background-color:#286090}.bg-success{background-color:#dff0d8}a.bg-success:focus,a.bg-success:hover{background-color:#c1e2b3}.bg-info{background-color:#d9edf7}a.bg-info:focus,a.bg-info:hover{background-color:#afd9ee}.bg-warning{background-color:#fcf8e3}a.bg-warning:focus,a.bg-warning:hover{background-color:#f7ecb5}.bg-danger{background-color:#f2dede}a.bg-danger:focus,a.bg-danger:hover{background-color:#e4b9b9}.page-header{padding-bottom:9px;margin:40px 0 20px;border-bottom:1px solid #eee}ol,ul{margin-top:0;margin-bottom:10px}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}.list-unstyled{padding-left:0;list-style:none}.list-inline{padding-left:0;margin-left:-5px;list-style:none}.list-inline>li{display:inline-block;padding-right:5px;padding-left:5px}dl{margin-top:0;margin-bottom:20px}dd,dt{line-height:1.42857143}dt{font-weight:700}dd{margin-left:0}@media (min-width:768px){.dl-horizontal dt{float:left;width:160px;overflow:hidden;clear:left;text-align:right;text-overflow:ellipsis;white-space:nowrap}.dl-horizontal dd{margin-left:180px}}abbr[data-original-title],abbr[title]{cursor:help;border-bottom:1px dotted #777}.initialism{font-size:90%;text-transform:uppercase}blockquote{padding:10px 20px;margin:0 0 20px;font-size:17.5px;border-left:5px solid #eee}blockquote ol:last-child,blockquote p:last-child,blockquote ul:last-child{margin-bottom:0}blockquote .small,blockquote footer,blockquote small{display:block;font-size:80%;line-height:1.42857143;color:#777}blockquote .small:before,blockquote footer:before,blockquote small:before{content:'\\2014 \\00A0'}.blockquote-reverse,blockquote.pull-right{padding-right:15px;padding-left:0;text-align:right;border-right:5px solid #eee;border-left:0}.blockquote-reverse .small:before,.blockquote-reverse footer:before,.blockquote-reverse small:before,blockquote.pull-right .small:before,blockquote.pull-right footer:before,blockquote.pull-right small:before{content:''}.blockquote-reverse .small:after,.blockquote-reverse footer:after,.blockquote-reverse small:after,blockquote.pull-right .small:after,blockquote.pull-right footer:after,blockquote.pull-right small:after{content:'\\00A0 \\2014'}address{margin-bottom:20px;font-style:normal;line-height:1.42857143}code,kbd,pre,samp{font-family:Menlo,Monaco,Consolas,\"Courier New\",monospace}code{padding:2px 4px;font-size:90%;color:#c7254e;background-color:#f9f2f4;border-radius:4px}kbd{padding:2px 4px;font-size:90%;color:#fff;background-color:#333;border-radius:3px;-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,.25);box-shadow:inset 0 -1px 0 rgba(0,0,0,.25)}kbd kbd{padding:0;font-size:100%;font-weight:700;-webkit-box-shadow:none;box-shadow:none}pre{display:block;padding:9.5px;margin:0 0 10px;font-size:13px;line-height:1.42857143;color:#333;word-break:break-all;word-wrap:break-word;background-color:#f5f5f5;border:1px solid #ccc;border-radius:4px}pre code{padding:0;font-size:inherit;color:inherit;white-space:pre-wrap;background-color:transparent;border-radius:0}.pre-scrollable{max-height:340px;overflow-y:scroll}.container{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width:768px){.container{width:750px}}@media (min-width:992px){.container{width:970px}}@media (min-width:1200px){.container{width:1170px}}.container-fluid{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}.row{margin-right:-15px;margin-left:-15px}.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9{position:relative;min-height:1px;padding-right:15px;padding-left:15px}.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9{float:left}.col-xs-12{width:100%}.col-xs-11{width:91.66666667%}.col-xs-10{width:83.33333333%}.col-xs-9{width:75%}.col-xs-8{width:66.66666667%}.col-xs-7{width:58.33333333%}.col-xs-6{width:50%}.col-xs-5{width:41.66666667%}.col-xs-4{width:33.33333333%}.col-xs-3{width:25%}.col-xs-2{width:16.66666667%}.col-xs-1{width:8.33333333%}.col-xs-pull-12{right:100%}.col-xs-pull-11{right:91.66666667%}.col-xs-pull-10{right:83.33333333%}.col-xs-pull-9{right:75%}.col-xs-pull-8{right:66.66666667%}.col-xs-pull-7{right:58.33333333%}.col-xs-pull-6{right:50%}.col-xs-pull-5{right:41.66666667%}.col-xs-pull-4{right:33.33333333%}.col-xs-pull-3{right:25%}.col-xs-pull-2{right:16.66666667%}.col-xs-pull-1{right:8.33333333%}.col-xs-pull-0{right:auto}.col-xs-push-12{left:100%}.col-xs-push-11{left:91.66666667%}.col-xs-push-10{left:83.33333333%}.col-xs-push-9{left:75%}.col-xs-push-8{left:66.66666667%}.col-xs-push-7{left:58.33333333%}.col-xs-push-6{left:50%}.col-xs-push-5{left:41.66666667%}.col-xs-push-4{left:33.33333333%}.col-xs-push-3{left:25%}.col-xs-push-2{left:16.66666667%}.col-xs-push-1{left:8.33333333%}.col-xs-push-0{left:auto}.col-xs-offset-12{margin-left:100%}.col-xs-offset-11{margin-left:91.66666667%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-0{margin-left:0}@media (min-width:768px){.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9{float:left}.col-sm-12{width:100%}.col-sm-11{width:91.66666667%}.col-sm-10{width:83.33333333%}.col-sm-9{width:75%}.col-sm-8{width:66.66666667%}.col-sm-7{width:58.33333333%}.col-sm-6{width:50%}.col-sm-5{width:41.66666667%}.col-sm-4{width:33.33333333%}.col-sm-3{width:25%}.col-sm-2{width:16.66666667%}.col-sm-1{width:8.33333333%}.col-sm-pull-12{right:100%}.col-sm-pull-11{right:91.66666667%}.col-sm-pull-10{right:83.33333333%}.col-sm-pull-9{right:75%}.col-sm-pull-8{right:66.66666667%}.col-sm-pull-7{right:58.33333333%}.col-sm-pull-6{right:50%}.col-sm-pull-5{right:41.66666667%}.col-sm-pull-4{right:33.33333333%}.col-sm-pull-3{right:25%}.col-sm-pull-2{right:16.66666667%}.col-sm-pull-1{right:8.33333333%}.col-sm-pull-0{right:auto}.col-sm-push-12{left:100%}.col-sm-push-11{left:91.66666667%}.col-sm-push-10{left:83.33333333%}.col-sm-push-9{left:75%}.col-sm-push-8{left:66.66666667%}.col-sm-push-7{left:58.33333333%}.col-sm-push-6{left:50%}.col-sm-push-5{left:41.66666667%}.col-sm-push-4{left:33.33333333%}.col-sm-push-3{left:25%}.col-sm-push-2{left:16.66666667%}.col-sm-push-1{left:8.33333333%}.col-sm-push-0{left:auto}.col-sm-offset-12{margin-left:100%}.col-sm-offset-11{margin-left:91.66666667%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-0{margin-left:0}}@media (min-width:992px){.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9{float:left}.col-md-12{width:100%}.col-md-11{width:91.66666667%}.col-md-10{width:83.33333333%}.col-md-9{width:75%}.col-md-8{width:66.66666667%}.col-md-7{width:58.33333333%}.col-md-6{width:50%}.col-md-5{width:41.66666667%}.col-md-4{width:33.33333333%}.col-md-3{width:25%}.col-md-2{width:16.66666667%}.col-md-1{width:8.33333333%}.col-md-pull-12{right:100%}.col-md-pull-11{right:91.66666667%}.col-md-pull-10{right:83.33333333%}.col-md-pull-9{right:75%}.col-md-pull-8{right:66.66666667%}.col-md-pull-7{right:58.33333333%}.col-md-pull-6{right:50%}.col-md-pull-5{right:41.66666667%}.col-md-pull-4{right:33.33333333%}.col-md-pull-3{right:25%}.col-md-pull-2{right:16.66666667%}.col-md-pull-1{right:8.33333333%}.col-md-pull-0{right:auto}.col-md-push-12{left:100%}.col-md-push-11{left:91.66666667%}.col-md-push-10{left:83.33333333%}.col-md-push-9{left:75%}.col-md-push-8{left:66.66666667%}.col-md-push-7{left:58.33333333%}.col-md-push-6{left:50%}.col-md-push-5{left:41.66666667%}.col-md-push-4{left:33.33333333%}.col-md-push-3{left:25%}.col-md-push-2{left:16.66666667%}.col-md-push-1{left:8.33333333%}.col-md-push-0{left:auto}.col-md-offset-12{margin-left:100%}.col-md-offset-11{margin-left:91.66666667%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-9{margin-left:75%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-6{margin-left:50%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-3{margin-left:25%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-0{margin-left:0}}@media (min-width:1200px){.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9{float:left}.col-lg-12{width:100%}.col-lg-11{width:91.66666667%}.col-lg-10{width:83.33333333%}.col-lg-9{width:75%}.col-lg-8{width:66.66666667%}.col-lg-7{width:58.33333333%}.col-lg-6{width:50%}.col-lg-5{width:41.66666667%}.col-lg-4{width:33.33333333%}.col-lg-3{width:25%}.col-lg-2{width:16.66666667%}.col-lg-1{width:8.33333333%}.col-lg-pull-12{right:100%}.col-lg-pull-11{right:91.66666667%}.col-lg-pull-10{right:83.33333333%}.col-lg-pull-9{right:75%}.col-lg-pull-8{right:66.66666667%}.col-lg-pull-7{right:58.33333333%}.col-lg-pull-6{right:50%}.col-lg-pull-5{right:41.66666667%}.col-lg-pull-4{right:33.33333333%}.col-lg-pull-3{right:25%}.col-lg-pull-2{right:16.66666667%}.col-lg-pull-1{right:8.33333333%}.col-lg-pull-0{right:auto}.col-lg-push-12{left:100%}.col-lg-push-11{left:91.66666667%}.col-lg-push-10{left:83.33333333%}.col-lg-push-9{left:75%}.col-lg-push-8{left:66.66666667%}.col-lg-push-7{left:58.33333333%}.col-lg-push-6{left:50%}.col-lg-push-5{left:41.66666667%}.col-lg-push-4{left:33.33333333%}.col-lg-push-3{left:25%}.col-lg-push-2{left:16.66666667%}.col-lg-push-1{left:8.33333333%}.col-lg-push-0{left:auto}.col-lg-offset-12{margin-left:100%}.col-lg-offset-11{margin-left:91.66666667%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-0{margin-left:0}}table{background-color:transparent}caption{padding-top:8px;padding-bottom:8px;color:#777;text-align:left}th{text-align:left}.table{width:100%;max-width:100%;margin-bottom:20px}.table>tbody>tr>td,.table>tbody>tr>th,.table>tfoot>tr>td,.table>tfoot>tr>th,.table>thead>tr>td,.table>thead>tr>th{padding:8px;line-height:1.42857143;vertical-align:top;border-top:1px solid #ddd}.table>thead>tr>th{vertical-align:bottom;border-bottom:2px solid #ddd}.table>caption+thead>tr:first-child>td,.table>caption+thead>tr:first-child>th,.table>colgroup+thead>tr:first-child>td,.table>colgroup+thead>tr:first-child>th,.table>thead:first-child>tr:first-child>td,.table>thead:first-child>tr:first-child>th{border-top:0}.table>tbody+tbody{border-top:2px solid #ddd}.table .table{background-color:#fff}.table-condensed>tbody>tr>td,.table-condensed>tbody>tr>th,.table-condensed>tfoot>tr>td,.table-condensed>tfoot>tr>th,.table-condensed>thead>tr>td,.table-condensed>thead>tr>th{padding:5px}.table-bordered{border:1px solid #ddd}.table-bordered>tbody>tr>td,.table-bordered>tbody>tr>th,.table-bordered>tfoot>tr>td,.table-bordered>tfoot>tr>th,.table-bordered>thead>tr>td,.table-bordered>thead>tr>th{border:1px solid #ddd}.table-bordered>thead>tr>td,.table-bordered>thead>tr>th{border-bottom-width:2px}.table-striped>tbody>tr:nth-of-type(odd){background-color:#f9f9f9}.table-hover>tbody>tr:hover{background-color:#f5f5f5}table col[class*=col-]{position:static;display:table-column;float:none}table td[class*=col-],table th[class*=col-]{position:static;display:table-cell;float:none}.table>tbody>tr.active>td,.table>tbody>tr.active>th,.table>tbody>tr>td.active,.table>tbody>tr>th.active,.table>tfoot>tr.active>td,.table>tfoot>tr.active>th,.table>tfoot>tr>td.active,.table>tfoot>tr>th.active,.table>thead>tr.active>td,.table>thead>tr.active>th,.table>thead>tr>td.active,.table>thead>tr>th.active{background-color:#f5f5f5}.table-hover>tbody>tr.active:hover>td,.table-hover>tbody>tr.active:hover>th,.table-hover>tbody>tr:hover>.active,.table-hover>tbody>tr>td.active:hover,.table-hover>tbody>tr>th.active:hover{background-color:#e8e8e8}.table>tbody>tr.success>td,.table>tbody>tr.success>th,.table>tbody>tr>td.success,.table>tbody>tr>th.success,.table>tfoot>tr.success>td,.table>tfoot>tr.success>th,.table>tfoot>tr>td.success,.table>tfoot>tr>th.success,.table>thead>tr.success>td,.table>thead>tr.success>th,.table>thead>tr>td.success,.table>thead>tr>th.success{background-color:#dff0d8}.table-hover>tbody>tr.success:hover>td,.table-hover>tbody>tr.success:hover>th,.table-hover>tbody>tr:hover>.success,.table-hover>tbody>tr>td.success:hover,.table-hover>tbody>tr>th.success:hover{background-color:#d0e9c6}.table>tbody>tr.info>td,.table>tbody>tr.info>th,.table>tbody>tr>td.info,.table>tbody>tr>th.info,.table>tfoot>tr.info>td,.table>tfoot>tr.info>th,.table>tfoot>tr>td.info,.table>tfoot>tr>th.info,.table>thead>tr.info>td,.table>thead>tr.info>th,.table>thead>tr>td.info,.table>thead>tr>th.info{background-color:#d9edf7}.table-hover>tbody>tr.info:hover>td,.table-hover>tbody>tr.info:hover>th,.table-hover>tbody>tr:hover>.info,.table-hover>tbody>tr>td.info:hover,.table-hover>tbody>tr>th.info:hover{background-color:#c4e3f3}.table>tbody>tr.warning>td,.table>tbody>tr.warning>th,.table>tbody>tr>td.warning,.table>tbody>tr>th.warning,.table>tfoot>tr.warning>td,.table>tfoot>tr.warning>th,.table>tfoot>tr>td.warning,.table>tfoot>tr>th.warning,.table>thead>tr.warning>td,.table>thead>tr.warning>th,.table>thead>tr>td.warning,.table>thead>tr>th.warning{background-color:#fcf8e3}.table-hover>tbody>tr.warning:hover>td,.table-hover>tbody>tr.warning:hover>th,.table-hover>tbody>tr:hover>.warning,.table-hover>tbody>tr>td.warning:hover,.table-hover>tbody>tr>th.warning:hover{background-color:#faf2cc}.table>tbody>tr.danger>td,.table>tbody>tr.danger>th,.table>tbody>tr>td.danger,.table>tbody>tr>th.danger,.table>tfoot>tr.danger>td,.table>tfoot>tr.danger>th,.table>tfoot>tr>td.danger,.table>tfoot>tr>th.danger,.table>thead>tr.danger>td,.table>thead>tr.danger>th,.table>thead>tr>td.danger,.table>thead>tr>th.danger{background-color:#f2dede}.table-hover>tbody>tr.danger:hover>td,.table-hover>tbody>tr.danger:hover>th,.table-hover>tbody>tr:hover>.danger,.table-hover>tbody>tr>td.danger:hover,.table-hover>tbody>tr>th.danger:hover{background-color:#ebcccc}.table-responsive{min-height:.01%;overflow-x:auto}@media screen and (max-width:767px){.table-responsive{width:100%;margin-bottom:15px;overflow-y:hidden;-ms-overflow-style:-ms-autohiding-scrollbar;border:1px solid #ddd}.table-responsive>.table{margin-bottom:0}.table-responsive>.table>tbody>tr>td,.table-responsive>.table>tbody>tr>th,.table-responsive>.table>tfoot>tr>td,.table-responsive>.table>tfoot>tr>th,.table-responsive>.table>thead>tr>td,.table-responsive>.table>thead>tr>th{white-space:nowrap}.table-responsive>.table-bordered{border:0}.table-responsive>.table-bordered>tbody>tr>td:first-child,.table-responsive>.table-bordered>tbody>tr>th:first-child,.table-responsive>.table-bordered>tfoot>tr>td:first-child,.table-responsive>.table-bordered>tfoot>tr>th:first-child,.table-responsive>.table-bordered>thead>tr>td:first-child,.table-responsive>.table-bordered>thead>tr>th:first-child{border-left:0}.table-responsive>.table-bordered>tbody>tr>td:last-child,.table-responsive>.table-bordered>tbody>tr>th:last-child,.table-responsive>.table-bordered>tfoot>tr>td:last-child,.table-responsive>.table-bordered>tfoot>tr>th:last-child,.table-responsive>.table-bordered>thead>tr>td:last-child,.table-responsive>.table-bordered>thead>tr>th:last-child{border-right:0}.table-responsive>.table-bordered>tbody>tr:last-child>td,.table-responsive>.table-bordered>tbody>tr:last-child>th,.table-responsive>.table-bordered>tfoot>tr:last-child>td,.table-responsive>.table-bordered>tfoot>tr:last-child>th{border-bottom:0}}fieldset{min-width:0;padding:0;margin:0;border:0}legend{display:block;width:100%;padding:0;margin-bottom:20px;font-size:21px;line-height:inherit;color:#333;border:0;border-bottom:1px solid #e5e5e5}label{display:inline-block;max-width:100%;margin-bottom:5px;font-weight:700}input[type=search]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}input[type=radio],input[type=checkbox]{margin:4px 0 0;margin-top:1px\\9;line-height:normal}input[type=file]{display:block}input[type=range]{display:block;width:100%}select[multiple],select[size]{height:auto}input[type=file]:focus,input[type=radio]:focus,input[type=checkbox]:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}output{display:block;padding-top:7px;font-size:14px;line-height:1.42857143;color:#555}.form-control{display:block;width:100%;height:34px;padding:6px 12px;font-size:14px;line-height:1.42857143;color:#555;background-color:#fff;background-image:none;border:1px solid #ccc;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075);-webkit-transition:border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;-o-transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s;transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s}.form-control:focus{border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)}.form-control::-moz-placeholder{color:#999;opacity:1}.form-control:-ms-input-placeholder{color:#999}.form-control::-webkit-input-placeholder{color:#999}.form-control::-ms-expand{background-color:transparent;border:0}.form-control[disabled],.form-control[readonly],fieldset[disabled] .form-control{background-color:#eee;opacity:1}.form-control[disabled],fieldset[disabled] .form-control{cursor:not-allowed}textarea.form-control{height:auto}input[type=search]{-webkit-appearance:none}@media screen and (-webkit-min-device-pixel-ratio:0){input[type=date].form-control,input[type=time].form-control,input[type=datetime-local].form-control,input[type=month].form-control{line-height:34px}.input-group-sm input[type=date],.input-group-sm input[type=time],.input-group-sm input[type=datetime-local],.input-group-sm input[type=month],input[type=date].input-sm,input[type=time].input-sm,input[type=datetime-local].input-sm,input[type=month].input-sm{line-height:30px}.input-group-lg input[type=date],.input-group-lg input[type=time],.input-group-lg input[type=datetime-local],.input-group-lg input[type=month],input[type=date].input-lg,input[type=time].input-lg,input[type=datetime-local].input-lg,input[type=month].input-lg{line-height:46px}}.form-group{margin-bottom:15px}.checkbox,.radio{position:relative;display:block;margin-top:10px;margin-bottom:10px}.checkbox label,.radio label{min-height:20px;padding-left:20px;margin-bottom:0;font-weight:400;cursor:pointer}.checkbox input[type=checkbox],.checkbox-inline input[type=checkbox],.radio input[type=radio],.radio-inline input[type=radio]{position:absolute;margin-top:4px\\9;margin-left:-20px}.checkbox+.checkbox,.radio+.radio{margin-top:-5px}.checkbox-inline,.radio-inline{position:relative;display:inline-block;padding-left:20px;margin-bottom:0;font-weight:400;vertical-align:middle;cursor:pointer}.checkbox-inline+.checkbox-inline,.radio-inline+.radio-inline{margin-top:0;margin-left:10px}fieldset[disabled] input[type=radio],fieldset[disabled] input[type=checkbox],input[type=radio].disabled,input[type=radio][disabled],input[type=checkbox].disabled,input[type=checkbox][disabled]{cursor:not-allowed}.checkbox-inline.disabled,.radio-inline.disabled,fieldset[disabled] .checkbox-inline,fieldset[disabled] .radio-inline{cursor:not-allowed}.checkbox.disabled label,.radio.disabled label,fieldset[disabled] .checkbox label,fieldset[disabled] .radio label{cursor:not-allowed}.form-control-static{min-height:34px;padding-top:7px;padding-bottom:7px;margin-bottom:0}.form-control-static.input-lg,.form-control-static.input-sm{padding-right:0;padding-left:0}.input-sm{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.input-sm{height:30px;line-height:30px}select[multiple].input-sm,textarea.input-sm{height:auto}.form-group-sm .form-control{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.form-group-sm select.form-control{height:30px;line-height:30px}.form-group-sm select[multiple].form-control,.form-group-sm textarea.form-control{height:auto}.form-group-sm .form-control-static{height:30px;min-height:32px;padding:6px 10px;font-size:12px;line-height:1.5}.input-lg{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}select.input-lg{height:46px;line-height:46px}select[multiple].input-lg,textarea.input-lg{height:auto}.form-group-lg .form-control{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}.form-group-lg select.form-control{height:46px;line-height:46px}.form-group-lg select[multiple].form-control,.form-group-lg textarea.form-control{height:auto}.form-group-lg .form-control-static{height:46px;min-height:38px;padding:11px 16px;font-size:18px;line-height:1.3333333}.has-feedback{position:relative}.has-feedback .form-control{padding-right:42.5px}.form-control-feedback{position:absolute;top:0;right:0;z-index:2;display:block;width:34px;height:34px;line-height:34px;text-align:center;pointer-events:none}.form-group-lg .form-control+.form-control-feedback,.input-group-lg+.form-control-feedback,.input-lg+.form-control-feedback{width:46px;height:46px;line-height:46px}.form-group-sm .form-control+.form-control-feedback,.input-group-sm+.form-control-feedback,.input-sm+.form-control-feedback{width:30px;height:30px;line-height:30px}.has-success .checkbox,.has-success .checkbox-inline,.has-success .control-label,.has-success .help-block,.has-success .radio,.has-success .radio-inline,.has-success.checkbox label,.has-success.checkbox-inline label,.has-success.radio label,.has-success.radio-inline label{color:#3c763d}.has-success .form-control{border-color:#3c763d;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-success .form-control:focus{border-color:#2b542c;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168}.has-success .input-group-addon{color:#3c763d;background-color:#dff0d8;border-color:#3c763d}.has-success .form-control-feedback{color:#3c763d}.has-warning .checkbox,.has-warning .checkbox-inline,.has-warning .control-label,.has-warning .help-block,.has-warning .radio,.has-warning .radio-inline,.has-warning.checkbox label,.has-warning.checkbox-inline label,.has-warning.radio label,.has-warning.radio-inline label{color:#8a6d3b}.has-warning .form-control{border-color:#8a6d3b;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-warning .form-control:focus{border-color:#66512c;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b}.has-warning .input-group-addon{color:#8a6d3b;background-color:#fcf8e3;border-color:#8a6d3b}.has-warning .form-control-feedback{color:#8a6d3b}.has-error .checkbox,.has-error .checkbox-inline,.has-error .control-label,.has-error .help-block,.has-error .radio,.has-error .radio-inline,.has-error.checkbox label,.has-error.checkbox-inline label,.has-error.radio label,.has-error.radio-inline label{color:#a94442}.has-error .form-control{border-color:#a94442;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-error .form-control:focus{border-color:#843534;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483}.has-error .input-group-addon{color:#a94442;background-color:#f2dede;border-color:#a94442}.has-error .form-control-feedback{color:#a94442}.has-feedback label~.form-control-feedback{top:25px}.has-feedback label.sr-only~.form-control-feedback{top:0}.help-block{display:block;margin-top:5px;margin-bottom:10px;color:#737373}@media (min-width:768px){.form-inline .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.form-inline .form-control{display:inline-block;width:auto;vertical-align:middle}.form-inline .form-control-static{display:inline-block}.form-inline .input-group{display:inline-table;vertical-align:middle}.form-inline .input-group .form-control,.form-inline .input-group .input-group-addon,.form-inline .input-group .input-group-btn{width:auto}.form-inline .input-group>.form-control{width:100%}.form-inline .control-label{margin-bottom:0;vertical-align:middle}.form-inline .checkbox,.form-inline .radio{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.form-inline .checkbox label,.form-inline .radio label{padding-left:0}.form-inline .checkbox input[type=checkbox],.form-inline .radio input[type=radio]{position:relative;margin-left:0}.form-inline .has-feedback .form-control-feedback{top:0}}.form-horizontal .checkbox,.form-horizontal .checkbox-inline,.form-horizontal .radio,.form-horizontal .radio-inline{padding-top:7px;margin-top:0;margin-bottom:0}.form-horizontal .checkbox,.form-horizontal .radio{min-height:27px}.form-horizontal .form-group{margin-right:-15px;margin-left:-15px}@media (min-width:768px){.form-horizontal .control-label{padding-top:7px;margin-bottom:0;text-align:right}}.form-horizontal .has-feedback .form-control-feedback{right:15px}@media (min-width:768px){.form-horizontal .form-group-lg .control-label{padding-top:11px;font-size:18px}}@media (min-width:768px){.form-horizontal .form-group-sm .control-label{padding-top:6px;font-size:12px}}.btn{display:inline-block;padding:6px 12px;margin-bottom:0;font-size:14px;font-weight:400;line-height:1.42857143;text-align:center;white-space:nowrap;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-image:none;border:1px solid transparent;border-radius:4px}.btn.active.focus,.btn.active:focus,.btn.focus,.btn:active.focus,.btn:active:focus,.btn:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn.focus,.btn:focus,.btn:hover{color:#333;text-decoration:none}.btn.active,.btn:active{background-image:none;outline:0;-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn.disabled,.btn[disabled],fieldset[disabled] .btn{cursor:not-allowed;filter:alpha(opacity=65);-webkit-box-shadow:none;box-shadow:none;opacity:.65}a.btn.disabled,fieldset[disabled] a.btn{pointer-events:none}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-default.focus,.btn-default:focus{color:#333;background-color:#e6e6e6;border-color:#8c8c8c}.btn-default:hover{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default.active,.btn-default:active,.open>.dropdown-toggle.btn-default{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default.active.focus,.btn-default.active:focus,.btn-default.active:hover,.btn-default:active.focus,.btn-default:active:focus,.btn-default:active:hover,.open>.dropdown-toggle.btn-default.focus,.open>.dropdown-toggle.btn-default:focus,.open>.dropdown-toggle.btn-default:hover{color:#333;background-color:#d4d4d4;border-color:#8c8c8c}.btn-default.active,.btn-default:active,.open>.dropdown-toggle.btn-default{background-image:none}.btn-default.disabled.focus,.btn-default.disabled:focus,.btn-default.disabled:hover,.btn-default[disabled].focus,.btn-default[disabled]:focus,.btn-default[disabled]:hover,fieldset[disabled] .btn-default.focus,fieldset[disabled] .btn-default:focus,fieldset[disabled] .btn-default:hover{background-color:#fff;border-color:#ccc}.btn-default .badge{color:#fff;background-color:#333}.btn-primary{color:#fff;background-color:#337ab7;border-color:#2e6da4}.btn-primary.focus,.btn-primary:focus{color:#fff;background-color:#286090;border-color:#122b40}.btn-primary:hover{color:#fff;background-color:#286090;border-color:#204d74}.btn-primary.active,.btn-primary:active,.open>.dropdown-toggle.btn-primary{color:#fff;background-color:#286090;border-color:#204d74}.btn-primary.active.focus,.btn-primary.active:focus,.btn-primary.active:hover,.btn-primary:active.focus,.btn-primary:active:focus,.btn-primary:active:hover,.open>.dropdown-toggle.btn-primary.focus,.open>.dropdown-toggle.btn-primary:focus,.open>.dropdown-toggle.btn-primary:hover{color:#fff;background-color:#204d74;border-color:#122b40}.btn-primary.active,.btn-primary:active,.open>.dropdown-toggle.btn-primary{background-image:none}.btn-primary.disabled.focus,.btn-primary.disabled:focus,.btn-primary.disabled:hover,.btn-primary[disabled].focus,.btn-primary[disabled]:focus,.btn-primary[disabled]:hover,fieldset[disabled] .btn-primary.focus,fieldset[disabled] .btn-primary:focus,fieldset[disabled] .btn-primary:hover{background-color:#337ab7;border-color:#2e6da4}.btn-primary .badge{color:#337ab7;background-color:#fff}.btn-success{color:#fff;background-color:#5cb85c;border-color:#4cae4c}.btn-success.focus,.btn-success:focus{color:#fff;background-color:#449d44;border-color:#255625}.btn-success:hover{color:#fff;background-color:#449d44;border-color:#398439}.btn-success.active,.btn-success:active,.open>.dropdown-toggle.btn-success{color:#fff;background-color:#449d44;border-color:#398439}.btn-success.active.focus,.btn-success.active:focus,.btn-success.active:hover,.btn-success:active.focus,.btn-success:active:focus,.btn-success:active:hover,.open>.dropdown-toggle.btn-success.focus,.open>.dropdown-toggle.btn-success:focus,.open>.dropdown-toggle.btn-success:hover{color:#fff;background-color:#398439;border-color:#255625}.btn-success.active,.btn-success:active,.open>.dropdown-toggle.btn-success{background-image:none}.btn-success.disabled.focus,.btn-success.disabled:focus,.btn-success.disabled:hover,.btn-success[disabled].focus,.btn-success[disabled]:focus,.btn-success[disabled]:hover,fieldset[disabled] .btn-success.focus,fieldset[disabled] .btn-success:focus,fieldset[disabled] .btn-success:hover{background-color:#5cb85c;border-color:#4cae4c}.btn-success .badge{color:#5cb85c;background-color:#fff}.btn-info{color:#fff;background-color:#5bc0de;border-color:#46b8da}.btn-info.focus,.btn-info:focus{color:#fff;background-color:#31b0d5;border-color:#1b6d85}.btn-info:hover{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info.active,.btn-info:active,.open>.dropdown-toggle.btn-info{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info.active.focus,.btn-info.active:focus,.btn-info.active:hover,.btn-info:active.focus,.btn-info:active:focus,.btn-info:active:hover,.open>.dropdown-toggle.btn-info.focus,.open>.dropdown-toggle.btn-info:focus,.open>.dropdown-toggle.btn-info:hover{color:#fff;background-color:#269abc;border-color:#1b6d85}.btn-info.active,.btn-info:active,.open>.dropdown-toggle.btn-info{background-image:none}.btn-info.disabled.focus,.btn-info.disabled:focus,.btn-info.disabled:hover,.btn-info[disabled].focus,.btn-info[disabled]:focus,.btn-info[disabled]:hover,fieldset[disabled] .btn-info.focus,fieldset[disabled] .btn-info:focus,fieldset[disabled] .btn-info:hover{background-color:#5bc0de;border-color:#46b8da}.btn-info .badge{color:#5bc0de;background-color:#fff}.btn-warning{color:#fff;background-color:#f0ad4e;border-color:#eea236}.btn-warning.focus,.btn-warning:focus{color:#fff;background-color:#ec971f;border-color:#985f0d}.btn-warning:hover{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning.active,.btn-warning:active,.open>.dropdown-toggle.btn-warning{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning.active.focus,.btn-warning.active:focus,.btn-warning.active:hover,.btn-warning:active.focus,.btn-warning:active:focus,.btn-warning:active:hover,.open>.dropdown-toggle.btn-warning.focus,.open>.dropdown-toggle.btn-warning:focus,.open>.dropdown-toggle.btn-warning:hover{color:#fff;background-color:#d58512;border-color:#985f0d}.btn-warning.active,.btn-warning:active,.open>.dropdown-toggle.btn-warning{background-image:none}.btn-warning.disabled.focus,.btn-warning.disabled:focus,.btn-warning.disabled:hover,.btn-warning[disabled].focus,.btn-warning[disabled]:focus,.btn-warning[disabled]:hover,fieldset[disabled] .btn-warning.focus,fieldset[disabled] .btn-warning:focus,fieldset[disabled] .btn-warning:hover{background-color:#f0ad4e;border-color:#eea236}.btn-warning .badge{color:#f0ad4e;background-color:#fff}.btn-danger{color:#fff;background-color:#d9534f;border-color:#d43f3a}.btn-danger.focus,.btn-danger:focus{color:#fff;background-color:#c9302c;border-color:#761c19}.btn-danger:hover{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger.active,.btn-danger:active,.open>.dropdown-toggle.btn-danger{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger.active.focus,.btn-danger.active:focus,.btn-danger.active:hover,.btn-danger:active.focus,.btn-danger:active:focus,.btn-danger:active:hover,.open>.dropdown-toggle.btn-danger.focus,.open>.dropdown-toggle.btn-danger:focus,.open>.dropdown-toggle.btn-danger:hover{color:#fff;background-color:#ac2925;border-color:#761c19}.btn-danger.active,.btn-danger:active,.open>.dropdown-toggle.btn-danger{background-image:none}.btn-danger.disabled.focus,.btn-danger.disabled:focus,.btn-danger.disabled:hover,.btn-danger[disabled].focus,.btn-danger[disabled]:focus,.btn-danger[disabled]:hover,fieldset[disabled] .btn-danger.focus,fieldset[disabled] .btn-danger:focus,fieldset[disabled] .btn-danger:hover{background-color:#d9534f;border-color:#d43f3a}.btn-danger .badge{color:#d9534f;background-color:#fff}.btn-link{font-weight:400;color:#337ab7;border-radius:0}.btn-link,.btn-link.active,.btn-link:active,.btn-link[disabled],fieldset[disabled] .btn-link{background-color:transparent;-webkit-box-shadow:none;box-shadow:none}.btn-link,.btn-link:active,.btn-link:focus,.btn-link:hover{border-color:transparent}.btn-link:focus,.btn-link:hover{color:#23527c;text-decoration:underline;background-color:transparent}.btn-link[disabled]:focus,.btn-link[disabled]:hover,fieldset[disabled] .btn-link:focus,fieldset[disabled] .btn-link:hover{color:#777;text-decoration:none}.btn-group-lg>.btn,.btn-lg{padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}.btn-group-sm>.btn,.btn-sm{padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.btn-group-xs>.btn,.btn-xs{padding:1px 5px;font-size:12px;line-height:1.5;border-radius:3px}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:5px}input[type=button].btn-block,input[type=reset].btn-block,input[type=submit].btn-block{width:100%}.fade{opacity:0;-webkit-transition:opacity .15s linear;-o-transition:opacity .15s linear;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{display:none}.collapse.in{display:block}tr.collapse.in{display:table-row}tbody.collapse.in{display:table-row-group}.collapsing{position:relative;height:0;overflow:hidden;-webkit-transition-timing-function:ease;-o-transition-timing-function:ease;transition-timing-function:ease;-webkit-transition-duration:.35s;-o-transition-duration:.35s;transition-duration:.35s;-webkit-transition-property:height,visibility;-o-transition-property:height,visibility;transition-property:height,visibility}.caret{display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-top:4px dashed;border-top:4px solid\\9;border-right:4px solid transparent;border-left:4px solid transparent}.dropdown,.dropup{position:relative}.dropdown-toggle:focus{outline:0}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:160px;padding:5px 0;margin:2px 0 0;font-size:14px;text-align:left;list-style:none;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #ccc;border:1px solid rgba(0,0,0,.15);border-radius:4px;-webkit-box-shadow:0 6px 12px rgba(0,0,0,.175);box-shadow:0 6px 12px rgba(0,0,0,.175)}.dropdown-menu.pull-right{right:0;left:auto}.dropdown-menu .divider{height:1px;margin:9px 0;overflow:hidden;background-color:#e5e5e5}.dropdown-menu>li>a{display:block;padding:3px 20px;clear:both;font-weight:400;line-height:1.42857143;color:#333;white-space:nowrap}.dropdown-menu>li>a:focus,.dropdown-menu>li>a:hover{color:#262626;text-decoration:none;background-color:#f5f5f5}.dropdown-menu>.active>a,.dropdown-menu>.active>a:focus,.dropdown-menu>.active>a:hover{color:#fff;text-decoration:none;background-color:#337ab7;outline:0}.dropdown-menu>.disabled>a,.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{color:#777}.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{text-decoration:none;cursor:not-allowed;background-color:transparent;background-image:none;filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.open>.dropdown-menu{display:block}.open>a{outline:0}.dropdown-menu-right{right:0;left:auto}.dropdown-menu-left{right:auto;left:0}.dropdown-header{display:block;padding:3px 20px;font-size:12px;line-height:1.42857143;color:#777;white-space:nowrap}.dropdown-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:990}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{content:\"\";border-top:0;border-bottom:4px dashed;border-bottom:4px solid\\9}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:2px}@media (min-width:768px){.navbar-right .dropdown-menu{right:0;left:auto}.navbar-right .dropdown-menu-left{right:auto;left:0}}.btn-group,.btn-group-vertical{position:relative;display:inline-block;vertical-align:middle}.btn-group-vertical>.btn,.btn-group>.btn{position:relative;float:left}.btn-group-vertical>.btn.active,.btn-group-vertical>.btn:active,.btn-group-vertical>.btn:focus,.btn-group-vertical>.btn:hover,.btn-group>.btn.active,.btn-group>.btn:active,.btn-group>.btn:focus,.btn-group>.btn:hover{z-index:2}.btn-group .btn+.btn,.btn-group .btn+.btn-group,.btn-group .btn-group+.btn,.btn-group .btn-group+.btn-group{margin-left:-1px}.btn-toolbar{margin-left:-5px}.btn-toolbar .btn,.btn-toolbar .btn-group,.btn-toolbar .input-group{float:left}.btn-toolbar>.btn,.btn-toolbar>.btn-group,.btn-toolbar>.input-group{margin-left:5px}.btn-group>.btn:not(:first-child):not(:last-child):not(.dropdown-toggle){border-radius:0}.btn-group>.btn:first-child{margin-left:0}.btn-group>.btn:first-child:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn:last-child:not(:first-child),.btn-group>.dropdown-toggle:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.btn-group>.btn-group{float:left}.btn-group>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-left-radius:0;border-bottom-left-radius:0}.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle{outline:0}.btn-group>.btn+.dropdown-toggle{padding-right:8px;padding-left:8px}.btn-group>.btn-lg+.dropdown-toggle{padding-right:12px;padding-left:12px}.btn-group.open .dropdown-toggle{-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn-group.open .dropdown-toggle.btn-link{-webkit-box-shadow:none;box-shadow:none}.btn .caret{margin-left:0}.btn-lg .caret{border-width:5px 5px 0;border-bottom-width:0}.dropup .btn-lg .caret{border-width:0 5px 5px}.btn-group-vertical>.btn,.btn-group-vertical>.btn-group,.btn-group-vertical>.btn-group>.btn{display:block;float:none;width:100%;max-width:100%}.btn-group-vertical>.btn-group>.btn{float:none}.btn-group-vertical>.btn+.btn,.btn-group-vertical>.btn+.btn-group,.btn-group-vertical>.btn-group+.btn,.btn-group-vertical>.btn-group+.btn-group{margin-top:-1px;margin-left:0}.btn-group-vertical>.btn:not(:first-child):not(:last-child){border-radius:0}.btn-group-vertical>.btn:first-child:not(:last-child){border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn:last-child:not(:first-child){border-top-left-radius:0;border-top-right-radius:0;border-bottom-right-radius:4px;border-bottom-left-radius:4px}.btn-group-vertical>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group-vertical>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group-vertical>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-left-radius:0;border-top-right-radius:0}.btn-group-justified{display:table;width:100%;table-layout:fixed;border-collapse:separate}.btn-group-justified>.btn,.btn-group-justified>.btn-group{display:table-cell;float:none;width:1%}.btn-group-justified>.btn-group .btn{width:100%}.btn-group-justified>.btn-group .dropdown-menu{left:auto}[data-toggle=buttons]>.btn input[type=radio],[data-toggle=buttons]>.btn input[type=checkbox],[data-toggle=buttons]>.btn-group>.btn input[type=radio],[data-toggle=buttons]>.btn-group>.btn input[type=checkbox]{position:absolute;clip:rect(0,0,0,0);pointer-events:none}.input-group{position:relative;display:table;border-collapse:separate}.input-group[class*=col-]{float:none;padding-right:0;padding-left:0}.input-group .form-control{position:relative;z-index:2;float:left;width:100%;margin-bottom:0}.input-group .form-control:focus{z-index:3}.input-group-lg>.form-control,.input-group-lg>.input-group-addon,.input-group-lg>.input-group-btn>.btn{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}select.input-group-lg>.form-control,select.input-group-lg>.input-group-addon,select.input-group-lg>.input-group-btn>.btn{height:46px;line-height:46px}select[multiple].input-group-lg>.form-control,select[multiple].input-group-lg>.input-group-addon,select[multiple].input-group-lg>.input-group-btn>.btn,textarea.input-group-lg>.form-control,textarea.input-group-lg>.input-group-addon,textarea.input-group-lg>.input-group-btn>.btn{height:auto}.input-group-sm>.form-control,.input-group-sm>.input-group-addon,.input-group-sm>.input-group-btn>.btn{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.input-group-sm>.form-control,select.input-group-sm>.input-group-addon,select.input-group-sm>.input-group-btn>.btn{height:30px;line-height:30px}select[multiple].input-group-sm>.form-control,select[multiple].input-group-sm>.input-group-addon,select[multiple].input-group-sm>.input-group-btn>.btn,textarea.input-group-sm>.form-control,textarea.input-group-sm>.input-group-addon,textarea.input-group-sm>.input-group-btn>.btn{height:auto}.input-group .form-control,.input-group-addon,.input-group-btn{display:table-cell}.input-group .form-control:not(:first-child):not(:last-child),.input-group-addon:not(:first-child):not(:last-child),.input-group-btn:not(:first-child):not(:last-child){border-radius:0}.input-group-addon,.input-group-btn{width:1%;white-space:nowrap;vertical-align:middle}.input-group-addon{padding:6px 12px;font-size:14px;font-weight:400;line-height:1;color:#555;text-align:center;background-color:#eee;border:1px solid #ccc;border-radius:4px}.input-group-addon.input-sm{padding:5px 10px;font-size:12px;border-radius:3px}.input-group-addon.input-lg{padding:10px 16px;font-size:18px;border-radius:6px}.input-group-addon input[type=radio],.input-group-addon input[type=checkbox]{margin-top:0}.input-group .form-control:first-child,.input-group-addon:first-child,.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group>.btn,.input-group-btn:first-child>.dropdown-toggle,.input-group-btn:last-child>.btn-group:not(:last-child)>.btn,.input-group-btn:last-child>.btn:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.input-group-addon:first-child{border-right:0}.input-group .form-control:last-child,.input-group-addon:last-child,.input-group-btn:first-child>.btn-group:not(:first-child)>.btn,.input-group-btn:first-child>.btn:not(:first-child),.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group>.btn,.input-group-btn:last-child>.dropdown-toggle{border-top-left-radius:0;border-bottom-left-radius:0}.input-group-addon:last-child{border-left:0}.input-group-btn{position:relative;font-size:0;white-space:nowrap}.input-group-btn>.btn{position:relative}.input-group-btn>.btn+.btn{margin-left:-1px}.input-group-btn>.btn:active,.input-group-btn>.btn:focus,.input-group-btn>.btn:hover{z-index:2}.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group{margin-right:-1px}.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group{z-index:2;margin-left:-1px}.nav{padding-left:0;margin-bottom:0;list-style:none}.nav>li{position:relative;display:block}.nav>li>a{position:relative;display:block;padding:10px 15px}.nav>li>a:focus,.nav>li>a:hover{text-decoration:none;background-color:#eee}.nav>li.disabled>a{color:#777}.nav>li.disabled>a:focus,.nav>li.disabled>a:hover{color:#777;text-decoration:none;cursor:not-allowed;background-color:transparent}.nav .open>a,.nav .open>a:focus,.nav .open>a:hover{background-color:#eee;border-color:#337ab7}.nav .nav-divider{height:1px;margin:9px 0;overflow:hidden;background-color:#e5e5e5}.nav>li>a>img{max-width:none}.nav-tabs{border-bottom:1px solid #ddd}.nav-tabs>li{float:left;margin-bottom:-1px}.nav-tabs>li>a{margin-right:2px;line-height:1.42857143;border:1px solid transparent;border-radius:4px 4px 0 0}.nav-tabs>li>a:hover{border-color:#eee #eee #ddd}.nav-tabs>li.active>a,.nav-tabs>li.active>a:focus,.nav-tabs>li.active>a:hover{color:#555;cursor:default;background-color:#fff;border:1px solid #ddd;border-bottom-color:transparent}.nav-tabs.nav-justified{width:100%;border-bottom:0}.nav-tabs.nav-justified>li{float:none}.nav-tabs.nav-justified>li>a{margin-bottom:5px;text-align:center}.nav-tabs.nav-justified>.dropdown .dropdown-menu{top:auto;left:auto}@media (min-width:768px){.nav-tabs.nav-justified>li{display:table-cell;width:1%}.nav-tabs.nav-justified>li>a{margin-bottom:0}}.nav-tabs.nav-justified>li>a{margin-right:0;border-radius:4px}.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:focus,.nav-tabs.nav-justified>.active>a:hover{border:1px solid #ddd}@media (min-width:768px){.nav-tabs.nav-justified>li>a{border-bottom:1px solid #ddd;border-radius:4px 4px 0 0}.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:focus,.nav-tabs.nav-justified>.active>a:hover{border-bottom-color:#fff}}.nav-pills>li{float:left}.nav-pills>li>a{border-radius:4px}.nav-pills>li+li{margin-left:2px}.nav-pills>li.active>a,.nav-pills>li.active>a:focus,.nav-pills>li.active>a:hover{color:#fff;background-color:#337ab7}.nav-stacked>li{float:none}.nav-stacked>li+li{margin-top:2px;margin-left:0}.nav-justified{width:100%}.nav-justified>li{float:none}.nav-justified>li>a{margin-bottom:5px;text-align:center}.nav-justified>.dropdown .dropdown-menu{top:auto;left:auto}@media (min-width:768px){.nav-justified>li{display:table-cell;width:1%}.nav-justified>li>a{margin-bottom:0}}.nav-tabs-justified{border-bottom:0}.nav-tabs-justified>li>a{margin-right:0;border-radius:4px}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:focus,.nav-tabs-justified>.active>a:hover{border:1px solid #ddd}@media (min-width:768px){.nav-tabs-justified>li>a{border-bottom:1px solid #ddd;border-radius:4px 4px 0 0}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:focus,.nav-tabs-justified>.active>a:hover{border-bottom-color:#fff}}.tab-content>.tab-pane{display:none}.tab-content>.active{display:block}.nav-tabs .dropdown-menu{margin-top:-1px;border-top-left-radius:0;border-top-right-radius:0}.navbar{position:relative;min-height:50px;margin-bottom:20px;border:1px solid transparent}@media (min-width:768px){.navbar{border-radius:4px}}@media (min-width:768px){.navbar-header{float:left}}.navbar-collapse{padding-right:15px;padding-left:15px;overflow-x:visible;-webkit-overflow-scrolling:touch;border-top:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1)}.navbar-collapse.in{overflow-y:auto}@media (min-width:768px){.navbar-collapse{width:auto;border-top:0;-webkit-box-shadow:none;box-shadow:none}.navbar-collapse.collapse{display:block!important;height:auto!important;padding-bottom:0;overflow:visible!important}.navbar-collapse.in{overflow-y:visible}.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse,.navbar-static-top .navbar-collapse{padding-right:0;padding-left:0}}.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse{max-height:340px}@media (max-device-width:480px) and (orientation:landscape){.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse{max-height:200px}}.container-fluid>.navbar-collapse,.container-fluid>.navbar-header,.container>.navbar-collapse,.container>.navbar-header{margin-right:-15px;margin-left:-15px}@media (min-width:768px){.container-fluid>.navbar-collapse,.container-fluid>.navbar-header,.container>.navbar-collapse,.container>.navbar-header{margin-right:0;margin-left:0}}.navbar-static-top{z-index:1000;border-width:0 0 1px}@media (min-width:768px){.navbar-static-top{border-radius:0}}.navbar-fixed-bottom,.navbar-fixed-top{position:fixed;right:0;left:0;z-index:1030}@media (min-width:768px){.navbar-fixed-bottom,.navbar-fixed-top{border-radius:0}}.navbar-fixed-top{top:0;border-width:0 0 1px}.navbar-fixed-bottom{bottom:0;margin-bottom:0;border-width:1px 0 0}.navbar-brand{float:left;height:50px;padding:15px 15px;font-size:18px;line-height:20px}.navbar-brand:focus,.navbar-brand:hover{text-decoration:none}.navbar-brand>img{display:block}@media (min-width:768px){.navbar>.container .navbar-brand,.navbar>.container-fluid .navbar-brand{margin-left:-15px}}.navbar-toggle{position:relative;float:right;padding:9px 10px;margin-top:8px;margin-right:15px;margin-bottom:8px;background-color:transparent;background-image:none;border:1px solid transparent;border-radius:4px}.navbar-toggle:focus{outline:0}.navbar-toggle .icon-bar{display:block;width:22px;height:2px;border-radius:1px}.navbar-toggle .icon-bar+.icon-bar{margin-top:4px}@media (min-width:768px){.navbar-toggle{display:none}}.navbar-nav{margin:7.5px -15px}.navbar-nav>li>a{padding-top:10px;padding-bottom:10px;line-height:20px}@media (max-width:767px){.navbar-nav .open .dropdown-menu{position:static;float:none;width:auto;margin-top:0;background-color:transparent;border:0;-webkit-box-shadow:none;box-shadow:none}.navbar-nav .open .dropdown-menu .dropdown-header,.navbar-nav .open .dropdown-menu>li>a{padding:5px 15px 5px 25px}.navbar-nav .open .dropdown-menu>li>a{line-height:20px}.navbar-nav .open .dropdown-menu>li>a:focus,.navbar-nav .open .dropdown-menu>li>a:hover{background-image:none}}@media (min-width:768px){.navbar-nav{float:left;margin:0}.navbar-nav>li{float:left}.navbar-nav>li>a{padding-top:15px;padding-bottom:15px}}.navbar-form{padding:10px 15px;margin-top:8px;margin-right:-15px;margin-bottom:8px;margin-left:-15px;border-top:1px solid transparent;border-bottom:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1),0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1),0 1px 0 rgba(255,255,255,.1)}@media (min-width:768px){.navbar-form .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.navbar-form .form-control{display:inline-block;width:auto;vertical-align:middle}.navbar-form .form-control-static{display:inline-block}.navbar-form .input-group{display:inline-table;vertical-align:middle}.navbar-form .input-group .form-control,.navbar-form .input-group .input-group-addon,.navbar-form .input-group .input-group-btn{width:auto}.navbar-form .input-group>.form-control{width:100%}.navbar-form .control-label{margin-bottom:0;vertical-align:middle}.navbar-form .checkbox,.navbar-form .radio{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.navbar-form .checkbox label,.navbar-form .radio label{padding-left:0}.navbar-form .checkbox input[type=checkbox],.navbar-form .radio input[type=radio]{position:relative;margin-left:0}.navbar-form .has-feedback .form-control-feedback{top:0}}@media (max-width:767px){.navbar-form .form-group{margin-bottom:5px}.navbar-form .form-group:last-child{margin-bottom:0}}@media (min-width:768px){.navbar-form{width:auto;padding-top:0;padding-bottom:0;margin-right:0;margin-left:0;border:0;-webkit-box-shadow:none;box-shadow:none}}.navbar-nav>li>.dropdown-menu{margin-top:0;border-top-left-radius:0;border-top-right-radius:0}.navbar-fixed-bottom .navbar-nav>li>.dropdown-menu{margin-bottom:0;border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.navbar-btn{margin-top:8px;margin-bottom:8px}.navbar-btn.btn-sm{margin-top:10px;margin-bottom:10px}.navbar-btn.btn-xs{margin-top:14px;margin-bottom:14px}.navbar-text{margin-top:15px;margin-bottom:15px}@media (min-width:768px){.navbar-text{float:left;margin-right:15px;margin-left:15px}}@media (min-width:768px){.navbar-left{float:left!important}.navbar-right{float:right!important;margin-right:-15px}.navbar-right~.navbar-right{margin-right:0}}.navbar-default{background-color:#f8f8f8;border-color:#e7e7e7}.navbar-default .navbar-brand{color:#777}.navbar-default .navbar-brand:focus,.navbar-default .navbar-brand:hover{color:#5e5e5e;background-color:transparent}.navbar-default .navbar-text{color:#777}.navbar-default .navbar-nav>li>a{color:#777}.navbar-default .navbar-nav>li>a:focus,.navbar-default .navbar-nav>li>a:hover{color:#333;background-color:transparent}.navbar-default .navbar-nav>.active>a,.navbar-default .navbar-nav>.active>a:focus,.navbar-default .navbar-nav>.active>a:hover{color:#555;background-color:#e7e7e7}.navbar-default .navbar-nav>.disabled>a,.navbar-default .navbar-nav>.disabled>a:focus,.navbar-default .navbar-nav>.disabled>a:hover{color:#ccc;background-color:transparent}.navbar-default .navbar-toggle{border-color:#ddd}.navbar-default .navbar-toggle:focus,.navbar-default .navbar-toggle:hover{background-color:#ddd}.navbar-default .navbar-toggle .icon-bar{background-color:#888}.navbar-default .navbar-collapse,.navbar-default .navbar-form{border-color:#e7e7e7}.navbar-default .navbar-nav>.open>a,.navbar-default .navbar-nav>.open>a:focus,.navbar-default .navbar-nav>.open>a:hover{color:#555;background-color:#e7e7e7}@media (max-width:767px){.navbar-default .navbar-nav .open .dropdown-menu>li>a{color:#777}.navbar-default .navbar-nav .open .dropdown-menu>li>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>li>a:hover{color:#333;background-color:transparent}.navbar-default .navbar-nav .open .dropdown-menu>.active>a,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:hover{color:#555;background-color:#e7e7e7}.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:hover{color:#ccc;background-color:transparent}}.navbar-default .navbar-link{color:#777}.navbar-default .navbar-link:hover{color:#333}.navbar-default .btn-link{color:#777}.navbar-default .btn-link:focus,.navbar-default .btn-link:hover{color:#333}.navbar-default .btn-link[disabled]:focus,.navbar-default .btn-link[disabled]:hover,fieldset[disabled] .navbar-default .btn-link:focus,fieldset[disabled] .navbar-default .btn-link:hover{color:#ccc}.navbar-inverse{background-color:#222;border-color:#080808}.navbar-inverse .navbar-brand{color:#9d9d9d}.navbar-inverse .navbar-brand:focus,.navbar-inverse .navbar-brand:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-text{color:#9d9d9d}.navbar-inverse .navbar-nav>li>a{color:#9d9d9d}.navbar-inverse .navbar-nav>li>a:focus,.navbar-inverse .navbar-nav>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav>.active>a,.navbar-inverse .navbar-nav>.active>a:focus,.navbar-inverse .navbar-nav>.active>a:hover{color:#fff;background-color:#080808}.navbar-inverse .navbar-nav>.disabled>a,.navbar-inverse .navbar-nav>.disabled>a:focus,.navbar-inverse .navbar-nav>.disabled>a:hover{color:#444;background-color:transparent}.navbar-inverse .navbar-toggle{border-color:#333}.navbar-inverse .navbar-toggle:focus,.navbar-inverse .navbar-toggle:hover{background-color:#333}.navbar-inverse .navbar-toggle .icon-bar{background-color:#fff}.navbar-inverse .navbar-collapse,.navbar-inverse .navbar-form{border-color:#101010}.navbar-inverse .navbar-nav>.open>a,.navbar-inverse .navbar-nav>.open>a:focus,.navbar-inverse .navbar-nav>.open>a:hover{color:#fff;background-color:#080808}@media (max-width:767px){.navbar-inverse .navbar-nav .open .dropdown-menu>.dropdown-header{border-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu .divider{background-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a{color:#9d9d9d}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:hover{color:#fff;background-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:hover{color:#444;background-color:transparent}}.navbar-inverse .navbar-link{color:#9d9d9d}.navbar-inverse .navbar-link:hover{color:#fff}.navbar-inverse .btn-link{color:#9d9d9d}.navbar-inverse .btn-link:focus,.navbar-inverse .btn-link:hover{color:#fff}.navbar-inverse .btn-link[disabled]:focus,.navbar-inverse .btn-link[disabled]:hover,fieldset[disabled] .navbar-inverse .btn-link:focus,fieldset[disabled] .navbar-inverse .btn-link:hover{color:#444}.breadcrumb{padding:8px 15px;margin-bottom:20px;list-style:none;background-color:#f5f5f5;border-radius:4px}.breadcrumb>li{display:inline-block}.breadcrumb>li+li:before{padding:0 5px;color:#ccc;content:\"/\\00a0\"}.breadcrumb>.active{color:#777}.pagination{display:inline-block;padding-left:0;margin:20px 0;border-radius:4px}.pagination>li{display:inline}.pagination>li>a,.pagination>li>span{position:relative;float:left;padding:6px 12px;margin-left:-1px;line-height:1.42857143;color:#337ab7;text-decoration:none;background-color:#fff;border:1px solid #ddd}.pagination>li:first-child>a,.pagination>li:first-child>span{margin-left:0;border-top-left-radius:4px;border-bottom-left-radius:4px}.pagination>li:last-child>a,.pagination>li:last-child>span{border-top-right-radius:4px;border-bottom-right-radius:4px}.pagination>li>a:focus,.pagination>li>a:hover,.pagination>li>span:focus,.pagination>li>span:hover{z-index:2;color:#23527c;background-color:#eee;border-color:#ddd}.pagination>.active>a,.pagination>.active>a:focus,.pagination>.active>a:hover,.pagination>.active>span,.pagination>.active>span:focus,.pagination>.active>span:hover{z-index:3;color:#fff;cursor:default;background-color:#337ab7;border-color:#337ab7}.pagination>.disabled>a,.pagination>.disabled>a:focus,.pagination>.disabled>a:hover,.pagination>.disabled>span,.pagination>.disabled>span:focus,.pagination>.disabled>span:hover{color:#777;cursor:not-allowed;background-color:#fff;border-color:#ddd}.pagination-lg>li>a,.pagination-lg>li>span{padding:10px 16px;font-size:18px;line-height:1.3333333}.pagination-lg>li:first-child>a,.pagination-lg>li:first-child>span{border-top-left-radius:6px;border-bottom-left-radius:6px}.pagination-lg>li:last-child>a,.pagination-lg>li:last-child>span{border-top-right-radius:6px;border-bottom-right-radius:6px}.pagination-sm>li>a,.pagination-sm>li>span{padding:5px 10px;font-size:12px;line-height:1.5}.pagination-sm>li:first-child>a,.pagination-sm>li:first-child>span{border-top-left-radius:3px;border-bottom-left-radius:3px}.pagination-sm>li:last-child>a,.pagination-sm>li:last-child>span{border-top-right-radius:3px;border-bottom-right-radius:3px}.pager{padding-left:0;margin:20px 0;text-align:center;list-style:none}.pager li{display:inline}.pager li>a,.pager li>span{display:inline-block;padding:5px 14px;background-color:#fff;border:1px solid #ddd;border-radius:15px}.pager li>a:focus,.pager li>a:hover{text-decoration:none;background-color:#eee}.pager .next>a,.pager .next>span{float:right}.pager .previous>a,.pager .previous>span{float:left}.pager .disabled>a,.pager .disabled>a:focus,.pager .disabled>a:hover,.pager .disabled>span{color:#777;cursor:not-allowed;background-color:#fff}.label{display:inline;padding:.2em .6em .3em;font-size:75%;font-weight:700;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:.25em}a.label:focus,a.label:hover{color:#fff;text-decoration:none;cursor:pointer}.label:empty{display:none}.btn .label{position:relative;top:-1px}.label-default{background-color:#777}.label-default[href]:focus,.label-default[href]:hover{background-color:#5e5e5e}.label-primary{background-color:#337ab7}.label-primary[href]:focus,.label-primary[href]:hover{background-color:#286090}.label-success{background-color:#5cb85c}.label-success[href]:focus,.label-success[href]:hover{background-color:#449d44}.label-info{background-color:#5bc0de}.label-info[href]:focus,.label-info[href]:hover{background-color:#31b0d5}.label-warning{background-color:#f0ad4e}.label-warning[href]:focus,.label-warning[href]:hover{background-color:#ec971f}.label-danger{background-color:#d9534f}.label-danger[href]:focus,.label-danger[href]:hover{background-color:#c9302c}.badge{display:inline-block;min-width:10px;padding:3px 7px;font-size:12px;font-weight:700;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:middle;background-color:#777;border-radius:10px}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.btn-group-xs>.btn .badge,.btn-xs .badge{top:0;padding:1px 5px}a.badge:focus,a.badge:hover{color:#fff;text-decoration:none;cursor:pointer}.list-group-item.active>.badge,.nav-pills>.active>a>.badge{color:#337ab7;background-color:#fff}.list-group-item>.badge{float:right}.list-group-item>.badge+.badge{margin-right:5px}.nav-pills>li>a>.badge{margin-left:3px}.jumbotron{padding-top:30px;padding-bottom:30px;margin-bottom:30px;color:inherit;background-color:#eee}.jumbotron .h1,.jumbotron h1{color:inherit}.jumbotron p{margin-bottom:15px;font-size:21px;font-weight:200}.jumbotron>hr{border-top-color:#d5d5d5}.container .jumbotron,.container-fluid .jumbotron{padding-right:15px;padding-left:15px;border-radius:6px}.jumbotron .container{max-width:100%}@media screen and (min-width:768px){.jumbotron{padding-top:48px;padding-bottom:48px}.container .jumbotron,.container-fluid .jumbotron{padding-right:60px;padding-left:60px}.jumbotron .h1,.jumbotron h1{font-size:63px}}.thumbnail{display:block;padding:4px;margin-bottom:20px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:border .2s ease-in-out;-o-transition:border .2s ease-in-out;transition:border .2s ease-in-out}.thumbnail a>img,.thumbnail>img{margin-right:auto;margin-left:auto}a.thumbnail.active,a.thumbnail:focus,a.thumbnail:hover{border-color:#337ab7}.thumbnail .caption{padding:9px;color:#333}.alert{padding:15px;margin-bottom:20px;border:1px solid transparent;border-radius:4px}.alert h4{margin-top:0;color:inherit}.alert .alert-link{font-weight:700}.alert>p,.alert>ul{margin-bottom:0}.alert>p+p{margin-top:5px}.alert-dismissable,.alert-dismissible{padding-right:35px}.alert-dismissable .close,.alert-dismissible .close{position:relative;top:-2px;right:-21px;color:inherit}.alert-success{color:#3c763d;background-color:#dff0d8;border-color:#d6e9c6}.alert-success hr{border-top-color:#c9e2b3}.alert-success .alert-link{color:#2b542c}.alert-info{color:#31708f;background-color:#d9edf7;border-color:#bce8f1}.alert-info hr{border-top-color:#a6e1ec}.alert-info .alert-link{color:#245269}.alert-warning{color:#8a6d3b;background-color:#fcf8e3;border-color:#faebcc}.alert-warning hr{border-top-color:#f7e1b5}.alert-warning .alert-link{color:#66512c}.alert-danger{color:#a94442;background-color:#f2dede;border-color:#ebccd1}.alert-danger hr{border-top-color:#e4b9c0}.alert-danger .alert-link{color:#843534}@-webkit-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-o-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}.progress{height:20px;margin-bottom:20px;overflow:hidden;background-color:#f5f5f5;border-radius:4px;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,.1);box-shadow:inset 0 1px 2px rgba(0,0,0,.1)}.progress-bar{float:left;width:0;height:100%;font-size:12px;line-height:20px;color:#fff;text-align:center;background-color:#337ab7;-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,.15);-webkit-transition:width .6s ease;-o-transition:width .6s ease;transition:width .6s ease}.progress-bar-striped,.progress-striped .progress-bar{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);-webkit-background-size:40px 40px;background-size:40px 40px}.progress-bar.active,.progress.active .progress-bar{-webkit-animation:progress-bar-stripes 2s linear infinite;-o-animation:progress-bar-stripes 2s linear infinite;animation:progress-bar-stripes 2s linear infinite}.progress-bar-success{background-color:#5cb85c}.progress-striped .progress-bar-success{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-info{background-color:#5bc0de}.progress-striped .progress-bar-info{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-warning{background-color:#f0ad4e}.progress-striped .progress-bar-warning{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-danger{background-color:#d9534f}.progress-striped .progress-bar-danger{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.media{margin-top:15px}.media:first-child{margin-top:0}.media,.media-body{overflow:hidden;zoom:1}.media-body{width:10000px}.media-object{display:block}.media-object.img-thumbnail{max-width:none}.media-right,.media>.pull-right{padding-left:10px}.media-left,.media>.pull-left{padding-right:10px}.media-body,.media-left,.media-right{display:table-cell;vertical-align:top}.media-middle{vertical-align:middle}.media-bottom{vertical-align:bottom}.media-heading{margin-top:0;margin-bottom:5px}.media-list{padding-left:0;list-style:none}.list-group{padding-left:0;margin-bottom:20px}.list-group-item{position:relative;display:block;padding:10px 15px;margin-bottom:-1px;background-color:#fff;border:1px solid #ddd}.list-group-item:first-child{border-top-left-radius:4px;border-top-right-radius:4px}.list-group-item:last-child{margin-bottom:0;border-bottom-right-radius:4px;border-bottom-left-radius:4px}a.list-group-item,button.list-group-item{color:#555}a.list-group-item .list-group-item-heading,button.list-group-item .list-group-item-heading{color:#333}a.list-group-item:focus,a.list-group-item:hover,button.list-group-item:focus,button.list-group-item:hover{color:#555;text-decoration:none;background-color:#f5f5f5}button.list-group-item{width:100%;text-align:left}.list-group-item.disabled,.list-group-item.disabled:focus,.list-group-item.disabled:hover{color:#777;cursor:not-allowed;background-color:#eee}.list-group-item.disabled .list-group-item-heading,.list-group-item.disabled:focus .list-group-item-heading,.list-group-item.disabled:hover .list-group-item-heading{color:inherit}.list-group-item.disabled .list-group-item-text,.list-group-item.disabled:focus .list-group-item-text,.list-group-item.disabled:hover .list-group-item-text{color:#777}.list-group-item.active,.list-group-item.active:focus,.list-group-item.active:hover{z-index:2;color:#fff;background-color:#337ab7;border-color:#337ab7}.list-group-item.active .list-group-item-heading,.list-group-item.active .list-group-item-heading>.small,.list-group-item.active .list-group-item-heading>small,.list-group-item.active:focus .list-group-item-heading,.list-group-item.active:focus .list-group-item-heading>.small,.list-group-item.active:focus .list-group-item-heading>small,.list-group-item.active:hover .list-group-item-heading,.list-group-item.active:hover .list-group-item-heading>.small,.list-group-item.active:hover .list-group-item-heading>small{color:inherit}.list-group-item.active .list-group-item-text,.list-group-item.active:focus .list-group-item-text,.list-group-item.active:hover .list-group-item-text{color:#c7ddef}.list-group-item-success{color:#3c763d;background-color:#dff0d8}a.list-group-item-success,button.list-group-item-success{color:#3c763d}a.list-group-item-success .list-group-item-heading,button.list-group-item-success .list-group-item-heading{color:inherit}a.list-group-item-success:focus,a.list-group-item-success:hover,button.list-group-item-success:focus,button.list-group-item-success:hover{color:#3c763d;background-color:#d0e9c6}a.list-group-item-success.active,a.list-group-item-success.active:focus,a.list-group-item-success.active:hover,button.list-group-item-success.active,button.list-group-item-success.active:focus,button.list-group-item-success.active:hover{color:#fff;background-color:#3c763d;border-color:#3c763d}.list-group-item-info{color:#31708f;background-color:#d9edf7}a.list-group-item-info,button.list-group-item-info{color:#31708f}a.list-group-item-info .list-group-item-heading,button.list-group-item-info .list-group-item-heading{color:inherit}a.list-group-item-info:focus,a.list-group-item-info:hover,button.list-group-item-info:focus,button.list-group-item-info:hover{color:#31708f;background-color:#c4e3f3}a.list-group-item-info.active,a.list-group-item-info.active:focus,a.list-group-item-info.active:hover,button.list-group-item-info.active,button.list-group-item-info.active:focus,button.list-group-item-info.active:hover{color:#fff;background-color:#31708f;border-color:#31708f}.list-group-item-warning{color:#8a6d3b;background-color:#fcf8e3}a.list-group-item-warning,button.list-group-item-warning{color:#8a6d3b}a.list-group-item-warning .list-group-item-heading,button.list-group-item-warning .list-group-item-heading{color:inherit}a.list-group-item-warning:focus,a.list-group-item-warning:hover,button.list-group-item-warning:focus,button.list-group-item-warning:hover{color:#8a6d3b;background-color:#faf2cc}a.list-group-item-warning.active,a.list-group-item-warning.active:focus,a.list-group-item-warning.active:hover,button.list-group-item-warning.active,button.list-group-item-warning.active:focus,button.list-group-item-warning.active:hover{color:#fff;background-color:#8a6d3b;border-color:#8a6d3b}.list-group-item-danger{color:#a94442;background-color:#f2dede}a.list-group-item-danger,button.list-group-item-danger{color:#a94442}a.list-group-item-danger .list-group-item-heading,button.list-group-item-danger .list-group-item-heading{color:inherit}a.list-group-item-danger:focus,a.list-group-item-danger:hover,button.list-group-item-danger:focus,button.list-group-item-danger:hover{color:#a94442;background-color:#ebcccc}a.list-group-item-danger.active,a.list-group-item-danger.active:focus,a.list-group-item-danger.active:hover,button.list-group-item-danger.active,button.list-group-item-danger.active:focus,button.list-group-item-danger.active:hover{color:#fff;background-color:#a94442;border-color:#a94442}.list-group-item-heading{margin-top:0;margin-bottom:5px}.list-group-item-text{margin-bottom:0;line-height:1.3}.panel{margin-bottom:20px;background-color:#fff;border:1px solid transparent;border-radius:4px;-webkit-box-shadow:0 1px 1px rgba(0,0,0,.05);box-shadow:0 1px 1px rgba(0,0,0,.05)}.panel-body{padding:15px}.panel-heading{padding:10px 15px;border-bottom:1px solid transparent;border-top-left-radius:3px;border-top-right-radius:3px}.panel-heading>.dropdown .dropdown-toggle{color:inherit}.panel-title{margin-top:0;margin-bottom:0;font-size:16px;color:inherit}.panel-title>.small,.panel-title>.small>a,.panel-title>a,.panel-title>small,.panel-title>small>a{color:inherit}.panel-footer{padding:10px 15px;background-color:#f5f5f5;border-top:1px solid #ddd;border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.list-group,.panel>.panel-collapse>.list-group{margin-bottom:0}.panel>.list-group .list-group-item,.panel>.panel-collapse>.list-group .list-group-item{border-width:1px 0;border-radius:0}.panel>.list-group:first-child .list-group-item:first-child,.panel>.panel-collapse>.list-group:first-child .list-group-item:first-child{border-top:0;border-top-left-radius:3px;border-top-right-radius:3px}.panel>.list-group:last-child .list-group-item:last-child,.panel>.panel-collapse>.list-group:last-child .list-group-item:last-child{border-bottom:0;border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.panel-heading+.panel-collapse>.list-group .list-group-item:first-child{border-top-left-radius:0;border-top-right-radius:0}.panel-heading+.list-group .list-group-item:first-child{border-top-width:0}.list-group+.panel-footer{border-top-width:0}.panel>.panel-collapse>.table,.panel>.table,.panel>.table-responsive>.table{margin-bottom:0}.panel>.panel-collapse>.table caption,.panel>.table caption,.panel>.table-responsive>.table caption{padding-right:15px;padding-left:15px}.panel>.table-responsive:first-child>.table:first-child,.panel>.table:first-child{border-top-left-radius:3px;border-top-right-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child,.panel>.table:first-child>thead:first-child>tr:first-child{border-top-left-radius:3px;border-top-right-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child td:first-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child th:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child td:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child th:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child td:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child th:first-child,.panel>.table:first-child>thead:first-child>tr:first-child td:first-child,.panel>.table:first-child>thead:first-child>tr:first-child th:first-child{border-top-left-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child td:last-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child th:last-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child td:last-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child th:last-child,.panel>.table:first-child>tbody:first-child>tr:first-child td:last-child,.panel>.table:first-child>tbody:first-child>tr:first-child th:last-child,.panel>.table:first-child>thead:first-child>tr:first-child td:last-child,.panel>.table:first-child>thead:first-child>tr:first-child th:last-child{border-top-right-radius:3px}.panel>.table-responsive:last-child>.table:last-child,.panel>.table:last-child{border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child{border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child td:first-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child th:first-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child td:first-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child th:first-child,.panel>.table:last-child>tbody:last-child>tr:last-child td:first-child,.panel>.table:last-child>tbody:last-child>tr:last-child th:first-child,.panel>.table:last-child>tfoot:last-child>tr:last-child td:first-child,.panel>.table:last-child>tfoot:last-child>tr:last-child th:first-child{border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child td:last-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child th:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child td:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child th:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child td:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child th:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child td:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child th:last-child{border-bottom-right-radius:3px}.panel>.panel-body+.table,.panel>.panel-body+.table-responsive,.panel>.table+.panel-body,.panel>.table-responsive+.panel-body{border-top:1px solid #ddd}.panel>.table>tbody:first-child>tr:first-child td,.panel>.table>tbody:first-child>tr:first-child th{border-top:0}.panel>.table-bordered,.panel>.table-responsive>.table-bordered{border:0}.panel>.table-bordered>tbody>tr>td:first-child,.panel>.table-bordered>tbody>tr>th:first-child,.panel>.table-bordered>tfoot>tr>td:first-child,.panel>.table-bordered>tfoot>tr>th:first-child,.panel>.table-bordered>thead>tr>td:first-child,.panel>.table-bordered>thead>tr>th:first-child,.panel>.table-responsive>.table-bordered>tbody>tr>td:first-child,.panel>.table-responsive>.table-bordered>tbody>tr>th:first-child,.panel>.table-responsive>.table-bordered>tfoot>tr>td:first-child,.panel>.table-responsive>.table-bordered>tfoot>tr>th:first-child,.panel>.table-responsive>.table-bordered>thead>tr>td:first-child,.panel>.table-responsive>.table-bordered>thead>tr>th:first-child{border-left:0}.panel>.table-bordered>tbody>tr>td:last-child,.panel>.table-bordered>tbody>tr>th:last-child,.panel>.table-bordered>tfoot>tr>td:last-child,.panel>.table-bordered>tfoot>tr>th:last-child,.panel>.table-bordered>thead>tr>td:last-child,.panel>.table-bordered>thead>tr>th:last-child,.panel>.table-responsive>.table-bordered>tbody>tr>td:last-child,.panel>.table-responsive>.table-bordered>tbody>tr>th:last-child,.panel>.table-responsive>.table-bordered>tfoot>tr>td:last-child,.panel>.table-responsive>.table-bordered>tfoot>tr>th:last-child,.panel>.table-responsive>.table-bordered>thead>tr>td:last-child,.panel>.table-responsive>.table-bordered>thead>tr>th:last-child{border-right:0}.panel>.table-bordered>tbody>tr:first-child>td,.panel>.table-bordered>tbody>tr:first-child>th,.panel>.table-bordered>thead>tr:first-child>td,.panel>.table-bordered>thead>tr:first-child>th,.panel>.table-responsive>.table-bordered>tbody>tr:first-child>td,.panel>.table-responsive>.table-bordered>tbody>tr:first-child>th,.panel>.table-responsive>.table-bordered>thead>tr:first-child>td,.panel>.table-responsive>.table-bordered>thead>tr:first-child>th{border-bottom:0}.panel>.table-bordered>tbody>tr:last-child>td,.panel>.table-bordered>tbody>tr:last-child>th,.panel>.table-bordered>tfoot>tr:last-child>td,.panel>.table-bordered>tfoot>tr:last-child>th,.panel>.table-responsive>.table-bordered>tbody>tr:last-child>td,.panel>.table-responsive>.table-bordered>tbody>tr:last-child>th,.panel>.table-responsive>.table-bordered>tfoot>tr:last-child>td,.panel>.table-responsive>.table-bordered>tfoot>tr:last-child>th{border-bottom:0}.panel>.table-responsive{margin-bottom:0;border:0}.panel-group{margin-bottom:20px}.panel-group .panel{margin-bottom:0;border-radius:4px}.panel-group .panel+.panel{margin-top:5px}.panel-group .panel-heading{border-bottom:0}.panel-group .panel-heading+.panel-collapse>.list-group,.panel-group .panel-heading+.panel-collapse>.panel-body{border-top:1px solid #ddd}.panel-group .panel-footer{border-top:0}.panel-group .panel-footer+.panel-collapse .panel-body{border-bottom:1px solid #ddd}.panel-default{border-color:#ddd}.panel-default>.panel-heading{color:#333;background-color:#f5f5f5;border-color:#ddd}.panel-default>.panel-heading+.panel-collapse>.panel-body{border-top-color:#ddd}.panel-default>.panel-heading .badge{color:#f5f5f5;background-color:#333}.panel-default>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#ddd}.panel-primary{border-color:#337ab7}.panel-primary>.panel-heading{color:#fff;background-color:#337ab7;border-color:#337ab7}.panel-primary>.panel-heading+.panel-collapse>.panel-body{border-top-color:#337ab7}.panel-primary>.panel-heading .badge{color:#337ab7;background-color:#fff}.panel-primary>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#337ab7}.panel-success{border-color:#d6e9c6}.panel-success>.panel-heading{color:#3c763d;background-color:#dff0d8;border-color:#d6e9c6}.panel-success>.panel-heading+.panel-collapse>.panel-body{border-top-color:#d6e9c6}.panel-success>.panel-heading .badge{color:#dff0d8;background-color:#3c763d}.panel-success>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#d6e9c6}.panel-info{border-color:#bce8f1}.panel-info>.panel-heading{color:#31708f;background-color:#d9edf7;border-color:#bce8f1}.panel-info>.panel-heading+.panel-collapse>.panel-body{border-top-color:#bce8f1}.panel-info>.panel-heading .badge{color:#d9edf7;background-color:#31708f}.panel-info>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#bce8f1}.panel-warning{border-color:#faebcc}.panel-warning>.panel-heading{color:#8a6d3b;background-color:#fcf8e3;border-color:#faebcc}.panel-warning>.panel-heading+.panel-collapse>.panel-body{border-top-color:#faebcc}.panel-warning>.panel-heading .badge{color:#fcf8e3;background-color:#8a6d3b}.panel-warning>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#faebcc}.panel-danger{border-color:#ebccd1}.panel-danger>.panel-heading{color:#a94442;background-color:#f2dede;border-color:#ebccd1}.panel-danger>.panel-heading+.panel-collapse>.panel-body{border-top-color:#ebccd1}.panel-danger>.panel-heading .badge{color:#f2dede;background-color:#a94442}.panel-danger>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#ebccd1}.embed-responsive{position:relative;display:block;height:0;padding:0;overflow:hidden}.embed-responsive .embed-responsive-item,.embed-responsive embed,.embed-responsive iframe,.embed-responsive object,.embed-responsive video{position:absolute;top:0;bottom:0;left:0;width:100%;height:100%;border:0}.embed-responsive-16by9{padding-bottom:56.25%}.embed-responsive-4by3{padding-bottom:75%}.well{min-height:20px;padding:19px;margin-bottom:20px;background-color:#f5f5f5;border:1px solid #e3e3e3;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.05);box-shadow:inset 0 1px 1px rgba(0,0,0,.05)}.well blockquote{border-color:#ddd;border-color:rgba(0,0,0,.15)}.well-lg{padding:24px;border-radius:6px}.well-sm{padding:9px;border-radius:3px}.close{float:right;font-size:21px;font-weight:700;line-height:1;color:#000;text-shadow:0 1px 0 #fff;filter:alpha(opacity=20);opacity:.2}.close:focus,.close:hover{color:#000;text-decoration:none;cursor:pointer;filter:alpha(opacity=50);opacity:.5}button.close{-webkit-appearance:none;padding:0;cursor:pointer;background:0 0;border:0}.modal-open{overflow:hidden}.modal{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1050;display:none;overflow:hidden;-webkit-overflow-scrolling:touch;outline:0}.modal.fade .modal-dialog{-webkit-transition:-webkit-transform .3s ease-out;-o-transition:-o-transform .3s ease-out;transition:transform .3s ease-out;-webkit-transform:translate(0,-25%);-ms-transform:translate(0,-25%);-o-transform:translate(0,-25%);transform:translate(0,-25%)}.modal.in .modal-dialog{-webkit-transform:translate(0,0);-ms-transform:translate(0,0);-o-transform:translate(0,0);transform:translate(0,0)}.modal-open .modal{overflow-x:hidden;overflow-y:auto}.modal-dialog{position:relative;width:auto;margin:10px}.modal-content{position:relative;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #999;border:1px solid rgba(0,0,0,.2);border-radius:6px;outline:0;-webkit-box-shadow:0 3px 9px rgba(0,0,0,.5);box-shadow:0 3px 9px rgba(0,0,0,.5)}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{filter:alpha(opacity=0);opacity:0}.modal-backdrop.in{filter:alpha(opacity=50);opacity:.5}.modal-header{padding:15px;border-bottom:1px solid #e5e5e5}.modal-header .close{margin-top:-2px}.modal-title{margin:0;line-height:1.42857143}.modal-body{position:relative;padding:15px}.modal-footer{padding:15px;text-align:right;border-top:1px solid #e5e5e5}.modal-footer .btn+.btn{margin-bottom:0;margin-left:5px}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.modal-footer .btn-block+.btn-block{margin-left:0}.modal-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}@media (min-width:768px){.modal-dialog{width:600px;margin:30px auto}.modal-content{-webkit-box-shadow:0 5px 15px rgba(0,0,0,.5);box-shadow:0 5px 15px rgba(0,0,0,.5)}.modal-sm{width:300px}}@media (min-width:992px){.modal-lg{width:900px}}.tooltip{position:absolute;z-index:1070;display:block;font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:12px;font-style:normal;font-weight:400;line-height:1.42857143;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;word-spacing:normal;word-wrap:normal;white-space:normal;filter:alpha(opacity=0);opacity:0;line-break:auto}.tooltip.in{filter:alpha(opacity=90);opacity:.9}.tooltip.top{padding:5px 0;margin-top:-3px}.tooltip.right{padding:0 5px;margin-left:3px}.tooltip.bottom{padding:5px 0;margin-top:3px}.tooltip.left{padding:0 5px;margin-left:-3px}.tooltip-inner{max-width:200px;padding:3px 8px;color:#fff;text-align:center;background-color:#000;border-radius:4px}.tooltip-arrow{position:absolute;width:0;height:0;border-color:transparent;border-style:solid}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-left .tooltip-arrow{right:5px;bottom:0;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-right .tooltip-arrow{bottom:0;left:5px;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-width:5px 5px 5px 0;border-right-color:#000}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-width:5px 0 5px 5px;border-left-color:#000}.tooltip.bottom .tooltip-arrow{top:0;left:50%;margin-left:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-left .tooltip-arrow{top:0;right:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-right .tooltip-arrow{top:0;left:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.popover{position:absolute;top:0;left:0;z-index:1060;display:none;max-width:276px;padding:1px;font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;font-style:normal;font-weight:400;line-height:1.42857143;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;word-spacing:normal;word-wrap:normal;white-space:normal;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #ccc;border:1px solid rgba(0,0,0,.2);border-radius:6px;-webkit-box-shadow:0 5px 10px rgba(0,0,0,.2);box-shadow:0 5px 10px rgba(0,0,0,.2);line-break:auto}.popover.top{margin-top:-10px}.popover.right{margin-left:10px}.popover.bottom{margin-top:10px}.popover.left{margin-left:-10px}.popover-title{padding:8px 14px;margin:0;font-size:14px;background-color:#f7f7f7;border-bottom:1px solid #ebebeb;border-radius:5px 5px 0 0}.popover-content{padding:9px 14px}.popover>.arrow,.popover>.arrow:after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}.popover>.arrow{border-width:11px}.popover>.arrow:after{content:\"\";border-width:10px}.popover.top>.arrow{bottom:-11px;left:50%;margin-left:-11px;border-top-color:#999;border-top-color:rgba(0,0,0,.25);border-bottom-width:0}.popover.top>.arrow:after{bottom:1px;margin-left:-10px;content:\" \";border-top-color:#fff;border-bottom-width:0}.popover.right>.arrow{top:50%;left:-11px;margin-top:-11px;border-right-color:#999;border-right-color:rgba(0,0,0,.25);border-left-width:0}.popover.right>.arrow:after{bottom:-10px;left:1px;content:\" \";border-right-color:#fff;border-left-width:0}.popover.bottom>.arrow{top:-11px;left:50%;margin-left:-11px;border-top-width:0;border-bottom-color:#999;border-bottom-color:rgba(0,0,0,.25)}.popover.bottom>.arrow:after{top:1px;margin-left:-10px;content:\" \";border-top-width:0;border-bottom-color:#fff}.popover.left>.arrow{top:50%;right:-11px;margin-top:-11px;border-right-width:0;border-left-color:#999;border-left-color:rgba(0,0,0,.25)}.popover.left>.arrow:after{right:1px;bottom:-10px;content:\" \";border-right-width:0;border-left-color:#fff}.carousel{position:relative}.carousel-inner{position:relative;width:100%;overflow:hidden}.carousel-inner>.item{position:relative;display:none;-webkit-transition:.6s ease-in-out left;-o-transition:.6s ease-in-out left;transition:.6s ease-in-out left}.carousel-inner>.item>a>img,.carousel-inner>.item>img{line-height:1}@media all and (transform-3d),(-webkit-transform-3d){.carousel-inner>.item{-webkit-transition:-webkit-transform .6s ease-in-out;-o-transition:-o-transform .6s ease-in-out;transition:transform .6s ease-in-out;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-perspective:1000px;perspective:1000px}.carousel-inner>.item.active.right,.carousel-inner>.item.next{left:0;-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}.carousel-inner>.item.active.left,.carousel-inner>.item.prev{left:0;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0)}.carousel-inner>.item.active,.carousel-inner>.item.next.left,.carousel-inner>.item.prev.right{left:0;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}}.carousel-inner>.active,.carousel-inner>.next,.carousel-inner>.prev{display:block}.carousel-inner>.active{left:0}.carousel-inner>.next,.carousel-inner>.prev{position:absolute;top:0;width:100%}.carousel-inner>.next{left:100%}.carousel-inner>.prev{left:-100%}.carousel-inner>.next.left,.carousel-inner>.prev.right{left:0}.carousel-inner>.active.left{left:-100%}.carousel-inner>.active.right{left:100%}.carousel-control{position:absolute;top:0;bottom:0;left:0;width:15%;font-size:20px;color:#fff;text-align:center;text-shadow:0 1px 2px rgba(0,0,0,.6);background-color:rgba(0,0,0,0);filter:alpha(opacity=50);opacity:.5}.carousel-control.left{background-image:-webkit-linear-gradient(left,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);background-image:-o-linear-gradient(left,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);background-image:-webkit-gradient(linear,left top,right top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,.0001)));background-image:linear-gradient(to right,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1);background-repeat:repeat-x}.carousel-control.right{right:0;left:auto;background-image:-webkit-linear-gradient(left,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);background-image:-o-linear-gradient(left,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);background-image:-webkit-gradient(linear,left top,right top,from(rgba(0,0,0,.0001)),to(rgba(0,0,0,.5)));background-image:linear-gradient(to right,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#00000000', endColorstr='#80000000', GradientType=1);background-repeat:repeat-x}.carousel-control:focus,.carousel-control:hover{color:#fff;text-decoration:none;filter:alpha(opacity=90);outline:0;opacity:.9}.carousel-control .glyphicon-chevron-left,.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next,.carousel-control .icon-prev{position:absolute;top:50%;z-index:5;display:inline-block;margin-top:-10px}.carousel-control .glyphicon-chevron-left,.carousel-control .icon-prev{left:50%;margin-left:-10px}.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next{right:50%;margin-right:-10px}.carousel-control .icon-next,.carousel-control .icon-prev{width:20px;height:20px;font-family:serif;line-height:1}.carousel-control .icon-prev:before{content:'\\2039'}.carousel-control .icon-next:before{content:'\\203a'}.carousel-indicators{position:absolute;bottom:10px;left:50%;z-index:15;width:60%;padding-left:0;margin-left:-30%;text-align:center;list-style:none}.carousel-indicators li{display:inline-block;width:10px;height:10px;margin:1px;text-indent:-999px;cursor:pointer;background-color:#000\\9;background-color:rgba(0,0,0,0);border:1px solid #fff;border-radius:10px}.carousel-indicators .active{width:12px;height:12px;margin:0;background-color:#fff}.carousel-caption{position:absolute;right:15%;bottom:20px;left:15%;z-index:10;padding-top:20px;padding-bottom:20px;color:#fff;text-align:center;text-shadow:0 1px 2px rgba(0,0,0,.6)}.carousel-caption .btn{text-shadow:none}@media screen and (min-width:768px){.carousel-control .glyphicon-chevron-left,.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next,.carousel-control .icon-prev{width:30px;height:30px;margin-top:-10px;font-size:30px}.carousel-control .glyphicon-chevron-left,.carousel-control .icon-prev{margin-left:-10px}.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next{margin-right:-10px}.carousel-caption{right:20%;left:20%;padding-bottom:30px}.carousel-indicators{bottom:20px}}.btn-group-vertical>.btn-group:after,.btn-group-vertical>.btn-group:before,.btn-toolbar:after,.btn-toolbar:before,.clearfix:after,.clearfix:before,.container-fluid:after,.container-fluid:before,.container:after,.container:before,.dl-horizontal dd:after,.dl-horizontal dd:before,.form-horizontal .form-group:after,.form-horizontal .form-group:before,.modal-footer:after,.modal-footer:before,.modal-header:after,.modal-header:before,.nav:after,.nav:before,.navbar-collapse:after,.navbar-collapse:before,.navbar-header:after,.navbar-header:before,.navbar:after,.navbar:before,.pager:after,.pager:before,.panel-body:after,.panel-body:before,.row:after,.row:before{display:table;content:\" \"}.btn-group-vertical>.btn-group:after,.btn-toolbar:after,.clearfix:after,.container-fluid:after,.container:after,.dl-horizontal dd:after,.form-horizontal .form-group:after,.modal-footer:after,.modal-header:after,.nav:after,.navbar-collapse:after,.navbar-header:after,.navbar:after,.pager:after,.panel-body:after,.row:after{clear:both}.center-block{display:block;margin-right:auto;margin-left:auto}.pull-right{float:right!important}.pull-left{float:left!important}.hide{display:none!important}.show{display:block!important}.invisible{visibility:hidden}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.hidden{display:none!important}.affix{position:fixed}@-ms-viewport{width:device-width}.visible-lg,.visible-md,.visible-sm,.visible-xs{display:none!important}.visible-lg-block,.visible-lg-inline,.visible-lg-inline-block,.visible-md-block,.visible-md-inline,.visible-md-inline-block,.visible-sm-block,.visible-sm-inline,.visible-sm-inline-block,.visible-xs-block,.visible-xs-inline,.visible-xs-inline-block{display:none!important}@media (max-width:767px){.visible-xs{display:block!important}table.visible-xs{display:table!important}tr.visible-xs{display:table-row!important}td.visible-xs,th.visible-xs{display:table-cell!important}}@media (max-width:767px){.visible-xs-block{display:block!important}}@media (max-width:767px){.visible-xs-inline{display:inline!important}}@media (max-width:767px){.visible-xs-inline-block{display:inline-block!important}}@media (min-width:768px) and (max-width:991px){.visible-sm{display:block!important}table.visible-sm{display:table!important}tr.visible-sm{display:table-row!important}td.visible-sm,th.visible-sm{display:table-cell!important}}@media (min-width:768px) and (max-width:991px){.visible-sm-block{display:block!important}}@media (min-width:768px) and (max-width:991px){.visible-sm-inline{display:inline!important}}@media (min-width:768px) and (max-width:991px){.visible-sm-inline-block{display:inline-block!important}}@media (min-width:992px) and (max-width:1199px){.visible-md{display:block!important}table.visible-md{display:table!important}tr.visible-md{display:table-row!important}td.visible-md,th.visible-md{display:table-cell!important}}@media (min-width:992px) and (max-width:1199px){.visible-md-block{display:block!important}}@media (min-width:992px) and (max-width:1199px){.visible-md-inline{display:inline!important}}@media (min-width:992px) and (max-width:1199px){.visible-md-inline-block{display:inline-block!important}}@media (min-width:1200px){.visible-lg{display:block!important}table.visible-lg{display:table!important}tr.visible-lg{display:table-row!important}td.visible-lg,th.visible-lg{display:table-cell!important}}@media (min-width:1200px){.visible-lg-block{display:block!important}}@media (min-width:1200px){.visible-lg-inline{display:inline!important}}@media (min-width:1200px){.visible-lg-inline-block{display:inline-block!important}}@media (max-width:767px){.hidden-xs{display:none!important}}@media (min-width:768px) and (max-width:991px){.hidden-sm{display:none!important}}@media (min-width:992px) and (max-width:1199px){.hidden-md{display:none!important}}@media (min-width:1200px){.hidden-lg{display:none!important}}.visible-print{display:none!important}@media print{.visible-print{display:block!important}table.visible-print{display:table!important}tr.visible-print{display:table-row!important}td.visible-print,th.visible-print{display:table-cell!important}}.visible-print-block{display:none!important}@media print{.visible-print-block{display:block!important}}.visible-print-inline{display:none!important}@media print{.visible-print-inline{display:inline!important}}.visible-print-inline-block{display:none!important}@media print{.visible-print-inline-block{display:inline-block!important}}@media print{.hidden-print{display:none!important}}");
})
(function(factory) {
  factory();
});